- en: P26：Talks - Christopher Ariza_ Building NumPy Arrays from CSV Files, Faster
    than Pan - VikingDen7 - BV1114y1o7c5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P26：演讲 - 克里斯托弗·阿里萨_ 从CSV文件构建NumPy数组，比Pan更快 - VikingDen7 - BV1114y1o7c5
- en: Good afternoon everyone。 Thank you so much for joining me today's show。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大家下午好。非常感谢你们今天参加我的节目。
- en: '![](img/b840ff5722b15db3c148661cdad8345d_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b840ff5722b15db3c148661cdad8345d_1.png)'
- en: So a little bit about the need to show the good started。 I am Chief Technology
    Officer at。 RUSCA-CADER， Finance Plan， where I created an important health under。
    I've been partnering。 Python since 2000 and back then I was working my team team
    in the coffee museum in the middle。 of the audience， a professor of music technology。
    I don't think I'm going to work at the。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所以关于展示的需要，良好的开始。我是RUSCA-CADER的首席技术官，Finance Plan，在那里我创建了一个重要的健康项目。我自2000年以来一直在合作使用Python，当时我和我的团队在咖啡博物馆的观众中工作，音乐技术的教授。我觉得我不会在这里工作。
- en: time for algorithmic composition and competition in musicology。 In 2012 however，
    I've been。 meeting the Python to build financial systems and that worked for me
    to build a site of training。 a pretty good site in the library built on an immutable
    data model。 So we're all here。 this week to build in 20 years of playcom， right？
    Well I'm still building something。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在音乐学中，算法创作和竞争的时间。然而在2012年，我开始接触Python来构建金融系统，这对我构建一个培训网站很有帮助。这个网站是基于不可变数据模型构建的相当不错的库网站。所以我们本周都在这里，构建20年的playcom，对吗？好吧，我仍在构建一些东西。
- en: slightly different。 20 years of students in the parking and Python， all of you
    are， there as well。 right？ Well it turned out in 2000， 20 years ago， Python 2。3
    was reading。 which included the very first time the student-led computer in the
    standard library and in that。 was a function called the student-in-。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 略有不同。20年的学生在停车场和Python，大家都在那里，对吗？好吧，结果在2000年，20年前，Python 2.3在使用。这包括第一次学生主导的计算机进入标准库，并且其中有一个名为student-in-的函数。
- en: '![](img/b840ff5722b15db3c148661cdad8345d_3.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b840ff5722b15db3c148661cdad8345d_3.png)'
- en: code right here。 And this is that core student-in-the- token I did。 the function
    called part-process star and then it's small。 And what this function。 does is
    process one character at a time with a giant switch that we've been controlling，
    the state。 We all know we're seeing a rise behind giant switch screen。 But the
    student-in-the-。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 代码就在这里。这是我做的核心student-in-the-token。我创建了名为part-process star的函数，然后它很小。这个函数的作用是一次处理一个字符，配合我们控制的巨大开关状态。我们都知道我们在巨大开关屏幕后看到的东西。但是student-in-the-。
- en: '![](img/b840ff5722b15db3c148661cdad8345d_5.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b840ff5722b15db3c148661cdad8345d_5.png)'
- en: code is very efficient because it is too poor and it's configurable for a wide
    range of。 conditions in data。 So a basic reason you can take a scenario wrapping
    up screen that is。 representing the online and you can see that's good。 There
    is no good back-end reader in。 it and we can do that through the list and we can
    get as nicely parked out as well from。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常高效，因为它过于简单，并且可配置以适应各种数据条件。因此，你可以通过一个场景包裹屏幕，表示在线，你会发现这很好。在这里没有好的后端阅读器，我们也可以通过列表做到这一点，并且我们可以很漂亮地排放出来。
- en: the building。 Now really the speaker of this new video is a highly conceivable。
    So here。 I did it across the internet， across in a state character， across the
    whole character。 and I always knew it possible to be an anarchist as expected。
    Now this new video didn't do everything。 It returns across the road， not common。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个新视频的演讲者是一个高度可信的人。所以在这里，我在互联网上做到了这一点，跨越了状态字符，跨越了整个字符。我一直知道这可能是一个无政府主义者，正如预期的那样。现在这个新视频并没有做到所有事情。它跨越了道路，并不常见。
- en: and it's a real and convenient column of data， by column。 So this new video
    doesn't help us with the detection of the present per column。 which is something
    useful， nor do we continue to follow their collections already。 Since， 2018。 the
    middle of the last 10 years， 10 years and no time to teach a little bit of it
    have。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一列真实且方便的数据，以列的形式。所以这个新视频对我们每列的现有检测没有帮助，这是有用的，也不继续跟踪他们已经收集的数据。自2018年以来，过去10年的中间，10年里没有时间教授一点点。
- en: offered from a planter。 Now panders and Indian peers and youth does automatic
    take to take。 the government per column。 It has full support for CSU readers，
    die-electrics and disability。 And it has been a very good performance。 I often
    think that the early growth of panders。 will be a large part of the unit and the
    effort to form it with CSU readers。 However， not all。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个种植者那里提供的支持。现在，panders和印度同行以及青少年确实自动采集每列的政府支持。它对CSU读者、电介质和残疾提供了全面的支持。而且它的表现非常好。我常常认为panders的早期增长将是单位的重要组成部分，以及与CSU读者一起形成它的努力。然而，并非所有。
- en: the types of support that provide their school。 There's no support for unit
    programs。 All。 strings are broad and as high objects and non-high objects are
    raised。 And there's no。 support for big time， big time， big time， big time。 No
    time has a full range of big time。 54 units to allow you to specify the unit of
    big time。 But panders really less to bring。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 提供其学校的支持类型。没有单位程序的支持。所有字符串都是广泛的，高对象和非高对象都被提升。并且没有大时间的支持，大时间，大时间，大时间。没有时间有完整的大时间范围。54个单位允许你指定大时间的单位。但panders真的很少带来。
- en: everything in as an action。 Now non-high office and offices， non-high- high-
    high- high- high。 functions and road tech and wellness and tech doesn't seem to
    have been。 We can support。 all of the high-time types and high-time systems for
    units。 And entry road tech， for example。 works well but doesn't look to support
    if it takes to make and doesn't do any automatic。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都作为一种行动。现在，非高级办公室和办公室，非高级-高级-高级-高级-高级。功能、道路技术和健康，以及技术似乎都没有被支持。我们可以支持所有高时间类型和高时间系统的单元。而入口道路技术，例如，运作良好，但似乎不支持制作所需的自动化。
- en: type of service。 And entry road tech does do automatic type of service。 So we
    have a。 mixture of functions here。 Genflow tech also doesn't make a specific performance
    at scale。 And I show example of that right now。 So in trying to come up with a
    solution to this。 and start it by， which I stuck together keeping between some
    kind of a model。 So I need to。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 服务类型。入口道路技术确实提供自动服务。因此，我们在这里有混合的功能。Genflow技术在规模上也没有特定的性能。我现在给你展示一个例子。所以在尝试找出解决方案时，我试图将某种模型粘合在一起。所以我需要。
- en: be a leader for handling code of the state characters and that gave me an iterative
    that。 I've been setting to gain some text to do my type of discovery and every
    creation。 And， this。 as you might expect， has fairly poor performance as well。
    And this is what needs。 to create a new recommendation called derivative to the
    grades。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 成为处理状态字符代码的领导者，这让我得到了一个迭代的结果。我一直在设置以获得一些文本来进行我的类型发现和每次创建。而且，正如你可能预料的那样，这的表现也相当差。而这正是需要的，以创建一种新推荐，称为导数，针对成绩。
- en: We support full-dylist configuration， from the community leader to support all
    non-high-time types and can use optional type discovery。 for columns with performance
    largely better than time to increase CSEs。 And we'll continue。 to get rid of them。
    So today we're going to talk about some of the challenges building。 the columnar
    array from CSEs， who work in depth as a implementation of the data to， the grades。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们支持全动态配置，从社区领导到支持所有非高时间类型，并可以使用可选的类型发现，用于性能远优于时间以增加CSEs的列。我们将继续去除它们。所以今天我们将讨论构建来自CSEs的列数组的一些挑战，他们在深度上作为数据的实现，涉及到成绩。
- en: And even with the performance playing， we can talk about CSEs and things。 Now。
    for these presentations， I'm going to give a lot of diagrams and flow charts to
    try。 to show you what's going on in these underlines in terms of the necessary
    results。 And it's。 very verbal and it won't sit on the slide here at all。 So we're
    not going to do a lot of， diagrams。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在性能游戏中，我们也可以讨论CSEs和其他事情。现在，对于这些演示，我将给出很多图表和流程图，以尝试展示在这些下划线中发生的事情，以便获得必要的结果。这是非常口头化的，这里不会放置任何幻灯片。因此，我们不会做很多图表。
- en: In this diagram， I'm going to try to isolate the purest genotype and genes from。
    those that involve pie objects。 And you call pie objects。 And this is pie objects。
    So we're。 going to think about this。 Now， you'll have to understand this right
    now。 We're going to。 come back to this。 But everyone even noticed the purple and
    the white boxes。 The purple。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，我将尝试将最纯粹的基因型和基因与涉及派对象的基因分离。你称之为派对象。这就是派对象。所以我们要思考这个。现在，你必须立刻理解这一点。我们将回来讨论。但每个人甚至都注意到了紫色和白色的框。紫色。
- en: boxes were interesting in the pie objects。 The white boxes were really only
    with purest， genotype。 And they were doing this seriously type and get the best
    performance。 And you can， see right here。 this little group all from type sets，
    all from this performance。 And in， fact。 you can even not hear the deal on the
    things like that。 Okay。 So all of them probably。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 盒子在饼图对象中很有趣。白色盒子实际上只与最纯粹的基因型有关。它们认真进行这一类型并获得最佳性能。您可以在这里看到，这些小组全部来自类型集，都是来自这种性能。实际上，您甚至可能听不到类似的事情。所以它们可能会非常困难。
- en: dealt with this and filed at one point。 And they really are still a necessary
    result。 They are doing a little bit of grading and they're widely re-instant for
    it。 But they're almost。 always growers and binaries that might such a parcalian
    or an incision in a many others。 There is no standard way of encoding a meditate
    or a gene that he has a gene， which means it's。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻处理过这个问题并归档了。它们确实仍然是必要的结果。它们正在进行一些评分，并且在这方面得到了广泛的再实施。但是它们几乎总是生长者和可能在许多其他地方存在的二进制文件。这并没有标准的方法来编码一个冥想或基因。
- en: going to be very difficult to work with。 So when we're trying to build a way
    in front of， the gene。 we cannot know the number of columns or rows in advance。
    If we can't have a file。 we can't know this in advance。 The test per column， further，
    is not encoding in the file。 There is no idea what a gene is filed。 So in general，
    it takes two full iterations and。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与之合作将非常困难。因此，当我们试图在基因面前建立一种方式时，我们无法提前知道列或行的数量。如果我们没有文件，我们无法提前知道这一点。每列的测试进一步没有在文件中编码。没有人知道基因是如何归档的。因此，通常情况下，这需要两次完整的迭代。
- en: get everything into the way。 First， we have to load the unicorn data into some
    sort of。 a dynamic array per column。 And we can also discover the type of the
    gene that。 And we。 want to know the size and type so we can keep first the skills
    to value and load the。 manner of the gene。 And it's very hard to do。 All right。
    So the moment of the program is。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 把一切都放入正确的方式。首先，我们必须将独角兽数据加载到某种每列的动态数组中。我们还可以发现基因的类型。我们想要知道大小和类型，以便可以优先保留技能值并加载基因的方式。这非常困难。好的。那么程序的时刻是。
- en: a key to taking into the interval of the test。 You can find it on GitHub。 And
    we have this。 E-type on and done by CVI。 And also I want to call out a hypothesis
    for helping you do。 extensive proper intelligence in teaching functions when dealing
    with arbitrary and。 superficial ways to help you get to a good solid implementation。
    So I need heavy。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于将测试的间隔纳入其中。您可以在GitHub上找到它。我们有这个。E类型由CVI处理。我还想提到一个假设，以帮助您在处理任意和表面的方法时，进行广泛的适当智能教学功能，帮助您达到一个良好的实现。因此，我需要大量的。
- en: use of the solution to read on this implementation。 So I took that， and I think
    we've seen it。 in a tokenizer code and re-purplered。 By doing so， I was able to
    keep all of the。 dialects and figurations often that are present in the standard
    library。 Now。 I mentioned that instead of the Python performance， there are people
    which wire， not using client。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用解决方案来阅读此实现。因此，我采纳了这个，我认为我们在一个分词器代码中已经看到了，并进行了重新定位。通过这样做，我能够保留标准库中常见的所有方言和配置。现在，我提到过，与Python性能相比，有些人并没有使用客户。
- en: we can put a few of them for the client that would get saved by client， for
    the client。 But if you want to be accepted in that， you need to deal with C-type。
    Now。 client objects incur overhead， even when you're working in C。 You have to
    be typed。 in air-setting and you have to manage our resting plan。 So there is
    overheads， only。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为客户保存几个对象。但如果您想被接受，您需要处理C类型。现在，客户对象会产生开销，即使在C中工作时也是如此。您必须在空气设置中进行类型化，并且必须管理我们的休息计划。因此，这里会有开销。
- en: deal with client objects that you don't have when you deal with C-type。 But
    you're a portion of this。 I'm just going to tell you how not to do it。 because
    you can kind of avoid it。 And you can take the GIS window and create client objects。
    and then you can see how the C-type is changed。 You can convert those things to
    client objects down。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 处理C类型时，您可能没有客户对象。但是您是其中的一部分。我只是想告诉您如何避免这样做。您可以使用GIS窗口创建客户对象，然后查看C类型如何变化。您可以将这些东西转换为客户对象。
- en: you can expose them into， the GIS window to create a client。 And you can copy
    those clients into。 non-pilot arrays。 Now， you can do this in a word， but it's
    been telling you to。 under-care into the year in client objects and those become
    a shanker。 Furthermore， if not。 really what we want to do。 We don't have to raise
    our arrays in place。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将它们暴露到GIS窗口中以创建客户端。你可以将这些客户端复制到非飞行员数组中。现在，你可以在一个词中做到这一点，但它一直在告诉你。在客户端对象中进行年内关怀，这些变成一个shanker。此外，如果不是的话。真的不是我们想做的。我们不必在原地提升我们的数组。
- en: What we want to do is we want to， install the GIS code to the C-type and get
    all of these clients。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想做的是将GIS代码安装到C类型并获取所有这些客户端。
- en: '![](img/b840ff5722b15db3c148661cdad8345d_7.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b840ff5722b15db3c148661cdad8345d_7.png)'
- en: So we go back to the thing that you can do as a general understanding library。
    As I do。 I have to sign up for this ad and figure out how to send work and share
    this， a while。 And so。 I can notice that these two key functions that are being
    called， as a process into character。 One function is part and add part。 It is
    starting through the first thing in the very state of the German。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们回到你可以作为一般理解库所做的事情。像我一样。我必须注册这个广告，并弄清楚如何发送工作并分享这段时间。因此。我注意到这两个关键功能被调用，作为进入特性的过程。一个功能是部分和添加部分。它从德语的第一状态开始。
- en: yes， it's the character we could keep。 And then there's part to the team。 We
    just want to continue to continue。 We're done。 We want to close the team。 and
    we're ready to move on。 So that's the inside of the GIS。 We can continue to function
    very well with rises， allowing them to extend。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是我们可以保留的特性。然后还有团队的一部分。我们只想继续继续。我们完成了。我们想结束团队。我们准备好继续前进。所以这就是GIS的内部。我们可以在上升中继续很好地运作，允许他们扩展。
- en: '![](img/b840ff5722b15db3c148661cdad8345d_9.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b840ff5722b15db3c148661cdad8345d_9.png)'
- en: a new purpose as to what I need to do。 So this is how to do it。 We need to have
    to continue to continue to continue to continue to move on。 And we will change
    those two functions with different functions that will allow us。 to attend the
    point and attend an offset and then also find out a little bit。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我需要做的新目标。所以这就是做法。我们需要继续继续继续继续前进。我们将用不同的功能来改变这两个功能，这将允许我们。参加重点并参加偏移，然后还要找出一点。
- en: We store characters per column， now by run now， per column， into dynamic communities。
    And then we convert both columns to GIS and C-type。 And then in this end， into
    the non-tyre range。 it's a buffer。 It can be all without involving an entire object。
    Another thing to make me a new entire object is that you have to create an experience。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在按列存储字符，现在通过动态社区运行。然后我们将两列转换为GIS和C类型。然后在最后，进入非轮胎范围。它是一个缓冲区。它可以在不涉及整个对象的情况下全部完成。另一个让我创造一个新整个对象的事情是，你必须创造一种体验。
- en: into a directory from a new code to a new color and color。 So， keep it to function。
    And you can use it if you are very confused。 So give it an iterator of lines and
    return a list of one new non-tyre range。 All the arguments for dialects and figurations
    are inherited from the C-a-g。 and we can also argue that for per column， definition，
    and a case of an assumption。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从新代码到新颜色和颜色的目录。所以，保持它的功能。如果你感到困惑，可以使用它。所以给它一个行的迭代器，并返回一个新的非轮胎范围的列表。所有方言和配置的参数都继承自C-a-g。我们还可以就每列、定义以及假设的情况进行讨论。
- en: that it solves and problems in writing and doing it with the second thing。 For
    example。 to specify G-type， you can consider it in type 4， but if you want to
    specify G-type。 you can give it a function that's within a solution which determines
    the entire object in the driver's name。 Similarly， if you want to specify a solution
    that's within a solution。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 它解决了写作和处理的第二件事。例如。要指定G类型，你可以考虑类型4，但如果你想指定G类型。你可以给出一个在解决方案中的函数，该函数决定驱动程序名称中的整个对象。类似地，如果你想指定一个在解决方案中的解决方案。
- en: you can tell it's in type in the driver's name。 Similarly。 if you want to specify
    a solution that's function， you can call it a solution。 and you can give a function
    to the line for that parameter which is given a column。 to the standard of the
    function。 So， look at the data you can use as a result of this function。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看出它在驱动程序名称中的类型。类似地。如果你想指定一个功能的解决方案，你可以称之为解决方案。你可以给该参数的行一个函数，该参数给定一个列。以该函数的标准为准。所以，看看你可以作为这个函数结果使用的数据。
- en: which is a very simple case。 I'm giving it a list of names representing record
    of lines。 which is using an open file or any other iterator of records。 And we
    start off with two records。 and we see that the div back three arrays， one-point
    column。 are the integers and the arrays in a row of names and a array of one-character
    of new codes。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的案例。我给它一个表示行记录的名称列表，使用一个打开的文件或其他任何记录迭代器。我们从两个记录开始。我们看到div返回了三个数组，一点列。是整数和名称行中的数组，以及一个新代码的单字符数组。
- en: We see the types have been marked and determined for us， which is very nice。
    A slightly more involved example was the more configuration。 Here we provide a
    custom divinitor and provide a function to make sure that everything that's in
    the first column comes in as a sign。 and then we provide a second function for
    lines that's just between the third column。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到类型已经被标记和确定，这非常好。稍微复杂一些的例子是更多的配置。在这里我们提供一个自定义的divinitor，并提供一个函数来确保第一列中的所有内容都以符号形式出现。然后我们为第三列之间的行提供第二个函数。
- en: And we see now we get back two arrays， and we see that our booleans are not
    converted to boolean。 but that's what this is written。 This is what this is written
    in the name。 Okay。 I wrote this piece of the predicate， and it's perfectly useful
    on their own。 It can be called a new code for a non-type。 But instead of friends。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到两个数组，我们看到布尔值没有转换为布尔值，但这就是它的书写。这就是它在名称中书写的内容。好的，我写了这个谓词部分，它完全可以独立使用。它可以被称为非类型的新代码。但不是朋友。
- en: all the constructors just call this one the new， so some divinitor， the function
    is new。 the function is new， still call this one the new code， still the non-pyro-based
    domain。 and then package that into the new code for a new code。 And then we have
    a configuration that stands within static random， actually opening the file。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有构造函数都只是调用这个新函数，所以某个divinitor，函数是新的。函数是新的，仍然调用这个新代码，仍然是非火基领域。然后将其打包成新代码的新代码。然后我们有一个配置，它位于静态随机中，实际上打开了文件。
- en: so I don't put that into limited ways， and you can do that in static。 And it's
    perfectly in different columns。 All of that is encapsulated within static random
    constructors。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我不把它放入限制方式中，你可以在静态中做到这一点。这在不同的列中是完全可以的。所有这些都被封装在静态随机构造函数内。
- en: '![](img/b840ff5722b15db3c148661cdad8345d_11.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b840ff5722b15db3c148661cdad8345d_11.png)'
- en: Okay， let's begin to the implementation。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始实现。
- en: '![](img/b840ff5722b15db3c148661cdad8345d_13.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b840ff5722b15db3c148661cdad8345d_13.png)'
- en: So the three things we see three things in the first。 but underline how this
    framework is what the divinitor's rendered， what I call a code point run。 and
    what I call a code point grid。 Now， I'll refer to this sometimes in CPT。 Now。
    I need to turn code points into a refers to the unified unit code character。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在第一部分看到三件事。但我想强调这个框架是divinitor的渲染结果，我称之为代码点运行。还有我称之为代码点网格。现在，我有时会在CPT中提到这个。现在，我需要将代码点转换为统一单元代码字符。
- en: which is called a character， which is called in CPT。 In CPT I'm using the type
    using the four type coordinates， which is a four byte unit code character。 In
    particular， this is not a type object。 This is a simple CPT。 but it has a convenient
    area in the CPT line of CPT。 So we'll start with the individual。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为字符，在CPT中调用。在CPT中，我使用四个类型坐标的类型，这是一种四字节单位代码字符。特别是，这不是一个类型对象。这是一个简单的CPT，但它在CPT行中有一个方便的区域。所以我们从个体开始。
- en: The divinitor is a dependent parameter to the content of the CPT。 And it just
    iterates over the reference frame。 It calls the CPT type on CPT， which is a type
    on CPT。 which is a type on CPT， which is a type on CPT。 And it shows that once
    per record。 And then it costs the field per record， which costs a CPT character
    one of the times。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: divinitor是CPT内容的一个依赖参数。它只是遍历参考框架。它在CPT上调用CPT类型，这又是CPT上的一种类型。这是CPT上的一种类型，这是CPT上的一种类型。它表示每条记录显示一次。然后它为每条记录计算字段，这样就会消耗CPT字符的一次。
- en: calling them same functions for adding characters and completing CPT。 All the
    while to cut field。 column， and row conditions， so we always have the context
    of where we are in the file。 Now。 the code point line scores unit or data per
    column。 This is what we're going to use to collect our characters as we're moving
    into the file。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 调用相同的函数来添加字符和完成CPT。同时切割字段、列和行条件，这样我们总是能够了解在文件中的位置。现在，代码点行为每列分数或数据。这就是我们在进入文件时用来收集字符的。
- en: And it's basically on the area of screen array data structure。 So we have to
    dynamically allocate a view array to each side of the structure。 One of them。
    you call it buffer， is just a few array of new character characters。 And it's
    going to store continuous characters without no container。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上它在屏幕数组数据结构的区域上。因此我们必须动态分配一个视图数组到结构的每一侧。其中之一，你称之为缓冲区，仅仅是一个新的字符字符数组。它将存储连续的字符，没有任何容器。
- en: So it's going to be maximum in the content。 Now the second array also contains
    the information from there。 This stores the offset or the size of the field。 And
    separated the thing into two arrays。 Once the field is fully loaded， you can then
    go to the field per offset。 and convert those fields to a control。 If you dive
    in there with a little traumatic。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在内容中将达到最大值。现在第二个数组也包含来自那里信息。这存储了字段的偏移量或大小。并将其分隔成两个数组。一旦字段完全加载，你就可以通过偏移量访问字段，并将这些字段转换为控制。如果你在这里潜入，会有一点创伤。
- en: you've got to help you understand what the code points are going to be。 These
    two characters will write three horizontal blocks。 It will represent the tension
    of a dynamically allocated array。 And we think we have one array of a buffer and
    another array of offset。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须帮助你理解代码点将会是什么。这两个字符将写入三个水平块。它将表示动态分配数组的张力。我们认为我们有一个缓冲区的数组和另一个偏移量的数组。
- en: And we can unpack this by looking at the offset。 We've seen the first field
    is three characters that's read。 The second field is five characters that's read。
    And the third field is four characters that's read。 And the code point is really
    where the third， size。 and intensity between the limited reader and the student。
    First。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看偏移量来解包这一内容。我们已经看到第一个字段是三个字符被读取。第二个字段是五个字符被读取。第三个字段是四个字符被读取。而代码点实际上是第三个字段、大小和有限读取器与学生之间的强度。首先。
- en: dynamically created a copy of the NCO， that's really the public entity。 And
    it exposes you to functions that we call a game that's seen in total。 We're attending
    either a point or we're attending an offset。 And again。 the limited reader knows
    where we are in the file。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 动态创建一个NCO的副本，这确实是公共实体。它向你暴露我们称之为游戏的函数，这是总共看到的。我们正在关注一个点或关注一个偏移量。而且有限读取器再次知道我们在文件中的位置。
- en: so we know which column which NCO to copy those as we move through the file。
    So the return is a game dive in， which is a code point where it surrounds and
    contains one or more code point welcome。 All right， so let's go to the next slide。
    We'll just go ahead and ask these copies of these changes。 How do we need to learn
    how they can get to a final result？ So we first， use our input。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们知道在文件中移动时，哪个列和哪个NCO来复制它们。因此，返回是一个潜水游戏，这是一个代码点，它环绕并包含一个或多个代码点欢迎。好的，我们来看看下一张幻灯片。我们只需继续询问这些更改的副本。我们需要了解它们如何能够得到最终结果？所以我们首先使用我们的输入。
- en: Our input is simply an iterator of records。 It can be a file， it can be an array
    of experiments。 Next， we initialize the limited reader and the code point break。
    Now we're ready to。 in our first iteration， use the NCO to file a load up our
    code point welcome。 So in this short part。 I'll start over to discuss how that
    works。 So we start a couple of boxes here， a pie on this。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输入仅仅是一个记录的迭代器。它可以是一个文件，也可以是一个实验数组。接下来，我们初始化有限读取器和代码点断点。现在我们准备好了。在第一次迭代中，使用NCO来加载我们的代码点欢迎。因此在这个简短的部分，我将重新讨论这一过程的运作方式。我们在这里开始几个框，这里放一个饼图。
- en: an iterator of code， we need that to get the underlying UCO to array。 and we
    can v-set our code right through a number， and we're ready to iterate through
    an array of code points。 So as you iterate through code points， that's just fine
    with the bottom there。 But as you see。 iterate through code points， we say， is
    it a good number or not？ If it's not a good number。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个代码的迭代器，我们需要这个来获取底层的UCO到数组。我们可以通过一个数字来设置我们的代码，并且我们准备好遍历一个代码点的数组。因此，当你遍历代码点时，这在底部是没问题的。但是正如你所见，遍历代码点时，我们会说，这是一个好数字还是坏数字？如果不是一个好数字。
- en: then we need to iterate through a point， and if you can prevent this new number。
    If you iterate through the middle， then you know we're done with the field。 We
    can attend an offset。 and we can implement this new number in a new state。 This
    new number。 Then when we're done with that character， we go on， and say， we'll
    give you have more characters。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要迭代一个点，如果你能防止这个新数字。如果你从中间开始迭代，那么你就知道我们已经完成了这个字段。我们可以关注一个偏移量，并且可以在一个新状态中实现这个新数字。这个新数字。当我们完成这个字符后，我们继续，并说，我们会给你更多的字符。
- en: and we'll use the field， until we're done with this record。 Now again。 notice
    that the field here has no file， but really capable of getting the performance
    sizes。 Finally， we are done with the delegate record， and going and working with
    the record count。 and you can see if we have any more records， and then we go
    back and we need to keep the whole process again。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用该字段，直到完成此记录。再次注意，这里的字段没有文件，但实际上能够获取性能大小。最后，我们完成了代理记录，并继续处理记录计数。你可以查看是否还有其他记录，然后我们需要重新开始整个过程。
- en: We've completed our first iteration， two of the elements of what we're trying
    to represent here。 Now we're ready to essentially go to the middle again， but
    we know all the middle records。 we know all the middle to the middle of the middle。
    Now everything is loaded in our code point line。 and we're ready to convert those
    two arrays to the middle of our final output。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了第一次迭代，涉及到我们试图表示的两个元素。现在我们准备再次进入中间，但我们知道所有的中间记录，知道所有中间的中间。现在一切都已加载到我们的代码点行，并且我们准备将这两个数组转换为我们最终输出的中间。
- en: which is going to be a little bit of a super rate。 So this whole。 the different
    part shows that special iteration is going to be done。 We're going to start with
    the CCL。 We're going to walk into the code point line。 and then the next step
    is we need to complete our NumPy array。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个超级速率的过程。所以整个不同的部分显示特殊迭代将会完成。我们将从CCL开始，进入代码点行，然后下一步是我们需要完成我们的NumPy数组。
- en: that we're going to ultimately deliver back to the power。 To do that。 you can
    see all the size and the type。 We know the size， because the CCL is already loaded。
    and the text might come from the type processor， or it might come from the G-Brings
    provided by the argument。 Once we have that， we can complete our NumPy array。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终将把它交回到功能中。为此，你可以查看所有的大小和类型。我们知道大小，因为CCL已经加载，文本可能来自类型处理器，或者来自参数提供的G-Brings。一旦我们有了这些，我们就可以完成我们的NumPy数组。
- en: and it would be a complete array of some kind of array， in which we can pull
    off the other line。 and do the buffer。 And so we're done with purple boxes。 We
    have no after this step。 we can put aside our high objects， and we can focus on
    just doing the secure C-type。 Now in this case， we're going to grab the next offset。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是某种数组的完整数组，我们可以从其他行中提取数据并进行缓冲。所以我们已经完成了紫色框。此步骤之后我们没有其他操作，可以将我们的高对象放在一边，专注于安全的C类型。现在在这种情况下，我们将获取下一个偏移量。
- en: We're going to use an offset to bring the sum of our unit code code points。
    so we can convert those two into the type， and we're going to insert that C-type
    directly into our NumPy array。 And then we can continue to do that in every unit。
    and we can do that all without any interaction with the high objects。 Finally，
    already done。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个偏移量来引入我们单位代码点的总和，以便可以将这两个转换为类型，并将该C类型直接插入到我们的NumPy数组中。然后我们可以在每个单位中继续这样做，而无需与高对象进行任何交互。最后，已经完成。
- en: we need to attend that array to a list， and then we can interact with the high
    objects。 and we go on and consider here more C-to-do-l as the process。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将该数组转换为列表，然后可以与高对象进行交互。我们继续在这里考虑更多的C-to-do-l作为过程。
- en: '![](img/b840ff5722b15db3c148661cdad8345d_15.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b840ff5722b15db3c148661cdad8345d_15.png)'
- en: and we can take the type of data。 So as the addition performance， we just need
    a critical。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取数据类型。因此，作为附加性能，我们只需要一个关键因素。
- en: '![](img/b840ff5722b15db3c148661cdad8345d_17.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b840ff5722b15db3c148661cdad8345d_17.png)'
- en: and that is the main goal of the C-to-do-l as we said we have completed。 So
    we're going to get a number of questions。 Now the way I've seen benchmarks is
    on fairly large numbers of elements。 which we are making at 10 million elements，
    and we're going to use a tremendous。 random generated value in the high objects
    called playing 16。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所说的C-to-do-l的主要目标，我们已经完成了。所以我们将会有许多问题。根据我的观察，基准测试通常是在相当大的元素数量上进行的，我们正在处理`1000万`个元素，并且将使用一种在高对象中随机生成的值，称为playing
    16。
- en: And we're going to get a super-incinary array for interpreting columns。 in both
    types and in templates。 So one scenario is type to cover。 You can get in the C-to-do-l
    as you know any of the types。 It's going to figure out the types for you。 The
    second scenario is just go to the C-to-do-l as well。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得一个超级递增数组，用于解释列，包括类型和模板。因此，一个场景是类型覆盖。你可以在C-to-do-l中获取任何类型。它会为你确定类型。第二种场景也是直接进入C-to-do-l。
- en: I don't care what the types are， just send me off to any of these。 And the third
    scenario is I know all my types， so can type to cover。 and just go to the C-to-do-l
    as you know that I'm going to go。 So we're going to come back to this。 So right
    now I want you to focus on the legend of the hero and the right。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我不在乎类型是什么，只需把我送到这些任何地方。而第三种情况是我知道我的所有类型，所以可以输入以覆盖。然后就去C-to-do-l，正如你知道的，我会去那里。因此，我们将回到这个问题。所以现在我想让你专注于英雄的传奇和正确。
- en: which shows those three scenarios。 First， the static frame， type to the screen，
    type to the given。 and second， type to the standard， type to the end， and type
    to the end。 So we're going to come back to this。 Now， I think it's really important
    when you're getting to films and albums。 for data frames that we need to explore
    different things and can type better data。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了这三种情况。首先，静态框，类型到屏幕，类型到给定。其次，类型到标准，类型到结束，类型到结束。所以我们将回到这个问题。现在，我认为在你接触电影和专辑时，这真的很重要。对于数据框，我们需要探索不同的事物，并能够更好地输入数据。
- en: I've been far too often I see performance as better as the data frame operation。
    where you just compare one table to the other。 And you can get quite different
    results by having different versions。 eight to table， and type to the other table。
    So we're going to look at three things， one， two。 three， three， three， and type
    to the other table。 So we're going to look at three types of different types of
    images。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我常常看到性能比数据框操作更好。在那里你只是将一个表与另一个表进行比较。通过拥有不同的版本，你可以获得相当不同的结果。八到表，类型到另一个表。因此我们将看三件事，一，二。三，三，三，类型到另一个表。因此我们将看三种不同类型的图像。
- en: whether we have a different type for columns， whether we have the nips。 or we
    have a chunk of new content together， or whether it's uniform， it's just all one
    type。 So we're going to create our grid。 We're going to have the state and talk
    for a wide of columns。 and we're going to have a wide range of data frames。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是否为列有不同的类型，是否有nip，或者我们是否有一块新内容在一起，或者它是否均匀，都是一种类型。所以我们将创建我们的网格。我们将有状态，并为广泛的列进行讨论。我们将会有广泛的数据框。
- en: And we're going to have a wide range of data frames。 And we're going to have
    a wide range of data frames。 and we're going to have a wide range of data frames。
    And we're going to have a wide range of data frames。 And we're going to have a
    wide range of data frames。 And we're going to have a wide range of data frames。
    And we're going to have a wide range of data frames。 And we're going to have a
    wide range of data frames。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会有广泛的数据框。我们将会有广泛的数据框。我们将会有广泛的数据框。我们将会有广泛的数据框。我们将会有广泛的数据框。我们将会有广泛的数据框。我们将会有广泛的数据框。我们将会有广泛的数据框。
- en: And we're going to have a wide range of data frames。 And we're going to have
    a wide range of data frames。 So in general。 certain alcohols can be handled in
    a lot of these cases， specifically。 can't get out of the 20-centre areas that
    are， in alcohols and those。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会有广泛的数据框。我们将会有广泛的数据框。因此一般来说，某些醇可以在很多这些情况下处理，具体来说。不能超出20个中心区域，这些区域是在醇中及那些。
- en: The one case that we don't is right there in the uniformed。 call scenario where
    the type part in these new things， will render the data a little bit better。 Other
    than that， there are certain elements of alcohols， and those are all of these
    scenarios。 Another other thing that is that the word standard converts， strings
    to non-high obviously ways。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一不符合的情况就在那里，在没有信息的情况下。调用场景中，这些新事物中的类型部分，将使数据的呈现稍微好一些。除此之外，还有某些类型的醇，这些都是这些场景。另一个事情是，标准转换词将字符串以非高显然的方式转换。
- en: And since the branch is high object， that's very expensive。 So if you look here。
    you see the candles， what do you do， at the screen？ And that's that orange bar。
    You see that almost every piece that that orange bar is， taking the most time。
    So that is an expensive concept and a solution for that first。 So finally。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个分支是高对象，这非常昂贵。所以如果你看这里。你看到蜡烛，你在屏幕上做什么？那就是那个橙色条。你会看到几乎每一部分那个橙色条，花费了最多的时间。因此，这是一个昂贵的概念和第一个解决方案。所以最后。
- en: you notice that we just knew the excellent performance。 for a permanent fill
    rate and started playing with wide， data findings。 Whereas when we did call。 our
    performance was then， consistent with the label。 And I think that might continue
    to be using the previous side， of the Unicode type， which was four。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们刚刚了解到出色的性能，针对永久填充率并开始处理宽数据发现。而当我们进行调用时，我们的性能与标签一致。我认为这可能会继续使用之前的 Unicode
    类型，那个是四个。
- en: that made me look， into a call performance there。 So you can hear in the wide
    result。 we can see the， outcomes of static playing in many of these files in order
    of， magnitude。 better than pandas。 But as we go to more call， we can get a community。
    that is made in just about twice a thousand nights。 We'll change it to a bit，
    I think。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我关注那里的调用性能。因此你可以在宽结果中听到，我们可以看到静态处理在许多这些文件中的结果是数量级地好于 pandas。但当我们进行更多调用时，我们可以得到一个社区，这在大约两千个夜晚中制造。我们将稍微改变它，我想。
- en: a different page。 I'm missing the timeline from tech。 This 15 is important。
    which is what I use for many years。 It is the only one time we see that supports
    micro-submarine。 but as I mentioned at the beginning， it doesn't really meet，
    my needs。 So here I've added an un-type data from tech to these， performance studies。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的页面。我错过了技术的时间线。这个 15 很重要，这是我多年来使用的。这是唯一一次我们看到支持微型潜艇的，但正如我在开头提到的，它并不真正满足我的需求。因此，在这里我增加了来自技术的非类型数据到这些性能研究中。
- en: And we can see for call and swear， people， it performs much， much slower than
    by static playing。 And I'm happy to see you on wide data playing。 It's a very
    important benefit。 which pandas and effect， performs a little bit better than
    pandas and places。 All right。 so hopefully I could be seeing the， community's
    range offering the fast， full-featured tools。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在调用和宣誓方面，人们的性能比静态处理慢得多。我很高兴看到你在宽数据处理上。这是一个非常重要的好处，而 pandas 的表现稍微优于 pandas
    和其他地方。好吧，希望我能看到社区提供快速、功能齐全的工具。
- en: for Canadian non-type arrays from CSUN。 If you're working with non-type。 you
    can use it in isolation。 If you want to use it within a full-featured data playing，
    library。 it's going to start at time， what everything you can do。 So instead of
    where else do you want to go with this， I have to consider a parallelization。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 针对来自 CSUN 的加拿大非类型数组。如果你正在使用非类型，你可以独立使用它。如果你想在一个功能齐全的数据处理库中使用它，它会从时间开始，列出你能做的所有事情。所以与其问你想要往哪里去，我必须考虑并行化。
- en: If you're aware of anything， you can parallelize some of these， operations。
    Now。 when we're reading the file and we're loading the details。 I don't think
    we can serialize that kind of history。 But once all of our teams know they're
    fully loaded， we can convert those to non-type arrays。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道任何事情，你可以并行化一些操作。现在，当我们读取文件并加载细节时，我认为我们无法序列化那种历史。但一旦我们所有团队都知道他们已完全加载，我们可以将这些转换为非类型数组。
- en: And that is， in fact， an embarrassing and parallel problem， that we're going
    to have to do。 So。 the more-type-subtitling string， the more-type-subtitling。
    we can type on that our cost platforms are in use。 And if we're going to write
    to the other side。 we'll have to have a significant use that， in possibly a half-game
    batch。 Now。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个令人尴尬的并行问题，我们必须解决。因此，更多的类型细分字符串，更多的类型细分。我们可以在我们的成本平台上进行类型。如果我们要写到另一边，我们必须显著使用它，可能在半个游戏批次中。现在。
- en: we're going to get a bit of a parallelized miss-reward。 and provide it to us
    by the polarist data-subtling library。 As many of you probably know。 polarism
    implemented in Rust， based on the arrow array definitions。 and it offers what
    we call the release。 This gives advantage of multi- and multi-threaded implementation。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会获得一些并行化的错误奖励，并通过极化数据细分库提供给我们。正如你们可能知道的，极化是用 Rust 实现的，基于箭头数组定义，并提供我们所称的释放。这为多线程和多进程实现提供了优势。
- en: And this is really how third it can be， because it does not support the following。
    of dialogue/diolex considerations， and it's built around arrows。 where it does
    not really support all non-type details。 But thank you for your question。 So。
    as we add four new performance test values in the other bar， this is where we
    will work forward。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是第三方如何运作，因为它不支持对话/对立考虑，并且是围绕箭头构建的，它并不真正支持所有非类型细节。但感谢你的提问。因此，当我们在另一个条形图中添加四个新的性能测试值时，这就是我们将要向前推进的地方。
- en: But as we get where and more columnar， we should set a frame using a little
    bit of such a TV in one thread。 and I'll perform the four multi-threaded implementation，
    at least for wide data summaries。 So。 some more work to do potentially there，
    but this is very， very good。 All right， in conclusion。 we can go back to the piece
    of code。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们变得更加结构化时，我们应该在一个线程中使用一些这样的电视来设置一个框架。我将执行四个多线程实现，至少用于宽数据汇总。所以，那里可能还有更多的工作要做，但这非常非常好。好的，总结一下，我们可以回到那段代码。
- en: '![](img/b840ff5722b15db3c148661cdad8345d_19.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b840ff5722b15db3c148661cdad8345d_19.png)'
- en: I think all of us write code hoping that it might be useful， for a month or
    a year or maybe maybe。 So， to have a piece of code that's been around for 20 years，
    it continues to be useful。 but in the standard library， and useful for people
    like me to take this。 and build it into something else， which is really exciting
    in this particular way。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我们所有人写代码时都希望它可能有用，可能持续一个月、一年，或者更久。所以，有一段代码已经存在了 20 年，依然有用。它在标准库中，对像我这样的人有用，可以将其构建成其他东西，这在这个特定的方式上非常令人兴奋。
- en: '![](img/b840ff5722b15db3c148661cdad8345d_21.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b840ff5722b15db3c148661cdad8345d_21.png)'
- en: And it's something that's relevant in the other part of that。 All right。 thank
    you for your attention。 It seems like you'll learn more about set of thing。 or
    other related tools。 You can build it with URL。 And， since there are 10。000 things
    throughout the conference， I'll be around， happy to take these questions now，
    or later on。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这在其他部分也是相关的。好的，谢谢你的关注。看来你将会了解更多相关的事情或其他工具。你可以用 URL 来构建它。由于在整个会议中有 10,000 件事情，我会在这里，很高兴现在或稍后回答这些问题。
- en: thank you for your attention。 [ Pause ]。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢你的关注。[暂停]。
- en: '![](img/b840ff5722b15db3c148661cdad8345d_23.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b840ff5722b15db3c148661cdad8345d_23.png)'
- en: '![](img/b840ff5722b15db3c148661cdad8345d_24.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b840ff5722b15db3c148661cdad8345d_24.png)'
