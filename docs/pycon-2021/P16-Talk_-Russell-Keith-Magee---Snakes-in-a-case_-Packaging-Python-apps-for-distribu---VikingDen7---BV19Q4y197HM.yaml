- en: P16：Talk_ Russell Keith-Magee - Snakes in a case_ Packaging Python apps for
    distribu - VikingDen7 - BV19Q4y197HM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P16：Talk_ Russell Keith-Magee - Snakes in a case_ 打包Python应用以进行分发 - VikingDen7
    - BV19Q4y197HM
- en: Hi there， my name is Russell Keith McGearn。 I'm here today to talk to you about
    putting。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大家好，我叫拉塞尔·基思·麦吉恩。今天我在这里与你们谈谈分发。
- en: '![](img/6af2dd25d93531faab78b7ea91661a6d_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6af2dd25d93531faab78b7ea91661a6d_1.png)'
- en: your snakes into a briefcase for easy transportation。 I am speaking to you today
    from Wajuknunga。 Puchar， otherwise known as Perth Western Australia and I would
    like to recognise the。 Wajuknunga as the traditional owners of the land where
    I'm recording to recognise their。 continuing connection to their land， waters
    and culture and to pay my respects to their。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你的蛇装进公文包中以便于运输。今天我在瓦朱克农戈·普查尔（即西澳大利亚珀斯）向你们讲话，我想认可瓦朱克农戈作为我录制的土地的传统所有者，以认可他们与土地、水域和文化的持续联系，并向他们致以敬意。
- en: builders past， present and emerging。 So last year at PyCon US in Cleveland。
    I had the very distinct honour of being the opening。 keynote and in that talk
    I spoke about the challenges facing Python as a language and。 the gaps that exist
    in our community's tools。 One of those gaps relates to something that。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 构建者的过去、现在和未来。所以去年在克利夫兰的PyCon US上，我非常荣幸地成为开幕主题演讲者。在那次演讲中，我谈到了Python作为一门语言所面临的挑战以及我们社区工具中的空白。其中一个空白与某种东西有关。
- en: seems like it should have an obvious solution。 If you're an author of some Python
    code and。 the time comes to give that code to somebody else so that they can run
    it， how do you do， that？
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎应该有一个明显的解决方案。如果你是某些Python代码的作者，当是时候将这些代码交给其他人以便他们可以运行时，你该如何做到呢？
- en: There isn't a single simple answer to this problem and part of the reason is
    that。 distribution means different things to different people。 If you are an author
    of a library of。 code that is a collection of Python code that has a well-defined
    API that you want other。 people to embed into their own projects， Python does
    have a reasonably good answer for you。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，没有一个简单的答案，部分原因是分发对不同的人有不同的含义。如果你是一个库的作者，这个库是一个有良好定义API的Python代码集合，你希望其他人将其嵌入到自己的项目中，Python确实为你提供了一个相当不错的答案。
- en: and it's built in。 A project like Requests for example has a clear distribution
    story。 The project is configured with a set up。py and a set up。cfg file and when
    the maintainers。 want to publish a new version they build a wheel for that new
    version and upload the， wheel to PyPI。 And as an end user you can then pip install
    Requests and then import Requests。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这内置的功能。例如，像Requests这样的项目有一个明确的分发故事。该项目配置了一个`setup.py`和一个`setup.cfg`文件，当维护者想要发布新版本时，他们会为该新版本构建一个wheel并上传到PyPI。作为最终用户，你可以通过pip安装Requests，然后导入Requests。
- en: in your code and then start making Requests。 And okay， Python's packaging ecosystem
    occasionally。 has some rough edges but for the most part for most use cases thanks
    to the amazing efforts。 of the Python packaging authority tools like PyPI and
    pip and twine work really reliably。 A second use case for distribution is a Python
    project。 A project might have a version control。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中，然后开始发出请求。好的，Python的打包生态系统偶尔会有一些小问题，但在大多数情况下，得益于Python打包机构的出色努力，像PyPI、pip和twine这样的工具工作得相当可靠。另一个分发的用例是Python项目。一个项目可能具有版本控制。
- en: repository or it might just be a collection of code in a directory somewhere
    but it won't be。 uploaded to PyPI。 You get the code from the repository where
    you get a copy of the directory and you。 effectively run the repository or the
    directory。 A website like the PyConUS website would be the。 classic example here
    but it's not a website specific phenomenon。 Other software can be distributed。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个代码库，或者只是某个目录中的代码集合，但不会被上传到PyPI。你从代码库获取代码，或者获取目录的副本，并有效地运行这个代码库或目录。像PyCon
    US网站这样的网站就是经典例子，但这并不是特定于网站的现象。其他软件也可以被分发。
- en: as a project。 A lot of Jupyter notebooks are projects in this sense。 They are
    collections of code that， aren't designed for commodified reuse。 They serve a
    single purpose。 These projects are， distributed by copying and then deployed in
    some way。 The project isn't installed in any， conventional sense。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个项目。很多Jupyter笔记本在这个意义上是项目。它们是代码的集合，并不是为了商品化重用而设计。它们服务于一个单一的目的。这些项目是通过复制分发的，然后以某种方式部署。这个项目在任何传统意义上都没有被安装。
- en: They don't have a single Python mandated configuration either。 They may have。
    some configuration in a requirements file but even that name is a little bit more
    than a convention。 and the problem of how you set up your execution environment
    is left as a documentation issue and。 usually presumes some degree of familiarity
    with the Python development ecosystem。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 他们也没有单一的Python强制配置。他们可能在requirements文件中有一些配置，但即使那个名称也只是一个约定。而如何设置执行环境的问题则留作文档问题，通常假设用户对Python开发生态系统有一定的了解。
- en: Another use case for developer tools in the Python ecosystem is on PyPI as well
    just like a。 library。 You can pip install PyTest into your development environment
    and you can import PyTest。 to add fixtures of parameterized test cases to your
    code base but because of metadata in the。 PyTest wheel， pip will also install
    an entry point that will let you invoke PyTest from the。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python生态系统中的另一个开发工具用例也是在PyPI，就像一个库。你可以在开发环境中`pip install PyTest`，然后可以导入PyTest，以便为你的代码库添加参数化测试用例的固定装置，但由于PyTest
    wheel中的元数据，pip还会安装一个入口点，让你从。
- en: command line。 However， it's not always as straightforward as this。 If you've
    used GitHub pages you might， have come across a static site generator called Jekyll。
    Jekyll is written in Ruby and the quick， starting instructions on the Jekyll homepage
    say that you should run gem install bundler jekyll。 Now， I'm not a Ruby developer
    so what does that mean？ And when I find another Ruby tool that tells。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行。然而，这并不总是那么简单。如果你使用过GitHub Pages，可能会遇到一个名为Jekyll的静态网站生成器。Jekyll是用Ruby编写的，Jekyll主页上的快速启动说明说你应该运行`gem
    install bundler jekyll`。现在，我不是Ruby开发者，这意味着什么呢？当我发现另一个Ruby工具时，它会告诉我。
- en: me to bundle other tool， have I already installed bundle？
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我是否已经安装了bundle，以便将其他工具打包？
- en: Will the version that I have or be compatible？ If this new tool tells me that
    I need to update my Ruby interpreter。 is Jekyll going to keep working？ Jekyll
    is written in Ruby but this isn't a problem about Ruby。 Python tools have exactly，
    the same problem。 It's a distribution problem。 The language of implementation
    is of almost no， significance to the end user。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我拥有的版本是否兼容？如果这个新工具告诉我需要更新我的Ruby解释器，Jekyll会继续工作吗？Jekyll是用Ruby写的，但这并不是关于Ruby的问题。Python工具也有完全相同的问题。这是一个分发问题。实现语言对最终用户几乎没有意义。
- en: The authors of PyTest can be reasonably， sure that you know something about
    the Python ecosystem because PyTest users are pretty much。 all going to be Python
    developers but what if your users aren't Python developers saying， oh。 create
    a virtual environment and run pip install my tool？ That makes no sense to anybody
    who isn't。 already an experienced Python developer and to someone who is just
    starting with Python， it's a。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: PyTest的作者可以合理地认为你对Python生态系统有一定了解，因为PyTest用户几乎都是Python开发者，但如果你的用户不是Python开发者，比如说，哦，创建一个虚拟环境并运行`pip
    install my tool`？这对任何不是已经有经验的Python开发者的人来说毫无意义，而对刚开始接触Python的人来说，这更是一个。
- en: consistent source of confusion。 And frankly， it's not even a good user experience
    if your users。 are Python developers。 Take a tool like Black for example， with
    some exceptions you probably just。 need one copy on your computer。 When an update
    comes out， you probably want to use that update。 everywhere。 But how do you install
    a Python tool like Black globally if you install it into your。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一直以来的混淆来源。坦白说，即使你的用户是Python开发者，这也不是一个好的用户体验。以Black这样的工具为例，除了少数例外，你可能只需要在计算机上保留一份。当更新发布时，你可能希望在所有地方使用该更新。但如果你将它安装到你的。
- en: system Python then it won't be available or won't be reliable if you ever activate
    a virtual environment？
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你激活了虚拟环境，系统Python将不可用或不可靠？
- en: And what about graphical applications？ Pick a random user space application
    on your laptop。 say Slack。 What languages are written in？ Who cares？
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那么图形应用程序呢？随便选择你笔记本上的一个用户空间应用程序，比如Slack。它们是用什么语言写的？谁在乎？
- en: I'm not looking to engage with Slack as a library， I'm not looking to import
    Slack。 I just want to use it。 I want to install it in a familiar way。 click on
    an icon and have the application start reliably every time。 And if I update another。
    application say Firefox， I don't want my Slack installed to break because Firefox
    updated a shared。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不想将Slack作为库来使用，我只想用它。我想以熟悉的方式安装它，点击一个图标，让应用每次都可靠启动。如果我更新另一个应用，比如Firefox，我不想因为Firefox更新了共享库而导致我的Slack安装出现问题。
- en: interpreter。 What an end user of these applications。 these apps does care about
    is ease of installation， ease of installation。 having the app appear in the start
    menu with a launchpad and potentially。 having that app appear and be downloadable
    via an app store and having it regularly updated via that。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器。这些应用程序的最终用户真正关心的是安装的便利性，安装的便利性。让应用出现在启动菜单中的启动板上，并且有可能让该应用通过应用商店可下载，并定期更新。
- en: channel。 Each of these types of tools has a different distribution requirement。
    they all need Python， at a runtime。 But the only the first of these use cases
    really has a good answer for the Python。 ecosystem。 And even then that development
    story essentially presumes your Python developer who has。 a Python development
    environment and that you're comfortable manipulating it。 The question of how。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 渠道。每种类型的工具都有不同的分发需求，它们都需要在运行时使用Python。但这些用例中只有第一个真正对Python生态系统有好的解决方案。即便如此，那种开发故事本质上假定你是一个有Python开发环境的Python开发者，并且你对操作它感到舒适。问题是如何。
- en: you give Python code to an end user when that end user doesn't care about Python
    or when they're not。 experts in setting up and configuring a Python environment，
    that's a bit of an open question。 But it's a really important question。 It affects
    how users experience our code。 And it's great that。 we have a solution for the
    first use case， but we need reliable solutions for the other three。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将Python代码提供给最终用户时，如果最终用户对Python不感兴趣或不擅长设置和配置Python环境，那就是一个开放的问题。但这是一个非常重要的问题。它影响着用户对我们代码的体验。很高兴我们为第一个用例有了解决方案，但我们需要其他三个用例的可靠解决方案。
- en: Personally， I'm especially interested in the last one to a lesser extent the
    third。 I'm the founder of the B-Web project， which is an attempt to make sure
    that Python remains。 relevant in a computing world that is increasingly mobile
    focused。 If you are building applications。 for iPhone and Android， the only unit
    of distribution is the app。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我特别感兴趣的是最后一个，其次是第三个。我是B-Web项目的创始人，该项目旨在确保Python在一个日益移动化的计算世界中保持相关性。如果你正在为iPhone和Android构建应用程序，唯一的分发单位就是应用。
- en: You can't pip install on an iPhone。 You can't install a system copy of Python
    on your Android device and tell users to create a virtual。 environment。 If Python
    wants to remain relevant in a mobile world， we need a story that encompasses。
    the distribution of apps。 And increasingly， while my primary interest is mobile
    platforms。 the same story actually applies to desktop platforms too。 MacOS and
    Windows have always。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法在iPhone上使用pip安装。你无法在Android设备上安装系统版的Python并告诉用户创建一个虚拟环境。如果Python想在移动世界中保持相关性，我们需要一个涵盖应用分发的故事。并且，尽管我主要关注移动平台，但同样的故事实际上也适用于桌面平台。MacOS和Windows一直。
- en: had applications， but those platforms are increasingly encouraging distribution
    of apps as standalone。 sandbox bundles via app stores。 What I'm going to do today
    is introduce you to the。 B-Web project's solution for this problem。 And that solution
    is briefcase。 Briefcase is a tool for packaging Python applications。 It takes
    your Python code。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 过去有应用程序，但这些平台越来越鼓励通过应用商店以独立沙箱捆绑的方式分发应用。今天我将向你介绍B-Web项目对此问题的解决方案，而这个解决方案就是Briefcase。Briefcase是一个用于打包Python应用程序的工具。它将你的Python代码。
- en: wraps it up as a standalone unit that can be given to an end user with no Python
    experience。 so that they can install it on their platform of choice without ever
    knowing that they're running。 Python code。 Briefcase is a PEP518-complied build
    tool。 If you don't know what that means。 I recommend checking out this blog post
    from Brick Cannon， but the short version is that it。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 它将应用打包成一个独立单元，可以提供给没有Python经验的最终用户，以便他们可以在自己选择的平台上安装，而无需知道他们正在运行Python代码。Briefcase是一个符合PEP
    518的构建工具。如果你不知道这意味着什么，我建议查看Brick Cannon的这篇博客文章，但简而言之，它是一个。
- en: means that it is a build tool that uses PyProject。Tongle for configuration。
    It produces MSI installers for Windows， DMG or raw app bundles for MacOS， App
    Images on Linux。 and it produces iOS and Android projects that can be uploaded
    to the Apple App Store or the Google。 Play Store。 It's also highly extensible。
    If you wanted to add a flat pack or snap back in for。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它是一个使用PyProject进行配置的构建工具。它为Windows生成MSI安装程序，为MacOS生成DMG或原始应用包，为Linux生成App
    Images，并生成可以上传到Apple App Store或Google Play Store的iOS和Android项目。它也具有高度的可扩展性。如果你想为其添加flat
    pack或snap back。
- en: Linux， you could。 Or if you wanted to support an entirely new platform like
    a set-top box or。 watches。 You could do that too。 Now， while it pairs well with
    B-Wears GUI framework， toga。 it doesn't require it。 You can wrap Pyside or TK
    interapps with Briefcase。 The caveat on that。 claim is that Briefcase's capabilities
    are only as good as the frameworks themselves。 Briefcase。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Linux，你可以。或者如果你想支持一个全新的平台，比如机顶盒或手表，你也可以做到。现在，虽然它与 B-Wears 的 GUI 框架 toga 配合得很好，但并不需要它。你可以用
    Briefcase 封装 Pyside 或 TK 交互应用。这个声明的警告是，Briefcase 的能力仅与框架本身一样好。Briefcase。
- en: is a packaging tool。 It won't make your TK interapp work on mobile because TK
    hasn't been ported to。 mobile。 Briefcase also isn't a good match for command line
    tools。 At least not yet。 It could。 potentially be adapted for command line use，
    and I'm personally very interested in seeing that use。 case supported， but it's
    not obvious to me at the moment exactly what that support would look like。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个打包工具。它无法让你的 TK 交互应用在移动设备上运行，因为 TK 尚未移植到移动设备。Briefcase 对命令行工具也不是很合适，至少目前还不是。它可能会被改编为命令行使用，我个人非常希望看到这一用例的支持，但目前对我来说，确切的支持形式并不明显。
- en: And this is mostly a function of how Briefcase works under the hood。 The approach
    used by。 Briefcase is essentially the dumbest thing that could possibly work for
    the problem of app distribution。 A Briefcase application is a full copy of your
    Python code， a full copy of all your code's。 dependencies， and a full copy of
    a full Python interpreter bundle in a way that makes sense for。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是 Briefcase 在内部工作方式的一个功能。Briefcase 使用的方法本质上是可能解决应用程序分发问题的最简单方法。Briefcase
    应用是你的 Python 代码的完整副本、所有代码依赖项的完整副本，以及完整的 Python 解释器捆绑，以一种对你有意义的方式。
- en: the platform you are supporting。 And that's it。 Briefcase is mostly a templating
    tool。 combined with wrappers around PIP to install your Python dependencies and
    wrappers around whatever。 native platform tools are necessary to build DMG or
    MSI files or sign applications for distribution。 Now， Briefcase isn't the only
    application packaging tool that exists in Python， so。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。Briefcase 大多是一个模板工具，结合了 PIP 的封装来安装你的 Python 依赖项，以及构建 DMG 或 MSI 文件或为分发签署应用程序所需的本地平台工具的封装。现在，Briefcase
    并不是 Python 中唯一存在的应用程序打包工具，所以。
- en: why should you use Briefcase and not one of the other options？ Well， firstly，
    it doesn't try to be。 clever。 Some alternatives to Briefcase， like Pyoxidizer
    or Py installer and some modes of operation。 convolve getting a working app with
    making an executable。 And to support the aim of making。 the executable， they play
    all sorts of tricks with your code， bundling it into a zip archive。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你应该使用 Briefcase 而不是其他选项呢？首先，它并不试图聪明。一些替代 Briefcase 的工具，如 Pyoxidizer 或 Py
    installer 及其某些操作模式，将获取一个工作应用与创建可执行文件相卷积。为了支持创建可执行文件的目标，它们对你的代码做各种花招，把它打包成一个 zip
    归档。
- en: it's embedded into the data block and then executed while it's unpacked into
    memory at runtime。 And when that works， it's great。 But it doesn't always work，
    because fundamentally。 Python code is designed to be run by parsing an interpreter
    over a directory of code。 Okay。 if you know enough about Python's import system
    or you know that that's not strictly true。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它嵌入到数据块中，并在运行时解压到内存时执行。当这能正常工作时，那是很棒的。但它并不总是有效，因为从根本上说，Python 代码是设计为通过解析解释器在代码目录上运行的。好吧，如果你对
    Python 的导入系统有足够的了解，或者你知道这并不完全正确。
- en: but if you've got enough practical experience with Python in the real world，
    you know that it。 is close enough to being true in practice and makes no difference。
    If you don't believe me。 all I have to say is zip save X。 And on the other hand，
    Briefcase runs Python the way Python was。 designed to be run an interpreter running
    over a directory of source code。 The only thing Briefcase。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你在现实世界中拥有足够的 Python 实践经验，你会知道这在实践中是足够接近真实的，并且没有区别。如果你不相信我，我只需说一句 zip save
    X。另一方面，Briefcase 以 Python 设计的方式运行 Python，即在源代码目录上运行的解释器。Briefcase 唯一的事情就是你所支持的平台。
- en: does is automate the process of getting that working interpreter to an end user
    in a way that。 doesn't require them to know anything about Python。 Briefcase is
    also cross-platform。 which means that you have a single configuration file that
    produces in stores for MacOS， Windows。 Linux， iOS and Android。 And that means
    you don't have duplicated configurations for distributing。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它的作用是自动化将工作解释器提供给最终用户的过程，以一种不需要他们了解任何 Python 的方式。Briefcase 也是跨平台的，这意味着你有一个单一的配置文件，可以生成适用于
    MacOS、Windows、Linux、iOS 和 Android 的商店。这意味着你不需要为分发重复配置。
- en: your app or removing a potential source of error。 Okay， so enough yak shaving，
    show me the code。 What I'm going to do today， we'll do now， is walk you through
    the lifecycle of packaging a。 project with Briefcase。 If you want a more detailed
    walkthrough， the be where tutorial at docs。bwe。org， has a fully walked work demo
    that gives a lot more explanation than I'm going to be able to give you。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序或消除潜在的错误源。好吧，够了，给我看代码。今天我将要做的是带你了解使用 Briefcase 打包项目的生命周期。如果你想要更详细的讲解，docs.bwe.org
    上的 be where 教程有一个完整的演示，提供了比我能给你的更多解释。
- en: in 25 minutes。 So let's start a new project。 We had a new virtual environment
    and we installed。 Briefcase。 I am giving instructions here with UNIX conventions，
    but Briefcase does also work on。 Windows。 The be where tutorial gives the commands
    for both if you've got how to convert。 If you want， to start a completely new
    project， Briefcase has a wizard to help you run Briefcase new。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 25 分钟内。让我们开始一个新项目。我们创建了一个新的虚拟环境并安装了 Briefcase。我在这里提供的是 UNIX 规范的指令，但 Briefcase
    也在 Windows 上运行。如果你想要了解如何转换，be where 教程为两者提供了命令。如果你想要开始一个全新的项目，Briefcase 有一个向导帮助你运行
    Briefcase new。
- en: and you'll， be presented with a list of questions with some explanatory text。
    And you'll be prompted for a， bunch of details。 You'll be prompted for a form
    online。 That's the name that you show to humans as， the name of your app and an
    app name。 which is the Pythonized version of your name， something you， would pip
    install。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会看到一系列问题，伴随一些解释性文本。你会被提示提供一系列细节。你将被提示填写一个在线表单。那是你展示给用户的应用名称，以及一个 Python 化的名称，是你将会
    pip 安装的名称。
- en: You'll be asked for a bundle that's used for namesbasing to separate my hello。
    world from your hello world。 A bundle ID is a common format used by app stores。
    It's usually a。 reversed ordering of a domain name that you control。 That bundle
    is then combined with an。 app name to make a full bundle ID for your app。 So org。bwe。hello
    world， for example。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被问到一个用于命名空间的捆绑包，以将我的 hello world 与你的 hello world 区分开来。捆绑 ID 是应用商店使用的常见格式。它通常是你控制的域名的反向顺序。然后将该捆绑与应用名称结合，形成你应用的完整捆绑
    ID。例如 org.bwe.hello world。
- en: You'll be asked for a project name。 A Briefcase project can include multiple
    distributed apps。 so you can build multiple app bundles from a single code repository。
    But if you're only going to。 have one app， you can use the form name as your project
    name。 You'll be asked for a one line。 description of the project。 You'll be asked
    for the author's name and emails as used in help text。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被询问项目名称。Briefcase 项目可以包含多个分发应用，因此你可以从一个代码库构建多个应用捆绑。但是如果你只打算有一个应用，你可以将表单名称用作项目名称。你将被要求提供项目的一行描述。你将被询问作者的姓名和在帮助文本中使用的电子邮件。
- en: and copyright labels。 A URL for the project， a license because of his Dributing
    code， you need。 a license。 And lastly， a GUI framework。 Briefcase provides a template
    for toga。 bewears own GUI framework， but there's also a pie side template as well
    as an empty app that you。 can fill with whatever framework you happen to want
    to use。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以及版权标签。项目的 URL，许可因为他的分发代码，你需要一个许可证。最后，还有一个 GUI 框架。Briefcase 为 toga 提供了一个模板，bewears
    自己的 GUI 框架，但也有一个 pie side 模板以及一个空应用，你可以根据需要填充任何你想使用的框架。
- en: And what you'll get at the end of the day， is a complete stop project。 including
    enough code to start an app application icons and a variety。 of formats and some
    project metadata。 You'll also notice that the DAP， the dash in the application。
    name here has been normalized and underscore。 So the app name Hello Dash World
    has been converted。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终得到的，将是一个完整的停止项目，包括足够的代码来启动一个应用程序图标和多种格式以及一些项目元数据。你还会注意到，应用程序名称中的 DAP 破折号已经被规范化为下划线。所以应用名称
    Hello Dash World 已被转换。
- en: into Hello Underscore World when it becomes a source code source directory。
    You'll also get the。 same files regardless of what GUI framework you pick。 The
    only difference with the contents of the。 app。py， the main。py， and some of the
    values in the pie project。tomal。 The metadata that is。 particular interest here
    is in pie project。tomal。 That's the file that contains all the details about。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当它成为源代码源目录时，变为Hello Underscore World。无论你选择哪个GUI框架，你都会得到相同的文件。应用的内容唯一不同的是app.py、main.py和pie
    project.toml中的一些值。这里特别关注的元数据在pie project.toml中。该文件包含有关应用本身的所有细节。
- en: your app。 The contents of this file will match the answers that you gave in
    the wizard。 There's a。 built system section， which is a requirement of PEP518
    that declares that this is a briefcase。 project。 And all the briefcase options
    are then defined in a tool。briefcase section。 The。 project level options are defined
    in that root level tool。briefcase。 Individual applications then。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用。此文件的内容将与您在向导中提供的答案相匹配。还有一个built system部分，这是PEP518的要求，声明这是一个briefcase项目。所有的briefcase选项随后在tool.briefcase部分中定义。项目级别的选项在该根级tool.briefcase中定义。各个应用则。
- en: have their own sections。 So this configuration file defines Hello Dash World
    as an app。 That's the。 app name with a formal name of Hello World and so on。 The
    configuration for the Hello World app is。 comprised or is composed out of the
    project settings overridden by the application settings。 So the。 Hello World app
    will inherit the project level version definition。 And if you wanted to have a。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 他们有自己的部分。因此，此配置文件将Hello Dash World定义为一个应用。这是应用名称，正式名称为Hello World，等等。Hello World应用的配置由项目设置和应用设置覆盖组成。因此，Hello
    World应用将继承项目级别的版本定义。如果你想要有一个。
- en: different author name for this application， you could do so by adding an author
    name into the。 app's configuration block。 And to be clear， this is a briefcase
    specific behavior。 not something you'll， see unnecessarily， see any other PEP518
    tools。 There are two exceptions to this overriding behavior， source and requires。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为此应用指定不同的作者名称，可以通过在应用的配置块中添加作者名称来实现。需要明确的是，这是一种briefcase特定的行为，并不是你会在其他PEP518工具中看到的。有两个例外情况适用于这种覆盖行为，即sources和requires。
- en: Sources defines the list of directories of source code that you want to。 include
    in your application。 So here we're saying that the source Hello World directory
    is part of。 this application。 That entire folder will be copied recursively into
    our packaged application。 The only requirement on this is that one of your source
    directories needs to match the name of your。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Sources定义了你想包含在应用中的源代码目录列表。因此，这里我们表示源Hello World目录是此应用的一部分。整个文件夹将被递归复制到我们的打包应用中。对此的唯一要求是，你的源目录之一需要与。
- en: application itself。 Requires defines the Python requirements for your application。
    Again， this is。 just as a list using the same format that you'd use as an argument
    to pip install。 Sources and。 requires a cumulative setting。 So if you specify
    a sources definition at the project level， any。 application level sources will
    be appended to that list defined at the project level。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Requires定义了应用的Python依赖项。同样，这只是一个列表，采用你在pip install时使用的相同格式。Sources和requires是一个累积设置。因此，如果你在项目级别指定了sources定义，任何应用级别的sources将被附加到该在项目级别定义的列表中。
- en: Icons also deserve a special mention here。 You'll notice that the icon setting
    doesn't include a。 file format extension。 That's because briefcase uses the provided
    value as a base name and。 appends the format depending upon the platform。 So 。icoverwindows。png
    for Linux and so on。 Some platforms you have to provide multiple icons in multiple
    resolutions and those size。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图标也值得特别提及。你会注意到图标设置不包括文件格式扩展名。这是因为briefcase使用提供的值作为基础名称，并根据平台附加格式。因此，.ico用于Windows，.png用于Linux，等等。在某些平台上，你必须提供多个分辨率的多个图标，这些尺寸。
- en: modifiers will be appended to the file name as well as the extension。 You can
    also specify options that are platform specific by adding a configuration section。
    for that platform。 The generated pipe project。tom will include a section for all
    of the supported。 platforms MacOS Linux Windows iOS and Android。 So here we've
    specified a pytool。briefcase。app。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符将附加到文件名以及扩展名。你还可以通过为该平台添加配置部分来指定特定于平台的选项。生成的pipe project.toml将包括所有支持的平台的部分：MacOS、Linux、Windows、iOS和Android。因此，这里我们指定了一个pytool.briefcase.app。
- en: helloworld。macos， section。 Those options will only apply to MacOS builds of
    this app。 Now again。 sources and requires a cumulative or other settings will
    override app level or project level。 values。 The content here is what you get
    if you pick toga in the wizard but you'll get。 different content if you pick PySide
    or no frame。 You can actually even go and lay it deep still。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: helloworld。macos，部分。这些选项只会应用于该应用程序的MacOS构建。再次强调，sources和requires等累积或其他设置将覆盖应用级或项目级的值。这里的内容是如果你在向导中选择toga时获得的内容，但如果你选择PySide或不使用框架，你将获得不同的内容。实际上，你甚至可以深入探讨。
- en: If you define a tool。briefcase。app。helloworld。macos。dmg， those settings will
    only apply to。 dng builds on MacOS。 You might do this to specify an icon for the
    dng installer for example。 And if you wanted to add a second app to your project
    definition， you can define a tool。briefcase。app。second， app section and then so
    on for platform and packaging formats and so on。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你定义了一个工具。briefcase。app。helloworld。macos。dmg，这些设置只会应用于MacOS上的dng构建。例如，你可能这样做是为了指定dng安装程序的图标。如果你想在项目定义中添加第二个应用程序，你可以定义一个工具。briefcase。app。second，app部分，然后继续为平台和打包格式等进行定义。
- en: Now this stub py project。tom will， file has been generated for you by briefcase
    new but you don't have to use that wizard。 If you've got an existing project you
    can roll your own py project。tom will from scratch。 So however you've created
    it， you've now got a briefcase configuration file。 How do we use it？
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个stub py项目.tom文件是由briefcase new为你生成的，但你不必使用那个向导。如果你有一个现有项目，你可以从头开始自己创建py项目.tom文件。不管你是如何创建的，你现在有了一个briefcase配置文件。我们如何使用它？
- en: Well the first thing you probably want to do is just see if your app runs。 Briefcase
    includes a。 developer mode which lets you rapidly iterate on your configuration。
    Now if you run briefcase， dev。 briefcase will use your py project。tom will to
    work out how to run your project and then run。 it in your local virtual environment。
    The first time you do this it will look at your configuration。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你可能首先想做的就是看看你的应用程序是否能运行。Briefcase包含一个开发者模式，让你快速迭代配置。如果你运行briefcase dev，Briefcase将使用你的py项目.tom文件来确定如何运行你的项目，然后在本地虚拟环境中运行它。第一次这样做时，它将查看你的配置。
- en: file， install all of your declared requirements and then it will install your
    app。 Now keep in mind。 the design motivation for briefcase。 The dumbest thing
    that can possibly work。 Briefcase dev is。 nothing more than shorthand for a pip
    install for a list of requirements for your current platform。 followed by Python
    minus M hello world running your application。 On subsequent runs the dependency。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 文件，将安装你声明的所有要求，然后它将安装你的应用程序。现在请记住，briefcase的设计动机是，最简单的事情也能成功。Briefcase dev只是你当前平台要求列表的pip
    install的简写，接着是Python minus M helloworld运行你的应用程序。在后续运行中，依赖项。
- en: step won't be executed by default。 Briefcase will only start the project just
    by itself。 If you add。 or modify dependency you'll need to add it minus D flag
    to force an updated dependencies。 And if you've used the wizard what you'll get
    is a working application。 It will be an empty window。 but it'll be a working application
    and you can now iterate on the code in your app adding features。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤默认不会执行。Briefcase只会自行启动项目。如果你添加或修改依赖项，你需要添加-D标志以强制更新依赖项。如果你使用了向导，你将得到一个可工作的应用程序。它会是一个空窗口，但它将是一个可工作的应用程序，你可以现在在应用程序代码中进行迭代，添加功能。
- en: fixing bugs， whatever you need to do。 Eventually though the time will come when
    you're ready to。 package your app for distribution。 The first step will be to
    create your app。 And to do this you。 need to invoke briefcase create。 This will
    do a bunch of things。 First it will look at the platform。 you're currently on
    and get an application template for that platform。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 修复bug，无论你需要做什么。然而，最终时机会到来，当你准备好打包你的应用程序以进行分发时。第一步将是创建你的应用程序。为此，你需要调用briefcase
    create。这将做一堆事情。首先，它将查看你当前的平台，并获取该平台的应用程序模板。
- en: So I'm running on Macos so it， will use the Macos DNG template。 Secondly it
    will obtain a support package。 A support package is a。 version of Python that
    can be embedded into your app。 For Windows we use the officially。 distributed
    Python embedded package for every other platform。 Beware maintains a support package。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我在MacOS上运行，因此它将使用MacOS DNG模板。其次，它将获取一个支持包。支持包是一个可以嵌入到你的应用程序中的Python版本。对于Windows，我们使用官方发布的Python嵌入包，其他平台则小心维护支持包。
- en: Whatever your platform briefcase will download the support package unpacked
    into the。 application template that was just created。 Briefcase then downloads
    and installs your app's dependencies。 but it doesn't install them into your local
    virtual environment。 It installs them into the。 application template。 Briefcase
    then installs the application specific bits or the source code for。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 不论你的平台是什么，briefcase将下载支持包，解压到刚刚创建的应用程序模板中。briefcase然后下载并安装你应用的依赖项，但它不会安装到你本地的虚拟环境中，而是安装到应用程序模板中。briefcase接着安装特定于应用程序的部分或源代码。
- en: your app and all the application resources like icons。 And then it's done。 You've
    now got a complete， application template。 Your project directory will now contain
    a platform folder so a folder called。 Macos in this case。 Inside that folder will
    be a folder for every app in your project。 The next step is to build that app。
    And I'm sure you'll be shocked to hear the command to do this。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用和所有应用程序资源，如图标。然后就完成了。你现在拥有一个完整的应用程序模板。你的项目目录现在将包含一个平台文件夹，在这种情况下是一个名为Macos的文件夹。在这个文件夹里会有你项目中每个应用的文件夹。下一步是构建那个应用。我相信你会震惊地听到执行此操作的命令。
- en: is briefcase build。 Now on Macos this actually does nothing because an application
    or the application。 template that was generated is actually executable as is。
    A Macos app is nothing more than a directory， in a particular format with some
    metadata in a known location。 On other platforms there may be， some compilation
    that needs to be done here and briefcase managers invoking that compiler。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 是briefcase build。现在在Macos上，这实际上什么也不做，因为生成的应用程序或应用程序模板实际上是可执行的。Macos应用只不过是一个特定格式的目录，里面有一些已知位置的元数据。在其他平台上，可能需要进行一些编译，而briefcase管理器负责调用那个编译器。
- en: And at this point there will be a folder in your project matching a platform
    and that。 folder will be an application along with any files created as part of
    that build process。 In this case it's a Macos app。 If you were to click on that
    icon an application would start。 Or you could keep it all console based and use
    briefcase。 You can run your app with， you missed it。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，你的项目中会有一个与平台匹配的文件夹，该文件夹将是一个应用程序，以及作为构建过程一部分创建的任何文件。在这种情况下，它是一个Macos应用。如果你点击那个图标，一个应用程序会启动。或者你也可以保持控制台模式，使用briefcase。你可以运行你的应用，你错过了它。
- en: briefcase run。 And what you should see is a running application。 Now it is not
    a。 very interesting application。 But it is a running application。 Whatever that
    means on your platform。 of choice。 On Macos that means an icon in your taskbar。
    an application menu matching your application， name。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: briefcase run。你应该看到一个正在运行的应用程序。现在这不是一个非常有趣的应用程序，但它是一个正在运行的应用程序。不论在你所选的平台上这意味着什么。在Macos上，这意味着任务栏中的一个图标，以及与应用程序名称匹配的应用程序菜单。
- en: The last step is to package your app with briefcase package。 This does any final
    packaging。 that has to be done before distribution。 So creating an installer doing
    code signing and so on。 Code signing support is currently in the early stages
    of development。 Only Macos apps are currently。 signed and they're currently only
    signed not not notarized if you know what that means。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是使用briefcase package打包你的应用。这是分发之前需要完成的任何最终打包工作。因此，创建安装程序、进行代码签名等等。代码签名支持目前处于早期开发阶段。目前只有Macos应用被签名，并且目前仅被签名而未经过公证，如果你知道这是什么意思的话。
- en: This is an area where more work is needed but the pieces are all in place。 But
    after packaging the platform folder in your project will contain an artifact that
    could be。 uploaded for distribution。 A dmg file， an MSI whatever is appropriate
    for the platform of choice。 So we have packaged our app and we discover a problem。
    We need to update our code。 Do we need to。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要更多工作的领域，但所有的组件都已到位。但在打包之后，项目中的平台文件夹将包含一个可以上传进行分发的工件。一个dmg文件，一个MSI，或任何适合所选平台的文件。因此，我们打包了我们的应用，发现了一个问题。我们需要更新我们的代码。我们需要吗？
- en: go through this whole process again？ No。 For that there is briefcase update。
    By default this will。 reinstall just the code for the app。 If you want to update
    the dependencies as well you can specify。 -d if you want to update the application
    resources like icons you can specify -r。 Some other features of briefcase that
    are worthy of note。 Briefcase create is a shorthand。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重新经历这个整个过程吗？不需要。为此有briefcase update。默认情况下，这将重新安装应用程序的代码。如果你也想更新依赖项，可以指定-d。如果你想更新应用程序资源，比如图标，可以指定-r。briefcase还有一些其他值得注意的功能。briefcase
    create是一个简写。
- en: Your platform is implied from the platform where you are currently running the
    code。 The。 output format is the default output format for that platform。 If you
    want a Mac， Briefcase create。 is shorthand for Briefcase create Macos DMG。 Now
    if you wanted to create a different output format。 say you wanted a raw app not
    a DMG file you can invoke Briefcase create Macos app。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你的平台是从你当前运行代码的平台隐含得出的。输出格式是该平台的默认输出格式。如果你想要 Mac，Briefcase create 是 Briefcase
    create Macos DMG 的简写。如果你想创建不同的输出格式，比如你想要一个原始应用而不是 DMG 文件，你可以调用 Briefcase create
    Macos app。
- en: And if you wanted to target a completely different platform， Briefcase create
    platform。 Now in practice that's not especially useful because you can't create
    a Macos DMG or Windows or。 Windows MSI on Mac because the tools required are platform
    specific。 But there is one important。 use case for it and we'll come to that in
    a moment。 Briefcase will also imply early steps if。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想针对完全不同的平台，Briefcase 创建平台。实际上，这并不是特别有用，因为你不能在 Mac 上创建 Macos DMG 或 Windows
    MSI，因为所需的工具是平台特定的。但这有一个重要的用例，我们稍后会提到。Briefcase 还将暗示早期步骤如果。
- en: they are needed。 If you have a completely fresh project straight out of Briefcase
    new and you run。 Briefcase run， Briefcase will detect that there is an attempt
    late and create it and then build it。 and then run it。 Briefcase run also allows
    for a minus U option that updates the app before。 execution。 So your development
    cycle could be as short as Briefcase run minus U over and over again。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是必要的。如果你有一个全新的项目，刚从 Briefcase 新建并运行 Briefcase run，Briefcase 会检测到有一个尝试延迟并创建它，然后构建并运行它。Briefcase
    run 还允许使用 -U 选项，在执行之前更新应用。因此，你的开发周期可以短到不断重复 Briefcase run -U。
- en: Briefcase also checks whether you've got the necessary tools to compile and
    if possible。 manages downloading those tools for you， accepting any licenses and
    so on。 If you can't install the tools for you like it can't like on Macos you've
    got to get Xcode through。 the App Store it will at least tell you explicitly which
    tools you need to get and where you go to。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Briefcase 还会检查你是否具备编译所需的工具，并尽可能为你管理下载这些工具，接受任何许可等等。如果你无法为自己安装工具，比如在 Mac 上无法安装，你必须通过
    App Store 获取 Xcode，至少它会明确告诉你需要获取哪些工具以及去哪里获取。
- en: get them。 And if you're ever unsure what your options are you can add dash dash
    help and get a。 full rundown。 Now the other thing that Briefcase does that I haven't
    mentioned so far deploying to。 mobile platforms。 This is the one place where specifying
    a platform does work and is necessary。 If you want to create an iOS app the steps
    are exactly the same as creating any other app you just add。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 获取它们。如果你不确定自己的选项，可以添加 --help 来获取详细信息。现在，Briefcase 还做的一件事情是部署到移动平台。这是指定平台有效且必要的唯一地方。如果你想创建
    iOS 应用，步骤与创建任何其他应用完全相同，你只需添加。
- en: iOS to all the commands to specify a different platform。 Briefcase create iOS，
    Briefcase build。 iOS and so on。 Similarly for Android Briefcase create Android。
    iOS builds only work on Macos because， of the underlying tooling requirements
    but Android builds will work on MacOS Linux all windows。 The build and run steps
    are also slightly different。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 的所有命令都指定不同的平台。Briefcase create iOS，Briefcase build iOS，等等。对于 Android 也是一样，Briefcase
    create Android。iOS 构建仅在 Mac 上工作，因为底层工具的要求，但 Android 构建将在 MacOS、Linux 和 Windows
    上工作。构建和运行步骤也稍有不同。
- en: When you compile an application you need to target， a specific device。 If you
    run Briefcase run iOS。 Briefcase will inspect your system， find out what， devices
    are available。 ask you what device you want to target。 If you shortcut that， if
    you want。 to shortcut that question you can specify -d to give a device id or
    a device description like an。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 编译应用程序时，你需要针对特定设备。如果运行 Briefcase run iOS，Briefcase 会检查你的系统，找出可用的设备，并询问你想要针对哪个设备。如果你想简化这个问题，可以指定
    -d 来提供设备 ID 或设备描述。
- en: iPhone 11 or iPhone 11 running iOS 11。3。 If there's any ambiguity say if you've
    got multiple iPhone。 11 simulators running you'll be asked to resolve the discrepancy。
    Android does the same thing creating， Android simulators for you or any of those
    for you starting as emulator is necessary。 Once your app is running it is running
    as normal Python code running in the normal Python way。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone 11 或 iPhone 11 运行 iOS 11.3。如果有任何模糊之处，请说明是否有多个 iPhone 11 模拟器在运行，否则会要求你解决差异。Android
    也是如此，创建 Android 模拟器或任何这些，从模拟器开始是必要的。一旦你的应用运行，它就像正常的 Python 代码一样以正常的方式运行。
- en: but it might be useful to get access to some of this packaging metadata at runtime
    and to support。 this Briefcase generates pep566 compliant packaging metadata。
    If you've got a hello world app you can， use importlib。medadata to access your
    briefcase metadata。 Importlib。medadata was added in Python 3。8， but there is a
    backwards compatibility shim that you can use for older Python versions。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但在运行时访问一些打包元数据可能会很有用，并提供支持。这个 Briefcase 生成符合 pep566 的打包元数据。如果你有一个 hello world
    应用，你可以使用 `importlib.metadata` 访问你的 Briefcase 元数据。`importlib.metadata` 是在 Python
    3.8 中添加的，但可以为旧版本的 Python 使用向后兼容的补丁。
- en: The keys aren't exactly the same as they are Briefcase specification。 A app
    name for example is。 named with capital N but that's done for pep566 compatibility。
    All right so Briefcase sounds awesome。 What's the catch？
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些键并不完全相同，它们符合 Briefcase 规范。例如，应用名称是用大写字母 N 命名的，但这是为了符合 pep566 的兼容性。好的，Briefcase
    听起来很棒。那么有什么问题呢？
- en: Well there are plenty of aspects of the individual platforms that could definitely
    be improved。 Linux app images don't currently support desktop entries at present。
    Windows apps aren't currently code signed and they currently report that system
    inspector。 as Python。exe。 iOS can't currently deploy to physical devices。 Android
    support doesn't do code。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，确实有很多方面可以改进各个独立平台。Linux 应用镜像目前不支持桌面条目。Windows 应用目前没有代码签名，且当前报告的系统检查器为 Python.exe。iOS
    目前无法部署到物理设备。Android 支持不进行代码。
- en: signing for the emulator。 MacOS doesn't do not have notarization。 These are
    all solvable problems。 though。 They need time， attention， in some cases a little
    bit of expertise or at least a little bit。 of research to work out what extra
    options we need to pass into our compile command。 The biggest downside， pun intended，
    is the size of the support package。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器的签名。MacOS 不需要公证。这些都是可解决的问题。不过，它们需要时间、关注，在某些情况下需要一点专业知识或至少一些研究，以确定我们需要在编译命令中传递什么额外选项。最大的缺点，双关语，支持包的大小。
- en: The default Briefcase support， package includes a full Python install which
    means a Briefcase app for MacOS is about 200 megabytes。 Now that's not unheard
    of when it comes to applications in the world。 Slack is 174 megabytes but。 they're
    doing it too isn't really a good excuse。 The good news though is that this can
    also be。 fixed。 This Hello World app contains an entire Python standard library。
    It includes bzip2 and。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 Briefcase 支持包包括完整的 Python 安装，这意味着 MacOS 上的 Briefcase 应用大约是 200 兆字节。在应用程序领域，这并不是不寻常的。Slack
    是 174 兆字节，但他们的做法并不能算是一个好借口。不过，好消息是这也可以得到解决。这个 Hello World 应用包含了整个 Python 标准库。它包括
    bzip2 和。
- en: h2dplib and all of this due to and much more and they're never used in many
    most apps。 So there is a lot that can be optimized here。 The immediate workaround
    is the Briefcase will。 allow you to specify your own support package。 So once
    you know that your app only needs a specific。 subset on the standard library you
    can build a hand-tuned version of a support package and use。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: h2dplib 以及所有这些，由于许多应用从未使用过，因此这里有很多可以优化的地方。立即的解决方案是，Briefcase 允许你指定自己的支持包。因此，一旦你知道你的应用只需要标准库的特定子集，你可以构建一个手动调优的支持包并使用。
- en: that。 And with that approach Hello World easily reduces to around 30 megabytes
    as little as 15。 if you try really hard。 That does require hand tuning though
    and the hand tuning process isn't very。 user-friendly at present。 There is a lot
    that could be done to improve that user experience。 There is also an intermittent
    discussion on the Python core team about a kernel Python。 The idea。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，Hello World 的大小轻松减少到约 30 兆字节，努力的话可以低至 15 兆字节。不过，这确实需要手动调优，而目前手动调优的过程并不是很用户友好。还有很多事情可以做来改善用户体验。Python
    核心团队还间歇性讨论了一个内核 Python。这个想法。
- en: of an official Python distribution that is the minimum viable Python with the
    rest of the standard。 library being imported as needed。 That would be absolute
    gold for Briefcase。 Briefcase isn't。 feature complete by any stretch。 It works
    well but there are lots of ways that it could be improved。 during HAST。 I've already
    flagged some of the obvious potential improvements for existing platforms。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个官方的 Python 发行版，即最低可行的 Python，其余标准库根据需要导入。这对于 Briefcase 来说是绝对的黄金。Briefcase
    在功能上并不是完全的。它工作得很好，但有很多方面可以改进。在 HAST 期间，我已经标记了一些现有平台明显的潜在改进。
- en: but we could also add support for new platforms like set up boxes and smartwatches
    or add support。 for other packaging formats like flatpack or snap on Linux。 Adding
    these backends actually isn't。 that much work。 It mostly requires a little expertise
    or research on how to drive the packaging。 tools for those platforms。 I'd also
    like to be able to provide an answer for command line apps。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以为新平台添加支持，比如机顶盒和智能手表，或者为其他打包格式添加支持，比如在Linux上使用flatpack或snap。实际上，添加这些后端并不是太复杂。它主要需要一些专业知识或研究，了解如何驱动这些平台的打包工具。我也希望能为命令行应用提供一个解决方案。
- en: That's mostly a design question at this point rather than a technical limitation。
    What does the Briefcase model of app distribution mean for command line apps？
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这更多是一个设计问题，而不是技术限制。Briefcase的应用分发模型对命令行应用意味着什么？
- en: Most of my testing has also been based on TOGA but one of the biggest areas
    of potential。 improvement is testing that the support works for other GUI frameworks。
    Personally， I am especially。 interested in seeing tests of gaming libraries like
    Pi Game or Pursued Pi Bear because I think。 Python Gaming is one of the biggest
    areas where Briefcase has potential making it easy to distribute。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我的大部分测试也基于TOGA，但潜在的最大改进领域之一是测试支持是否适用于其他GUI框架。就我个人而言，我特别感兴趣的是测试游戏库，如Pi Game或Pursued
    Pi Bear，因为我认为Python游戏是Briefcase最有潜力的领域之一，使游戏能够轻松分发给玩家，而不是开发者，甚至可能分发到移动应用商店。
- en: games to gamers not to developers and potentially to mobile app stores as well。
    And lastly app publication。 Briefcase currently stops with the process of packaging
    your app。 However， app stores all have APIs to support automated publications
    so potentially Briefcase。 could manage that process too。 Does a one-command publication
    process pushing to steam？
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应用发布。Briefcase目前的流程止于打包你的应用。然而，所有应用商店都有支持自动发布的API，因此Briefcase也可能管理这一过程。是否存在一个一键发布流程，推送到Steam？
- en: Sound interesting， to anyone？ Adding all those features though that's dependent
    upon someone having the time to。 improve。 I would like to be able to spend a whole
    lot more time working on Briefcase and。 beware as a whole but at the moment this
    is something I do mostly in my spare time。 If you'd like to， support my work on
    the Briefcase and the Beware project you can join the project as a financial。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来有趣吗？不过，添加所有这些功能依赖于有人有时间去改进。我希望能够花更多时间来开发Briefcase和Beware项目，但目前这主要是我在业余时间做的。如果你愿意，支持我在Briefcase和Beware项目上的工作，你可以作为财务成员加入该项目。
- en: member。 You can also back me on GitHub sponsors。 That income is currently enough
    to cover stickers。 hosting and things like that but it's nowhere near enough to
    make this a full-time gig。 If you've got ideas or experience that might help an
    open source project funders development。 or you'd like to know more about the
    project or get involved， please get in touch。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在GitHub赞助我。这个收入目前足以覆盖贴纸、托管等费用，但远不足以让我将其作为全职工作。如果你有想法或经验，可以帮助开源项目的开发资金，或者你想了解更多关于该项目的信息或参与其中，请随时联系我。
- en: Thank you all very much and I hope I'll see you online then hopefully in person
    next year。 [BLANK_AUDIO]。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢大家，希望明年能在线上见到你们，再希望能亲自见面。[BLANK_AUDIO]
- en: '![](img/6af2dd25d93531faab78b7ea91661a6d_3.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6af2dd25d93531faab78b7ea91661a6d_3.png)'
