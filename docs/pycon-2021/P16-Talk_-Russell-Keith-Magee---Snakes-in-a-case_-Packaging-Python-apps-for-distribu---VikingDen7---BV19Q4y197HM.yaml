- en: P16：Talk_ Russell Keith-Magee - Snakes in a case_ Packaging Python apps for
    distribu - VikingDen7 - BV19Q4y197HM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hi there， my name is Russell Keith McGearn。 I'm here today to talk to you about
    putting。
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6af2dd25d93531faab78b7ea91661a6d_1.png)'
  prefs: []
  type: TYPE_IMG
- en: your snakes into a briefcase for easy transportation。 I am speaking to you today
    from Wajuknunga。 Puchar， otherwise known as Perth Western Australia and I would
    like to recognise the。 Wajuknunga as the traditional owners of the land where
    I'm recording to recognise their。 continuing connection to their land， waters
    and culture and to pay my respects to their。
  prefs: []
  type: TYPE_NORMAL
- en: builders past， present and emerging。 So last year at PyCon US in Cleveland。
    I had the very distinct honour of being the opening。 keynote and in that talk
    I spoke about the challenges facing Python as a language and。 the gaps that exist
    in our community's tools。 One of those gaps relates to something that。
  prefs: []
  type: TYPE_NORMAL
- en: seems like it should have an obvious solution。 If you're an author of some Python
    code and。 the time comes to give that code to somebody else so that they can run
    it， how do you do， that？
  prefs: []
  type: TYPE_NORMAL
- en: There isn't a single simple answer to this problem and part of the reason is
    that。 distribution means different things to different people。 If you are an author
    of a library of。 code that is a collection of Python code that has a well-defined
    API that you want other。 people to embed into their own projects， Python does
    have a reasonably good answer for you。
  prefs: []
  type: TYPE_NORMAL
- en: and it's built in。 A project like Requests for example has a clear distribution
    story。 The project is configured with a set up。py and a set up。cfg file and when
    the maintainers。 want to publish a new version they build a wheel for that new
    version and upload the， wheel to PyPI。 And as an end user you can then pip install
    Requests and then import Requests。
  prefs: []
  type: TYPE_NORMAL
- en: in your code and then start making Requests。 And okay， Python's packaging ecosystem
    occasionally。 has some rough edges but for the most part for most use cases thanks
    to the amazing efforts。 of the Python packaging authority tools like PyPI and
    pip and twine work really reliably。 A second use case for distribution is a Python
    project。 A project might have a version control。
  prefs: []
  type: TYPE_NORMAL
- en: repository or it might just be a collection of code in a directory somewhere
    but it won't be。 uploaded to PyPI。 You get the code from the repository where
    you get a copy of the directory and you。 effectively run the repository or the
    directory。 A website like the PyConUS website would be the。 classic example here
    but it's not a website specific phenomenon。 Other software can be distributed。
  prefs: []
  type: TYPE_NORMAL
- en: as a project。 A lot of Jupyter notebooks are projects in this sense。 They are
    collections of code that， aren't designed for commodified reuse。 They serve a
    single purpose。 These projects are， distributed by copying and then deployed in
    some way。 The project isn't installed in any， conventional sense。
  prefs: []
  type: TYPE_NORMAL
- en: They don't have a single Python mandated configuration either。 They may have。
    some configuration in a requirements file but even that name is a little bit more
    than a convention。 and the problem of how you set up your execution environment
    is left as a documentation issue and。 usually presumes some degree of familiarity
    with the Python development ecosystem。
  prefs: []
  type: TYPE_NORMAL
- en: Another use case for developer tools in the Python ecosystem is on PyPI as well
    just like a。 library。 You can pip install PyTest into your development environment
    and you can import PyTest。 to add fixtures of parameterized test cases to your
    code base but because of metadata in the。 PyTest wheel， pip will also install
    an entry point that will let you invoke PyTest from the。
  prefs: []
  type: TYPE_NORMAL
- en: command line。 However， it's not always as straightforward as this。 If you've
    used GitHub pages you might， have come across a static site generator called Jekyll。
    Jekyll is written in Ruby and the quick， starting instructions on the Jekyll homepage
    say that you should run gem install bundler jekyll。 Now， I'm not a Ruby developer
    so what does that mean？ And when I find another Ruby tool that tells。
  prefs: []
  type: TYPE_NORMAL
- en: me to bundle other tool， have I already installed bundle？
  prefs: []
  type: TYPE_NORMAL
- en: Will the version that I have or be compatible？ If this new tool tells me that
    I need to update my Ruby interpreter。 is Jekyll going to keep working？ Jekyll
    is written in Ruby but this isn't a problem about Ruby。 Python tools have exactly，
    the same problem。 It's a distribution problem。 The language of implementation
    is of almost no， significance to the end user。
  prefs: []
  type: TYPE_NORMAL
- en: The authors of PyTest can be reasonably， sure that you know something about
    the Python ecosystem because PyTest users are pretty much。 all going to be Python
    developers but what if your users aren't Python developers saying， oh。 create
    a virtual environment and run pip install my tool？ That makes no sense to anybody
    who isn't。 already an experienced Python developer and to someone who is just
    starting with Python， it's a。
  prefs: []
  type: TYPE_NORMAL
- en: consistent source of confusion。 And frankly， it's not even a good user experience
    if your users。 are Python developers。 Take a tool like Black for example， with
    some exceptions you probably just。 need one copy on your computer。 When an update
    comes out， you probably want to use that update。 everywhere。 But how do you install
    a Python tool like Black globally if you install it into your。
  prefs: []
  type: TYPE_NORMAL
- en: system Python then it won't be available or won't be reliable if you ever activate
    a virtual environment？
  prefs: []
  type: TYPE_NORMAL
- en: And what about graphical applications？ Pick a random user space application
    on your laptop。 say Slack。 What languages are written in？ Who cares？
  prefs: []
  type: TYPE_NORMAL
- en: I'm not looking to engage with Slack as a library， I'm not looking to import
    Slack。 I just want to use it。 I want to install it in a familiar way。 click on
    an icon and have the application start reliably every time。 And if I update another。
    application say Firefox， I don't want my Slack installed to break because Firefox
    updated a shared。
  prefs: []
  type: TYPE_NORMAL
- en: interpreter。 What an end user of these applications。 these apps does care about
    is ease of installation， ease of installation。 having the app appear in the start
    menu with a launchpad and potentially。 having that app appear and be downloadable
    via an app store and having it regularly updated via that。
  prefs: []
  type: TYPE_NORMAL
- en: channel。 Each of these types of tools has a different distribution requirement。
    they all need Python， at a runtime。 But the only the first of these use cases
    really has a good answer for the Python。 ecosystem。 And even then that development
    story essentially presumes your Python developer who has。 a Python development
    environment and that you're comfortable manipulating it。 The question of how。
  prefs: []
  type: TYPE_NORMAL
- en: you give Python code to an end user when that end user doesn't care about Python
    or when they're not。 experts in setting up and configuring a Python environment，
    that's a bit of an open question。 But it's a really important question。 It affects
    how users experience our code。 And it's great that。 we have a solution for the
    first use case， but we need reliable solutions for the other three。
  prefs: []
  type: TYPE_NORMAL
- en: Personally， I'm especially interested in the last one to a lesser extent the
    third。 I'm the founder of the B-Web project， which is an attempt to make sure
    that Python remains。 relevant in a computing world that is increasingly mobile
    focused。 If you are building applications。 for iPhone and Android， the only unit
    of distribution is the app。
  prefs: []
  type: TYPE_NORMAL
- en: You can't pip install on an iPhone。 You can't install a system copy of Python
    on your Android device and tell users to create a virtual。 environment。 If Python
    wants to remain relevant in a mobile world， we need a story that encompasses。
    the distribution of apps。 And increasingly， while my primary interest is mobile
    platforms。 the same story actually applies to desktop platforms too。 MacOS and
    Windows have always。
  prefs: []
  type: TYPE_NORMAL
- en: had applications， but those platforms are increasingly encouraging distribution
    of apps as standalone。 sandbox bundles via app stores。 What I'm going to do today
    is introduce you to the。 B-Web project's solution for this problem。 And that solution
    is briefcase。 Briefcase is a tool for packaging Python applications。 It takes
    your Python code。
  prefs: []
  type: TYPE_NORMAL
- en: wraps it up as a standalone unit that can be given to an end user with no Python
    experience。 so that they can install it on their platform of choice without ever
    knowing that they're running。 Python code。 Briefcase is a PEP518-complied build
    tool。 If you don't know what that means。 I recommend checking out this blog post
    from Brick Cannon， but the short version is that it。
  prefs: []
  type: TYPE_NORMAL
- en: means that it is a build tool that uses PyProject。Tongle for configuration。
    It produces MSI installers for Windows， DMG or raw app bundles for MacOS， App
    Images on Linux。 and it produces iOS and Android projects that can be uploaded
    to the Apple App Store or the Google。 Play Store。 It's also highly extensible。
    If you wanted to add a flat pack or snap back in for。
  prefs: []
  type: TYPE_NORMAL
- en: Linux， you could。 Or if you wanted to support an entirely new platform like
    a set-top box or。 watches。 You could do that too。 Now， while it pairs well with
    B-Wears GUI framework， toga。 it doesn't require it。 You can wrap Pyside or TK
    interapps with Briefcase。 The caveat on that。 claim is that Briefcase's capabilities
    are only as good as the frameworks themselves。 Briefcase。
  prefs: []
  type: TYPE_NORMAL
- en: is a packaging tool。 It won't make your TK interapp work on mobile because TK
    hasn't been ported to。 mobile。 Briefcase also isn't a good match for command line
    tools。 At least not yet。 It could。 potentially be adapted for command line use，
    and I'm personally very interested in seeing that use。 case supported， but it's
    not obvious to me at the moment exactly what that support would look like。
  prefs: []
  type: TYPE_NORMAL
- en: And this is mostly a function of how Briefcase works under the hood。 The approach
    used by。 Briefcase is essentially the dumbest thing that could possibly work for
    the problem of app distribution。 A Briefcase application is a full copy of your
    Python code， a full copy of all your code's。 dependencies， and a full copy of
    a full Python interpreter bundle in a way that makes sense for。
  prefs: []
  type: TYPE_NORMAL
- en: the platform you are supporting。 And that's it。 Briefcase is mostly a templating
    tool。 combined with wrappers around PIP to install your Python dependencies and
    wrappers around whatever。 native platform tools are necessary to build DMG or
    MSI files or sign applications for distribution。 Now， Briefcase isn't the only
    application packaging tool that exists in Python， so。
  prefs: []
  type: TYPE_NORMAL
- en: why should you use Briefcase and not one of the other options？ Well， firstly，
    it doesn't try to be。 clever。 Some alternatives to Briefcase， like Pyoxidizer
    or Py installer and some modes of operation。 convolve getting a working app with
    making an executable。 And to support the aim of making。 the executable， they play
    all sorts of tricks with your code， bundling it into a zip archive。
  prefs: []
  type: TYPE_NORMAL
- en: it's embedded into the data block and then executed while it's unpacked into
    memory at runtime。 And when that works， it's great。 But it doesn't always work，
    because fundamentally。 Python code is designed to be run by parsing an interpreter
    over a directory of code。 Okay。 if you know enough about Python's import system
    or you know that that's not strictly true。
  prefs: []
  type: TYPE_NORMAL
- en: but if you've got enough practical experience with Python in the real world，
    you know that it。 is close enough to being true in practice and makes no difference。
    If you don't believe me。 all I have to say is zip save X。 And on the other hand，
    Briefcase runs Python the way Python was。 designed to be run an interpreter running
    over a directory of source code。 The only thing Briefcase。
  prefs: []
  type: TYPE_NORMAL
- en: does is automate the process of getting that working interpreter to an end user
    in a way that。 doesn't require them to know anything about Python。 Briefcase is
    also cross-platform。 which means that you have a single configuration file that
    produces in stores for MacOS， Windows。 Linux， iOS and Android。 And that means
    you don't have duplicated configurations for distributing。
  prefs: []
  type: TYPE_NORMAL
- en: your app or removing a potential source of error。 Okay， so enough yak shaving，
    show me the code。 What I'm going to do today， we'll do now， is walk you through
    the lifecycle of packaging a。 project with Briefcase。 If you want a more detailed
    walkthrough， the be where tutorial at docs。bwe。org， has a fully walked work demo
    that gives a lot more explanation than I'm going to be able to give you。
  prefs: []
  type: TYPE_NORMAL
- en: in 25 minutes。 So let's start a new project。 We had a new virtual environment
    and we installed。 Briefcase。 I am giving instructions here with UNIX conventions，
    but Briefcase does also work on。 Windows。 The be where tutorial gives the commands
    for both if you've got how to convert。 If you want， to start a completely new
    project， Briefcase has a wizard to help you run Briefcase new。
  prefs: []
  type: TYPE_NORMAL
- en: and you'll， be presented with a list of questions with some explanatory text。
    And you'll be prompted for a， bunch of details。 You'll be prompted for a form
    online。 That's the name that you show to humans as， the name of your app and an
    app name。 which is the Pythonized version of your name， something you， would pip
    install。
  prefs: []
  type: TYPE_NORMAL
- en: You'll be asked for a bundle that's used for namesbasing to separate my hello。
    world from your hello world。 A bundle ID is a common format used by app stores。
    It's usually a。 reversed ordering of a domain name that you control。 That bundle
    is then combined with an。 app name to make a full bundle ID for your app。 So org。bwe。hello
    world， for example。
  prefs: []
  type: TYPE_NORMAL
- en: You'll be asked for a project name。 A Briefcase project can include multiple
    distributed apps。 so you can build multiple app bundles from a single code repository。
    But if you're only going to。 have one app， you can use the form name as your project
    name。 You'll be asked for a one line。 description of the project。 You'll be asked
    for the author's name and emails as used in help text。
  prefs: []
  type: TYPE_NORMAL
- en: and copyright labels。 A URL for the project， a license because of his Dributing
    code， you need。 a license。 And lastly， a GUI framework。 Briefcase provides a template
    for toga。 bewears own GUI framework， but there's also a pie side template as well
    as an empty app that you。 can fill with whatever framework you happen to want
    to use。
  prefs: []
  type: TYPE_NORMAL
- en: And what you'll get at the end of the day， is a complete stop project。 including
    enough code to start an app application icons and a variety。 of formats and some
    project metadata。 You'll also notice that the DAP， the dash in the application。
    name here has been normalized and underscore。 So the app name Hello Dash World
    has been converted。
  prefs: []
  type: TYPE_NORMAL
- en: into Hello Underscore World when it becomes a source code source directory。
    You'll also get the。 same files regardless of what GUI framework you pick。 The
    only difference with the contents of the。 app。py， the main。py， and some of the
    values in the pie project。tomal。 The metadata that is。 particular interest here
    is in pie project。tomal。 That's the file that contains all the details about。
  prefs: []
  type: TYPE_NORMAL
- en: your app。 The contents of this file will match the answers that you gave in
    the wizard。 There's a。 built system section， which is a requirement of PEP518
    that declares that this is a briefcase。 project。 And all the briefcase options
    are then defined in a tool。briefcase section。 The。 project level options are defined
    in that root level tool。briefcase。 Individual applications then。
  prefs: []
  type: TYPE_NORMAL
- en: have their own sections。 So this configuration file defines Hello Dash World
    as an app。 That's the。 app name with a formal name of Hello World and so on。 The
    configuration for the Hello World app is。 comprised or is composed out of the
    project settings overridden by the application settings。 So the。 Hello World app
    will inherit the project level version definition。 And if you wanted to have a。
  prefs: []
  type: TYPE_NORMAL
- en: different author name for this application， you could do so by adding an author
    name into the。 app's configuration block。 And to be clear， this is a briefcase
    specific behavior。 not something you'll， see unnecessarily， see any other PEP518
    tools。 There are two exceptions to this overriding behavior， source and requires。
  prefs: []
  type: TYPE_NORMAL
- en: Sources defines the list of directories of source code that you want to。 include
    in your application。 So here we're saying that the source Hello World directory
    is part of。 this application。 That entire folder will be copied recursively into
    our packaged application。 The only requirement on this is that one of your source
    directories needs to match the name of your。
  prefs: []
  type: TYPE_NORMAL
- en: application itself。 Requires defines the Python requirements for your application。
    Again， this is。 just as a list using the same format that you'd use as an argument
    to pip install。 Sources and。 requires a cumulative setting。 So if you specify
    a sources definition at the project level， any。 application level sources will
    be appended to that list defined at the project level。
  prefs: []
  type: TYPE_NORMAL
- en: Icons also deserve a special mention here。 You'll notice that the icon setting
    doesn't include a。 file format extension。 That's because briefcase uses the provided
    value as a base name and。 appends the format depending upon the platform。 So 。icoverwindows。png
    for Linux and so on。 Some platforms you have to provide multiple icons in multiple
    resolutions and those size。
  prefs: []
  type: TYPE_NORMAL
- en: modifiers will be appended to the file name as well as the extension。 You can
    also specify options that are platform specific by adding a configuration section。
    for that platform。 The generated pipe project。tom will include a section for all
    of the supported。 platforms MacOS Linux Windows iOS and Android。 So here we've
    specified a pytool。briefcase。app。
  prefs: []
  type: TYPE_NORMAL
- en: helloworld。macos， section。 Those options will only apply to MacOS builds of
    this app。 Now again。 sources and requires a cumulative or other settings will
    override app level or project level。 values。 The content here is what you get
    if you pick toga in the wizard but you'll get。 different content if you pick PySide
    or no frame。 You can actually even go and lay it deep still。
  prefs: []
  type: TYPE_NORMAL
- en: If you define a tool。briefcase。app。helloworld。macos。dmg， those settings will
    only apply to。 dng builds on MacOS。 You might do this to specify an icon for the
    dng installer for example。 And if you wanted to add a second app to your project
    definition， you can define a tool。briefcase。app。second， app section and then so
    on for platform and packaging formats and so on。
  prefs: []
  type: TYPE_NORMAL
- en: Now this stub py project。tom will， file has been generated for you by briefcase
    new but you don't have to use that wizard。 If you've got an existing project you
    can roll your own py project。tom will from scratch。 So however you've created
    it， you've now got a briefcase configuration file。 How do we use it？
  prefs: []
  type: TYPE_NORMAL
- en: Well the first thing you probably want to do is just see if your app runs。 Briefcase
    includes a。 developer mode which lets you rapidly iterate on your configuration。
    Now if you run briefcase， dev。 briefcase will use your py project。tom will to
    work out how to run your project and then run。 it in your local virtual environment。
    The first time you do this it will look at your configuration。
  prefs: []
  type: TYPE_NORMAL
- en: file， install all of your declared requirements and then it will install your
    app。 Now keep in mind。 the design motivation for briefcase。 The dumbest thing
    that can possibly work。 Briefcase dev is。 nothing more than shorthand for a pip
    install for a list of requirements for your current platform。 followed by Python
    minus M hello world running your application。 On subsequent runs the dependency。
  prefs: []
  type: TYPE_NORMAL
- en: step won't be executed by default。 Briefcase will only start the project just
    by itself。 If you add。 or modify dependency you'll need to add it minus D flag
    to force an updated dependencies。 And if you've used the wizard what you'll get
    is a working application。 It will be an empty window。 but it'll be a working application
    and you can now iterate on the code in your app adding features。
  prefs: []
  type: TYPE_NORMAL
- en: fixing bugs， whatever you need to do。 Eventually though the time will come when
    you're ready to。 package your app for distribution。 The first step will be to
    create your app。 And to do this you。 need to invoke briefcase create。 This will
    do a bunch of things。 First it will look at the platform。 you're currently on
    and get an application template for that platform。
  prefs: []
  type: TYPE_NORMAL
- en: So I'm running on Macos so it， will use the Macos DNG template。 Secondly it
    will obtain a support package。 A support package is a。 version of Python that
    can be embedded into your app。 For Windows we use the officially。 distributed
    Python embedded package for every other platform。 Beware maintains a support package。
  prefs: []
  type: TYPE_NORMAL
- en: Whatever your platform briefcase will download the support package unpacked
    into the。 application template that was just created。 Briefcase then downloads
    and installs your app's dependencies。 but it doesn't install them into your local
    virtual environment。 It installs them into the。 application template。 Briefcase
    then installs the application specific bits or the source code for。
  prefs: []
  type: TYPE_NORMAL
- en: your app and all the application resources like icons。 And then it's done。 You've
    now got a complete， application template。 Your project directory will now contain
    a platform folder so a folder called。 Macos in this case。 Inside that folder will
    be a folder for every app in your project。 The next step is to build that app。
    And I'm sure you'll be shocked to hear the command to do this。
  prefs: []
  type: TYPE_NORMAL
- en: is briefcase build。 Now on Macos this actually does nothing because an application
    or the application。 template that was generated is actually executable as is。
    A Macos app is nothing more than a directory， in a particular format with some
    metadata in a known location。 On other platforms there may be， some compilation
    that needs to be done here and briefcase managers invoking that compiler。
  prefs: []
  type: TYPE_NORMAL
- en: And at this point there will be a folder in your project matching a platform
    and that。 folder will be an application along with any files created as part of
    that build process。 In this case it's a Macos app。 If you were to click on that
    icon an application would start。 Or you could keep it all console based and use
    briefcase。 You can run your app with， you missed it。
  prefs: []
  type: TYPE_NORMAL
- en: briefcase run。 And what you should see is a running application。 Now it is not
    a。 very interesting application。 But it is a running application。 Whatever that
    means on your platform。 of choice。 On Macos that means an icon in your taskbar。
    an application menu matching your application， name。
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to package your app with briefcase package。 This does any final
    packaging。 that has to be done before distribution。 So creating an installer doing
    code signing and so on。 Code signing support is currently in the early stages
    of development。 Only Macos apps are currently。 signed and they're currently only
    signed not not notarized if you know what that means。
  prefs: []
  type: TYPE_NORMAL
- en: This is an area where more work is needed but the pieces are all in place。 But
    after packaging the platform folder in your project will contain an artifact that
    could be。 uploaded for distribution。 A dmg file， an MSI whatever is appropriate
    for the platform of choice。 So we have packaged our app and we discover a problem。
    We need to update our code。 Do we need to。
  prefs: []
  type: TYPE_NORMAL
- en: go through this whole process again？ No。 For that there is briefcase update。
    By default this will。 reinstall just the code for the app。 If you want to update
    the dependencies as well you can specify。 -d if you want to update the application
    resources like icons you can specify -r。 Some other features of briefcase that
    are worthy of note。 Briefcase create is a shorthand。
  prefs: []
  type: TYPE_NORMAL
- en: Your platform is implied from the platform where you are currently running the
    code。 The。 output format is the default output format for that platform。 If you
    want a Mac， Briefcase create。 is shorthand for Briefcase create Macos DMG。 Now
    if you wanted to create a different output format。 say you wanted a raw app not
    a DMG file you can invoke Briefcase create Macos app。
  prefs: []
  type: TYPE_NORMAL
- en: And if you wanted to target a completely different platform， Briefcase create
    platform。 Now in practice that's not especially useful because you can't create
    a Macos DMG or Windows or。 Windows MSI on Mac because the tools required are platform
    specific。 But there is one important。 use case for it and we'll come to that in
    a moment。 Briefcase will also imply early steps if。
  prefs: []
  type: TYPE_NORMAL
- en: they are needed。 If you have a completely fresh project straight out of Briefcase
    new and you run。 Briefcase run， Briefcase will detect that there is an attempt
    late and create it and then build it。 and then run it。 Briefcase run also allows
    for a minus U option that updates the app before。 execution。 So your development
    cycle could be as short as Briefcase run minus U over and over again。
  prefs: []
  type: TYPE_NORMAL
- en: Briefcase also checks whether you've got the necessary tools to compile and
    if possible。 manages downloading those tools for you， accepting any licenses and
    so on。 If you can't install the tools for you like it can't like on Macos you've
    got to get Xcode through。 the App Store it will at least tell you explicitly which
    tools you need to get and where you go to。
  prefs: []
  type: TYPE_NORMAL
- en: get them。 And if you're ever unsure what your options are you can add dash dash
    help and get a。 full rundown。 Now the other thing that Briefcase does that I haven't
    mentioned so far deploying to。 mobile platforms。 This is the one place where specifying
    a platform does work and is necessary。 If you want to create an iOS app the steps
    are exactly the same as creating any other app you just add。
  prefs: []
  type: TYPE_NORMAL
- en: iOS to all the commands to specify a different platform。 Briefcase create iOS，
    Briefcase build。 iOS and so on。 Similarly for Android Briefcase create Android。
    iOS builds only work on Macos because， of the underlying tooling requirements
    but Android builds will work on MacOS Linux all windows。 The build and run steps
    are also slightly different。
  prefs: []
  type: TYPE_NORMAL
- en: When you compile an application you need to target， a specific device。 If you
    run Briefcase run iOS。 Briefcase will inspect your system， find out what， devices
    are available。 ask you what device you want to target。 If you shortcut that， if
    you want。 to shortcut that question you can specify -d to give a device id or
    a device description like an。
  prefs: []
  type: TYPE_NORMAL
- en: iPhone 11 or iPhone 11 running iOS 11。3。 If there's any ambiguity say if you've
    got multiple iPhone。 11 simulators running you'll be asked to resolve the discrepancy。
    Android does the same thing creating， Android simulators for you or any of those
    for you starting as emulator is necessary。 Once your app is running it is running
    as normal Python code running in the normal Python way。
  prefs: []
  type: TYPE_NORMAL
- en: but it might be useful to get access to some of this packaging metadata at runtime
    and to support。 this Briefcase generates pep566 compliant packaging metadata。
    If you've got a hello world app you can， use importlib。medadata to access your
    briefcase metadata。 Importlib。medadata was added in Python 3。8， but there is a
    backwards compatibility shim that you can use for older Python versions。
  prefs: []
  type: TYPE_NORMAL
- en: The keys aren't exactly the same as they are Briefcase specification。 A app
    name for example is。 named with capital N but that's done for pep566 compatibility。
    All right so Briefcase sounds awesome。 What's the catch？
  prefs: []
  type: TYPE_NORMAL
- en: Well there are plenty of aspects of the individual platforms that could definitely
    be improved。 Linux app images don't currently support desktop entries at present。
    Windows apps aren't currently code signed and they currently report that system
    inspector。 as Python。exe。 iOS can't currently deploy to physical devices。 Android
    support doesn't do code。
  prefs: []
  type: TYPE_NORMAL
- en: signing for the emulator。 MacOS doesn't do not have notarization。 These are
    all solvable problems。 though。 They need time， attention， in some cases a little
    bit of expertise or at least a little bit。 of research to work out what extra
    options we need to pass into our compile command。 The biggest downside， pun intended，
    is the size of the support package。
  prefs: []
  type: TYPE_NORMAL
- en: The default Briefcase support， package includes a full Python install which
    means a Briefcase app for MacOS is about 200 megabytes。 Now that's not unheard
    of when it comes to applications in the world。 Slack is 174 megabytes but。 they're
    doing it too isn't really a good excuse。 The good news though is that this can
    also be。 fixed。 This Hello World app contains an entire Python standard library。
    It includes bzip2 and。
  prefs: []
  type: TYPE_NORMAL
- en: h2dplib and all of this due to and much more and they're never used in many
    most apps。 So there is a lot that can be optimized here。 The immediate workaround
    is the Briefcase will。 allow you to specify your own support package。 So once
    you know that your app only needs a specific。 subset on the standard library you
    can build a hand-tuned version of a support package and use。
  prefs: []
  type: TYPE_NORMAL
- en: that。 And with that approach Hello World easily reduces to around 30 megabytes
    as little as 15。 if you try really hard。 That does require hand tuning though
    and the hand tuning process isn't very。 user-friendly at present。 There is a lot
    that could be done to improve that user experience。 There is also an intermittent
    discussion on the Python core team about a kernel Python。 The idea。
  prefs: []
  type: TYPE_NORMAL
- en: of an official Python distribution that is the minimum viable Python with the
    rest of the standard。 library being imported as needed。 That would be absolute
    gold for Briefcase。 Briefcase isn't。 feature complete by any stretch。 It works
    well but there are lots of ways that it could be improved。 during HAST。 I've already
    flagged some of the obvious potential improvements for existing platforms。
  prefs: []
  type: TYPE_NORMAL
- en: but we could also add support for new platforms like set up boxes and smartwatches
    or add support。 for other packaging formats like flatpack or snap on Linux。 Adding
    these backends actually isn't。 that much work。 It mostly requires a little expertise
    or research on how to drive the packaging。 tools for those platforms。 I'd also
    like to be able to provide an answer for command line apps。
  prefs: []
  type: TYPE_NORMAL
- en: That's mostly a design question at this point rather than a technical limitation。
    What does the Briefcase model of app distribution mean for command line apps？
  prefs: []
  type: TYPE_NORMAL
- en: Most of my testing has also been based on TOGA but one of the biggest areas
    of potential。 improvement is testing that the support works for other GUI frameworks。
    Personally， I am especially。 interested in seeing tests of gaming libraries like
    Pi Game or Pursued Pi Bear because I think。 Python Gaming is one of the biggest
    areas where Briefcase has potential making it easy to distribute。
  prefs: []
  type: TYPE_NORMAL
- en: games to gamers not to developers and potentially to mobile app stores as well。
    And lastly app publication。 Briefcase currently stops with the process of packaging
    your app。 However， app stores all have APIs to support automated publications
    so potentially Briefcase。 could manage that process too。 Does a one-command publication
    process pushing to steam？
  prefs: []
  type: TYPE_NORMAL
- en: Sound interesting， to anyone？ Adding all those features though that's dependent
    upon someone having the time to。 improve。 I would like to be able to spend a whole
    lot more time working on Briefcase and。 beware as a whole but at the moment this
    is something I do mostly in my spare time。 If you'd like to， support my work on
    the Briefcase and the Beware project you can join the project as a financial。
  prefs: []
  type: TYPE_NORMAL
- en: member。 You can also back me on GitHub sponsors。 That income is currently enough
    to cover stickers。 hosting and things like that but it's nowhere near enough to
    make this a full-time gig。 If you've got ideas or experience that might help an
    open source project funders development。 or you'd like to know more about the
    project or get involved， please get in touch。
  prefs: []
  type: TYPE_NORMAL
- en: Thank you all very much and I hope I'll see you online then hopefully in person
    next year。 [BLANK_AUDIO]。
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6af2dd25d93531faab78b7ea91661a6d_3.png)'
  prefs: []
  type: TYPE_IMG
