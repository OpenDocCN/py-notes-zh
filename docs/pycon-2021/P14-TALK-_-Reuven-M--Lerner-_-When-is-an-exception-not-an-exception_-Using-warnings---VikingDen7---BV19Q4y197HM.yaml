- en: P14：TALK _ Reuven M. Lerner _ When is an exception not an exception_ Using warnings
    - VikingDen7 - BV19Q4y197HM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P14：讨论 _ Reuven M. Lerner _ 何时异常不是异常 _ 使用警告 - VikingDen7 - BV19Q4y197HM
- en: '[MUSIC]。'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[音乐]。'
- en: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_1.png)'
- en: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_2.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_2.png)'
- en: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_3.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_3.png)'
- en: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_4.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_4.png)'
- en: Hey there， this is Reuben Lerner and I want to welcome you to my talk for Python
    2021。 When is an exception， not an exception？ Warnings in Python。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 嗨，我是Reuben Lerner，欢迎来到我为Python 2021的演讲。何时异常不是异常？Python中的警告。
- en: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_6.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_6.png)'
- en: So let's start off with an example from real life。 Your car， your car needs
    gasoline。 Well。 most of us in our cars we need gasoline。 And that gasoline can
    run out。 And you really don't want to be stranded on the road without gasoline。
    So your car has a fuel gauge and the fuel gauge goes from empty to full。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们先从现实生活中的一个例子开始。你的车，需要汽油。嗯，我们大多数人在车上都需要汽油。而汽油会用完。你真的不想在路上没油。所以你的车有一个燃油表，燃油表从空到满。
- en: And you are supposed to go put gas in your car when it gets close to empty。
    Because again。 you don't want it to run out of gas。 What happens if your car is
    close to empty， not quite empty。 and， you haven't put gas in？ Well， that's right，
    a yellow warning light goes on。 Now。 the lights on the dashboard of the cars you
    might know are known as idiot lights sometimes。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的车接近空时，你应该去加油。因为再说一次，你不想让它没油。如果你的车接近空，几乎没油，但你没有加油？没错，黄灯亮起。现在，仪表盘上的灯，有时被称为傻瓜灯。
- en: And this light is indeed saying， hey dummy， you really don't want to be stranded
    on。 the side of the road without gas。 You really should put gas in the car now。
    Drop everything else you're doing， get gas。 Well， that's great because the car
    is trying to stop us from doing something that。 couldn't be harmful before we
    actually caused harm to ourselves or even to the car。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个灯确实在说，嘿，傻瓜，你真的不想在路边没油。你现在真的应该给车加油。放下你正在做的其他事情，去加油。好吧，这很好，因为车试图阻止我们做一些在我们实际上对自己或车造成伤害之前可能并不危险的事情。
- en: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_8.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_8.png)'
- en: Well， think of how often in our code， our program encounters all sorts of really。
    dangerous situations or the user is going to do something potentially dangerous。
    They haven't done anything dangerous yet， but if they persist in their behavior，
    things can get bad。 So what we need is some sort of low fuel light for our software
    and， idiot light as it were to say。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想想在我们的代码中，我们的程序多么频繁地遇到各种非常危险的情况，或者用户将要做一些潜在危险的事情。他们还没有做任何危险的事情，但如果他们坚持这种行为，事情可能会变糟。所以我们需要某种低燃油灯为我们的软件发出警告，就像傻瓜灯一样。
- en: hey dummy， if you don't change what you're doing soon， bad things will happen。
    And such a low fuel light， such a warning， needs to be annoying。 It needs to be
    persistent enough to get us to change。 We need to say， not this again。 I really
    should change what I'm doing。 But it shouldn't be fatal to the program。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，傻瓜，如果你不尽快改变你的做法，坏事就会发生。而如此低的燃油灯，如此警告，确实需要让人感到恼火。它需要足够持续，以促使我们改变。我们需要说，不要再这样了。我真的应该改变我的做法。但它不应该对程序造成致命影响。
- en: It should be annoying， but not stop us from running what we're doing。 Well。
    that's what I'm going to talk about here。 Warnings and warnings have been around
    in Python for an awfully long time。 Since November of 2000， it was introduced
    in PEP 230 and， it was first in Python 2。1。 And the original motivation was to
    annoy Python developers enough with bad behavior。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该让人恼火，但不应该阻止我们继续进行我们正在做的事情。好吧，这就是我在这里要谈论的。警告和警告在Python中已经存在很长时间了。自2000年11月起，它在PEP
    230中被引入，并且首次出现在Python 2.1中。最初的动机是让Python开发者因不当行为而感到足够烦恼。
- en: that they would change how they do things so it would be compatible with Python
    3。 At the time。 the Python core developers were really worried that people were，
    not going to switch to Python 3。 And quite frankly， there was good reason for
    them to be worried。 given how things played out and how long people continued
    to use Python 2。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以便他们改变做事的方式，使其与Python 3兼容。当时，Python核心开发者真的担心人们不会切换到Python 3。坦率地说，他们有理由担心，考虑到事情的发展以及人们继续使用Python
    2的时间。
- en: And so what they wanted to do was say， don't do it this way， do it this other
    way。 And you can get rid of the warnings of course， by adopting new best practices。
    Now you've probably seen some warnings already。 Here's one that's in Python 3。9。
    which is the latest version。 If you try to import mapping from collections， you
    get this message。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所以他们想做的是说，别这样做，换一种方式。你当然可以通过采用新的最佳实践来消除警告。现在你可能已经看到了一些警告。这里有一个在 Python 3.9 中的警告，这是最新版本。如果你尝试从
    collections 导入 mapping，你会收到这个消息。
- en: Deprecation warning， using or importing the ABCs from collections。 instead of
    from collections ABC is deprecated since Python 3。3。 And in 3。10 it will stop
    working。 So it's basically saying， look dummy， change your behavior。 It's also
    saying you should have noticed this before and。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 弃用警告，使用或导入来自 collections 的 ABC，而不是从 collections ABC 导入，自 Python 3.3 起已被弃用。在
    3.10 中将停止工作。所以这基本上是在说，看吧，傻瓜，改变你的行为。这也是在说你应该之前注意到这个。
- en: we're really trying to save you from yourself。 Because the next time we release
    a new version of Python。 Python 310， what you're doing in your code will no longer
    work。 Don't run out of gas， pull over。 put some gas in your car， or just change
    the import statement， which is actually quite easy。 So doing really need warnings，
    aren't there other mechanisms in Python。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的在试图拯救你自己。因为下次我们发布新的 Python 版本，Python 3.10，你代码中的某些内容将不再有效。不要耗尽油，靠边停车。给你的车加油，或者只需更改导入语句，这实际上非常简单。所以你真的需要警告吗，Python中不是还有其他机制吗？
- en: that we could use instead of them？ Well， one is we could go with exceptions。
    And exceptions actually have a lot going for them。 There are separate communications
    channels。 People don't really appreciate this enough。 Exceptions are not just
    different in that they're providing us with a way。 to indicate something has gone
    wrong。 They are a separate way of communicating that doesn't get mixed up with
    assignments。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们可以用什么来代替它们呢？一个就是我们可以使用异常。而异常实际上有很多优点。它们是独立的通信渠道。人们并没有充分认识到这一点。异常不仅仅是不同的，它们为我们提供了一种指示某些东西出错的方法。它们是一种不与赋值混淆的独立沟通方式。
- en: doesn't get mixed up with anything else， and we can trap them。 The way that
    I like to think of exceptions actually is sort of like a cell phone。 If you're
    talking with a good friend， maybe not such a good friend after you hear my example。
    talking with a friend and your cell phone goes off。 You're going to say to your
    friend。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 不会和其他任何东西混在一起，我们可以捕获它们。我喜欢将异常看作是一部手机。如果你在和一个好朋友聊天，也许在听到我的例子后，这个朋友就没那么好了。你在和朋友聊天时，手机响了。你会对朋友说。
- en: hold on a second， let me just get this， right， right， on my right， we all do
    this， right？
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下，让我确认一下，对的，我们大家都是这样做的，对吧？
- en: And you answer your cell phone。 And then when the cell phone is done， that conversation
    is done。 you put down the mobile， phone and you continue speaking with your friend。
    assuming they are still friends with， you after such a rude behavior。 Well。 basically
    you can think of your exceptions and your code as being like a cell phone。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你接听手机。然后当手机通话结束时，那段对话也结束了。你放下手机，继续和你的朋友交谈。假设他们在你这么无礼之后仍然和你是朋友。嗯，基本上你可以把你的异常和代码看作是一部手机。
- en: You have to take it。 You have to deal with it。 And then after you're done dealing
    with it。 then you can go back to the program。 And so that's really good about
    exceptions。 Also we can trap them by name。 We can distinguish between them。 And
    then we can decide whether we want to ignore them。 Yeah。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须接电话。你必须处理它。然后在你处理完之后，你可以回到程序中。所以异常真的很好。此外，我们可以通过名称捕获它们。我们可以区分它们，然后决定是否想要忽略它们。是的。
- en: but exceptions aren't exactly what we want for this kind of warning because
    if。 you don't catch an exception， the program ends。 And it's not a crash， right？
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但是异常并不是我们希望用于这种警告的原因，因为如果你不捕获异常，程序就会结束。这不是崩溃，对吧？
- en: It might as well be a crash because the program exiting with an unhandled exception
    doesn't。 make anyone feel better about it。 It just means like we're using a different
    term for it exiting。 Now in some other languages， you have to trap for any exceptions
    that might be raised。 They have to be mentioned explicitly， but in Python， anyone
    can raise any exception at， any time。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能就像崩溃一样，因为程序以未处理的异常退出并不会让任何人感觉更好。这只是意味着我们使用了不同的术语来描述它的退出。现在在一些其他语言中，你必须捕获可能被引发的任何异常。它们必须明确提到，但在
    Python 中，任何人可以在任何时间引发任何异常。
- en: So in order to trap these sorts of warnings， you would have all sorts of equivalent
    of。 accept clauses。 So that's not really going to work for us。 We can go sort
    of to the other extreme。 We can try print， right？ Why not just print？ Hey， something's
    going wrong here。 The thing is it's not serious or scary enough。 We want something
    that's really going to like shake people up and say。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获这类警告，你会有各种等价的接受子句。这对我们来说并不真正奏效。我们可以走到另一个极端。我们可以尝试打印，对吧？为什么不直接打印呢？嘿，这里出了一些问题。问题是，这并不严重或令人害怕。我们希望有些东西能真正震撼人心，让人说。
- en: hey， you should， really change your behavior。 The other thing is that print。
    it might get mixed up with regular program output。 And yeah。 we can start printing
    the standard error instead， but it's not really what we， want。 The other thing
    is we can't really filter or trap print statements。 I guess print functions， right？
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，你真的应该改变你的行为。另一件事是打印。它可能会和常规程序输出混淆。是的。我们可以开始打印标准错误，但这并不是我们想要的。另一件事是我们无法过滤或捕获打印语句。我想是打印函数，对吧？
- en: You can't filter what's being printed on the screen。 And we really need something。
    some sort of mechanism like that。 And that's what warnings provides us with。 It
    provides us with sort of an in-between thing， between exceptions and print， that，
    we can filter。 we can trap， and we can even redirect to other places so that it
    doesn't。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法过滤屏幕上打印的内容。我们确实需要某种机制。正是警告为我们提供了这种机制。它在异常和打印之间提供了一种东西，我们可以过滤、捕获，甚至重定向到其他地方，以避免它。
- en: get interfered with or doesn't interfere with our code。 So how do we use warnings？
    Well。 let's assume that I maintain a module with a Python function hello。 So my
    module is called hello。 my function is called hello， and it's pretty simple， right？
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 被干扰或不干扰我们的代码。那么我们如何使用警告呢？假设我维护一个包含Python函数hello的模块。我的模块叫hello，我的函数也叫hello，它相当简单，对吧？
- en: So death hello name and return F hello and then F string curly braces name。
    Now I'm going to change this function。 I'm not to change the API on all of my
    users。 which not the smartest thing to do， but fine。 And now I want to take a
    list of inputs rather than a single string。 How can I notify my users they should
    start passing me a list of inputs rather than a single。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所以定义hello名称并返回F hello，然后F字符串大括号名称。现在我要更改这个函数。我不打算更改所有用户的API，这并不是最聪明的做法，但没关系。现在我想接受一个输入列表，而不是一个单独的字符串。我该如何通知我的用户，他们应该开始传递一个输入列表而不是单个输入？
- en: string？ Well， I'm going to make this change and this change is going to be dramatic。
    So I better warn people about this。 So before it goes into effect。 and it's a
    really crucial point about warnings， you want， to warn them。 giving them enough
    time to do something like the low fuel light， right？
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串？好吧，我要进行这个更改，这个更改将会很剧烈。所以我最好提前警告人们。在它生效之前，这是关于警告的一个非常关键的点，你想提前警告他们，给他们足够的时间做点什么，就像低油灯一样，对吧？
- en: If you told them 30 seconds before you're about to run out of fuel， they better
    be asked， up。 That's not so helpful。 So what are we going to do？
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在他们快要耗尽燃料的30秒前告诉他们，他们最好做好准备。这并不那么有帮助。那么我们该怎么办呢？
- en: We're going to before this change goes into effect add a warning to the function。
    And here's what the warning looks like。 Well， first of all， I have to import warnings。
    It's not in built-ins。 In the pet， they actually say that this was considered。
    but they decided that developers， are， you know， we can deal with a little bit
    of importing。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更改生效之前，我们将向函数添加警告。警告看起来是这样的。首先，我必须导入警告。它不在内置模块中。在提案中，他们实际上表示这被考虑过，但他们决定开发者，知道，我们可以处理一点导入。
- en: So import warnings。 And then I'm going to call the function warnings。warn。 That
    is how we。 this is sort of the equivalent of rays。 That's how we indicate that
    something is going wrong。 And we pass an argument there， a string indicating what
    message we want to show to the user。 So how does this work？ Well， now in my program，
    I'm going to say from hello， import hello。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所以导入警告。然后我将调用函数warnings.warn。这是我们。这种方式类似于引发异常。这是我们指示出问题的方法。我们在那里传递一个参数，一个字符串，表示我们想向用户显示的消息。那么这如何运作呢？好吧，现在在我的程序中，我要说从hello导入hello。
- en: I'm going to call print hello world。 And when I run it， that's what I get。 This
    is the output that we see。 Now， the output is broken into a few different pieces。
    We see in what file did we get this warning and what line of that file as well。
    Then we see what kind of warning it was。 And you're going to see there are lots
    of different types of warnings or categories。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我将调用print hello world。当我运行它时，这就是我得到的。这是我们看到的输出。现在，输出被分为几个不同的部分。我们看到在哪个文件中得到了这个警告，以及该文件的哪一行。然后我们看到这是什么类型的警告。你会发现有许多不同类型的警告或类别。
- en: of warnings that we can issue。 Then the message， the message that was passed
    as that second argument to warnings。warn。 And then finally， we see that indeed
    this warning was raised by the function warnings。warn。 That's not such a surprise。
    We're going to talk about that more in a bit。 Finally you see that our program
    does actually run。 We have not exited。 We have not， you know。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以发出警告。然后是消息，作为第二个参数传递给warnings.warn的消息。最后，我们看到确实是这个警告由函数warnings.warn引发。这并不奇怪。我们稍后会详细讨论这个。最后，你会看到我们的程序确实运行了。我们没有退出。你知道的。
- en: crashed nothing like that。 The program still runs。 The warning just sort of
    pops up and they're saying， hey， don't forget about me。 Now it's true that the
    output from the warnings is sent to standard error not to standard， app。 So that
    means that if you're redirecting standard app from the program， you'll still see
    the。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 崩溃没有这样的事情。程序仍然运行。警告只是冒出来，他们在说，嘿，不要忘记我。现在确实，警告的输出是发送到标准错误，而不是标准应用程序。这意味着如果你正在从程序重定向标准应用程序，你仍然会看到。
- en: warning on your screen。 And it'll go along with any other errors that are printed。
    So that's really good。 Now， of course， you redirect standard error。 That's not
    a bad thing because it'll go， as I said， with all the other errors。 So if I now
    say use hello。py and I redirect it to hello。txt， we're still going to see。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上的警告。它将与打印的其他错误一起出现。这是非常好的。当然，你会重定向标准错误。这并不是一件坏事，因为它会，如我所说，和所有其他错误一起显示。所以如果我现在说使用hello.py并将其重定向到hello.txt，我们仍然会看到。
- en: the warning on the screen here， which is good。 So the thing to keep in mind
    is that warnings require you to plan ahead。 You need to warn your users that in
    advance of what they are doing that's wrong and how。 things are going to break。
    And we see this in well maintained open source projects。 They plan ahead enough
    that they can say， okay， in another two versions， this is no longer。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上的警告是好的。因此，需要记住的是，警告要求你提前计划。你需要提前告知用户他们做错了什么，以及事情将如何崩溃。我们在维护良好的开源项目中看到这一点。他们提前规划，以便能说，好吧，在接下来的两个版本中，这将不再。
- en: going to work。 So this version， the next version， we're going to give them increasingly
    dire sounding。 warnings saying， hey， dummy， you better keep saying dummy， right？
    You want to respect our users。 Yes。 Hey， user， we really want you to plan ahead
    and think about what's going on。 You want to give your users time to transition。
    So really think about if you need to make changes like this。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将会工作。因此这个版本，下一版本，我们将给他们越来越严厉的警告，告诉他们，嘿，傻瓜，你最好继续说傻瓜，对吧？你想要尊重我们的用户。是的。嘿，用户，我们真的希望你提前计划，考虑正在发生的事情。你要给用户留出过渡的时间。所以真的要考虑一下你是否需要做这样的改变。
- en: how far in advance you can， make them and then how far in advance you can warn
    your users about it。 So we saw before that user warning was what was being sent。
    And as I said。 user warning is a category similar to an exception class and it
    provides。 us with two different benefits， one of which is the semantic power。
    I as a person will read and say。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以提前多长时间发出警告，以及你能提前多长时间告知用户。所以我们之前看到的是发送的用户警告。正如我所说，用户警告是类似于异常类的一个类别，它为我们提供了两个不同的好处，其中之一是语义的力量。作为一个人，我会阅读并说。
- en: oh， it's a user warning。 I understand what it means。 I understand how to distinguish
    that from other kinds of warnings。 But the other advantage is that by having this
    category， it's sort of like with exception， classes。 I can detect it and filter
    it。 And the warning system actually does help us with that。 By the way。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，这是一个用户警告。我理解它的意思。我知道如何将其与其他类型的警告区分开。但另一个好处是，通过拥有这个类别，这有点像异常类。我可以检测并过滤它。警告系统实际上确实帮助我们实现这一点。顺便说一下。
- en: warning categories are exception classes。 How do I know this？ Well。 if I go
    to user warning and I say， what is your dunder basis and dunder basis is how。
    a class in Python indicates what it inherits from and inherits from class warning。
    All right。 So warning is sort of the overall parent class for all warnings。 But
    then I go to warning and say。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 警告类别是异常类。我怎么知道这一点？好吧。如果我去查看用户警告，问道，你的`dunder`基类是什么，`dunder`基类是如何定义的。一个Python类表明它从哪里继承，继承自警告类。好的。所以警告在所有警告中是总体的父类。但随后我去查看警告，问。
- en: hey， warning， what are your bases？ It says， oh， I inherit from exception。 So
    warnings are exceptions， at least in a typical sense， but they're handled separately。
    and differently。 You're not going to raise a warning typically。 although we'll
    see how you can turn warnings， into exceptions if you really want。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，警告，你的基类是什么？它说，哦，我继承自异常。因此，警告是异常，至少在典型意义上，但它们被单独处理，并且有所不同。通常你不会引发警告。尽管我们会看到如果你真的想的话，如何将警告转变为异常。
- en: So built-in warning categories， there are a whole bunch of them， right？ There's
    regular warning。 That's the parent class， as I said。 There's user warning， deprecation
    warning， syntax warning。 runtime warning， and pending， deprecation warning。 So
    deprecation warnings means you really should not be using this。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 内置警告类别有很多，对吧？有常规警告。这是父类，如我所说。还有用户警告、弃用警告、语法警告、运行时警告和待弃用警告。所以弃用警告意味着你真的不应该使用这个。
- en: Pending deprecation warning means， hey， soon you won't want to be able to use
    this。 And so I can actually pass this as the second argument to warnings。warn。
    So when I call warnings。warn， I'm going to pass a message。 I'm going to say， what
    kind of warning I want to pass。 Here's the deprecation warning， because that's
    sort of appropriate， right？
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 待弃用警告意味着，嘿，不久之后你将不想使用这个。因此，我实际上可以将其作为第二个参数传递给`warnings.warn`。所以当我调用`warnings.warn`时，我将传递一条消息。我会说，我想传递什么类型的警告。这是待弃用警告，因为这算是适当的，对吧？
- en: The thing is if we actually run this code， suddenly our warnings don't appear
    anymore。 It disappears。 And that's because deprecation warning is filtered out
    by default。 So it won't appear。 You have to explicitly say that you wanted to
    appear。 And we're going to talk about filtering in a little bit。 The thing is，
    as you might know， in Python。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是如果我们实际上运行这段代码，突然间我们的警告不再出现了。它消失了。这是因为弃用警告默认被过滤掉了。所以它不会出现。你必须明确表示你希望它出现。我们稍后将讨论过滤。问题是，正如你可能知道的，在Python中。
- en: when you're just writing code and you want， to raise an exception to indicate
    that something has gone wrong。 you should not raise the built-in， exceptions。
    It seems so tempting， right？
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只是编写代码并想要引发异常以指示某些事情出了问题时，你不应该引发内置的异常。这似乎非常诱人，对吧？
- en: I'll raise a type error here。 I'll raise an index error there。 But it's generally
    frowned upon to raise the built-in exceptions。 You should create your own exception
    classes and raise those。 And once again。 those give us extra semantic power and
    they allow us to do better filtering。 Similarly。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我会在这里引发类型错误。我会在那里引发索引错误。但通常来说，引发内置异常是不被赞成的。你应该创建自己的异常类并引发这些异常。再一次，这些给我们额外的语义能力，并允许我们进行更好的过滤。类似地。
- en: it's a really good idea to create your own custom warning categories。 Now。 your
    new warning should probably subclass one of the existing types， so it'll be filtered。
    appropriately。 But you can do what you want。 As long as you create a class that
    inherits from warning。 you're good。 So let's see how that could work here。 Well，
    I'm going to create my class， as I said。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你自己的自定义警告类别真的是个好主意。现在，你的新警告可能应该从现有类型中继承，以便能够被适当地过滤。但是你可以随意处理。只要你创建一个继承自警告的类，就可以了。那么我们来看看这在这里如何运作。好吧，我要创建我的类，如我所说。
- en: Class are exchanging warning， which inherits from user warning。 And then what
    is going to be the content-- what are the contents of my class？ Nothing。 Just
    paths。 Why？ Well， because I don't really want to give any content， right？
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 类正在交换警告，继承自用户警告。那么我的类的内容是什么呢？什么也没有。只是路径。为什么？因为我并不想提供任何内容，对吧？
- en: So warning is not useful as a class I'm going to instantiate and then call a
    method on。 And I don't need to store any additional state。 I just want to be able
    to distinguish it from other warnings。 And then what we can do-- in addition to
    paths， we can then pass， as it were， our exchanging。 warning as our second argument
    to warnings。war。 So what happens when we're warned？ Well。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，警告作为一个类并不是有用的，我将实例化它，然后调用一个方法。我不需要存储任何额外的状态。我只想能够将它与其他警告区分开来。然后我们可以做的——除了路径，我们还可以将我们的交换警告作为第二个参数传递给
    warnings。war。那么，当我们被警告时发生了什么呢？
- en: we've already seen that a warning will be sent to standard error， like the message。
    would print it there。 But we can actually customize what happens to particular
    categories of warnings。 And that's done with warnings filters or Python's warnings
    filter。 We can specify what should be done with particular types of warnings，
    particularly categories。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到警告将被发送到标准错误，像消息一样将其打印出来。但我们实际上可以定制特定类别警告的处理方式。这是通过警告过滤器或 Python 的警告过滤器完成的。我们可以指定应该如何处理特定类型的警告，特别是类别。
- en: But we can specify not only based on category， we can filter based on the message
    contents。 and the module in which it was raised and a whole bunch of other things。
    Now， the default filter。 what comes with Python by default if you don't do anything
    else。 it prints warnings the first time they appear in a given file on a given
    line。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们不仅可以基于类别进行指定，我们还可以根据消息内容、引发的模块以及许多其他因素进行过滤。现在，默认过滤器就是，如果你什么都不做，Python 默认会在给定文件的特定行第一次出现时打印警告。
- en: So if you encounter the same call to warnings。war multiple times， then you're
    only going。 to see one message。 But the same warning appears in multiple places
    of the code。 you will see multiple messages。 Let's see how that would work。 So
    I'm actually going to call now hello twice in my program， in my use hello。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你多次遇到相同的调用警告。war，那么你只会看到一条消息。但是，如果相同的警告出现在代码的多个地方，你会看到多条消息。让我们看看这将如何工作。因此，我现在将在我的程序中调用
    hello 两次，在我的使用 hello 中。
- en: I'm going to say hello world one and hello world two。 And if I just say use
    hello。py， look。 we're going to get our warning once， even though， you see we have
    output twice。 So we did call the function twice， but because of the default behavior
    in Python for this。 kind of warning is only going to warn us once。 Wait a second
    though， hello。py nine。 Okay。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我将说 hello world 一和 hello world 二。如果我只说使用 hello。py，看看。即使你看到我们输出了两次，我们也只会收到一次警告。因此，我们确实调用了这个函数两次，但由于
    Python 对这种警告的默认行为，只会警告我们一次。等等，hello。py 九。好的。
- en: like I can see where the warning was raised。 And it was raised by warnings。one
    is that kind of obvious？ Like don't we know that the warning was raised by warning
    that one that hasn't added any。 useful information to us。 But when we call one
    is that one， we can actually pass a stack level。 And that stack level is an integer
    indicating what function should be message。 So how far back。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 比如我可以看到警告是在哪里引发的。它是由警告引发的，这很明显吗？我们难道不知道警告是由警告引发的，这没有给我们添加任何有用的信息。但当我们调用那个时候，我们实际上可以传递一个栈级别。这个栈级别是一个整数，表示应该传递哪个函数的消息。那么要回溯多少呢？
- en: how many stack frames back should we go to pull out information about。 the function
    and print it on standard out。 So by default stack level equals one。 I mean the
    call the warnings that warn itself， meaning。 you're going to see them on what
    line warnings that one was called。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该回溯多少个栈帧以提取关于函数的信息并在标准输出上打印出来。因此，默认的栈级别等于一。我的意思是，调用警告本身的警告，你将看到它们在第几行被调用。
- en: But it's pretty common to say stack level equals two。 So you're going to see
    who called the thing that generated the warning。 And indeed here we can see now
    if I call with our changing warning， comma two。 Now we're going to see that the
    call to hello with is what triggered it， not the call to， warnings。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但通常来说，栈级别等于二。所以你将看到是谁调用了生成警告的东西。实际上，如果我调用我们的交换警告，逗号二。现在我们将看到 hello 的调用触发了它，而不是
    warnings 的调用。
- en: warning。 And sure enough， if I call use hello。py， we're going to see that now
    is a new solo。py。py。 five of line five。 And it's going to say， hey， it happened
    here when you called hello。 So many times it's going to be more useful。 All right，
    back to our filter。 When Python counters are warning， it has actually six different
    actions it can take。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 警告。而且，如果我调用use hello.py，我们将看到现在是新的solo.py。第5行，它将说，嘿，当你调用hello时发生了这一点。这样多次会更加有用。好吧，回到我们的过滤器。当Python遇到警告时，实际上可以采取六种不同的操作。
- en: We can choose which of these we want。 So we can say always and always means
    it doesn't matter how many times the warning is raised。 from where we always want
    to print it out。 Another option is ignore。 I don't need this warning。 I don't
    care about it。 Not important to me。 And another one sort of the other direction
    is error。 meaning turn this into an exception。 And that's the advantage of having
    warnings as a sub-class of exception。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择这些中的哪些。因此我们可以说总是，意味着无论警告被引发多少次，我们都想打印出来。另一个选项是忽略。我不需要这个警告。我对此不在乎。对我来说不重要。而另一个方向的选项是错误，意味着将其转化为异常。这就是将警告作为异常子类的优势。
- en: the Python can， handle it then right away。 And so if you want to be really harsh。
    you can just say always raise an exception， make， an error for everything。 So
    for example。 let's say we want our exchanging warning to be displayed every time
    it occurs， no matter what。 So every time that the always action。 So how do I say
    this warning should be shown always no matter how often it's chosen？
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Python可以立即处理它。如果你想非常严格，你可以直接说总是引发异常，对所有内容产生错误。例如，假设我们希望每次发生交换警告时都显示它，无论如何。所以每次总是进行的操作。那么我怎么说这个警告应该总是显示，无论选择多少次？
- en: Well， if I want from the command line， it can pass the minus big W option and
    that switch。 there takes an argument and that argument is the action we want。
    So I can say minus big W always。 By the way， each action begins with a different
    letter。 So you can abbreviate to minus big W little a。 So if I now say Python
    3 minus big W always for use hello 2。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，如果我想从命令行，它可以传递大写W选项，那个开关有一个参数，而那个参数就是我们想要的操作。因此我可以说大写W总是。顺便说一下，每个操作以不同的字母开头。所以你可以缩写为大写W小写a。因此如果我现在说Python
    3大写W总是使用hello 2。
- en: py， right？ So what it's going to show now is both times， both times that we
    called hello world。 It's going to show me， well， I only said it to be stack level
    one。 So it's going to show us warnings that warn and the final which that's fine，
    which is fine。 Now the thing is you can filter in a lot of different ways。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: py，对吧？所以现在它将显示两次，我们调用hello world的两次。它会告诉我，嗯，我只说它的堆栈级别为1。所以它将向我们显示警告，而最终那是可以的。现在问题是你可以用很多不同的方式进行过滤。
- en: We've already seen how you can filter based on the action， but you can filter
    based on。 the message and there's a regular expression match of the case insensitive
    message start。 I know that sounds complicated， but basically we can use reg X
    to match the beginning of。 the message。 You can filter based on the category。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何根据操作进行过滤，但你也可以根据消息进行过滤，并且有一个不区分大小写的消息开头的正则表达式匹配。我知道这听起来很复杂，但基本上我们可以使用正则表达式来匹配消息的开头。你可以根据类别进行过滤。
- en: You can filter based on the module name in which we have the warning。 You can
    also do the line number。 So you can say I want to filter on。 I want to give this
    action for this category for this message in this module with this line， number。
    The thing is if you want to pass multiple actions for multiple types of categories，
    you just。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据我们有警告的模块名称进行过滤。你也可以根据行号进行过滤。所以你可以说我想过滤。我想为这个类别、这个消息、这个模块和这个行号提供这个操作。问题是如果你想为多种类别传递多种操作，你只需要。
- en: pass minus big W multiple times。 So for example， if I want to give deprecation
    warning。 but nothing else and always action， and regardless of the message， I
    can say minus big W action。 colon colon double colon。 That means I'm going to
    ignore the message deprecation warning。 What if I want to make those deprecation
    warnings visible， but only if the message starts with。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 传递大写W多次。例如，如果我想给出弃用警告，但不需要其他任何内容，并且总是采取行动，不论消息如何，我可以说大写W操作：：：双冒号。这意味着我要忽略消息弃用警告。如果我想让这些弃用警告可见，但仅当消息以...开头。
- en: an A and I should add again， it's case insensitive。 So then I'll put an A there
    between those two codes。 If I want to make Unicode warnings。 anytime I make out
    the Unicode warning， turn that into， exception， I'll say minus big W error。 colon
    colon Unicode warning。 By default， the warning system works like this。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 而且我应该再次添加，忽略大小写。所以我会在这两个代码之间放一个A。如果我想生成Unicode警告。每当我发出Unicode警告，将其转为异常时，我会说减号大写W错误：：Unicode警告。默认情况下，警告系统是这样工作的。
- en: These are the filters that are set。 It says deprecation warning， main has the
    default。 but we're going to ignore general deprecation， warnings and you can see
    them that you can set up the filters to work on the same warning。 category， but
    you can do it with different actions for different matches。 Now。 why would they
    have done this？ Aren't deprecation warnings important？
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是设置的过滤器。它显示弃用警告，主有默认设置。但我们将忽略一般的弃用警告，你可以看到你可以设置过滤器以在同一警告类别上工作，但可以对不同的匹配使用不同的操作。现在，为什么他们会这么做？弃用警告难道不重要吗？
- en: Don't we want to know about them？ Well， the answer is of course， yes and no。
    We want to know about deprecation warnings in our own code and the programs that
    we're， running。 But if I import a module and that module hasn't been updated and
    gives me a deprecation， warning。 do I really want to see warnings for someone
    else's code？ Probably not。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想知道它们吗？答案当然是，有和没有。我们希望知道我们自己代码和正在运行的程序中的弃用警告。但如果我导入一个模块，而那个模块没有更新并给我一个弃用警告。我真的想看到别人代码的警告吗？可能不想。
- en: And if you've ever encountered that， where when if you import something， some
    of you're。 flooded with warnings， you know how annoying that can be。 Because like
    you're not going to go maintain that code that someone else's code。 And yet you're
    suffering the consequences because they haven't maintained it。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经遇到过这样的情况，当你导入某些内容时，有些警告会淹没你，你知道这有多烦人。因为你不可能去维护别人的代码。而且你却在承受后果，因为他们没有维护它。
- en: That's why deprecation warnings are traditionally ignored， except it doesn't
    remain because。 then it's your fault。 We're also going to ignore pending deprecations
    and import warnings and resource warnings。 Of course， you can change all this，
    but these are the defaults。 Now。 there is another option where you can set the
    Python warnings environment variable。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么弃用警告传统上被忽略，除非它不会保持，因为那是你的错。我们还将忽略待处理的弃用警告、导入警告和资源警告。当然，你可以更改所有这些，但这些是默认设置。现在，还有另一种选择，你可以设置Python警告环境变量。
- en: So we can say Python warnings equals e deprecation warning and d resource warning。
    So we can do all that stuff。 Now the thing is you can't use what we just saw。
    You can't use the minus big W switch or Python warnings that you've environment
    variable。 You cannot do that for custom warning categories。 And that's because
    our custom warning categories are classes defined in our code。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以说Python警告等于e弃用警告和d资源警告。因此我们可以做所有这些事情。现在的问题是你不能使用我们刚才看到的内容。你不能使用减号大写W开关或Python警告的环境变量。你不能为自定义警告类别这么做。这是因为我们的自定义警告类别是在代码中定义的类。
- en: And because those warning switches are done before our code is loaded and run，
    it just。 can't know about it。 The thing is we can do it from within Python and
    there are a few different functions we。 can call。 There's warnings that filter
    warnings， which are less specified all five different filter。 elements。 But a
    lot of times you're not going to want to do that。 So for people like us。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 而且因为这些警告开关在我们的代码加载和运行之前完成，它就是。无法知道这件事。问题是我们可以从Python内部做这件事，还有一些不同的函数我们可以调用。有过滤警告的警告，五种不同的过滤元素。不过很多时候你可能不想这么做。因此对于我们这样的人。
- en: like moral people， they're going to have simple filter and then， just specify
    the action。 the category line number。 And then there's also reset warning。 So
    if you have one portion of your code where you really want to be using warnings
    in a。 certain way and you want to change the filter later on， just do reset filter，
    reset warnings。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 像道德人一样，他们会有简单的过滤器，然后仅指定操作。类别行号。然后还有重置警告。如果你有一部分代码真的希望以某种方式使用警告，并且想稍后更改过滤器，只需执行重置过滤器，重置警告。
- en: and they'll do that。 And here's an example of how you can do that in code。 So
    I'm going to import warnings and then I'm going to import from hello， import hello。
    and are exchanging warning。 I'm going to import a custom category。 Now I can actually
    set on the filter for my custom category。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 他们会这样做。这是一个如何在代码中做到这一点的示例。所以我将导入警告，然后从 hello 导入 hello，并交换警告。我将导入一个自定义类别。现在我可以为我的自定义类别设置过滤器。
- en: I'm going to say set the default for that。 And then when I call hello world
    one and low world two will be fine。 There's even a context manager you can use
    catch warnings。 If you want to temporarily change the filters just for one simple
    set of code。 So we can turn off all warnings that I'm doing if I'm calling some
    poorly behaved function。 Right。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我要说的是，为此设置默认值。当我调用 hello world 一和 low world 二时将没问题。你甚至可以使用上下文管理器来捕获警告。如果你想暂时仅对一段简单代码更改过滤器。那么我们可以关闭所有警告，如果我调用某个表现不佳的函数。对吧。
- en: I know it's going to cause warnings but I don't care。 So I'll just do a with
    warnings。catch warnings and then I set the simple filter to ignore。 I'm going
    to ignore everything。 Like I'll go around with yep。 Can't see any problems that
    there must not be problems call poorly behaved function。 So where should we use
    warnings？ It's very nice to have all this， you know。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这会导致警告，但我不在乎。所以我只需用警告捕获警告，然后将简单过滤器设置为忽略。我将忽略一切。就像我四处走动时，嗯，没看到任何问题，那应该就没有问题，调用表现不佳的函数。那么我们应该在哪里使用警告？拥有这些是非常不错的，你知道的。
- en: technology around that we can use， but where， should we use it？ Well。 one is
    if you have a module that is that that people are using and it's going。 away or
    it's going to change its API。 If you're making sense of changes。 you can put warnings
    that weren't at the top of the， module。 Remember。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的技术，但应该在哪里使用呢？一个例子是，如果你有一个模块，人们在使用，而它要消失或其 API 要改变。如果你在理解这些变化，你可以在模块的顶部放置警告。记住。
- en: remember that modules are executed when they're imported。 Now。 normally I'm
    not a big fan of putting executable code or at least like printing things。 out
    in modules。 But this is an exception。 It's not an exception。 It's a warning。 All
    right。 But I like it。 Remember that deprecation warning is ignored by default。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，模块在被导入时会被执行。现在，通常我不喜欢在模块中放置可执行代码或至少打印东西。但这是个例外。其实并不是例外，而是警告。好吧，但我喜欢。记住，弃用警告默认是被忽略的。
- en: So you might want to change that or you might want to understand that maybe
    you shouldn't。 be turning on warnings for other people who are using your modules。
    You'll have to figure exactly how you want to do this。 But again。 you want to
    inform people before it's too late。 Another great thing to do is if you're noticing
    common mistakes。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可能想要改变这个，或者你可能想明白也许不应该为使用你模块的其他人打开警告。你需要弄清楚你想怎么做。但再一次，你想在为时已晚之前告知人们。另一个很好的做法是如果你注意到常见错误。
- en: so people are commonly causing， calling a function with the wrong arguments。
    use a warning to point them in the right direction。 So if you have a function
    and people are constantly calling with an integer and you really expect。 a string，
    you can warn them about that。 That might even be nice。 Now。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所以人们常常因为使用了错误的参数而调用函数。使用警告来引导他们走向正确的方向。因此，如果你有一个函数，人们总是用一个整数调用，而你真正期望的是一个字符串，你可以对此发出警告。这可能会很有帮助。
- en: the most famous warning in PANDAS is the setting with copy warning。 And that
    basically happens when you are using， for lack of better term， double square brackets。
    You're trying to set data on a data frame。 The problem is that you're not actually
    setting on that data frame。 You're setting it on the thing that you got back from
    the second set of square brackets。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PANDAS 中最著名的警告是“设置副本警告”。这基本上发生在你使用双方括号时。你试图在数据框上设置数据。问题是你并没有在那个数据框上设置，而是在第二组方括号返回的对象上设置。
- en: So a lot of people make this mistake。 And so PANDAS is constantly issuing these
    setting with copy warnings all over the world。 Lots of people。 How do I know that
    happens a lot of times？ Because if you look on Stack Overflow。 it's just full
    with people complaining about setting， with copy warning， what do we do？
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所以很多人犯这个错误。因此 PANDAS 在全世界不断发出这些设置副本警告。很多人。我怎么知道这发生得很频繁？因为如果你查看 Stack Overflow，满是人们抱怨设置副本警告，我们该怎么办？
- en: So rather than let people make these mistakes， PANDAS says， "Hey， this is a
    warning。"。 And even in the warning text points you to the URL of the documentation
    for PANDAS where。 you can fix it。 Scikit-learn used to warn you if you tried to
    run predict on a one-dimensional list or。 array。 Now it's an exception。 So they
    were sort of trying to wean people off of bad behavior。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所以与其让人们犯这些错误，PANDAS 说，“嘿，这是一个警告。”。甚至在警告文本中给你提供 PANDAS 文档的 URL，你可以在那里解决问题。Scikit-learn
    曾经会警告你，如果你试图在一维列表或数组上运行预测。现在它是一个异常。因此，他们试图让人们摆脱不良行为。
- en: And Python 2， which I hope you're not using， inside of a function， if you use
    the global。 statement after you'd already signed to a variable， that variable，
    it would give you， a warning。 Nowadays it raises an exception。 That's an example，
    I guess。 sort of going back to the beginning of how Python 2 started。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 还有 Python 2，我希望你没有在使用它，在一个函数内部，如果你在已经赋值给一个变量后使用 global 语句，那么这个变量会给你一个警告。现在它会引发一个异常。我想这就是一个例子，某种程度上回到了
    Python 2 的起点。
- en: to try to warn us of bad behavior that would not work in Python 3。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试警告我们一些在 Python 3 中无法工作的不良行为。
- en: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_10.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_10.png)'
- en: Speaking of going back to the beginning， remember our fuel gauge？ So you as
    the driver of the car。 the owner of the car， you're supposed to notice when， you're
    low on fuel。 If you don't notice that。 then you have the yellow light and that's
    like screaming you， "Hey， you should really do something。"， But what if you ignore
    the yellow light？ Guess what？ There's another warning that kicks in。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 说到回到开始，记得我们的燃油表吗？作为车的司机，车的拥有者，你应该注意当你燃油不足时。如果你没有注意到，那么你会看到黄灯，这就像在尖叫，“嘿，你真的应该做点什么。”，但是如果你忽略了黄灯？猜猜会发生什么？还有另一个警告会启动。
- en: A lot of beeping。 A lot of beeping telling you， "Listen， you didn't notice the
    fuel gauge。 It didn't notice the yellow light。 It's really time to get gasoline
    before you're stuck in the edge of the road。"， Be nice to your users。 Give them
    warnings。 Suggest how they can improve and they will thank you for it。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 很多哔哔声。很多哔哔声告诉你，“听着，你没有注意到燃油表。你没有注意到黄灯。是时候加油了，否则你就会被困在路边。”，对你的用户要友好。给他们警告。建议他们如何改进，他们会感谢你的。
- en: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_12.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_12.png)'
- en: If there are any questions or comments， I would love to hear them。 If you want。
    you can always email me， you can catch me on Twitter， go to my website， load it
    about my courses。 my books， my corporate training。 You can also sign up for my
    better developers free weekly list。 Only about 20，000 other Python developers
    around the world get an article about Python。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有任何问题或意见，我很乐意听取。如果你愿意，可以随时给我发邮件，你可以在 Twitter 上找到我，访问我的网站，了解我的课程、书籍和企业培训。你还可以注册我的更好开发者每周免费邮件列表。全球大约有
    20,000 名其他 Python 开发者会收到关于 Python 的文章。
- en: to help them improve their fluency every week。 Thanks so much for coming to
    my talk and I really。 really hope to see you in person， next year in Salt Lake
    City and Python 2022。 Thanks so much。 [ Silence ]。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每周帮助他们提高流利度。非常感谢你来听我的演讲，我真的希望明年在盐湖城的 Python 2022 见到你。非常感谢。[沉默]。
- en: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_14.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_14.png)'
- en: '[ Silence ]， [ Silence ]， [ Silence ]， [ Silence ]， [ Silence ]， [ Silence
    ]， (silence)。'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[沉默]，[沉默]，[沉默]，[沉默]，[沉默]，[沉默]，（沉默）。'
- en: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_16.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3bf99e35cbdc0130ca1be7c66c2a65e_16.png)'
