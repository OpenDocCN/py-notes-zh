- en: P1：TALK _ Alexander Hultnér _ Intro to Pydantic, run-time type checking for
    your da - VikingDen7 - BV19Q4y197HM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[MUSIC]。'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98d3126a31287dc7ece0555ee1b7c225_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/98d3126a31287dc7ece0555ee1b7c225_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Hello， I'm Alexander Halzner。 I'm from Gothenburg， Sweden。 I'm here at PyCon
    US this year。 and I'm very happy to be here and speak for you all today。 I'm going
    to talk a little bit about Pydantic。 My talk is titled Intro to Pydantic。 Runtime
    Type-Shacking for your Python data classes。 So let's get ahead done。 So as I told
    you。
  prefs: []
  type: TYPE_NORMAL
- en: my name is Alexander Hartner， and I'm the founder of Halzner Technologies and
    as well， prepare。io which is a service which me and my colleague， Magnus have
    been working on for the past year。 You can see a small screenshot here down to
    the right。 I also talk at a lot of conferences。 I'm a frequent speaker at the
    different conferences。 For instance， PyCon Sweden， quite a few years。
  prefs: []
  type: TYPE_NORMAL
- en: Europiphon and of course here in PyCon US， for my first time this time around。
    So that's very nice。 I do some freelance consulting and I also， do some training
    and workshops so you can contact me。 if you're interested about that。 My Twitter
    handle is @ahoutner and you can also email me via。 contact@houtner。sc。 All my
    slides are available at slides。com/houtner。
  prefs: []
  type: TYPE_NORMAL
- en: And all the links you can see in these slides， they are clickable so you can
    find them via the slides。com。 And just scroll down until you find the PyCon US
    slides。 which should probably be on top right now。 And you can also reach me on
    LinkedIn where I'm also a。 houtner。 So let's go ahead then。 So the outline for
    today's talk is like this done。
  prefs: []
  type: TYPE_NORMAL
- en: We're going to start with a quick refresher for Python data。 classes which could
    be good if you're forgotten in some of。 the details or if not just see what we're
    going to be covering。 And then I'm going to introduce you to Pythonic。 I'm going
    to talk a little bit about the runtime type。
  prefs: []
  type: TYPE_NORMAL
- en: checking。 I'm going to show you some really cool JSON stuff you can do。 I'm
    going to show you some custom validators as well as， built-in validators。 I'm
    also going to show you a little bit how you can use。 Pythonic to runtime type
    check the types of your functions in， runtime。
  prefs: []
  type: TYPE_NORMAL
- en: So basically if you have a function you can check that as， well。 I'm going to
    show you a little bit about some framework。 integrations and how Pythonic can
    be used with a lot of， different frameworks。 I'm also going to show a small example
    of that and some。
  prefs: []
  type: TYPE_NORMAL
- en: automated testing which I'm not going to go too deep into。 but I'm going to
    drop a little hint there so you can find out， more if you're interested about
    that。 Some cool features worth mentioning and then we're going， to conclude this
    talk today。 So let's not wait any further and get started。 So data class is done。
    Here's a quick refresh。
  prefs: []
  type: TYPE_NORMAL
- en: We have the @DataClass decorator and for this talk we're。 going to use imagine
    a rewaffle place for our examples， because who doesn't love waffles？ Anyway。 so
    our imaginary company is a cafe named the， WaffleBistro。 And the WaffleBistro
    needs to model their waffles。
  prefs: []
  type: TYPE_NORMAL
- en: So let's take a look at how such a data class could look， like。 So here we have
    a waffle。 We have some style。 We have some toppings and we have some type annotations
    on， that。 Now let's try it out then。 So as you can see we're trying to create
    a Swedish。 style waffle with chocolate sauce and ham。 Not my favorite combination
    of toppings and I'm not sure if。
  prefs: []
  type: TYPE_NORMAL
- en: it's what the waffleBistro wants to serve either。 But as you can see it's completely
    allowed by our waffle。 class at this point。 So that's something we probably would
    want to avoid。 Maybe we want some stricter types on this because string， could
    be anything basically。 So let's go ahead then and see if we can constrain which。
  prefs: []
  type: TYPE_NORMAL
- en: types of toppings we offer and which styles。 So we offer a couple of cream based
    toppings。 So you can see we have whipped cream， we have ice cream。 We also have
    a couple of dessert sauces。 So you can see that we have a clove berry jam。 One
    of my personal favorites。 It's a beer we have here in Sweden， which is very good。
  prefs: []
  type: TYPE_NORMAL
- en: And if you have the chance you should try it out。 Raspberry jam， a classic。
    chocolate sauce for our Belgian， style waffles。 And as you can see， we have two
    styles。 Swedish and Belgian。 And we updated our data class using the waffle style。
    for our style and a couple of toppings for the toppings。
  prefs: []
  type: TYPE_NORMAL
- en: So let's see what happens now if we try to create a waffle， with ham topping。
    So as you can see。 the user provided a waffle order， where we have a Swedish style
    waffle and chocolate sauce。 with ham。 OK。 So did another type stop this？ Well，
    first statically checked types with my pie。 this would maybe be enough。 You would
    catch it as a type error in your static type， validation。
  prefs: []
  type: TYPE_NORMAL
- en: But in runtime， it's still not stopped。 And especially if you're working with
    runtime data。 then this could be a problem。 So you can see that we're completely。
    allowed to create a waffle with ham。 There's nothing stopping us。 So what can
    we do about that then？
  prefs: []
  type: TYPE_NORMAL
- en: And this is where Python comes handy。 So Python library， which allows you to
    enforce， run type--。 enforce types from type annotations in runtime。 It's compatible
    with data classes。 And you also have some bonus stuff if you want to go further。
    You have very user friendly errors。 There's no special syntax。 It's just pure
    Python classes。 Nothing strange。
  prefs: []
  type: TYPE_NORMAL
- en: We have built-in this serialization， and serialization of classes。 And it's
    even supporting nested structures。 There are some predecessors like data classes。
    after Smoshmallow， Valadier， and Orm libraries。 Those could be good to look at
    what makes。 pedantic standout is that it's just， using the standard type annotations。
  prefs: []
  type: TYPE_NORMAL
- en: And the documentation is really great。 As you can see， it's blue hair in the
    slide。 And that means you can click the link if you go to the slide。 software
    and find all the nice documentation yourself。 So let's get into pedantic time。
    So run type type checking is， of course， very nice。 This is what we want to do。
  prefs: []
  type: TYPE_NORMAL
- en: So let's lean on the shoulder of the giant in the house， which is pedantic in
    this case。 So now we change our code a little bit。 We import data classes from
    pedantic。 instead of the standard library data classes。 And then we don't really
    change anything else。 We keep our waffle class the same。 But when we now try to
    initiate the waffle。
  prefs: []
  type: TYPE_NORMAL
- en: you can see that we get a validation error。 Actually， we get two validation
    errors。 And they provide a nice readable value。 You can see that the references
    which index in the top。 being top all that's actually invalid。 So ham at index
    one。 And it gives us an error explaining what's wrong。 So this is really helpful。
  prefs: []
  type: TYPE_NORMAL
- en: And we can see it's neither the search source nor is it a cream。 So it's not
    allowed。 And with that simple change， we already， got some runtime type checking
    on our classes。 So we could stop here。 But of course， we want to go further and
    see what more we can do。 So let's try to create a valid waffle。 Maybe with Cloud
    Vergium。
  prefs: []
  type: TYPE_NORMAL
- en: You can see in the picture here is what Cloud Vergium looks like。 It's kind
    of like orange raspberries in look， but it tastes completely different。 So let's
    create a Swedish style waffle， with whipped cream and Cloud Vergium。 See here
    how I use the cream enum for the whipped cream。
  prefs: []
  type: TYPE_NORMAL
- en: but strings were representations for the other fields。 Pedantic is a parsing
    library which。 will try to parse the data you actually want from this。 So it will
    convert it to enums for you automatically。 As you can see here。 Cloud Vergium
    automatically， got parsed as the search source。 If you want more strictness than
    this。
  prefs: []
  type: TYPE_NORMAL
- en: you can achieve some of this with strict types， which you can also see in the
    documentation。 Or if you want even further， there， is being work made on a fully
    strict mode。 So that might be coming in the future。 Not sure when， but keep your
    eyes open。 if that's something that matters to you。 So what about JSON then？
  prefs: []
  type: TYPE_NORMAL
- en: So the data class drop-in replacements， is really great for probability and
    makes it possible。 to get started really quickly。 You don't need to change anything。
    But sometimes you want to do even more。 And with the pedantic base model， you
    can。 So you have first class JSON support built-in。 And the only thing we change
    right now。
  prefs: []
  type: TYPE_NORMAL
- en: as you can see， is that we removed the data class decorator， and instead inherit
    from base model。 And of course， you can also have your own base class， that inherits
    from base model。 And then later。 you can inherit that class， and you automatically
    get it all the way。 But let's not go into that too much right now。 So let's see
    then。
  prefs: []
  type: TYPE_NORMAL
- en: I always need to specify the arguments， you see in keyword arguments when we
    use our base model。 And as you can see here， we use style equals Swedish。 And
    toppings equals the same data as before。 And as you can see， we get the same style
    of Waffle object， as we did before。 So everything works great。 But now we can
    easily both encode this entire object。
  prefs: []
  type: TYPE_NORMAL
- en: as JSON and decode it as well。 There's also built-in support for Dicks， Pickle。
    and there's an immutable copy method。 But that they can also deserialize or serialize。
    subclasses and also if you reference another pedantic。 class within your properties
    in the pedantic class， that will also be handled for you。
  prefs: []
  type: TYPE_NORMAL
- en: So it's really handy for those kinds of things。 So let's see then we have our
    JSON object。 We could easily create here。 You can see we just run the JSON function
    on it。 And we can see that we get JSON output。 So what about reconstruction then？
  prefs: []
  type: TYPE_NORMAL
- en: So let's try to reconstruct our object from the JSON output。 So we will use
    the parse_raw function。 You can also parse a list of pedantic items。 But let's
    not do that right now。 So we can use parse_raw。 And as you see， we get the original
    Waffle object back again。 So that's really great。 So let's see then what happens
    with errors。
  prefs: []
  type: TYPE_NORMAL
- en: So we have the validation errors， which were readable， and exceptions are great。
    But when you're working with third party clients or with APIs， or stuff like that。
    maybe you want to expose those errors， in a structured format。 And of course。
    the async can be used here as well。 So let's see here we create an invalid Waffle。
    And in this case。
  prefs: []
  type: TYPE_NORMAL
- en: we have the style 42， which， isn't an allowed style at the WaffleBist group。
    And we point error。 And here you can see we have the same error data。 But in a
    structured object where we can get this location。 of the error， we can get a message
    telling in a more， human readable way what's wrong。 And we also get some context
    data and a type of error。 So that's really useful。
  prefs: []
  type: TYPE_NORMAL
- en: I've used this for instance in React and other front-end libraries。 to wrap
    it and easily get some very nice output。 And maybe automatically mark in a form。
    for instance， where the error is。 Yeah， I think that's really nice。 So JSON schema
    done。 So maybe you've heard about JSON schema。 And we can also export JSON schema
    directly from our model。
  prefs: []
  type: TYPE_NORMAL
- en: So this is where pedantic almost gets magical for me。 Because I mean， this is
    so useful。 You can use it to create a swagger or open API， as it's known as now。
    And specifications for your data。 So here we have the waffle class。 And we run
    the schema function on it。 And as you can see， we get this large schema， which。
  prefs: []
  type: TYPE_NORMAL
- en: is actually a JSON schema。 Keep in mind that the pedantic does， use the draft
    7 of the ASIN schema。 which， is standard in open API 3。1， which， was released
    earlier this year。 But maybe if you're using the still common 3。0， you could have
    some slight compatibility issues。 Usually it's no problem。 But I've run into it
    like a few times。 So it's good to know。
  prefs: []
  type: TYPE_NORMAL
- en: The difference is it's quite small， but there are some。 And if you want to have
    straight compatibility， with the draft 4。 you can create the ASIN extra function，
    which handles it for you。 So that was the built-in validators。 But maybe you want
    to create some custom ones。
  prefs: []
  type: TYPE_NORMAL
- en: and code our own business logic。 And the waffle bistra sure does。 So we have
    our own business logic。 which we want to implement。 And in this case， we want
    to constrict a little bit。 about what kind of waffles we can create。 So now we're
    creating a waffle order。 which is the subclass of the waffle。 And the only difference
    is that we actually enforce some stuff。
  prefs: []
  type: TYPE_NORMAL
- en: when customers are ordering our waffles。 For instance， for Swedish style waffles。
    we only want to allow jam dessert sauces， so raspberry jam or a cloud barrier
    jam。 And for the Belgian styles， we allow chocolate sauce。 And additionally。 we
    don't want to have waffles， with both ice cream and whipped cream。
  prefs: []
  type: TYPE_NORMAL
- en: So they have to choose either ice cream or whipped cream。 And you can see we
    created some functions here。 Basically， we have this at root validator。 telling
    us that we should run these pre equals false。 Tells us that we should run this
    after。 We've done all the other validators， so we know that we have parsed all
    the data。
  prefs: []
  type: TYPE_NORMAL
- en: and stuff like that。 So that can be useful。 And we check the styles。 basically
    looking at the toppings， and at the styles。 And we can see that we follow these
    rules without。 Same for cream them。 So here we can see that we checked， that there's
    only one cream in the list of toppings。
  prefs: []
  type: TYPE_NORMAL
- en: And we raise a nice error if there's more。 So let's go ahead then。 So let's
    see now what happens。 we tried to create an invalid waffle based on these new
    rules。 So I'm gonna create one with both ice cream and whipped cream。 I'm really
    feeling like having a lot of cream today。 And as you can see， the order wasn't
    accepted。
  prefs: []
  type: TYPE_NORMAL
- en: It's telling us that we're only allowed， to have one cream topping。 but we were
    given both ice cream and whipped cream。 So that won't do。 Basically that gives
    us a very nice way of knowing。 Then you can see that we get an error。 on the root
    validator as well。 This is because the previous validator doesn't pass。
  prefs: []
  type: TYPE_NORMAL
- en: We could add like an exception for this， or handle it in a smarter way。 But
    in this case。 like for the purpose of this talk， I mean it's gonna keep it simple。
    So if we try to create a waffle order now， with both a cloud barrier jam and chocolate
    sauce。 and it's a Swedish style。 So we don't allow chocolate sauce on Swedish
    style。
  prefs: []
  type: TYPE_NORMAL
- en: We can see also we get them。 We're saying that two waffle bistro doesn't sell
    this， type of waffle。 Here we could also create even better errors if we want，
    but for custom ones it's up to you。 So these runtime functions or type checkers，
    are really， really useful for a lot of things。 So maybe you want to use them for
    functions as well。 Sometimes your boundaries in the class。
  prefs: []
  type: TYPE_NORMAL
- en: So actually， I finally got you covered here as well。 because there's a validator
    arguments decorator， which is still in beta。 And it was released in 2020， 18th
    of April in version 1。5， but it's great stable。 It could be good to know or interesting
    to see。 So here we have the valid arguments import。
  prefs: []
  type: TYPE_NORMAL
- en: and then we have our function， make order， with some undefined business logic
    taking in a waffle。 and actually our waffle order and actually making sure。 that
    the argument for waffle is an waffle order。 So we try to make a waffle here。 and
    we create a breakfast style waffle。 Here you can see we add a dict。
  prefs: []
  type: TYPE_NORMAL
- en: and if the dict would be valid， it would actually create the waffle object for
    you。 And as you can see， we get the error telling us， that the style wasn't correct。
    because we don't sell breakfast waffles， just Swedish and Belgian styles。 And
    we can also see that we get the root validator error。
  prefs: []
  type: TYPE_NORMAL
- en: saying that we don't sell this type of waffle。 So that's very nice。 And now
    that you've seen this。 maybe you're thinking that you want to integrate this，
    in your frameworks。 And that's also a very nice thing about pedantic。 There's
    a lot of frameworks。 having great integrations with pedantic。 So you can use it，
    for instance。
  prefs: []
  type: TYPE_NORMAL
- en: with the flask or Falcon or Stollet， with the framework agnostic spectra。 There's
    a quartz schema。 which is a async， or a quartz is async re-implementation of flask。
    and quartz schema is a first party pedantic integration， for that。 There's fast
    API。 which is very famous， and it's using pedantic for everything。 So it's really
    first class there。
  prefs: []
  type: TYPE_NORMAL
- en: We have something called Django NINIA， for you using Django outside there。 And
    I haven't used it myself， but I've looked at it， and it's very similar to the
    other ones。 Should be quite this to use。 There's another cool one I like to mention，
    which is Proberry。 which is actually a GraphQL framework。 But it got experimental
    support for pedantic classes， well。
  prefs: []
  type: TYPE_NORMAL
- en: for your GraphQL graphs。 So that's nice。 So it's like a puzzle piece。 that you
    can kind of fit into a little bit of everywhere。 And another thing I really， really
    like。 is automatic testing。 So there's a pedantic hypothesis plugin。 and you can
    use it for automatic testing。 I've linked an article here by Phil Jones。
  prefs: []
  type: TYPE_NORMAL
- en: Where he uses a technique very similar to one I use。 to automatically test the
    APIs using this hypothesis plugin。 Basically。 if you've used the hypothesis， when
    you built your strategy。 you just referenced the model and you're fine。 If you
    want to learn more about hypothesis。
  prefs: []
  type: TYPE_NORMAL
- en: you could watch my talk from PyCon Suite in 2019， which is linked here。 Another
    great library。 schema thesis， which takes in an open API spec， and makes sure
    that your API actually can handle。 everything the spec says。 So it just generates
    a lot of tests， very nice library。 If you want to know more， you can watch my
    Europil from last year linked here。
  prefs: []
  type: TYPE_NORMAL
- en: or just check out the library。 I highly recommend it。 So I'm gonna show you
    very quickly。 super small example using Fast API， basically。 And using it to create
    a very small API。 around our Waffle be through logic。 So Fast API is very tightly
    integrated with the pedantic。 and it's async ASCII framework， but it can be used
    with sync mode as well。
  prefs: []
  type: TYPE_NORMAL
- en: And this is everything we need to create an application， with an API around
    us。 So here we have the two functions， implementing our business logic。 basically
    make order and dispatch order。 So we can make a Waffle order and we can dispatch
    it。 when the Waffle is done。 And we just reference our Waffle models here。 And
    just using that。
  prefs: []
  type: TYPE_NORMAL
- en: you get the automatic API documentation， and you also get type validation for
    everything in runtime。 And this is just the beginning。 So this is just the tip
    of the iceberg。 There's a lot more and you can contact me via chat。 here on the
    conference or via Twitter or LinkedIn， or the email if you want to know more。
  prefs: []
  type: TYPE_NORMAL
- en: Here's just a quick taste about some of the things， you could look at。 but I'm
    not gonna have time to cover them。 But for instance， built-in support for 。n。
    so you can use it for settings management， very nice。 There's stuff like annotated
    types。 there's plugins for PyCharm， there's a MyPy plugin making the MyPy support
    even better。
  prefs: []
  type: TYPE_NORMAL
- en: But there's of course native MyPy support。 We have a very fast way of handling
    this。 So if you look at the benchmarks， it's very fast compared to alternatives。
    But of course it should make your own。 If you're gonna use it， there's a lot of
    built-in types。 you can use。 And of course you can create your own types。 So concluding
    this talk then。
  prefs: []
  type: TYPE_NORMAL
- en: we have the Pure Python syntax。 We get some better validation， very useful JSON
    tools for APIs。 easy to migrate from standard data classes， if you have those，
    lots of useful features。 And the more things are always coming， very active development
    stuff is happening all the time。 and they're working on the strict mode， and you
    should really try it out。 I mean。
  prefs: []
  type: TYPE_NORMAL
- en: just play around with it a little bit。 I've used it from everything from production
    applications。 to just small one-off experiments just playing around。 So if you
    have any further questions。 you can ask me either here on the conference， or you
    can contact me via some of these links。 I also have a link here to my GitHub，
    where I also have a GitHub page for this talk。
  prefs: []
  type: TYPE_NORMAL
- en: where I have even more information， some more links。 I have a Jupyter notebook
    with all the examples， so you can run them yourself。 You can sign up for my hypothesis
    course， if you're interested in property-based testing。 which I'm developing on
    the link here， and also for the papier。io beta。
  prefs: []
  type: TYPE_NORMAL
- en: if you're interested in optimizing your PDF workflow， being able to create PDFs
    with HTML。 CSS and JavaScript。 And I'm also available for training workshops。
    and freelance consulting if you want to learn more。 So I don't hesitate to contact
    me if you want to know。
  prefs: []
  type: TYPE_NORMAL
- en: And thank you a lot for watching my talk today。 It's been a pleasure and I hope
    you enjoyed it。 Bye。
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98d3126a31287dc7ece0555ee1b7c225_4.png)'
  prefs: []
  type: TYPE_IMG
- en: (chuckling)， (chuckling)， (chuckling)， (chuckling)， (chuckling)， (chuckling)，
    (chuckling)。 (chuckling)， (chuckling)， (chuckling)， (chuckling)， (chuckling)，
    (chuckling)， (chuckling)。 (chuckling)， (chuckling)， (chuckling)， (chuckling)，
    (chuckling)， (chuckling)， (chuckling)。 (chuckling)， (chuckling)， (chuckling)，
    (chuckling)， (chuckling)， (chuckling)， (silence)。
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98d3126a31287dc7ece0555ee1b7c225_6.png)'
  prefs: []
  type: TYPE_IMG
