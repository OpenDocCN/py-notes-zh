- en: P10：TALK _ Maggie Moss _ Gradual Typing in Practice - VikingDen7 - BV19Q4y197HM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P10：演讲 _ Maggie Moss _ 渐进式类型实践 - VikingDen7 - BV19Q4y197HM
- en: '[Music]。'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[音乐]。'
- en: '![](img/59751e99a12551c7e1d463fed8463a4b_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59751e99a12551c7e1d463fed8463a4b_1.png)'
- en: '![](img/59751e99a12551c7e1d463fed8463a4b_2.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59751e99a12551c7e1d463fed8463a4b_2.png)'
- en: Welcome to gradual typing and practice。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到渐进式类型和实践。
- en: '![](img/59751e99a12551c7e1d463fed8463a4b_4.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59751e99a12551c7e1d463fed8463a4b_4.png)'
- en: My name is Maggie and I'm a software engineer at Facebook。 And for the past
    two years。 I've been working on Pyre， which is a Python type checker。 Prior to
    that。 I was working on the hack team。 I'm not familiar with hack， it's Facebook's
    version of typed PHP。 So essentially， for the last three years， I've been working
    on adding types to dynamic programming languages。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我叫Maggie，是Facebook的一名软件工程师。在过去两年里，我一直在开发Pyre，这是一个Python类型检查器。在此之前，我在hack团队工作。我不太熟悉hack，它是Facebook的类型化PHP版本。因此，从本质上讲，在过去三年里，我一直在为动态编程语言添加类型。
- en: and building tools to help make that process smoother。 And when I tell people
    that I work on adding types to dynamic programming languages。 I get a very simple
    question and response。 Why would you do that？ And it's a fair question。 I'm assuming
    that because you're here at PyCon， you know that there are many benefits。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 并构建工具以帮助使该过程更顺利。当我告诉人们我在为动态编程语言添加类型时，通常会得到一个非常简单的问题和回应。你为什么要这样做？这是一个合理的问题。我假设你在PyCon上，知道有许多好处。
- en: to building with a flexible dynamic programming language like Python。 But the
    reality is that it does create room for bugs and errors that aren't possible。
    in a statically typed language like C or Java。 So no matter how many unit tests
    you write。 you're probably still finding type errors in your logs。 And as your
    project grows。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像Python这样的灵活动态编程语言进行构建。但现实是，这确实会产生潜在的错误和缺陷，这是在静态类型语言如C或Java中不可能发生的。因此，无论你编写多少单元测试，日志中仍然可能会出现类型错误。随着项目的增长。
- en: these issues can become amplified。 And it can be a frustrating spot to be in。
    You want the type safety of a static language without giving up all of the benefits
    from a language like Python。 And one solution gets suggested at this point is，
    well， why don't we just rewrite our project。 in an entirely different language，
    and that will solve all of our problems。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可能会被放大。而且这会让人感到沮丧。你希望拥有静态语言的类型安全，而又不想放弃像Python这样语言的所有好处。此时有人建议，为什么不把我们的项目重写成一种完全不同的语言，这样就能解决我们所有的问题。
- en: And this is often an unrealistic solution for many reasons。 Rewriting an entire
    code base requires a massive investment。 Is there any way to get this without
    changing languages and rewriting an entire code base？
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这往往是一个不现实的解决方案，原因有很多。重写整个代码库需要巨大的投资。有没有办法在不更换语言和重写整个代码库的情况下实现这一点？
- en: So the answer is yes。 And Facebook has done this in the past。 and we converted
    code from PHP to hack。 And then we've done it again by using a type checker for
    Python code。 both at Facebook and at Instagram。 And having a typed code base has
    increased our productivity。 We can make changes with more confidence， write more
    focused unit tests。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所以答案是肯定的。Facebook过去确实做过这个，我们将代码从PHP转换为hack。然后我们又通过为Python代码使用类型检查器做到了这一点，无论是在Facebook还是Instagram。拥有一个类型化的代码库提高了我们的生产力。我们可以更有信心地进行更改，编写更有针对性的单元测试。
- en: and have fewer bugs reach production。 And we're not the only company that's
    done this。 Stripe has built a type checker for Ruby， and if you've used TypeScript
    and Flow。 they're designed to tackle this same problem in JavaScript。 And the
    benefits of gradual types aren't limited to large projects with millions of lines
    of code and large development teams。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 并且让更少的错误进入生产环境。而且我们并不是唯一这样做的公司。Stripe为Ruby构建了一个类型检查器，如果你使用过TypeScript和Flow，它们的设计也是为了处理JavaScript中的同样问题。渐进式类型的好处并不局限于拥有数百万行代码和大型开发团队的大型项目。
- en: Small projects can benefit from using a type checker too。 So what we'll first
    go over today is what is gradual typing and what does it look like in Python specifically。
    We'll talk about why you should add types to your Python code and what benefits
    you'll get out of it。 What tools and strategies did we use to get engineers to
    invest time in adding types？
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 小型项目同样可以从使用类型检查器中受益。那么今天我们首先要讨论的是什么是渐进式类型，以及它在Python中具体是什么样子。我们将讨论为什么应该在Python代码中添加类型，以及你能从中获得哪些好处。我们使用了哪些工具和策略来促使工程师投入时间添加类型？
- en: So what were the steps we actually took to get from almost no types to a fully
    typed Python code base？
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们实际上采取了哪些步骤，从几乎没有类型到一个完全类型化的 Python 代码库呢？
- en: And finally， we'll go over some of the trickier code patterns that we've encountered。
    and what new features are coming to the Python type system。 Before we get started
    with discussing strategies for typing your Python project。 we first need to establish
    what gradual typing is。 So let's go back to basics for a second。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将讨论一些我们遇到的更棘手的代码模式，以及 Python 类型系统即将推出的新功能。在开始讨论你的 Python 项目的类型策略之前，我们首先需要建立什么是渐进类型。所以让我们先回到基础知识。
- en: In general， we can think of a type as something that describes a set of values
    that have a bunch of operations in common。 For example， the type int describes
    a set of numbers that support operations like addition and subtraction。 And a
    type error happens when we try to apply an operation to a value of the wrong type。
    Like if you try to subtract a dictionary from an int， for example。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们可以将类型视为描述一组具有共同操作的值的东西。例如，类型 int 描述了一组支持加法和减法等操作的数字。当我们尝试对错误类型的值应用某个操作时，就会发生类型错误。比如，如果你试图从一个整数中减去一个字典。
- en: If you've written in languages like Java， C， or REST， you're familiar with static
    types。 In statically typed languages， some or even all type errors are caught
    by a type checker prior to running the program。 And usually this type checker
    is part of the compiler。 and it's automatically run during compilation。 So in
    this example here。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾用过 Java、C 或 REST 这样的语言，你会熟悉静态类型。在静态类型语言中，某些或甚至所有类型错误在运行程序之前都会被类型检查器捕获。通常，这个类型检查器是编译器的一部分，并且在编译过程中自动运行。所以在这里的这个例子中。
- en: our variable x is defined as having a type integer。 and we'd get an error if
    we tried to re-assign it to be a string。 So not only would our variables need
    annotations， but so do parameters， return types。 and attributes。 In Python， we're
    familiar with dynamic typing。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的变量 x 被定义为类型整数。如果我们试图将其重新赋值为字符串，就会出现错误。因此，不仅我们的变量需要注释，参数、返回类型和属性也需要。在 Python
    中，我们熟悉动态类型。
- en: where we don't have to add annotations to every single variable。 In this example。
    we can reassign food to be an integer or even a dictionary， and it just works。
    So the values have types， but the variables and the functions do not。 In a dynamically
    typed language， type checking is performed during program execution。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不需要为每一个变量添加注释。在这个例子中，我们可以将 food 重新赋值为一个整数或甚至一个字典，这样也可以正常工作。因此，值有类型，但变量和函数没有。在动态类型语言中，类型检查是在程序执行期间进行的。
- en: immediately before the application of each operation。 And this makes it easy
    to deal with situations where the type of a value depends on runtime information。
    But the downside is that sometimes we get type errors that look like this， or
    maybe like this。 And I'm sure you've had an experience where you've written some
    code， added a bunch of unit tests。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这发生在每个操作应用之前。这使得处理值的类型依赖于运行时信息的情况变得容易。但缺点是，有时我们会遇到类似这样的类型错误，或者可能是这样的。我相信你有过这样的经历：写了一些代码，添加了一堆单元测试。
- en: confidently shipped it， only to find error messages that look like this in your
    logs。 So what is a gradual type system？ The type system or not every expression
    is typed。 It allows parts of a program to be dynamically typed and other parts
    to be statically typed。 You can show which part is which by either leaving out
    type annotations or by adding them in。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 自信地发布代码，却在日志中发现类似这样的错误信息。那么，什么是渐进类型系统呢？类型系统并不是每个表达式都有类型。它允许程序的某些部分是动态类型，而其他部分是静态类型。你可以通过省略类型注释或添加它们来展示哪个部分是哪个。
- en: So does this look like in Python？ Un-typed expressions are assumed to be type
    "any"。 which is defined as having every attribute and being a sub and super type
    of every other known type。 And the key thing to remember with types in Python
    is that only annotated functions are type checked。 So in this example， "fue" has
    a return annotation of type "int"。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在 Python 中，这看起来是什么样的呢？未类型化的表达式被假定为类型“any”，它被定义为具有每个属性并且是所有其他已知类型的超类型和子类型。需要记住的关键点是，在
    Python 中，只有带注释的函数才会进行类型检查。所以在这个例子中，“fue”有一个返回类型注释为“int”。
- en: so the body of this function will be type checked。 In contrast， "bar" has no
    return annotation。 so the body of it won't be type checked at all。 Un-annotated
    functions are assumed to take any and return any。 What this means is that you
    can add static types where you can and where you need type checking。 And as you
    add more annotations to your code， in other words， you increase type adoption。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个函数的主体将会进行类型检查。相比之下，“bar”没有返回注释，因此它的主体将根本不会进行类型检查。未注释的函数被假定为可以接受任何类型并返回任何类型。这意味着你可以在需要类型检查的地方添加静态类型。随着你为代码添加更多注释，换句话说，你会增加类型的采用。
- en: Python type checkers will surface more and more type errors。 This means you
    can slowly add types to your code， but still get meaningful results as you go。
    There are several different Python type checkers that you can choose to use in
    your project。 This is just a few of them。 In alt， type checkers implement the
    same typing specific peps。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Python 类型检查器将会显示越来越多的类型错误。这意味着你可以慢慢地为代码添加类型，但在此过程中仍能获得有意义的结果。你可以选择在项目中使用几种不同的
    Python 类型检查器。这只是其中的一些。在其他方面，类型检查器实现了相同的类型特定 PEP。
- en: like "pep-484"， for example。 The general workflow is that you write some code
    and then you run your type checker。 And this can be done via a command line tool，
    but often。 Python type checkers will also surface errors in your IDE。 And you'll
    want to set your type checker up in your CI job so that it's run on every pull
    request。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 比如“pep-484”。一般工作流程是你编写一些代码，然后运行你的类型检查器。这可以通过命令行工具完成，但通常 Python 类型检查器也会在你的 IDE
    中显示错误。你会希望在 CI 任务中设置类型检查器，以便在每个拉取请求上运行。
- en: This will help keep your project in a clean type checking state。 and if it's
    in a clean type checking state， type errors that are surfaced are going to be
    high signal。 I happen to work on PyRE， so parts of this talk will mention some
    PyRE specific features or tools。 but most type checkers have implemented something
    similar。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有助于保持你的项目处于干净的类型检查状态。如果处于干净的类型检查状态，出现的类型错误将具有很高的信号强度。我恰好在 PyRE 工作，因此这次演讲的一些部分会提到一些
    PyRE 特定的功能或工具，但大多数类型检查器都有类似的实现。
- en: So the advice and approaches that we'll talk about can be implemented no matter
    what Python type checker you happen to be using。 So why should you take time out
    of your busy development schedule to add types to your code base？
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将讨论的建议和方法可以在你使用的任何 Python 类型检查器中实现。那么，为什么你要在繁忙的开发日程中抽出时间为你的代码库添加类型呢？
- en: To illustrate this， let's pretend that we're starting our first day on a new
    project。 We're building a small online store。 Our task is to fix some bugs and
    some code that displays products on the home page。 And as we're digging around
    in the code， we need to answer the question。 "Does this function return none？"，
    And of course you could say， "Well。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，假设我们在新项目的第一天。我们正在构建一个小型在线商店。我们的任务是修复一些错误和显示主页产品的代码。当我们在代码中深入挖掘时，我们需要回答这个问题：“这个函数是否返回
    `none`？”当然你可以说，“好吧。”
- en: why don't we just check if it returns none when we call it and then we can handle
    this here？"。 And this would work， but it does have the potential to get a little
    bit messy after a while。 So let's go back to our function definition。 There are
    three return statements in our function。 and we decide to use the process of elimination
    to try and answer this question。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: “为什么我们不在调用它时检查它是否返回 `none`，然后在这里处理呢？”这样做是可行的，但随着时间的推移，这可能会变得有些复杂。因此让我们回到我们的函数定义。我们的函数中有三个返回语句，我们决定使用排除法来尝试回答这个问题。
- en: So we check out the function definition for get-latest products。 and we're pretty
    confident that that one doesn't return none。 But when we go to check out the function
    definitions for get-holiday products and get similar products。 we find that those
    functions have multiple return statements。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们查看 `get-latest` 产品的函数定义，我们非常有信心那个不会返回 `none`。但是当我们去查看 `get-holiday` 产品和
    `get-similar` 产品的函数定义时，我们发现这些函数有多个返回语句。
- en: and then those methods have multiple return statements， and they're all kind
    of complex。 and suddenly answering this question becomes time-consuming and tricky。
    We can go read all of these function bodies， but it becomes difficult to say for
    certain that no combination of states or inputs。 will result in none being returned
    from this function。 So what happens if we add types？
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些方法有多个返回语句，并且都比较复杂时，回答这个问题就会变得耗时且棘手。我们可以去阅读所有这些函数体，但很难确定没有状态或输入组合会导致该函数返回空值。那么，如果我们添加类型会发生什么呢？
- en: So here we've added two type annotations to our function。 The first is for a
    parameter-shaped cart and the second for our return type。 which is going to be
    a list of products。 And now all we have to do is run our type checker。 And we
    might see an error that looks like this。 Incompatible return type。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为函数添加了两个类型注解。第一个是参数形状的购物车，第二个是我们的返回类型，即产品列表。现在我们只需运行类型检查器。我们可能会看到一个类似于“返回类型不兼容”的错误。
- en: expected a list of products but got none。 So using a type checker。 we were able
    to answer this question fairly quickly。 Yes， this function does return none。 and
    now we know what return types need to handle when we're working with this function。
    So we've only really made two small changes to our code。 We've added two type
    annotations。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 期望获得产品列表，但没有获得。因此，使用类型检查器，我们能够相对快速地回答这个问题。是的，这个函数确实返回了空值，现在我们知道在处理这个函数时需要注意的返回类型是什么。所以我们实际上只对代码进行了两个小改动，添加了两个类型注解。
- en: and using a type checker allows us to be more confident about making changes
    and shipping code quickly。 We have a guarantee in place about the inputs and return
    types that we need to handle。 Whenever we add an annotation， we get the type checker
    to do the work of reading and understanding the code flow for us。 We tell the
    type checker what we expect this function to do。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型检查器可以让我们在进行更改和快速发布代码时更加自信。我们对需要处理的输入和返回类型有了保证。每当我们添加注解时，类型检查器会为我们读取和理解代码流。我们告诉类型检查器我们期望这个函数做什么。
- en: and it guarantees that this doesn't come in conflict with our expectations for
    any other function or object。 This means that when we go to write our unit tests。
    we can focus on the use cases that pass in these types without worrying about
    writing tests where this function would get something other than an art cart as
    an argument。 The added benefit is that this works as built-in up-to-date documentation。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它保证了这与我们对任何其他函数或对象的期望不冲突。这意味着当我们编写单元测试时，可以专注于传入这些类型的用例，而不必担心测试该函数接收其他类型参数的问题。额外的好处是这也作为内置的最新文档。
- en: One simply has to look at the function signature and know what types pass in
    and what types they'll get back。 As we've said earlier， types function as built-in
    up-to-date documentation。 They help you catch bugs before they reach production。
    and we can actually eliminate a whole category of bugs。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 只需查看函数签名，就能知道传入的是什么类型以及它们会返回什么类型。正如我们之前所说，类型作为内置的最新文档，可以帮助你在生产前捕捉到错误，并且我们实际上可以消除一个完整的错误类别。
- en: maybe where the wrong type is passed in as an argument。 which can make your
    unit test simpler and more focused。 Most Python type checkers have an IDE integration。
    which means you can actually catch these type errors as you're writing code。 and
    they often come with more powerful features， like autocomplete。 A typed code base
    makes it easier to leverage development tools， like libcst and pisa。 libcst is
    a code mod tool， and pisa can help you find security vulnerabilities in your code。
    So now that you understand the benefits of adding types to your Python projects。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 也许是因为错误的类型作为参数传入，这可以使你的单元测试更简单、更专注。大多数Python类型检查器都有IDE集成，这意味着你可以在编写代码时实际捕获这些类型错误，并且它们通常还带有更强大的功能，比如自动补全。一个带类型的代码库使得利用开发工具（如libcst和pisa）变得更加容易。libcst是一个代码修改工具，而pisa可以帮助你找到代码中的安全漏洞。因此，现在你理解了将类型添加到Python项目中的好处。
- en: how do you actually get started？ Our advice is to start adding types to your
    most used modules first。 and our second is that once you have types in your code
    base。 you want to prevent against type quality regressions。 So let's pretend this
    is our most used module。 It has one function， foo， takes in a list of items and
    returns a list of their IDs。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上该如何开始？我们的建议是首先为你最常用的模块添加类型注释。我们的第二个建议是，一旦你在代码库中有了类型，你需要防止类型质量的回归。所以假设这是我们最常用的模块。它有一个函数`foo`，接收一个项目列表并返回它们的ID列表。
- en: So in order to type this， we only need two type annotations。 So this looks great。
    and we go to run our type checker， and we see a bunch of errors look like this。
    Incompatible parameter type， expected a list of items， but got a list of strings。
    And the first couple times that this happens， it's a bit confusing。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所以为了进行类型注释，我们只需要两个类型注释。这看起来不错。我们去运行我们的类型检查器，看到一堆错误，看起来像这样。不兼容的参数类型，预期是项目列表，但得到了字符串列表。前几次发生这种情况时，有点令人困惑。
- en: because it's likely that these type errors are going to come from files that
    you haven't touched yet。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些类型错误很可能来自你尚未接触的文件。
- en: '![](img/59751e99a12551c7e1d463fed8463a4b_6.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59751e99a12551c7e1d463fed8463a4b_6.png)'
- en: So why is this happening？ Well， if we open up one of these files， we might see
    something like this。 We're importing from our most used module， and bar has a
    return annotation。 so this function has always been type checked。 But we do see
    that it's passing in a list of strings instead of a list of items。 But why is
    this error only popping up now？ If you remember earlier。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这为什么会发生呢？好吧，如果我们打开其中一个文件，我们可能会看到这样的内容。我们正在从我们最常用的模块导入，而`bar`有一个返回注释。所以这个函数一直在进行类型检查。但我们确实看到它传入的是一个字符串列表，而不是一个项目列表。但为什么这个错误现在才出现呢？如果你还记得之前的内容。
- en: we said that any untyped expression in Python is assumed to be type "any"。 which
    is compatible with a list of strings。 But now that we have our more specific type
    annotation on our parameter for foo。 it's a list of items， that's not compatible
    with a list of strings。 So our type checker is going to start raising error， which
    is good。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说在Python中，任何未类型化的表达式都被假定为类型“any”，与字符串列表兼容。但现在我们在`foo`的参数上有了更具体的类型注释。它是一个项目列表，这与字符串列表不兼容。因此，我们的类型检查器将开始引发错误，这是好的。
- en: We're going to catch more type errors。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将捕获更多的类型错误。
- en: '![](img/59751e99a12551c7e1d463fed8463a4b_8.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59751e99a12551c7e1d463fed8463a4b_8.png)'
- en: And this happens like a network effect。 So we have our modules， and they have
    their dependencies。 and we add types to one of them。 And then we start to see
    type errors pop up all over the code base。 And this is why you want to add annotations
    to your most used module first。 because you're going to get the most type errors
    from the fewest annotations。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像一种网络效应。所以我们有我们的模块，它们有各自的依赖关系。我们在其中一个模块中添加类型，然后我们开始看到整个代码库中出现类型错误。这就是为什么你想先为最常用的模块添加注释，因为你会从最少的注释中获得最多的类型错误。
- en: Type coverage is nonlinear， and its benefits and guarantees。 So typing these
    popular modules first is going to give you the most type coverage。 It's probably
    more beneficial to spend time typing class that's imported all over your project
    than it would be to maybe type a script that you run once or twice a year。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 类型覆盖是非线性的，它的好处和保证也是如此。因此，首先对这些流行模块进行类型注释，将为你提供最多的类型覆盖。花时间给在你项目中广泛导入的类添加类型可能比给一年只运行一两次的脚本添加类型更有益。
- en: '![](img/59751e99a12551c7e1d463fed8463a4b_10.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59751e99a12551c7e1d463fed8463a4b_10.png)'
- en: So now that we've added a few annotations to our most used module， we have a
    bunch of type errors。 which is great。 We know where more of the type errors in
    our project are。 But we may not have time to sit down and fix each one right away。
    So Python's type system allows you to suppress errors。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们已经在最常用的模块中添加了一些注释，我们有了一堆类型错误。这很好。我们知道项目中更多的类型错误在哪里。但我们可能没有时间立即坐下来修复每一个。因此，Python的类型系统允许你压制错误。
- en: And the way that you do this is just with a comment that says type ignore。 and
    this will ignore any type error from the following line。 The idea here is not
    to suppress every type error that your type checker surfaces。 That would defeat
    the point of using a type checker。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过一个注释来实现这一点，注释内容为“type ignore”，这将忽略下一行的任何类型错误。这里的想法并不是要压制类型检查器提出的每个类型错误。这会违背使用类型检查器的初衷。
- en: But it allows you to make incremental progress in annotating large code bases。
    So they're designed to be a temporary fix until you have time to come back and
    fix the underlying issue。 In the meantime， the function is warnings to you and
    other engineers that， "Hey。 there's an issue here。"。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但这允许你在大型代码库中逐步进行注释。因此，它们被设计为一个临时解决方案，直到你有时间回来修复潜在问题。在此期间，该函数向你和其他工程师发出警告：“嘿，这里有一个问题。”
- en: '![](img/59751e99a12551c7e1d463fed8463a4b_12.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59751e99a12551c7e1d463fed8463a4b_12.png)'
- en: When you first get started and you turn on type checking in your project。 you'll
    probably have a bunch of type errors even before you've added your first annotation。
    So we recommend that you set up your project and then suppress all of these initial
    errors that your project is in a clean type checking state。 The new errors that
    you introduced will be high signal this way。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你首次开始并在项目中开启类型检查时。你可能在添加第一个注释之前就会遇到一堆类型错误。因此，我们建议你先设置好项目，然后抑制所有这些初始错误，以确保项目处于干净的类型检查状态。这样你引入的新错误将更具信号性。
- en: We actually have a tool that will do this for you。 so a pyre upgrade will suppress
    any type errors in your project。 And it will also remove type ignores that are
    no longer needed。 So if you pip install pyre check。 pyre upgrade comes with it。
    Again， they're not meant to be there forever。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上有一个工具可以为你完成这项工作。因此，pyre 升级将抑制项目中的任何类型错误。它还会移除不再需要的类型忽略。因此，如果你通过 pip 安装
    pyre check，pyre upgrade 就会随之而来。同样，它们并不是打算永远存在。
- en: and a part of getting to a fully typed code base is removing them。 but they're
    a great tool to help you move from having no annotations to a fully typed code
    base。 Our second piece of advice was to prevent type quality regressions in modules
    that have already been fully typed。 So what do we mean by a type quality regression？
    If you have a file where every function has a return annotation and every parameter
    is annotated。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 完全类型化代码库的一部分是移除这些注释。但它们是一个很好的工具，帮助你从没有注释过渡到一个完全类型化的代码库。我们第二条建议是防止已经完全类型化的模块出现类型质量回退。那么，什么是类型质量回退呢？如果你有一个文件，其中每个函数都有返回注释，每个参数都有注释。
- en: and so is every attribute and global， and someone comes along and removes some
    of these annotations or adds a bunch of code that has no annotations。 we would
    call that a type quality regression。 So how do you prevent this？
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个属性和全局变量也是如此，如果有人来移除这些注释或添加一堆没有注释的代码，我们将称之为类型质量回退。那么你如何防止这种情况发生呢？
- en: The most Python type checkers have options to configure various strictness settings。
    For this next section， I'm going to talk about how pyre has implemented this。
    but you could do something similar if you're using a different type checker。 Pyre
    has two modes。 strict and default， and we've implemented this on a per file basis。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Python 类型检查器都有配置各种严格性设置的选项。在接下来的部分，我将讨论 pyre 如何实现这一点，但如果你使用的是不同的类型检查器，你也可以做类似的事情。Pyre
    有两种模式：严格模式和默认模式，我们已经在每个文件的基础上实现了这一点。
- en: '![](img/59751e99a12551c7e1d463fed8463a4b_14.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59751e99a12551c7e1d463fed8463a4b_14.png)'
- en: So you're going to start with all of your files in default mode， and in default
    mode。 functions that are missing， parameter， or return annotations are okay。 Just
    a reminder。 functions without return annotations are not type checked in Python。
    If you do have a return annotation， the body of that function will be type checked
    as expected。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你将开始时所有文件处于默认模式，在默认模式下，缺少参数或返回注释的函数是可以的。提醒一下：没有返回注释的函数在 Python 中不进行类型检查。如果你有返回注释，那么该函数的主体将按预期进行类型检查。
- en: and if you have an annotation that contains an explicit any， that's allowed。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个包含显式 `any` 的注释，这是被允许的。
- en: '![](img/59751e99a12551c7e1d463fed8463a4b_16.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59751e99a12551c7e1d463fed8463a4b_16.png)'
- en: Once you get a file close to being fully typed， you'll want to flip the mode
    to pyre strict。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将一个文件接近完全类型化，你将想要将模式切换到 pyre strict。
- en: '![](img/59751e99a12551c7e1d463fed8463a4b_18.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59751e99a12551c7e1d463fed8463a4b_18.png)'
- en: In strict mode， functions that have a missing annotation will be an error， as
    will parameters。 attributes， and globals that are missing annotations。 Functions
    with return annotations are type checked as expected。 but if those annotations
    happen to contain an explicit any， you'll also get an error there as well。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，缺少注释的函数将会出现错误，缺少注释的参数、属性和全局变量也是如此。带有返回注释的函数将按预期进行类型检查，但如果这些注释包含显式的 `any`，那么你也会在这里收到错误。
- en: So what you'll want to do is start with all of your files in default mode。 and
    then as you get those files close to or completely typed。 you'll want to protect
    that progress by switching them into strict mode。 In that way。 engineers will
    get errors if they try and remove annotations or add an annotated code to them。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你需要做的就是首先将所有文件置于默认模式，然后在你逐渐输入这些文件时，你会想通过切换到严格模式来保护你的进度。这样，工程师们如果试图移除注释或向其中添加带注释的代码，就会收到错误提示。
- en: Once you make progress typing your project， you can actually switch strict mode
    to be the default。 and this means that if anyone adds a new file to your project。
    they'll have to add types to it as well。 This prevents regression after the initial
    types are added。 as we've said。 You would see an error if you were to remove annotations
    or add an annotated code。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在项目中取得了类型的进展，你实际上可以将严格模式设为默认模式。这意味着，如果有人向你的项目添加新文件，他们也必须为其添加类型。这可以防止在初始类型添加后出现回归问题。正如我们所说，如果你移除注释或添加带注释的代码，你会看到错误提示。
- en: And it also makes all changes required for a fully typed code base explicit。
    so you can look at your project and say 30% of our files in strict mode and 70%
    are in default mode。 and know what you have to do to get to a fully typed project。
    At Facebook and Instagram。 we've converted several large projects from having
    almost no types to being nearly or completely typed。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这也使得所需的完全类型代码库的所有更改变得明确。因此，你可以查看你的项目，知道有30%的文件处于严格模式，70%处于默认模式，并了解如何才能实现完全类型的项目。在Facebook和Instagram，我们已经将几个大型项目从几乎没有类型转换为几乎或完全有类型。
- en: and in doing this， we found that some approaches are more effective than others。
    So the first thing that you'll want to do is get your teams and your engineers
    on board。 and this involves explaining the benefits of a typed code base。 So maybe
    you could start with its built-in up-to-date documentation。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们发现某些方法比其他方法更有效。因此，你首先要做的是让你的团队和工程师们参与进来，这需要解释一个有类型的代码库的好处。所以，也许你可以从它内置的最新文档开始。
- en: You'll have less errors reach production。 The list goes on。 And the second part
    is to set and communicate type goals clearly。 So we found that goals like we're
    going to type all of our Python projects。 We didn't really have much success with，
    but if we said 50% of our functions are going to have a return annotation by May
    15th。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 生产中出现的错误会减少。后续还有更多好处。第二部分是设定并清晰沟通类型目标。因此，我们发现像“我们要为所有Python项目添加类型”这样的目标并没有取得太大成功，但如果我们说“到5月15日，我们将有50%的函数添加返回注释”，效果就会好得多。
- en: we were much more successful with those。 So setting clear goals that are actionable
    and time-based are essential。 The second thing that we did was recognize contributions。
    So we actually have a dashboard that tracks individual contributions to type coverage。
    and it's been a good way to introduce a little bit of competition between engineers
    or between teams。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这方面取得了更多成功。因此，设定明确、可操作且有时间限制的目标是至关重要的。我们做的第二件事是认可贡献。因此，我们实际上有一个仪表板来跟踪个人对类型覆盖率的贡献，这在工程师之间或团队之间引入了一些竞争意识，效果不错。
- en: and it resulted in more types in our code base。 We also ran what we called code
    love days。 where we set aside time for engineers to add types to our code base。
    and in exchange we gave them Boba。 We also discovered that the Pyre team can be
    motivated with really anything involving Pokemon。 So find what works for your
    team and then use it。 As well。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致我们代码库中的类型更多。我们还进行了所谓的“代码爱日”，在这一天我们为工程师腾出时间，鼓励他们为我们的代码库添加类型，作为交换，我们给他们提供了波霸饮料。我们还发现，Pyre团队可以通过任何与宝可梦相关的内容来激励。因此，找出对你的团队有效的方法，并加以利用。
- en: we onboard new engineers with typing tasks。 Almost every engineer I've met at
    Facebook has done a typing task in their first few weeks at the company。 They
    range from removing a type ignore or switching a file to strict mode。 They're
    a really good way to get to know your way around a code base。 and we've also had
    a lot of success with them。 I've mentioned that setting goals for type coverage
    is a key part of successfully typing a code base。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过类型任务来引导新工程师。几乎每个我在Facebook见到的工程师在入职的头几周都完成过一次类型任务。这些任务的内容包括移除类型忽略或将文件切换到严格模式。这是一种非常好的方式，让你熟悉代码库，我们也取得了很多成功。我提到设定类型覆盖率目标是成功为代码库添加类型的关键部分。
- en: and we have some recommendations for the order in which you tackle this。 The
    first thing that you'll want to go on is reducing the number of functions without
    return annotations。 and this often comes at the expense of adding type ignore
    comments to your code at first。 but this is okay。 It can be accomplished two ways。
    One。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对解决此问题的顺序有一些建议。你首先想要做的是减少没有返回注释的函数数量，这往往会在一开始以添加类型忽略注释到代码为代价，但这没关系。可以通过两种方式实现。一种是。
- en: you add a bunch of return annotations to your code， or two， you delete a bunch
    of unannotated code。 both will reduce the number of unannotated functions in your
    project。 As you continue to increase type coverage， you'll want to then focus
    on strictifying as many files as possible。 And as this continues to improve， you'll
    then want to set a goal to flip the default to strict。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向代码添加一堆返回注释，或者删除一堆未注释的代码。两者都会减少项目中未注释的函数数量。随着你继续增加类型覆盖率，你会希望尽可能严格化尽可能多的文件。随着这一进程的不断改进，你会希望设定一个目标，将默认模式切换为严格模式。
- en: As you move closer to a fully typed code base， then you'll want to start setting
    goals on driving down the number of ignores in your code。 And then finally， moving
    annotations or sources of any in your code。 So once you've set these goals。 you'll
    also want to measure your progress。 And when working with teams to add type coverage
    to their projects。 feedback we got is that it's difficult to push for type adoption
    without metrics。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你接近一个完全类型化的代码库时，你会想开始设定目标，减少代码中类型忽略的数量。最后，移动代码中的任何注释或来源。因此，一旦你设定了这些目标，你还想衡量你的进展。在与团队合作为他们的项目增加类型覆盖时，我们收到的反馈是，没有指标很难推动类型采用。
- en: So if you pip install PyreCheck， you can then run Pyre Statistics。 And this
    will give you information about how many return annotations， parameter annotations。
    attribute annotations， global annotations you have in your code。 And it will also
    tell you how many files are in default versus strict mode。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 pip 安装 PyreCheck，你可以运行 Pyre Statistics。这将给你提供关于代码中有多少返回注释、参数注释、属性注释和全局注释的信息。它还会告诉你有多少文件处于默认模式与严格模式。
- en: and how many type ignores in your project。 So we actually run this nightly at
    Facebook。 and we log the data so that we can continuously track type coverage
    over time in our projects。 And we can compare our goals， say if we wanted 50%
    of our functions to have a return annotation。 we can then see if we're on track
    to meet it， if we're ahead or behind a schedule。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以及你项目中有多少类型忽略。因此，我们实际上在 Facebook 每晚运行这个，并记录数据，以便我们能够持续跟踪项目中的类型覆盖率。我们可以比较我们的目标，比如说如果我们希望
    50% 的函数具有返回注释，我们就可以看到自己是否在轨道上，是否领先或落后于计划。
- en: We also use the output of Pyre Statistics for other things。 So since it tells
    us which files are in default mode。 we can use it to auto generate tasks to flip
    files in district mode。 We can also do the same thing for removing type ignores。
    I would be lying if I said that every type annotation in a Python project at Facebook
    or Instagram was manually added by an engineer。 We've also leveraged a few tools
    that will automatically apply types to our projects for us。 So Pyre Infer is one
    of those， and it comes when you just install Pyre Check。 It uses static type analysis
    to infer types in your project。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 Pyre Statistics 的输出进行其他工作。所以它告诉我们哪些文件处于默认模式，我们可以利用它自动生成任务，将文件切换到区域模式。我们也可以对删除类型忽略做同样的事情。如果我说
    Facebook 或 Instagram 的 Python 项目中的每个类型注释都是工程师手动添加的，那我就是在撒谎。我们还利用了一些工具，可以自动为我们的项目应用类型。因此，Pyre
    Infer 就是其中之一，它在你安装 Pyre Check 时就会附带。它使用静态类型分析来推断你项目中的类型。
- en: and then automatically apply them to your code。 And we actually have a script
    that will run this daily on our Python projects on just one or two files and generate
    a small。 easy to review pull request。 And it's a really great way to continuously
    move the needle on type coverage with minimal effort。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后自动将它们应用到你的代码中。实际上，我们有一个脚本，每天在我们的 Python 项目上对一到两个文件运行它，并生成一个小而易于审阅的拉取请求。这是以最小的努力持续推动类型覆盖的一个很好的方法。
- en: We've also used monkey tape， which adds types based on what the value was at
    the runtime。 So you can run monkey tape on your tests or runtime sampling。 and
    then it will take those types and apply them back to your code。 PyAnitate is another
    open source tool that you can use。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了 monkey tape，它根据运行时的值添加类型。所以你可以在测试或运行时采样上运行 monkey tape，然后它会将这些类型应用回你的代码。PyAnitate
    是另一个可以使用的开源工具。
- en: and it inserts annotations into your code based on call arguments and return
    types observed at runtime。 We've made a lot of progress typing our project Facebook，
    and it Instagram。 But like Python itself。 types in Python are continually evolving，
    and there are several pups being written and proposals being made about how to
    make types easier to read and make Python code easier to type。 There's a few code
    patterns that we've noticed cause friction when typing projects。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它会根据运行时观察到的调用参数和返回类型将注释插入到你的代码中。我们在Facebook项目的类型注释上取得了很大进展，以及在Instagram。但和Python本身一样，Python中的类型也在不断演变，正在撰写多个pup，并提出如何使类型更易读、使Python代码更易于类型注释的提案。我们注意到一些代码模式在项目中打字时会造成摩擦。
- en: and you might encounter these two as you get started in your own work。 So empty
    containers can be a source of implicit any's。 So this is implicitly typed as list
    any。 and the solution is just to always add a type annotation when you initialize
    an empty container。 And some Python type checkers will actually error if you try
    and initialize without that annotation。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始自己的工作时，可能会遇到这两种情况。因此，空容器可以是隐式`any`的来源。所以这隐式地被类型为列表`any`。解决方案是在初始化空容器时始终添加类型注释。如果你试图在没有注释的情况下进行初始化，一些Python类型检查器实际上会报错。
- en: Refining optional attributes can also pose a challenge。 So here we can't blindly
    infer that the type of attribute is not optional after the check。 since any interleaving
    column is at the attribute to none。 So the solution would be to assign your attribute
    to a local variable and then do the check。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 提炼可选属性也可能带来挑战。因此在这里，我们不能盲目推断属性的类型在检查后不是可选的，因为任何交错列都将属性设置为`none`。解决方案是将你的属性分配给一个局部变量，然后进行检查。
- en: However， this is a little bit verbose。 So in Python 3。9。 you can use the walrus
    operator to help make this check a lot simpler。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这有点冗长。因此在Python 3.9中，你可以使用海象运算符来简化这个检查。
- en: '![](img/59751e99a12551c7e1d463fed8463a4b_20.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59751e99a12551c7e1d463fed8463a4b_20.png)'
- en: It's common to pass around dictionaries of data with an unclear structure in
    Python。 But often JSON types are self-referencing， which isn't currently supported
    with types in Python。 And Django endpoint responses can be huge dictionaries with
    a variety of types as the value。 And this is harder than a standard type dictionary
    because any number of these values can be optional。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，传递结构不清楚的数据字典是很常见的。但通常JSON类型是自引用的，这在Python中的类型目前不受支持。Django端点响应可能是包含多种类型值的大字典。这比标准类型字典更难，因为这些值中的任意数量都可以是可选的。
- en: '![](img/59751e99a12551c7e1d463fed8463a4b_22.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59751e99a12551c7e1d463fed8463a4b_22.png)'
- en: So as a result， this is an exception to the rule that any's are not allowed
    in strict mode。 So even though dict string， any contains an explicit any， it's
    a valid annotation in strict mode。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，结果是这是一个不允许在严格模式下使用`any`的规则的例外。因此，即使`dict string`中的`any`包含一个显式的`any`，在严格模式下它也是一个有效的注释。
- en: '![](img/59751e99a12551c7e1d463fed8463a4b_24.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59751e99a12551c7e1d463fed8463a4b_24.png)'
- en: As I said earlier， types in Python are continually evolving。 There are currently
    a few proposals about how to simplify types in text and make annotations less
    verbose and easier to read。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，Python中的类型不断演变。目前有一些提案旨在简化文本中的类型，使注释不那么冗长、更易读。
- en: '![](img/59751e99a12551c7e1d463fed8463a4b_26.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59751e99a12551c7e1d463fed8463a4b_26.png)'
- en: One of these is new syntax for union types。 Instead of having the import from
    typing。 you can just use the pipe operator。 And this will be available in Python
    3。10。 There is also a proposal in a similar vein to improve this syntax for optional
    types。 This one is still in the early stages and there's no guarantee that it
    will make it into the language。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一是新的联合类型语法。你可以直接使用管道运算符，而不必从`typing`导入。这将在Python 3.10中可用。还有一个类似的提案，旨在改进可选类型的语法。这个提案仍处于早期阶段，不能保证会纳入语言中。
- en: But it's a good example of some of the work that's currently being done to improve
    types in Python。 There are also proposals about new syntax for callables and new
    features or keywords for type dictionaries。 There's a lot of work being done to
    continually approve types in Python。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是一个目前正在进行的一些工作以改善Python中类型的好例子。还有一些关于可调用对象的新语法和类型字典的新特性或关键字的提案。为了不断改进Python中的类型，正在进行大量工作。
- en: '![](img/59751e99a12551c7e1d463fed8463a4b_28.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59751e99a12551c7e1d463fed8463a4b_28.png)'
- en: So before we wrap up， let's recap some of the things we learned about gradual
    typing in practice。 So gradual types can act as up-to-date documentation and reduce
    the amount of type errors that reach production。 In order to type your project，
    you'll first want to get your teams on board and set clear time-based goals。 As
    you get started， type your most used modules first and make sure that you measure
    your progress。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束之前，让我们回顾一下我们在实践中学到的渐进类型的一些内容。因此，渐进类型可以作为最新的文档，并减少进入生产环境的类型错误数量。为了给你的项目添加类型，首先要让你的团队达成一致，并设定明确的时间目标。在开始时，优先给你使用最多的模块添加类型，并确保你能衡量进展。
- en: If you're interested in learning more about types in Python， specifically at
    Facebook。 several Facebook engineers have done talks about typed Python。 So Carl
    did type-checked Python。 Peter has done types， deeper static analysis in you。
    And Shannon did leveraging the type system to write secure applications。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对学习更多关于Python中的类型感兴趣，特别是在Facebook，几位Facebook工程师已经做了关于类型化Python的演讲。所以卡尔做了类型检查的Python，彼得进行了类型的深入静态分析，香农则利用类型系统编写安全应用程序。
- en: I look forward to answering some of your questions。 Thanks。 [BLANK_AUDIO]， [BLANK_AUDIO]。
    [BLANK_AUDIO]， [BLANK_AUDIO]， [BLANK_AUDIO]， [BLANK_AUDIO]。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我期待回答你们的一些问题。谢谢。[BLANK_AUDIO]，[BLANK_AUDIO]。[BLANK_AUDIO]，[BLANK_AUDIO]，[BLANK_AUDIO]，[BLANK_AUDIO]。
- en: '![](img/59751e99a12551c7e1d463fed8463a4b_30.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59751e99a12551c7e1d463fed8463a4b_30.png)'
