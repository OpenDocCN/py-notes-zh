- en: P17：TUTORIAL _ Bernát Gabor _ Python Packaging Demystified - VikingDen7 - BV19Q4y197HM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P17：教程 _ Bernát Gabor _ Python 包装揭秘 - VikingDen7 - BV19Q4y197HM
- en: So yeah， hi everyone。 I'm Bernard Gabour， and I'll be hosting this tutorial
    today about。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，大家好。我是 Bernard Gabour，今天将主办这次教程。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_1.png)'
- en: the Python packaging ecosystem。 And I want to get out from the start out of
    the way that。 the structure of this tutorial is going to be focused on trying
    to present how the Python。 packaging ecosystem is built up。 It's not going to
    be necessarily how to use set up。 tools or how to use fill it some of the things
    we'll see later on。 If you want interested。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python 包装生态系统。我想一开始就澄清，这个教程的结构将专注于如何展示 Python 包装生态系统是如何构建的。它并不一定是如何设置工具或如何使用一些我们稍后会看到的东西。如果你感兴趣。
- en: on how to use a specific tool in detail， you're probably better off just reading
    up their。 documentation and their tutorial section。 This tutorial aims more like
    to give you the big。 picture and how the various pieces fit together。 Okay， that
    being said， we're going to look。 into some of these specific components and we'll
    try to use them for a smaller example。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何详细使用特定工具的部分，你可能更适合直接阅读他们的文档和教程部分。这个教程更像是给你一个大局观，以及各个部分是如何结合在一起的。好的，说到这里，我们将看一些具体的组件，并尝试在一个小例子中使用它们。
- en: but generally we're not going to be aiming to just do everything。 Okay。 So that
    being。 out of the way。 So the slides will be available on that link on the slide
    you can see。 You can。 just look it up and download them for later use。 But the
    way this presentation will be， structured。 the slides are going to be kind of
    like a helper's where as I'm going to present。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但一般来说，我们不会只是做所有事情。好的，既然这一点说清楚了，幻灯片会在你可以看到的那个链接上提供。你可以查找并下载它们以供后用。但本次演示的结构是，幻灯片会充当助手，而我会进行演示。
- en: various components， I'm going to demonstrate them live inside the terminal just
    so you。 can see more how it would look like in action rather than statically on
    a slide。 What I'm。 going to be doing this， I encourage you to follow along。 This
    is also for generally people。 tend to understand better if they type them out
    themselves， learning them themselves rather。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 各种组件，我将实时在终端演示这些内容，这样你就可以看到它们在实际操作中的样子，而不是静态地在幻灯片上。我要做这个时，我鼓励你跟着一起操作。通常人们自己输入时理解会更好，自己学习会更有效。
- en: than seeing， but otherwise it's up to you。 I plan to have two to three sections
    and we're。 going to do smaller sections， we're going to do an actual hand sound
    tutorial where I'm。 going to ask you to try to do something。 But those are going
    to be a bit later because。 first we have to kind of understand how to on what
    we're building on。 So probably in the。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 比起观看，其它的就看你了。我计划有两个到三个部分，我们将做一些较小的部分，进行实际的手把手教程，我会请你尝试做一些事情。但这些会稍后进行，因为我们首先需要理解我们正在构建的基础内容。因此，可能在。
- en: first 45 minutes or so I'm going to more like try to give you a picture of the
    basic building。 blocks。 So where am I？ I'm a software engineer at Bloomberg。 I
    work in a team called Data。 Technologies Quality Control and I mainly focus on
    the data ingestion at the company。 and within that also mainly on how we can ensure
    that the data that we collect is of。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 前 45 分钟左右，我将更多地试图给你们展示基本构建块的全貌。那么我在哪里呢？我是彭博社的软件工程师。我在一个叫做数据技术质量控制的团队工作，主要专注于公司的数据摄取，尤其是如何确保我们收集的数据是高质量的。
- en: a good quality， doesn't have outliers as well as the mice properties。 So other
    than that。 I'm also an open source contributor。 There you can see my GitHub account
    or my blog on， there。 You can find exactly what I do， but for the purpose of this，
    it's more important。 than I'm also a member of the Python packaging authority，
    which in practice just means that。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的质量，不含离群值以及较小的属性。除此之外，我还是一个开源贡献者。你可以在这里看到我的 GitHub 账号或我的博客。你可以确切找到我在做什么，但出于本次演示的目的，更重要的是，我还是
    Python 包装权威的成员，这在实践中意味着。
- en: I maintain projects which are part of the Python packaging core ecosystem。 So
    I tend to give。 my opinion and use the community and interact with the community
    if you come up with how。 the Python packaging ecosystem should work and how we
    can make it better。 Okay。 And beside， this。 I'm also the parent of two Rocha carriers，
    you can engineer， you'll be able to see them， here。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我维护的是Python打包核心生态系统的一部分项目。所以我倾向于发表我的意见，并与社区互动，讨论Python打包生态系统应该如何运作以及我们如何能使其更好。好的，除此之外，我还是两个Rocha携带者的家长，你可以看到他们在这里。
- en: And because the topic itself can tend to be a bit dry， I'll you'll see that
    I have。 spread throughout this presentation a few pictures themselves just to
    get a bit of relief and。 something more acute than myself throughout this presentation
    you can see。 Okay。 So just。 to give you an idea， these are the kind of like the
    projects I maintain。 Some of these， projects。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 而且因为这个主题本身可能会有些枯燥，你会看到我在整个演示中散布了一些图片，以便稍微缓解一下，并且提供一些比我更生动的内容。在这个演示中你可以看到。好的。因此，给你一个概念，这些就是我维护的项目。某些项目。
- en: some also the main author， the ones which I am actually put it with a star。
    And， yeah。 let's start then。 Let's dive into it。 Okay。 So the first question or
    the main topic。 we're going to try to understand today is how we distribute code
    within the Python ecosystem。 Okay。 And generally， I think it's agreed and that's
    one of the reason Python is so popular。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一些也是主要作者，我实际上把它们标记为星号。是的，让我们开始吧。让我们深入探讨一下。好的。那么我们今天要尝试理解的第一个问题或主题是我们如何在Python生态系统中分发代码。好的。一般来说，我认为这是达成一致的，这也是Python如此受欢迎的原因之一。
- en: that the Python code is easy to read and write。 However， just as much as this
    tends to be the。 feedback from within the community， the feedback also is that
    shipping and running that core。 is me to other machines is not。 And this is what
    I try to help you with today。 I want。 you to be a bit more hopeful and a bit happier
    and a bit more confident never really try to。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码易于阅读和编写。然而，正如社区内的反馈所示，运输和在其他机器上运行这个核心并不容易。这就是我今天想要帮助你的地方。我希望你能够更加乐观、更加快乐、更加自信，永远不要真正尝试。
- en: do packaging and not show the face of this part on this picture。 Okay。 Whenever
    you have。 a Python packaging， I'm not going to promise you that the Python package
    ecosystem is great。 but I'm going to give you the basic know how to understand
    where and how and how things。 should work so you can you know when something breaks
    where to reach and what could be the， issue。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 打包而不展示这个部分的面貌。好的。每当你有一个Python打包时，我不会向你保证Python包生态系统是伟大的。但我会给你基本的知识，让你了解事物应该如何运作，以便你知道当出现问题时该去哪里，可能是什么问题。
- en: Okay。 So the first thing we need to understand is what is the state of the packaging，
    today。 So I'm going to focus today mainly from the Python packages and go to this
    point of， view。 This is means that we're going to be focusing from a point of
    view， how can we ship。 Python code independent of the platform now every platform
    every operating system has。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。因此，我们需要了解的第一件事是今天打包的状态。所以我今天主要会从Python包的角度来关注这个问题。这意味着我们将从一个角度来看，我们如何能够独立于平台来发布Python代码，现在每个平台、每个操作系统都有。
- en: its own packaging ecosystem， which might be a bit more appropriate or less appropriate。
    to do anything on your context。 But this is not the type of ecosystems we're going
    to， cover today。 meaning we're not going to be covering your operating system
    packaging manager or。 we're not going to be covering Konda。 Okay。 So in order
    to be able to actually have tried。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它自己的打包生态系统，这可能在你的上下文中更合适或不太合适。但这不是我们今天要讨论的生态系统。这意味着我们不会涵盖你的操作系统打包管理器，也不会涵盖Konda。好的。因此，为了能够实际尝试。
- en: to do this packaging， we need a demo problem， something that we can use to demonstrate
    the。 packaging story and the demo problem we're going to be using today is going
    to be calculating， pi。 Pi is the ratio of the circle some circumference to its
    diameter。 And one of the easiest way。 you can calculate pi is using the Gregley
    lightning series。 This series basically built。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行这个打包，我们需要一个演示问题，某种我们可以用来演示打包故事的问题，而我们今天将使用的演示问题将是计算π。π是圆的周长与直径的比率。计算π的最简单方法之一是使用Gregley光线系列。这一系列基本上是建立在。
- en: on this infinite sum。 And it says that the peak and the calculated sum of all
    the this。 series basically every second sum in this series is positive every second
    one is negative。 And if you add up this division infinite series and you multiply
    it by four， you're going to。 end up with the number P itself。 Okay。 It's not the
    fastest， but this is one of the simplest。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个无限求和中。它表示峰值和计算的所有这个序列的总和，基本上这个序列中的每第二个和是正的，每第二个是负的。如果你将这个除法无限序列相加，并将其乘以四，你将得到π本身。好的。这不是最快的，但这是最简单的之一。
- en: way to calculate pi and require around 300 iteration just to get the first two
    per the。 similar precision correct。 Okay。 Now here I show you a simple case how
    this actually， might be。 For example， here you can see that the it is the simple
    implementation of it。 For example。 you can see I just see the sign operator， which
    I switch every odd time， every， other time。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 计算π的方式需要大约300次迭代才能达到前两位的类似精度。好的。现在我给你展示一个简单的案例，这实际上可能是这样的。例如，这里你可以看到它的简单实现。例如，你可以看到我使用了符号运算符，我每隔一次切换。
- en: And then I just summit up by doing that division。 And in the end， I just multiply，
    it by four。 Okay。 We can quickly actually try this code to actually see that it
    works。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我通过进行那次除法来总结。在最后，我将其乘以四。好的。我们可以快速尝试这段代码，看看它是否有效。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_3.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_3.png)'
- en: And I'm just going to quickly do that。 So let me open up here， editor and try
    to actually。 wrangle this into the screen。 Let me resize it。 Okay。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我将快速完成这个。让我在这里打开编辑器，尝试将其整合到屏幕上。让我调整一下大小。好的。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_5.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_5.png)'
- en: So if I put this in， yeah， just heads up。 Is that big enough for everyone？ And
    if you。 have any questions or the answer to that is no， feel free to unmute yourself
    and speak， up。 Okay。 So yeah， so this is like the simple code as you can see what
    we have here。 We also。 do some import but basically we have this function which
    takes the number of iteration。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我把这个放进来，是的，提醒一下。对每个人来说足够大了吗？如果你有任何问题，或者答案是否定的，随时可以解除静音并说出来。好的。所以，是的，这就是我们所拥有的简单代码。我们也做了一些导入，但基本上我们有这个函数，它接受迭代次数。
- en: and returns pi itself。 And inside this main section as we basically just going
    to be calculating。 the 300 and 300， 30 iteration of it and then just print it
    out。 Okay。 So if I do like Python。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 并返回π本身。在这个主要部分中，我们基本上将计算300和300，30次迭代，然后将其打印出来。好的。如果我输入像Python这样的命令。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_7.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_7.png)'
- en: yeah， approximate that pi， you can see it actually prints that information。
    Now。 one more thing I have to like get out generally on the windows operating
    system。 the way you would start Python is by using the pi executable if you are
    in between a terminal。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，近似计算π，你可以看到它实际上打印出这些信息。现在，还有一件事我必须一般性地在Windows操作系统上讲一下。启动Python的方式是使用pi可执行文件，如果你在终端之间。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_9.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_9.png)'
- en: Okay。 Now you can also use your editor to run it。 But for the scope of this
    plantation。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在你也可以使用编辑器来运行它。但在这个演示的范围内。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_11.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_11.png)'
- en: I use the terminal and you have the pi executable which you can use to run something。
    And this is。 basically kind of like an entry point which allows you to pick and
    choose your own Python。 interpreter when you want to， which one you want to run
    the code with it。 If I just pi。 you can see my default interpreter is Python 3。965。
    If I type something here like pi， be a small pi。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用终端，你有pi可执行文件，可以用来运行一些东西。这基本上是一个入口点，允许你选择自己的Python解释器，以及你想用哪个运行代码。如果我输入pi，你可以看到我的默认解释器是Python
    3.965。如果我在这里输入像pi这样的东西。
- en: this actually going to run with Python 3。9。 But I can do other patterns if I
    want。 So for example。 if I do here 3。6， then I can run it with 3。6。 Now。 how this
    would be different on Linux operating system is usually you have something like
    3。9。 And then you call that on the new windows。 I don't even have this available，
    but that's how you。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上将使用Python 3.9运行。但如果我想，我可以做其他模式。所以例如，如果我在这里输入3.6，我就可以用3.6来运行它。现在，在Linux操作系统上，这将有所不同，通常你有像3.9这样的东西，然后在新的Windows上调用它。我甚至没有这个可用，但就是这样。
- en: would do it。 And if you actually like this pi entry point。 you can actually
    get used that on windows。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 会这样做。如果你真的喜欢这个 pi 入口点，你实际上可以在 Windows 上习惯使用它。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_13.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_13.png)'
- en: too。 You want to just look into the Python launcher and install that one。 And
    I'm going to。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你也想查看 Python 启动器并安装那个。然后我会。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_15.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_15.png)'
- en: put like， so we're asking for a presentation。 So I'll just go here。 Yeah， this
    one。 So there is。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 放在这里，所以我们在要求一个演示。我就去这里。是的，这个。所以这里有。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_17.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_17.png)'
- en: this project by Brett Cannon who is one of the Python sharing console members。
    And if you use this。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目是由 Brett Cannon 开发的，他是 Python 分享控制台的成员。如果你使用这个。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_19.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_19.png)'
- en: one， you're basically going to get this pi executable， not just on windows，
    but also on。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你基本上会得到这个 pi 可执行文件，不仅在 Windows 上，也在。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_21.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_21.png)'
- en: Linux operating systems， such as my questions。 Oh， okay。 So that's why whenever
    I type pi， -3。6 just on Unix type Python 3。6 or similar。 Okay， now this obviously
    means that you need to have。 that version of the interpreter installed on the
    operating system。 But for the point of this。 demonstration， more often than not，
    I'll just stick with 3。9。 So all you have 3。9 should be。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 像我的问题那样的 Linux 操作系统。哦，好的。所以每当我输入 pi，-3.6 时，实际上是在 Unix 上输入 Python 3.6 或类似的版本。好的，现在显然这意味着你需要在操作系统上安装该版本的解释器。但就这个演示而言，我通常会坚持使用
    3.9。所以你有 3.9 就应该可以。
- en: suffice to for you to follow along。 Okay。 So another way I can actually use
    this code that we just。 written here is I can actually start the interpreter。
    And I can also import it。 You can see I can。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你跟随来说是足够的。好的。我可以用这段我们刚刚写的代码的另一个方式是启动解释器。我也可以导入它。你可以看到我可以。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_23.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_23.png)'
- en: what will it be approximate and can be a ROC-made P here。 And then I can call
    this inside the replo。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 它将大约是什么，可以是 ROC 制作的 P。在这里我可以在 replo 中调用它。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_25.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_25.png)'
- en: as that。 Okay。 Sorry， Lisa， which part of it？ Would you like to make it bigger？
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。好的。抱歉，丽莎，你想让哪个部分更大？
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_27.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_27.png)'
- en: Is it the resource studio one or the？ -。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 是资源工作室的那个吗？
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_29.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_29.png)'
- en: Better？ Okay。 So as you can see here， I can also run this code。 And I run this
    code also from the interpreter itself， the replo， rather than just running it
    from。 the console itself。 Okay。 So I'll just answer that question。 As far as developing
    this on Conda。 the lift is going to be kind of similar as， for example， using
    setup。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 更好吗？好的。所以如你所见，我也可以运行这段代码。我也可以直接从解释器本身运行这段代码，而不是仅仅从控制台运行。好的。那我就回答这个问题。至于在 Conda
    上开发，这个过程会和使用 setup 类似。
- en: the restore plate or something like that。 The core concept of Python works will
    not， change。 You got Conda users the same principles。 So you're going to be able
    to migrate most of it。 over one to one。 But obviously， for example， Conda uses
    a different packaging logic， a different。 packaging configuration。 But the core
    of it is similar。 It just might have nuanced to it。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 还原平台或类似的东西。Python 的核心概念不会改变。你有 Conda 用户遵循相同的原则。所以你将能够大部分一对一地迁移。但显然，例如，Conda
    使用不同的打包逻辑和配置。但核心是相似的。只是可能会有细微的不同。
- en: So you're still going to be useful。 It's more just that you might not be able
    to replicate everything。 one to one。 Okay。 And we'll just to give you a bit of
    a interpreter。 So just so people understand。 better， some people might， the first
    question might have is what's the difference between Conda and。 Python as the
    Python software foundation maintains it。 And the main difference is， Yeah。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你仍然会很有用。只是你可能无法一对一地复制所有内容。好的。我们会给你一个解释器的概述。这样人们就能更好地理解。有些人可能会问，第一个问题是 Conda
    和 Python 之间的区别是什么。主要的区别是。
- en: I'll answer that。 The main difference between Conda and the Python interpreter，
    as we'll get it。 from the Python software foundation is that Conda aims， the Python
    software foundation aims to。 ship you the Python interpreter itself plus Python
    packages alongside it。 Now， some of the packages。 that you might be using， such
    as tensor for whatnot， might require other binary dependencies。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我来回答这个问题。Conda和Python解释器之间的主要区别在于，正如我们将从Python软件基金会获得的那样，Conda的目标是将Python解释器本身以及与之并行的Python包一起提供给你。现在，有些包，比如你可能会使用的tensor等，可能需要其他二进制依赖。
- en: And this， binary dependence can be， for example， the video card driver that
    then will drive the machine learning。 or whatnot。 And the Python packaging story
    does not address this you even do not try to ship。 binaries to we only focus on
    shipping the Python code itself。 Okay。 And this is the reason why。 Conda is a
    bit more generic， but it's a bit more heavyweight。 Conda can actually ship you
    other。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些二进制依赖可以是视频卡驱动程序，这将驱动机器学习，或者其他用途。Python打包的故事没有涉及这一点，甚至没有尝试去打包二进制文件。我们只专注于打包Python代码本身。好的。这就是原因，Conda稍微通用一些，但它也稍微复杂一些。Conda实际上可以提供其他。
- en: executable skill。 For example， it's possible with Conda to install like TIG
    itself or other。 binary applications。 The Python story will not address that one。
    Okay。 And this is just the case。 because within the machine learning science where
    Conda is very popular， it tends to be the case。 that you have to rely on a lot
    of binaries while generating the Python story that's less often the。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行技能。例如，使用Conda安装TIG本身或其他二进制应用程序是可能的。Python的故事不会涉及这个。好的。这种情况发生是因为在机器学习科学中，Conda非常流行，通常情况下，你需要依赖许多二进制文件，而生成Python的故事则不太常见。
- en: case。 Okay。 So， yeah， as a Jack pointed out， what we did here is we import from
    the P。 approximate module， the approximate pi function。 And one of the reasons
    why I didn't name them the。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。因此，正如Jack指出的那样，我们在这里做的是从P。approximate模块导入了approximate pi函数。我没有给它们命名的原因之一就是。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_31.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_31.png)'
- en: same is exactly to point out this difference。 Like here， you see the name of
    this file is pi。 approximate。 That is the name of the module。 Or the name of the
    function is approximate pi。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 完全是为了指出这个区别。在这里，你可以看到这个文件的名称是pi.approximate。这是模块的名称。或者函数的名称是approximate pi。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_33.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_33.png)'
- en: Okay。 So those are differences。 And those are going to be important。 And we
    will get to them。 just those differences。 And we'll just get to them in a second。
    Okay。 Let me just go back to my slide。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这些是区别。这些区别非常重要，我们会在稍后讨论这些区别。好的，让我回到我的幻灯片。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_35.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_35.png)'
- en: Okay。 So if I run this， everything works all right。 So back to the packaging
    story。 So how does one make this code available and running someone else， code
    as we just seen it？ Okay。 As you may have just seen it， there's two way to run
    a Python code， that we've written。 One of the way is more how would say someone
    who is a Python developer would do。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。如果我运行这个，一切正常。那么回到打包的故事。那么，如何使这段代码可用，并运行其他人的代码呢？好的。正如你可能刚刚看到的，有两种方法来运行我们编写的Python代码。一种方法是更像是Python开发者的做法。
- en: it is just start up an interpreter and start using imports and run the functions。
    This is what I call， the developer way of using that code that you've just written。
    Another of the way would be just running， it from the common line or within an
    idea or whatever。 when you just literally do say run this， module inside Python
    run this file in Python。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，只需启动一个解释器，开始使用导入并运行函数。这就是我所说的，开发者使用你刚刚编写的代码的方式。另一种方式是从命令行或IDE中运行，或者其他任何方式，当你真的可以直接运行这个模块或在Python中运行这个文件时。
- en: that is more like the end user way of using that code。 And within the packaging
    logic。 there's a difference between these two。 The first one， when。 you run this
    code as you would be a Python developer。 is called as the library way of using
    that code。 And the second way when you just virtually point that file to the Python
    interpreter and just run it。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这更像是最终用户使用这段代码的方式。在打包逻辑中，这两者之间有区别。当你作为Python开发者运行这段代码时，称为以库的方式使用这段代码。而第二种方式是你只是将这个文件虚拟指向Python解释器并直接运行它。
- en: that's the application way of running that file。 Okay。 Now。 there's some differences
    between these two。 In case of the library way。 the expectation is that we're going
    to expose the source that you just。 written within the Python interpreter， perhaps
    on another machine， perhaps on your own machine。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是应用程序运行该文件的方式。好的。现在，这两者之间存在一些差异。在库模式下，期望是我们将暴露你刚刚在 Python 解释器中编写的源代码，可能是在另一台机器上，可能是在你自己的机器上。
- en: And the user will be able to interact with various sub parts of the code and
    can decide itself。 what I want to run， what I don't want to run。 Well。 in case
    of the when you just run the entire file， as a whole。 then there's kind of like
    an implicit entry point defined。 And only one thing is going， to happen。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将能够与代码的各个子部分进行交互，并自行决定想要运行什么，不想运行什么。好吧。如果你运行整个文件作为一个整体，那么就会有一个隐式的入口点被定义。而且只会发生一件事情。
- en: For example， in this case， until I don't change the content of this file， it
    will always run。 this logic that I defined it here and nothing else。 Okay。 Now，
    these two have different。 needs and requirements。 And as we'll see， the packaging
    story is going to be different。 depending of would you like to ship this code
    to another machine to be used as a library or to be。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这种情况下，只要我不更改这个文件的内容，它将始终运行我在这里定义的逻辑，而不执行其他任何操作。好的。现在，这两者有不同的需求和要求。正如我们将看到的，打包的方式将有所不同，取决于你是否想将这段代码作为库发送到另一台机器使用，或者要。
- en: used as an application？ Okay。 So the first thing which is going to be like the
    application mode。 In。 case of the application mode， we don't expect the user to
    understand how Python works。 We don't。 expect them to do anything advanced。 We
    basically just want to ship them something and they're just。 going to run it。
    This is something I would not say as simple but always as simple as someone who。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 用作应用程序？好的。所以第一个将类似于应用程序模式的东西。在应用程序模式下，我们不期望用户理解 Python 是如何工作的。我们不期望他们做任何高级的事情。我们基本上只想给他们发一些东西，他们就会运行它。这我不会说简单，但总是简单得像某个人。
- en: never used Python should be able to do it。 Just install Python point-to-point
    interpreter to this。 file。 And it's going to print out and going to show whatever
    you want it。 It might print out in this， case or you might start to entire graphical
    user interface。 Okay。 In this case， the user needs a， Python interpreter。 You
    need to give them all the dependencies。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从未使用过 Python 的人也应该能做到这一点。只需将 Python 解释器安装到这个文件中，它就会输出并显示你想要的内容。在这种情况下，它可能会以这种形式输出，或者你可能会启动整个图形用户界面。好的。在这种情况下，用户需要一个
    Python 解释器。你需要给他们提供所有的依赖项。
- en: Here you may ping to exact versions， just to make sure that the user is running
    the same dependencies as you're running with。 the code may be obfuscated because
    as you said beforehand， it really doesn't matter what is。 the content of the file。
    It just needs to do what is defined inside the code。 No one's going to。 bat an
    eye。 For example， if you rename this approximate pi method to x。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以精确地确认版本，以确保用户与您正在运行的依赖项一致。代码可能会被混淆，因为正如你之前所说的，这并不重要。文件的内容只需要按照代码中的定义来执行。没有人会对此表示关注。例如，如果你将这个近似的
    pi 方法重命名为 x。
- en: it's going to work just as far， from a common line interface point of view。
    Okay。 From an application point of view。 The only kind， of requirement is that
    you must define up front an entry point and this is the entry point Python。 going
    to run once the user starts to run that file。 Okay。 So in case of the library
    mode， things。 are a bit different。 When you want to share a bit of Python code
    as a library， generally the。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行界面的角度来看，它将正常工作。好的。从应用程序的角度来看，唯一的要求是你必须事先定义一个入口点，这是用户开始运行该文件时 Python 将运行的入口点。好的。在库模式下，情况有点不同。当你想将一段
    Python 代码作为库共享时，一般。
- en: tradition is that the other machine will have a Python interpreter will be able
    to pick its own。 dependencies。 For example， it might want to use in parallel other
    libraries， other packages。 So you need to make sure you're much more freely less
    restrictive with your dependencies。 because you want to make sure that two packages
    which use the same library can coexist at the same。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，其他机器上会有一个 Python 解释器，它能够选择自己的依赖项。例如，它可能希望并行使用其他库或其他包。因此，你需要确保你的依赖项设置得更为宽松，因为你想确保两个使用相同库的包可以在同一时刻共存。
- en: time。 And then you want to just shift them the code。 But here， importantly，
    it's important that。 you shift the code at it is written， because the user might
    access all the doc strings， all the。 functions， all the variables， everything
    from the Python file as they are。 And they can do this。 by using the imported
    system。 Generally， standard recommended naming convention is in a single entry。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你只想转换代码。但这里重要的是，你必须按照编写的方式转换代码，因为用户可能会访问所有文档字符串、所有函数、所有变量，一切都来自 Python 文件。用户可以通过使用导入系统来做到这一点。通常，标准推荐的命名约定是在一个入口点。
- en: point。 When we go later in the second part of this tutorial into how you package
    a Python application。 you'll see that generally there is a way。 But within a file
    point of view， generally， you put your。 entry point， single entry point within
    this main section here。 But we'll see later on。 you there's also a concept that
    generally entry points which can be run or also put inside the main。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们稍后在本教程的第二部分讨论如何打包一个 Python 应用程序时，你会看到通常有一个方法。但从文件的角度来看，通常你会将你的入口点放在这个主部分内。但我们稍后会看到，还有一个概念是通常可以运行的入口点，也可以放在主函数内部。
- en: Python。 But as I said， we'll see this later on more in detail。 Okay。 So first，
    we'll go with the。 library packaging。 And this is also work so that the library
    packaging is， let's say。 the more complicated。 Once we know， understand this one。
    the application is going to be a bit easier。 Okay。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Python。但正如我所说的，我们稍后会更详细地讨论这个。好的。所以首先，我们来谈谈库的打包。这也是一项工作，所以库的打包可以说是更复杂的。一旦我们理解了这个，应用程序会变得容易一些。好的。
- en: So the first thing that we need to like start out with it， what is a library？
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要明确的是什么是库？
- en: Library is a code that that can be imported and executed from within a Python
    interpreter。 Okay。 So the expectation is that you're going to have a Python interpreter。
    and you'll be able to import some code from this library and executed。 The first
    thing that we need。 to clarify is what is a Python interpreter to understand this
    a bit better。 And you'll be able。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 库是可以从 Python 解释器中导入并执行的代码。好的。因此，期望是你会有一个 Python 解释器，并且你能够从这个库中导入一些代码并执行。我们需要澄清的第一件事是，什么是
    Python 解释器，以便更好地理解这一点。你将能够。
- en: to see that there are multiple types of Python interpreters。 Usually what when
    people think。 when you say Python interpreter， what the people think about is
    the global or the system Python。 interpreter。 This is the one that you get as
    installed by operating system package manager。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到有多种类型的 Python 解释器。通常，当人们提到 Python 解释器时，大家想到的就是全局或系统 Python 解释器。这是通过操作系统包管理器安装的那个。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_37.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_37.png)'
- en: For example， in this case， when I do type in in pi， and I can just like do like
    see the executable。 You see， this is a system interpreter。 You can see that this
    installation location is somewhere on my。 operating system package locations。
    So inside the Linux， assuming you don't have any other。 virtual environments activated，
    we'll see a bit later what they are。 If you type in Python 3。9。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这种情况下，当我在命令行中输入时，我可以看到可执行文件。你看，这就是系统解释器。你可以看到这个安装位置在我的操作系统包位置的某个地方。因此，在
    Linux 系统中，假设你没有激活其他虚拟环境，我们稍后会看到它们。如果你输入 Python 3.9。
- en: this is what would be the system interpreter， what you would get normally。 Okay。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是通常会得到的系统解释器。好的。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_39.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_39.png)'
- en: But obviously there are other types of interpreters and the main type of other
    types of interpreters。 are virtual environments。 And virtual environments are
    basically a way to use the Python system。 interpreter， but easily from its library
    dependencies， from its other installations。 Okay。 And there are two ways to create
    virtual environment。 Well， there are multiple ways， but for， now。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，还有其他类型的解释器，主要的其他类型解释器是虚拟环境。虚拟环境基本上是一种使用 Python 系统解释器的方法，但可以轻松管理其库依赖关系和其他安装。好的，创建虚拟环境有两种方法。好吧，还有多种方法，但就现在而言。
- en: there are two main ways how you can create a virtual environment。 One of them
    is the VM。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 创建虚拟环境的主要方法有两种，其中一种是虚拟机。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_41.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_41.png)'
- en: module。 So if I do something like Python， the shm VM， and I do like and this
    environment that's。 going to be created is a virtual environment， and this virtual
    environment will not have the system。 Python packages available within it。 So
    what it means， if I do like find the shm people list。 you'll see that this is
    what my list system Python contains。 Okay。 But if I do。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 模块。所以如果我执行类似 Python 的命令，shm VM，并且这样做，那么创建的环境是一个虚拟环境，而这个虚拟环境将没有系统的 Python 包可用。所以这意味着，如果我执行类似查找
    shm 包列表的命令，你会看到这是我的列表系统 Python 包包含的内容。好的。但如果我执行。
- en: call the Python from within this Python interpreter， you'll see that in this
    environment。 I only have people and set up tools。 I don't have all， these operating
    system packages。 So in a sense， this virtual environment is a lesson from the
    system， packages。 the one that are inside the system level。 Okay。 So one more
    thing， generally people。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个 Python 解释器中调用 Python，你会看到在这个环境中。我只有包和工具设置。我没有所有这些操作系统包。因此，从某种意义上说，这个虚拟环境是与系统包隔离的。那些在系统级别的包。好的。还有一件事，通常人们。
- en: whenever they use virtual environments， they tend to create the virtual environment
    as I did here。 and then they activate it， like they can use the activate ps1。
    For example， if you power shell or。 just activate if you use bash and depending
    on your interpreter， you might want to use different。 activators。 And this what
    it will mean， what this means is going to do is that this kind of like。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每当他们使用虚拟环境时，他们倾向于像我这里一样创建虚拟环境。然后他们激活它，比如可以使用 activate ps1。例如，如果你使用 PowerShell，或者如果你使用
    Bash，只需激活，根据你的解释器，你可能需要使用不同的激活器。这意味着什么，这意味着将会像这样。
- en: creates another shell in which when I type out Python， this actually will。 choose
    the Python interpreter from within that virtual environment。 Okay。 And here you
    can see。 that it's actually from that environment by just which I just created
    it。 But this doesn't have to。 this is not the only way to use a virtual environment。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建另一个 shell，当我输入 Python 时，这实际上会选择该虚拟环境中的 Python 解释器。好的。在这里你可以看到，它实际上是来自我刚创建的那个环境。但这并不是唯一使用虚拟环境的方法。
- en: You don't have to activate a virtual environment， use it。 If you， I shouldn't
    have done that。 my bad。 So if I go back there， you can see I can also use a virtual
    environment by just typing the Python interpreter itself。 And this is basically
    the same。 Okay。 So from this point to one， the activators within a virtual。 environment
    are just the convenience。 So you don't have to type out the full path。 But otherwise。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必激活虚拟环境就可以使用它。如果你，我不应该这样做。我的错。所以如果我回到那里，你可以看到我也可以通过输入 Python 解释器本身来使用虚拟环境。这基本上是相同的。好的。从这一点到一个，虚拟环境中的激活器只是为了方便。所以你不必输入完整的路径。但除此之外。
- en: they don't offer any other functionality other than making helping you with
    not have to do type。 as much。 Does that make sense？ And again， if anyone has any
    questions， feel free to speak up。 If you feel I talk too fast， again， feel free
    to stay up。 The goal of this。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 它们没有提供除了帮助你不必多输入之外的任何其他功能。这样理解吗？再说一次，如果有人有任何问题，请随时发言。如果你觉得我说得太快，再次，请随时打断。这个的目标是。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_43.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_43.png)'
- en: tutorial is not for me to go to all my slides and finish with 10 minutes to
    spare。 I'm happy to。 present last， but make sure that what I do present everyone
    understands it and is crystal care。 Okay。 So another way you can create virtual
    environment is by the virtual AMP module。 And let me just。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程并不是让我完成所有幻灯片并留出 10 分钟的时间。我很乐意进行最后的演示，但确保我展示的内容每个人都能理解，并且清晰明了。好的。你可以通过虚拟
    AMP 模块来创建虚拟环境。让我来展示一下。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_45.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_45.png)'
- en: do that。 So you can see that I have this virtual AMP and I can also do this
    like M2。 Okay。 And let's， just wait a second。 So and as you can see。 this M2 virtual
    AMP is basically the same thing。 You get， the Python and it's pretty much the
    same。 So the question might arise。 So what are the differences。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 做到这一点。所以你可以看到我有这个虚拟的 AMP，我也可以像 M2 一样操作。好的。再等一下。所以正如你所看到的，这个 M2 虚拟 AMP 基本上是一样的。你得到了
    Python，它几乎是相同的。所以可能会出现问题。那么有什么区别呢？
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_47.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_47.png)'
- en: between the VM and the virtual AMP module？ Why would you use VAMB or virtual
    AMP？ Okay。 So this is a， quick overview of some of the differences between the
    virtual AMP and the VM package。 But to kind of， like go on the highlights of this。
    the main difference is that the virtual AMP is a third party， package。 What does
    it mean？
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在VM和虚拟AMP模块之间？为什么你会使用VAMB或虚拟AMP？好的。这是虚拟AMP和VM包之间一些区别的快速概述。但要突出这一点，主要区别是虚拟AMP是一个第三方包。这意味着什么？
- en: That's a third copy？ RT package means that you have to install it before， you
    use it。 While the VM module is a standard library module， meaning that if you
    install your， Python。 you should have already access to the VM module。 You don't
    have to install anything else。 just Python itself。 But like the virtual AMP after
    you install Python。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 那是第三份副本吗？RT包意味着在使用之前必须安装它。虽然VM模块是一个标准库模块，这意味着如果你安装了Python，你应该已经能够访问VM模块。你无需安装其他任何东西，只需安装Python本身。但就像虚拟AMP一样，在你安装Python之后。
- en: you also have to install on the， side the virtual AMP module。 Okay。 Now。 other
    kind of like benefits for the virtual AMP package might。 be the virtual AMP package
    just generally offers a mod back to your API。 And it's also has a， but。 that's
    more important if you're going to write some application that manages virtual
    environments。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须在虚拟AMP模块的那一侧进行安装。好的。现在，虚拟AMP包可能还有其他好处。虚拟AMP包通常为你的API提供了一个模块的返回。而且它也有，但如果你打算编写一些管理虚拟环境的应用程序，那就更重要了。
- en: creates virtual environments， that kind of things。 Also， the virtual AMP package
    has a much better。 configurability story。 But there are two main differences that
    kind of like from end user point。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 创建虚拟环境，这种事情。此外，虚拟AMP包有更好的可配置性。但从最终用户的角度来看，有两个主要区别。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_49.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_49.png)'
- en: of view， the big differences between the two packages。 So let me try to create
    a virtual environment for， Python 3。6。 Okay。 And I use the clear flag。 which basically
    means remove the current existing virtual， environment。 Okay。 So if I create a
    virtual environment by using the VM module， you'll see that once it， finishes。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，这两个包之间的主要区别。所以让我尝试为Python 3.6创建一个虚拟环境。好的。我使用清除标志，这基本上意味着移除当前现有的虚拟环境。好的。如果我使用VM模块创建虚拟环境，一旦完成，你会看到。
- en: if I do and scripts， Python， extra dash， and P please， the version of the PIP
    and setup tools。 that I get is 18。1 and 4。6。2。 But if I use the virtual AMP package。
    and I do like pretty much the same thing， I can just do clear AMP 2。 Okay。 In
    this case。 you'll see that if I do it's PIP placed， you'll see that this one gives
    me a。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我执行脚本，Python，额外的短横线，以及P，请求PIP和设置工具的版本。我得到的是18.1和4.6.2。但是如果我使用虚拟AMP包，几乎做同样的事情，我只需执行清除AMP
    2。好的。在这种情况下，你会看到如果我执行PIP，它会给我一个。
- en: much newer versions of the Python。 So you can see it gives me PIP setup tools，
    which is the latest。 PIP and the latest setup tools， but also gives me the real
    package too。 So as you can see， the。 difference is that the virtual AMP package
    will always give you a mostly up to date version。 of your seed packages。 And the
    seed packages are PIP virtual AMP or PIP VLAN setup tools。 Okay。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 更新版本的Python。因此，你可以看到它给了我PIP设置工具，这是最新的PIP和最新的设置工具，但也给了我真实的包。所以你可以看到，虚拟AMP包总是会给你大多数最新版本的种子包。而种子包是PIP虚拟AMP或PIP
    VLAN设置工具。好的。
- en: So just to give you kind of like a think， Chris mentioned PIP AMP。 I'm going
    to tell you that PIP AMP， under the hood uses virtual AMP。 Okay。 So if you've
    been using PIP AMP in practice， you've been using。 virtual AMP just through a
    different interface。 Okay。 So going back。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所以仅仅给你提供一些想法，克里斯提到PIP AMP。我想告诉你，PIP AMP在后台使用虚拟AMP。好的。所以如果你在实践中使用PIP AMP，你实际上是在通过不同的接口使用虚拟AMP。好的。那么回到正题。
- en: if you create virtual environments， with the virtual AMP package。 your default
    seed packages is already going to be up to date by default。 And there。 one of
    the other big differences between the two things， and this is something you。 might
    have noticed， is that creating a virtual environment with the via module， you
    can see here。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用虚拟AMP包创建虚拟环境，你的默认种子包默认已经是最新的。这是这两者之间的另一个主要区别，这也是你可能注意到的，使用VM模块创建虚拟环境时，你可以在这里看到。
- en: like six seconds it took while creating the same virtual environment， virtual
    AMP took 2。3 seconds。 As you can see， it's more than a two time performance improvement。
    meaning that the virtual AMP package， is much faster than the VM package。 And
    you can see at the subsecond one， it's even faster。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 创建相同虚拟环境时，虚拟环境花了六秒，而虚拟AMP只用了2.3秒。正如你所看到的，这提升了两倍以上的性能。这意味着虚拟AMP包比VM包快得多。在亚秒级别，它甚至更快。
- en: The point where it's no longer even shows up， it's less than a second。 Okay。
    And this is the one。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 无法再显示的时间少于一秒。好的。这就是。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_51.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_51.png)'
- en: of the main ways of brand user point of view。 Virtual AMP is faster because
    it uses caching to make。 sure that it can perform the creation of the virtual
    environment as fast as possible， while the via。 module is slower。 Okay。 Also，
    the virtual AMP package will give you more up to date default。 packages while
    the VM doesn't。 That's why the case often， if you use the VM package。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从品牌用户的角度来看，虚拟AMP更快，因为它使用缓存确保尽可能快地创建虚拟环境，而VM模块则较慢。好的。此外，虚拟AMP包将为你提供更最新的默认包，而VM则不会。这就是为什么在使用VM包时常常是这样的原因。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_53.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_53.png)'
- en: you more often that what either you have to pass in the download package， which
    then。 reach out the internet to get the latest dependencies。 I think it's upgrade
    actually not download。 If you do this， clear together or not upgrade， can't even
    do that。 Okay， so you can't， do that。 So basically， the difference is that the，
    VM module is going to give you the version of the PIP and setup tools that was
    available when。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你更常需要传递下载包，然后接入互联网获取最新依赖。我认为这实际上是升级而不是下载。如果这样做，清除或不升级，甚至无法做到。好的，所以你不能那样做。基本上，区别在于，VM模块会提供你在发布时可用的PIP和设置工具的版本。
- en: that interpreter worksheet。 And this is the reason why I could demonstrate this
    topic better with the。 Python 3。6。 Because Python 3。6 hasn't been updated for
    a while。 which means that the versions of PIP， setup tools that you get with them
    are very old。 However。 virtual AMP， because it's upgraded outside， of the life
    cycle upgrade of the Python interpreter itself。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该解释器工作表。这就是我能更好地演示这个主题的原因。Python 3.6因为一段时间没有更新，意味着你得到的PIP和设置工具版本非常旧。然而，虚拟AMP，因为它在Python解释器生命周期升级之外进行升级。
- en: it gets more frequent upgrade。 And plus， in the background， it quickly starts
    in the background。 It periodically will update your seed packages。 And you can
    read about this more in depth。 If you want to find out more about this。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 升级更频繁。此外，它在后台快速启动。它会定期更新你的种子包。如果你想深入了解，可以阅读更多内容。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_55.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_55.png)'
- en: the documentation of the virtual AMP， especially on the user guide。 And for
    example， there's a。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟AMP的文档，尤其是用户指南。例如，里面有一个。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_57.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_57.png)'
- en: dedicated section about the wheels here， where you can see how virtual AMP ensures
    that the。 version of the PIP and setup tools that you get is mostly up to date。
    What does mostly up to date。 means is means we'll try to give you the latest version
    of the setup tools PIP and wheels， which。 you know are not broken。 And the proxy
    that we use for getting this one is basically， we try to。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个专门讨论轮子的部分，你可以看到虚拟AMP如何确保你获得的PIP和设置工具版本大多是最新的。大多数最新意味着我们会尝试提供最新版本的设置工具、PIP和轮子，这些都是正常的。而我们用来获取这个的代理基本上是，我们会尝试。
- en: give 28 days after the release of a package。 And only after that start using
    it。 so that by that time， we'd expect it in 28 days， if there are any box within
    that release。 users would report it， and a fix would have been released。 Okay。
    Okay。 so that's mainly about the difference the virtual。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 给定软件包发布后需等待28天。仅在此之后才能开始使用它。因此，到那时，我们期望在28天内，如果该发布中存在任何问题，用户会报告，而修复将已发布。好的。好的。所以这主要是关于虚拟的区别。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_59.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_59.png)'
- en: AMP module。 And generally， I think the rule of thumb is that if you can use
    virtual AMP。 it's faster， it gives you up to date packages。 However， if installing
    virtual AMP is harder。 just fall back to the VM module， it just has good otherwise
    the virtual AMP and the VM package。 from a Python interpreter point of view， they
    create the same type of interpreter they should。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: AMP模块。一般来说，我认为经验法则是，如果你可以使用虚拟AMP，它会更快，并提供最新的包。然而，如果安装虚拟AMP更困难，就回退到VM模块，它同样良好，从Python解释器的角度来看，二者创建的解释器类型应当相同。
- en: behave equally well。 Okay， so now that doesn't mean that that's the only way
    of virtual environments。 And this is kind of like more， I don't think this is
    ready for day to day usage。 But this is something， that you might hear about on
    some blog post and whatnot。 you just wanted to mention。 There's another， way where
    people want to create virtual environments where you don't have to activate them
    to use them。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 行为同样良好。好吧，这并不意味着这是虚拟环境的唯一方式。这有点像，我不认为这已经准备好用于日常使用。但这是你可能在一些博客帖子等中听到的事情，只想提一下。还有另一种方式，人们想创建虚拟环境，不必激活它们就可以使用。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_61.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_61.png)'
- en: In a sense that you can just kind of like rely on wherever folder you are。 I'm
    gonna do here a quick， demonstration of that。 There's this application called
    Pyflow。 which you can use， which creates， virtual environments， and I just say
    3。9。 which are not using the virtual AMP way of thinking， but。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，你可以依赖于你所在的任何文件夹。我将在这里快速演示一下。这里有一个叫做Pyflow的应用程序，你可以使用它来创建虚拟环境，我只需说3.9，这并不是使用虚拟AMP的思维方式，但。
- en: instead they're trying to use and just to demonstrate this。 You can see in the
    VM case or the virtual， normal virtual AMP case， if you look in the folder。 these
    are the files you see， there's an include， there's a lib， VM and scripts files。
    Yeah。 but inside this demo one， if I use it， you can see， that now I have a Py
    packages folder。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，他们试图使用并展示这一点。在VM案例或正常虚拟AMP案例中，如果你查看文件夹，这些是你看到的文件，里面有一个include、lib、VM和脚本文件。是的。但在这个演示中，如果我使用它，你可以看到，现在我有一个Py包文件夹。
- en: And this is more in line with how people inside the Node。js。 world would expect
    things to behave when your virtual environment is always present in your。 current
    working directory under a given name。 In case of the Node。js， this is the not
    modules。 within your root folder。 In case of the Pyflow， they try to replicate
    this by creating these。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这与Node.js世界中人们期望的虚拟环境行为一致，即你的虚拟环境始终在当前工作目录下以给定名称存在。在Node.js中，这就是根文件夹内的not模块。在Pyflow中，他们试图通过创建这些来复制这一点。
- en: Py packages， my folder， which contains the same way those dependencies。 The
    main differences in。 between these two have this interpreter is created and activated。
    and where it stores those packages， that you're going to be installing it。 In
    case of the VM module。 your dependencies is going to be， stored inside this lib
    folder mostly， like this lib。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Py包，我的文件夹，其中包含相同的依赖项。这两个之间的主要区别在于解释器的创建和激活方式，以及它存储你要安装的包的位置。在VM模块中，你的依赖项主要存储在这个lib文件夹中，比如lib。
- en: while in case of the Pyflow in it， your， dependencies is going to be inside
    this Py packages folder。 or your package is going to be installed， inside that
    folder。 That makes sense？ Yes。 Pyflow is a third-party thing， and it's not a Py。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pyflow中，你的依赖项将位于这个Py包文件夹内，或者你的包将被安装在那个文件夹中。这有意义吗？是的。Pyflow是一个第三方工具，并不是Py。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_63.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_63.png)'
- en: packaging thing。 Inside this you can actually click on the link。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 打包事情。在这里你可以实际点击链接。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_65.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_65.png)'
- en: You can click on the link and see it， and it has some documentation how to install
    it。 It's something to look out for， probably will require a bit more time to be
    stable， so to say。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以点击链接查看，它有一些文档说明如何安装。这可能需要更多时间来保持稳定，可以这么说。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_67.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_67.png)'
- en: but it's a new way on how we should create and interact with Python environments。
    virtual environments。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是一种新的创建和交互Python环境的方式。虚拟环境。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_69.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_69.png)'
- en: Okay？ So， in order for us to understand what it means installing the package。
    I think what we need to understand is how does Python know if a library is available
    in portable？
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？因此，为了让我们理解安装包意味着什么，我认为我们需要理解的是Python如何知道一个库是否可用。
- en: Okay， because we say that having a library basically means that once I install
    it。 I'm able to import it and use it。 So for us to understand it， how this is
    possible， we need to。 understand how can I import something in Python？ And the
    short answer to this， that it doesn't。 the Python interpreter doesn't know what
    is important and what not important。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，因为我们说拥有一个库基本上意味着一旦我安装了它，我就能够导入并使用它。因此，要理解这一点，我们需要理解如何在Python中导入某些东西？简短的回答是，Python解释器并不知道什么是重要的，什么不是。
- en: but rather it goes on to the mantra。 It's easier to ask for me， it's that permission。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 而是继续坚持口头禅。对我来说，要求许可更容易。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_71.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_71.png)'
- en: So when you type in， for example， here， if I have a virtual environment， just
    go back。 Oh， so， oh。 there's another one， but doesn't matter。 So if I do type
    in import setup tools。 what happens at this point， Python doesn't know when I
    type in and hit enter there。 that setup tools is available or not。 Instead， it
    will try to import it。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当你输入时，例如，如果我有一个虚拟环境，回去一下。哦，还有另一个，但无所谓。如果我输入import setup tools。在这一点上会发生什么，Python并不知道当我输入并按回车时，setup
    tools是否可用。相反，它会尝试导入它。
- en: and if it manages to import it， it's going to bring back interpreter and then
    I have this。 setup tool subject， which is like a module of which I can use。 However，
    if I try to import。 something that's not available， it's going to try to do it
    and once it sees that it cannot do it。 it will print an error。 Okay， so the setup
    tool that we just imported here is actually a module。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它成功导入，它会返回给解释器，然后我就有了这个setup工具主题，就像我可以使用的一个模块。然而，如果我尝试导入一个不可用的东西，它会尝试并在看到无法完成时打印错误。好的，所以我们刚刚导入的setup工具实际上是一个模块。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_73.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_73.png)'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_74.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_74.png)'
- en: and it's kind of like a mapping module， meaning that it has a lot of keys and
    values in it。 Okay。 and the keys in the setup tools are basically all the functions
    methods variables defined in it。 and the values are the actual function variable
    value variable method。 Okay， so for example。 you see， I can use the deer function
    to check all the keys available inside the module， and I see。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它有点像一个映射模块，这意味着它有很多键和值。好的，setup工具中的键基本上是定义在其中的所有函数、方法、变量，而值是实际的函数、变量、值和方法。好的，例如，你可以看到，我可以使用dir函数来检查模块内可用的所有键，然后我看到。
- en: for example， here that setup tools has the， which one I wanted to show， has
    for example。 the name key in it。 Okay， and if I do the dot notation to look up
    that， yeah。 I see that it contains the value setup tools， or I can see that has
    the setup。 which is a function available on it， but modules are composable， meaning
    that it is possible to。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有setup工具，我想展示的就是这个，它里面有一个名字键。好的，如果我用点表示法去查找，我看到它包含值setup工具，或者我可以看到它有setup，这是一个可用的函数，但模块是可组合的，这意味着可以。
- en: have a module within a module。 For example， in this case， you can see that the
    version。 it's also a module， and it's available within the setup tools module。
    Okay， now。 a collection of modules is what we call the package， and therefore
    generally we refer to it。 as an entire， when you install a package， it may have
    one or more modules in it。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块内有一个模块。例如，在这种情况下，你可以看到版本。它也是一个模块，并且可在setup工具模块内使用。好的，现在。模块的集合就是我们所说的包，因此一般来说，我们称之为整体，当你安装一个包时，它可能包含一个或多个模块。
- en: but if there are some packages that have a single module in it， and that's perfectly
    fine。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果有一些包只有一个模块，那也是完全可以的。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_76.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_76.png)'
- en: Okay， so that's kind of like what happens after you import the things。 Okay，
    so the。 important something it means just bringing something into the interpreter。
    which gives you access to， all the functions variables and modules defined within
    that module。 Okay。 so just to， there's another， other way how you can import things，
    and that's the setup， that's the。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以这就像是导入后发生的事情。重要的东西意味着将某些内容带入解释器。这让你可以访问定义在该模块内的所有函数、变量和模块。好吧，所以只是还有另一种导入方式，那就是setup。
- en: from notation of the imports， and from setup tools import setup is just a syntax
    you should work to basically these other。 three lines of code。 Okay， it just basically
    means import setup tools。 once the important setup tools， take out the setup name，
    okay。 and just delete the actual imported setup tools module， so that in。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从导入的符号来看，`from setup_tools import setup`只是你应该了解的基本语法，这三行代码就是这样。好吧，这基本上意味着导入setup_tools。一旦导入了setup_tools，就去掉setup名称，好吧。然后删除实际导入的setup_tools模块。
- en: the local namespace you only now have available setup， you no longer have setup
    tools， self the。 module itself available。 So this is like a rough equivalent to
    it。 Okay， so basically we only need。 to understand import setup tools to understand
    what happening inside the background， because the。 from notation can be reduced
    from that。 Okay， so now the next thing which we need to understand that。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地命名空间中，你现在只拥有setup，而不再有setup_tools和模块本身。因此，这大致相当于此。好吧，所以基本上我们只需要理解`import
    setup_tools`，以了解后台发生的事情，因为符号可以从中简化。好吧，所以下一个我们需要理解的事情是。
- en: not all modules that we import are equal。 For example， the sys module that you
    may import。 and it even prints it out here is a built-in module， okay， or we have
    the OS module， or we have the。 CSV underscore module， or the Pytober module， or
    the PEP5。7 module。 You'll see here， the sys is a。 built-in module， the OS is a
    standard library module， what it means a standard library module。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入的模块并不都是平等的。例如，您可能导入的sys模块，甚至在这里打印出来的是一个内置模块，好吧，或者我们有OS模块，或者我们有CSV模块，或者Pytober模块，或者PEP5.7模块。你会看到sys是一个内置模块，OS是一个标准库模块，这意味着标准库模块。
- en: about it， a standard library module basically means that， hey， it's something
    that's available。 it's shipped by the stand within the Python interpreter itself。
    and the way you can notice this is if you， look at this pet here。 and maybe the
    highlight thing is not the best， but here you can see that。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 关于它，标准库模块基本上意味着，嘿，这是一种可用的东西。它是由Python解释器本身提供的。你可以通过查看这里的这个包来注意到这一点，也许重点不太好，但在这里你可以看到。
- en: the actual location where this file is， it's right after this Python 3。9 folder，
    okay。 and that means that， it's available right within the Python interpreter
    itself at the standard library level。 Then you have， also the standard library
    dynamic load modules。 and you can see these are like binary files， and this is
    just to showcase that it's not only Python files which may be important。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的实际位置就在这个Python 3.9文件夹后面，好吧。这意味着它在Python解释器的标准库级别中是可用的。然后你还有标准库动态加载模块。你可以看到这些就像二进制文件，这只是为了展示，不仅是Python文件可能很重要。
- en: for example， in this case， we imported， as you can see， an SO file。 which is
    kind of the equivalent of the， DLL file on Windows or the PyD file from Windows，
    okay。 and then you have the actual third-party， modules。 and the third-party modules
    often are available within a side package's pet。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这种情况下，我们导入了一个SO文件，它相当于Windows上的DLL文件或Windows上的PyD文件，好吧。然后你有实际的第三方模块。第三方模块通常在侧包内可用。
- en: like here you can see the side package's pet， and within the side package's
    pet you can have two。 variants， you have the global side package's pet， and you
    have the user side package's pet， okay。 the user is something that you get if
    you install something with the there's the shooter。 and the global one if you
    install something by just doing Python dash and pip install。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以看到侧包的包内，你可以有两个变体，一个是全局侧包，另一个是用户侧包。好吧，用户是在你通过某种方式安装时获得的，全球的则是在你仅通过Python
    dash和pip安装时获得的。
- en: and obviously this here is valid if you use your global system interpreter to
    install packages。 if you install some package into a virtual environment Python。
    then things going to be a bit different， we'll go into that just a second。 but
    now that we know that we can import， import logic， the execution。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果你使用全局系统解释器来安装包，这里是有效的。如果你在虚拟环境中安装某个包，那么情况会有所不同，我们马上就会深入探讨这一点。但现在我们知道可以导入，导入逻辑，执行。
- en: code can come from multiple locations， it's not a surprise that we'll learn
    that actually Python。 has multiple importing systems， and how it works， it has
    a list of importers registered。 and it goes， through each of those supporters
    gives the import value that we want to import it。 and we'll ask， "Hey， importer，
    can you materialize this import comment？
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以来自多个位置，毫不奇怪，我们会了解到实际上Python有多个导入系统，以及它是如何工作的，它有一个注册的导入者列表。它会遍历每一个支持者，给出我们想要导入的值。我们会问：“嘿，导入者，你能实现这个导入命令吗？”
- en: '" And if the importer can materialize it， it stops and returns， if not。 goes
    to the next importer and adds that importer to materialize it， and so on and so
    on， okay。 so the system importers or the list of importers that Python uses are。'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: “如果导入者能实现它，它会停止并返回，如果不能，就去下一个导入者，并添加该导入者以实现它，依此类推，好吧。因此，系统导入者或Python使用的导入者列表是。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_78.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_78.png)'
- en: is available on the this one， this is Metapat， thing contains it， and you can
    see here I actually。 have a few more， and I'm just gonna quickly print this so
    you can see it， and I write this， code。 oh， I need one more， spot the mistake
    I made and typing this up， it doesn't should work， okay。 it works， so yeah， yes，
    so just to， answer it， Jorgans， we'll get back to Jorgans question in a bit。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上面可以找到，这是Metapat，这里你可以看到我实际上还有一些更多的，我只是快速打印一下，这样你可以看到，然后我写这个代码。哦，我需要再找一个，找出我打错的地方，这样它就不会工作，好吧。它工作了，所以是的，所以只是为了回答它，Jorgans，我们稍后会回到Jorgans的问题。
- en: but just to go through it， so as you can see in this case， we have one， two，
    three， four， five， six。 seven importer， register， and whenever I type in import
    magic。 Python actually goes to each of these modules。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 但只是为了梳理一下，正如你所看到的，在这种情况下，我们有一、二、三、四、五、六。七个导入者注册，每当我输入import magic时，Python实际上会去每一个模块。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_80.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_80.png)'
- en: and we'll ask "Hey， can you import to me magic？" First it goes to build the
    importer。 then the frozen， import， and then the pet finder， then to this vendor
    importer。 then to this six-metapackage， another vendor import under six-metapackage。
    and only after it went to all these importers， it's gonna come back and say this
    error message to me。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会问：“嘿，你能给我导入magic吗？”首先，它会去构建导入者。然后是冻结导入，然后是宠物查找器，然后是这个供应商导入者。接着到这个六个元包，再到六个元包下的另一个供应商导入者。只有在访问完所有这些导入者后，它才会返回并给我这个错误信息。
- en: okay， so the built-in importer is basically。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以内置导入者基本上是。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_82.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_82.png)'
- en: stuff which imports logic from the Python executable itself， okay， so that like
    the sys module， he。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python可执行文件本身导入逻辑的东西，好吧，所以就像sys模块那样。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_84.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_84.png)'
- en: actually available in the Python interpreter itself， the code， the machine logic
    that's run。 it's available on the Python executable itself， that's why it's a
    built-in， importer。 that's why it's a built-in module， okay， then the second type
    is the frozen important。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上可用的在Python解释器本身，代码，运行的机器逻辑。它在Python可执行文件上可用，这就是它作为内置导入者的原因。这就是它作为内置模块的原因，好吧，第二种类型是冻结导入。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_86.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_86.png)'
- en: this is something that is not that much used out of the box， but it's a way
    how a feature。 provided by the Python interpreter where tools can kind of freeze
    modules and shift them as that。 and then these are imported by the freeze-in importer，
    this is something that for example。 Py installer is using and we'll see Py installer
    in the second part of the chapter， but for now。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些不那么常用的功能，但这是Python解释器提供的一个功能，工具可以以某种方式冻结模块并将它们移交。这些是由冻结导入者导入的，例如，PyInstaller正在使用这个，我们将在本章的第二部分看到PyInstaller，但现在。
- en: just think it is something， it's kind of like the built-in importer with the
    difference that it。 doesn't actually pull the logic from the interpreter itself，
    but rather than external location file。 and make sure that the code cannot be
    changed after the import， and then you have the pet finder。 importer， now 99%
    of the time you use the pet finder importer， the pet finder importer is basically。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 只需考虑一下，这有点像内置导入器，区别在于它并不真正从解释器本身提取逻辑，而是从外部位置的文件中提取。确保代码在导入后无法更改，然后你就有了宠物查找器。导入器，现在
    99% 的时间你使用宠物查找器导入器，宠物查找器导入器基本上是。
- en: an importer that's available to load materialized code from the file system
    itself， okay。 now the pet finder importer itself is configured from the CSPAT
    variable， okay。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可用的导入器，从文件系统本身加载物化代码，好的。现在宠物查找器导入器本身是从 CSPAT 变量配置的，好的。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_88.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_88.png)'
- en: and I can do the same thing for this one just to print it out， and yes you see
    there's quite a few。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以对这个做同样的事情，只是将其打印出来，是的，你会看到有相当多的。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_90.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_90.png)'
- en: pets on the CSPAT， and you will see some of this in this order here， but just
    to say it so。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 宠物在 CSPAT 上，你会在这里看到一些这个顺序，但只是说一下而已。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_92.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_92.png)'
- en: in this case what we do here is we have a by default the standard library or
    the default。 the content of the CSPAT is going to be as follows， first and foremost
    you're going to be looking。 in the standard library's zip location this lib python
    3。3 zip， and we can see this on the windows。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们所做的是，默认情况下标准库或 CSPAT 的默认内容将如下，首先，你将查看标准库的 zip 位置这个 lib python 3。3 zip，我们可以在
    Windows 上看到这个。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_94.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_94.png)'
- en: machine here too， this is the python 3。0 zip， and this is basically another
    functionality。 the pet import is not only able to import from the file system，
    but it's able to import from zip。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 机器上也是，这是 python 3。0 zip，这基本上是另一种功能。宠物导入不仅能够从文件系统导入，还能够从 zip 导入。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_96.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_96.png)'
- en: files on the file system， so in theory it's possible to take all your standard
    library packages or any。 of your packages， packages together into a single zip
    file and put it onto the CSPAT， and it will。 be discoverable just as much as if
    it would be available on the file system itself extracted， okay。 this is the standard
    library's zip location， then you have the standard library directory itself。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 文件在文件系统上，所以理论上可以将所有标准库包或你的任何包整合成一个单一的 zip 文件，并放到 CSPAT 上，它就会像在文件系统中提取一样可被发现，好的。这是标准库的
    zip 位置，然后你有标准库目录本身。
- en: this is basically if it's not zip， look at the file system itself， and then
    you have the standard。 library's C extension which is basically all the dynamic
    load， which is basically the。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是如果不是 zip，查看文件系统本身，然后你有标准库的 C 扩展，它基本上是所有动态加载，这基本上就是。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_98.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_98.png)'
- en: external， in this case you can see for example this DSL folders。 and we can
    just quickly see some of， it， for example you can see that the LZMO packages define
    their or the SSL packages define this。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 外部，在这种情况下，你可以看到例如这个 DSL 文件夹。我们可以快速查看其中一些，比如你可以看到 LZMO 包定义它们或 SSL 包定义这个。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_100.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_100.png)'
- en: file， so if I do like import SSH， this SSL it's actually much alike from that
    location， that file。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 文件，所以如果我像导入 SSH，这个 SSL 实际上与那个位置、那个文件非常相似。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_102.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_102.png)'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_103.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_103.png)'
- en: this is kind of like the binary dependencies of the interpreter， and then you
    have the user side。 package and the global side packages， okay， now there's just
    one more thing which some of you might。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点像解释器的二进制依赖关系，然后你有用户侧包和全局侧包，好的，现在还有一件事情是你们中的一些人可能会。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_105.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_105.png)'
- en: notice， you can see there this empty string at the start of this CSPAT。 can
    anyone tell me what this， is the empty PAT mean？ Current directory？ Yes。 and this
    is the reason you're right， it means the， Korean directory。 and this is the reason
    why earlier when I just started up a Python interpreter。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以看到在这个`CSPAT`的开头有一个空字符串。有人能告诉我这是什么意思，空`PATH`代表什么吗？当前目录？是的。这就是你对的原因，它意味着Korean目录。这就是为什么当我刚启动Python解释器时，这有效。
- en: this actually worked， because whenever you start a Python interpreter。 the Python
    interpreter always， adds the Korean working directory onto the PAT。 and that's
    why it works， but if I go here and I do， like import P approximate， and this works
    now。 okay， well not what I wanted to do， but let me just start， that up again，
    so I import the C's。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上有效，因为每当你启动Python解释器时，Python解释器总是将Korean工作目录添加到`PATH`中。这就是它工作的原因，但如果我去这里并且我做了像`import
    P`这样的操作，现在这有效。好吧，这不是我想做的，但让我再启动一次，所以我导入C的。
- en: and the C's that PAT is not static， it's for me it's possible， to do for example
    remove that one。 and if I do the import P approximate， now this is no longer，
    fun。 because now I remove the Korean directory from the list of folders the Python
    is looking to import。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 而C的`PATH`并不是静态的，对于我来说，它是可能的，比如说删除那个。如果我执行`import P`，现在这就不再有趣了，因为我从Python查找导入的文件夹列表中删除了Korean目录。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_107.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_107.png)'
- en: okay， so yeah， why is an empty string and not a dot？ Probably the answer to
    that is historical。 reasons， and it's just whatever whoever created it first used
    and went with that。 and then you never can change it for backwards compatibility
    reasons。 C's。pad is the environment variable right？ Not really， you can add additional
    locations to the。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那么为什么是空字符串而不是一个点呢？可能这个答案是历史原因，这只是最初创建它的人使用的方式，然后出于向后兼容的原因，你就不能更改它。C的`PATH`是环境变量，对吧？其实不是，你可以向`PATH`添加其他位置。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_109.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_109.png)'
- en: you can add additional elements to the C's that pay by using the Python PAT
    environment variables。 so if you do like， I don't know， a， and then you can do
    like， pie， there's some site for example。 let me just show if I can do like export
    or set， yeah， then I should be able to。 now that should show up， I think it might
    check if it's this。 That did not work。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Python的`PATH`环境变量向C的`PATH`添加其他元素。如果你做了像`a`这样的操作，然后你可以做类似`pie`的事情，比如说，有一些站点。让我展示一下，如果我可以使用`export`或`set`，是的，那么我应该能够。现在应该显示出来，我想它可能会检查是否是这个。这没有成功。
- en: but basically it's you can configure it on the Python PAT environment variable，
    okay。 and you can extend additional PATs onto the C's that PAT by using the environment
    variable。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你可以在Python的`PATH`环境变量中配置它，可以通过使用环境变量扩展C的`PATH`。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_111.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_111.png)'
- en: Okay， so with this knowledge now we can actually answer more exactly what is
    a virtual environment。 so virtual environment is a Python interpreter that has
    access to its own site packages。 basically this allows it to install packages
    only within itself and not the system interpreter。 and share success to the host
    built-ins and standard library， and optionally is easily。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，拥有这些知识后，我们实际上可以更准确地回答什么是虚拟环境。虚拟环境是一个Python解释器，能够访问其自己的站点包。基本上，这使它能够仅在内部安装包，而不影响系统解释器，并共享对主机内置和标准库的成功访问，且可选地易于配置。
- en: provided easily a few from the system site package。 For example， if you start
    up the system Python。 interpreter， this is what you're going to see， you see you
    have the standard library PAT， then you。 have the user and the global site packages
    inside the virtual environment， the user and global site。 packages are gone， and
    instead you have your own site packages available， or if you use the。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 从系统站点包中轻松提供几个。例如，如果你启动系统Python解释器，这就是你将看到的，你会看到你有标准库的`PATH`，然后你有用户和全局站点包在虚拟环境内，用户和全局站点包消失了，取而代之的是你自己的站点包可用，或者如果你使用。
- en: there's the system site packages option， then you still get using and global
    site packages， but。 your own site packages will be injected after the standard
    library PATs， okay。 So there's just one more complication， we often mean that
    you have your own site packages。 this is actually not strictly true， the site
    packages as a thing is just。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 还有系统站点包选项，你仍然可以使用全局站点包，但你的自定义站点包将在标准库PATs之后注入。好的。所以还有一个复杂性，我们通常意味着你有自己的站点包。这实际上并不完全正确，站点包作为一种东西只是。
- en: what is the default value for the purely band the platform variables， because
    in practice Python。 actually doesn't have one site packages， it actually every
    Python interpreter has two site packages。 and one of the site packages is the
    purely band other is the PAT clip， now on 99%， or 99， but。 I would say 80% of
    the platform these two are set to the same。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 纯band和平台变量的默认值是什么，因为在实践中Python。实际上没有一个站点包，实际上每个Python解释器都有两个站点包。一个站点包是纯band，另一个是PAT
    clip，现在在99%或99，但我会说80%的平台这两者设置为相同。
- en: and if I start your Python interpreter。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我启动你的Python解释器。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_113.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_113.png)'
- en: and I can use the Cisco config module to see this， and I do like get PAT pure
    lib， and I check。 PAT lib， you'll see that this returns me to the same thing，
    however， if for I start up a， fedora。 okay， and a fedora operating system and
    I need to do a update set lager， I can， wait。 do I have a Python here， no， I can't
    do it first and install Python， but you see on fedora。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用Cisco配置模块来查看这个，我确实喜欢获取PAT纯lib，并检查。PAT lib，你会看到这返回给我相同的东西，但如果我启动一个fedora。好的，在fedora操作系统上，我需要执行一个更新设置，我可以，等等。我这里有Python吗？不，我不能先做这个，得先安装Python，但你会看到在fedora上。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_115.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_115.png)'
- en: there are different one， the actual platform library， it's available on the
    lib 64， while the。 platform or the pure lib is available on the lib graphics within
    your virtual environment。 you can see it here， and the main difference what it
    meant to be a difference is that。 your binary dependencies like dlssos， pydys
    should go under the pure lib， while you're。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的一个，实际平台库，它可在lib 64上找到，而平台或纯lib则在你的虚拟环境中的lib graphics上可用。你可以在这里看到，主要的区别是你的二进制依赖项如dlssos，pydys应该放在纯lib下，而你。
- en: plateauing under the pydys， but the pure lib should contain pure Python code，
    which is mostly。 Python code as a dot pi extension， okay， now as I said， this
    distinction is there， it's available。 and this is something that operating system
    distributions might decide to use。 such as the case of the， fedora or the ratat
    operating systems。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在pydys下停滞，但纯lib应该包含纯Python代码，主要是以.dot pi扩展的Python代码。好的，正如我所说，这个区分是存在的，它是可用的。这是操作系统发行版可能决定使用的内容，例如fedora或ratat操作系统的情况。
- en: but it might also just choose to bypass like windows。 macwets generally just
    sets these two to the same value， even the db and d package distributions。 do
    the same thing， just set it to the same value， so you kind of have the impression
    that you have。 only one side packages folder， even to in practice， there's two
    variants of it。 Now the Python。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 但它也可能选择像windows一样绕过。macwets通常只是将这两个设置为相同的值，即使db和d包发行版也做同样的事情，只是将其设置为相同的值，所以你有种印象，认为你只有一个站点包文件夹，实际上有两个变体。现在Python。
- en: importer system is smart， you know， that you add multiple times the same path
    to it， it will。 be duplicated， so that's why you don't see the same path happening
    twice on this this dot path。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 导入器系统很聪明，你知道，当你多次将相同路径添加到它时，它会。被重复，因此这就是为什么你不会看到相同的路径在这个点上出现两次。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_117.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_117.png)'
- en: okay， so yeah， this might take a while， I'll just leave it there for now。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，没错，这可能需要一些时间，我暂时就放在这里。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_119.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_119.png)'
- en: So I hope I did not put you on a sip and we'll have a break in， I want to say
    10 minutes。 but before， we go there， let's get back to the packaging story， okay。
    So now that we know that where， how Python imports a module and where these modules
    are available on the machine。 we can answer， what does it mean， install a package，
    install a library？ Well。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我希望我没有让你感到无聊，我们将在10分钟后休息。但在我们去之前，让我们回到打包的故事。好的。既然我们知道Python如何导入模块以及这些模块在机器上可用的位置，我们可以回答，安装一个包，安装一个库意味着什么？好吧。
- en: it basically means that you need， to provision the correct Python files either
    into this purely work that location。 and once that is， available， basically the
    import system will take care of the rest。 Now for house maintenance， raises， you
    also generally package some metadata with your application。 and some entry points。
    Entry points are optional， not everything used， but for example。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上意味着你需要将正确的 Python 文件放置到这个纯工作位置。一旦可用，基本上导入系统将处理其余的内容。现在，对于房屋维护，通常你还会随应用程序打包一些元数据和一些入口点。入口点是可选的，并不是所有内容都使用，但例如。
- en: people actually have this also， provide you an entry point， these are like either
    UI or CLI。 kind of like little excitables that you， can run， and they give you
    various entry points into your package。 while beside it， another thing， that you
    might also see inside once you look into the side package。 all there is metadata。
    The， metadata as you can see here is basically just list what was for example
    the installer used to。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 人们实际上也会提供给你一个入口点，这些可以是 UI 或 CLI。类似于小的可执行文件，你可以运行，它们为你的包提供各种入口点。同时，另一件事是你在查看侧包时可能还会看到，所有的元数据。如你所见，这里的元数据基本上只是列出了例如安装程序使用的内容。
- en: install this package， what are the files within that package， any other metadata，
    for example。 what are the dependencies of this package。 So installing a package
    or once a package gets installed。 it basically means that the installer will take
    and give you the Python files in this purely work。 that location， will generate
    some entry points for you if the library is defining some entry points。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 安装这个包时，包内有什么文件，任何其他元数据，例如。这个包的依赖关系是什么。因此，安装一个包或者一旦包被安装，基本上意味着安装程序将获取并提供给你在这个纯工作位置中的
    Python 文件，如果库定义了一些入口点，安装程序将为你生成一些入口点。
- en: and also ships you some metadata which describes the package is dependencies。
    it's files that type of， logic。 Okay， and we'll see basically in order to generate
    a package library。 this is what we need to， generate， this is what we need to
    create。 and there are a few ways that we can do that， but okay。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 还会给你提供一些描述包的依赖关系的元数据。这是那种逻辑的文件。好的，我们基本上会看到为了生成一个包库，这就是我们需要生成的内容，这就是我们需要创建的内容。我们可以用几种方式来做到这一点，但好吧。
- en: so in case of just to circle back to our PI approximation logic。 the first thing
    that we'll have is that， hey， I want to import this， import。 once we import to
    do that， I have this file， I just want to take， this file。 put it into the side-side
    packages folder， and then put some metadata alongside it。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 所以以我们的 PI 近似逻辑为例，首先我们要做的是，嘿，我想导入这个，导入。一旦我们导入，要做到这一点，我有这个文件，我只想将这个文件放入侧包文件夹中，然后将一些元数据放在旁边。
- en: because I don't have any entry points for now in this package， and if I do this，
    and I ship these。 files to someone else's machine， then they'll be able to both
    install my packages， it no longer。 wanted， and they'll also be able to use it
    when they start the interpreter。 so this is what we'll be， aiming for。 Okay， now
    obviously this is what the end user gets。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我目前在这个包中没有任何入口点，如果我这样做，并且将这些文件传输到其他机器上，那么他们将能够安装我的包，它不再需要，并且当他们启动解释器时也能够使用它。因此，这就是我们要追求的目标。好的，显然这就是最终用户所获得的。
- en: but you the developer will have， other files for your source tree。 for example
    you have the business logic file， this is what you， want to ship to your other
    machine。 but then you have test files which don't show up on your install， side
    packages。 but you still have it in your source tree， then you have for example
    license。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你作为开发者将会有其他文件用于你的源代码树。例如，你有业务逻辑文件，这就是你想要传输到其他机器的内容。但是你还有测试文件，这些文件不会出现在你的安装侧包中。但它们仍然在你的源代码树中，然后你还有许可证等文件。
- en: you have other like the readme， other metadata project management files， or
    your CI configuration。 files， and you might also have other files which we'll
    refer to it a bit later， which we call。 metadata from based on what your packaging
    tool is able to actually generate a package for your。 project。 Okay， so basically
    our goal is that what you have on your own machine while you're。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你还有其他像 README、其他元数据项目管理文件，或者你的 CI 配置文件，可能还有其他文件，我们稍后会提到的，我们称之为基于你的打包工具能够实际为你的项目生成的元数据。好的，所以基本上我们的目标是你在自己机器上拥有的内容。
- en: developing the library is going to be the top code snippet， and the bottom code
    snippet is what we。 want to ship to someone else's machine。 As you can see， we'll
    move some of the files from our。 machines to someone else's machine as it is，
    but we'll also generate some new files， but we'll also。 not ship some files， okay，
    and yes， you're going to get your cash in a bit later。 Let's not。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 开发这个库将是顶部的代码片段，而底部的代码片段是我们想要发送到其他机器的。 如你所见，我们将把一些文件从我们的机器移动到其他人的机器，但我们也会生成一些新文件，但我们也不会发送某些文件，好的，没错，你稍后会得到你的现金。我们不这样做。
- en: ruin the punch line yet。 Okay， so just to take a second， so we'll take this
    is our source tree。 the development store tree， and we want to ship this package
    to this target machines。 and the way this is going to work， we generally don't
    tend to ship directly to other machines。 though we could， but in general instead
    we first stored the package inside some center package store。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 还没到揭晓高潮的时候。好吧，稍微花一点时间，我们把这个看作我们的源树，开发存储树，我们想把这个包发送到这个目标机器。 这种方式的工作通常不会直接发送到其他机器。尽管我们可以这样做，但一般情况下，我们首先将包存储在某个中央包存储中。
- en: and the reason why we do this is that if our developer machine is gone， something
    happens to it。 the target machine is still able to consume this package and install
    it， okay， so generally the。 packaging store it kind of like breaks down， I have
    my local developer search tree。 I generate a package， I upload that package into
    the center package store， I download that package。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这么做的原因是，如果我们的开发机器消失了，发生了什么事情，目标机器仍然能够使用这个包并安装它，所以通常这个。 打包商店有点像崩溃了，我有我的本地开发搜索树。我生成一个包，我将那个包上传到中央包存储，我下载那个包。
- en: and then I install it， onto that machine， okay， so， and this is where we'll
    take five minutes break。 just to give you a bit， of a coffee break， and we'll
    get back in five minutes and continue。 if anyone has any questions， feel free
    to shoot it， but yeah。 otherwise feel free to grab a coffee and be back in five
    minutes。 [silence]， Thank you。 [silence]。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我将它安装到那台机器上，好吧，所以，这里我们将休息五分钟。给你们一点咖啡休息时间，我们五分钟后再回来继续。如果有人有任何问题，请随时问，但没关系。否则，随意去喝杯咖啡，五分钟后回来。[沉默]，谢谢。[沉默]。
- en: '[silence]， [silence]， [silence]， [silence]， [silence]， [silence]， [silence]，
    [silence]， [silence]。 [silence]， [silence]， [silence]， [silence]， [silence]， [silence]，
    [silence]， [silence]， Hi。 I''m back just queshing up on questions。'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[沉默]，[沉默]，[沉默]，[沉默]，[沉默]，[沉默]，[沉默]，[沉默]，[沉默]。 [沉默]，[沉默]，[沉默]，[沉默]，[沉默]，[沉默]，[沉默]，[沉默]，嗨。我回来了，只是整理一下问题。'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_121.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_121.png)'
- en: '[silence]。'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[沉默]。'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_123.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_123.png)'
- en: '[silence]， The reason why I use Windows instead of Linux。 I think one of the
    strengths of the Python language is that it， runs everywhere。 And because of that，
    I maintain a few projects， as you can see beforehand， like virtual， and cups。
    and the aim of the Python packaging authority is to support all of these platforms。
    So for me。'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[沉默]，我使用Windows而不是Linux的原因。我认为Python语言的一个优势是它可以在任何地方运行。正因为如此，我维护了一些项目，正如你之前所见，像虚拟和cups。Python打包机构的目标是支持所有这些平台。因此，对我来说。'
- en: it's just as important to run something runs on Windows as it's run on Linux。
    So from that point of view， I constantly have to work with all of those， and。
    Windows generally just a bit more stable。 For example， at the moment。 I also had
    a federal operating， system which break on me。 So I have to add some point reinstall
    it。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上运行的东西和在Linux上运行一样重要。从这个角度来看，我不得不不断与这些所有系统打交道，Windows通常会更加稳定。例如，目前我也有一个联邦操作系统，它崩溃了。所以我必须在某些时候重新安装它。
- en: but Windows just kind of works。 So I just went with that。 And plus。 I tend to
    use nowadays PowerShell as my shell， and I use a。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 但Windows就是好用。所以我就选择了它。而且我现在倾向于使用PowerShell作为我的shell，我使用一个。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_125.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_125.png)'
- en: also Vastairm， which is like a terminal emulator as my ID or interpreter。 or
    the terminal application。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 还有Vastairm，它就像一个终端仿真器，作为我的ID或解释器，或终端应用程序。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_127.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_127.png)'
- en: which makes it， for me， working on Windows or Linux doesn't make much difference。
    So yeah。 We'll see Poetry a bit later， Ryan。 Probably I want to say in half an
    hour or so， we will touch。 on Poetry and then you'll see how it fits into it。
    Yeah， Chris。 I want to say your best chance is to， probably you want to you will
    need to recreate the virtual environments。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我来说，Windows和Linux之间的工作差异并不大。所以是的。我们稍后会看到Poetry，Ryan。可能我想说大约半小时后，我们会讨论Poetry，然后你会看到它如何适应这个环境。是的，Chris。我想说你最好能，可能你需要重建虚拟环境。
- en: It's probably an odd， interaction between Vast called people and plug in people
    itself and virtual and I want to say your。 issue will be with the people and book
    tracker， but people and itself， it's not overstaffed。 So unless you can dig in
    yourself， it's unlikely you'll have a quick fix on their side。 Yeah。 But yeah，
    I mean， people generally， I found it good when you're developing an application。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个奇怪的互动，涉及Vast的people和插件本身以及虚拟环境。我想说你的问题在于people和book tracker，但people本身并没有过度配置。所以，除非你自己深入研究，否则不太可能快速解决他们那边的问题。是的。但总的来说，我发现开发应用程序时people是好的。
- en: find it less optimal for developing libraries。 That's why I personally。 besides
    just being a maintain of the virtual project， I tend to use the virtual and itself。
    it gives me a bit more flexibility， a bit more， strength when I'm testing libraries。
    Okay。 we'll start back again。 I think that was around five， minutes。 So swimming，
    I find my slides。 Okay。
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现这对于开发库来说不太理想。这就是为什么我个人，除了作为虚拟项目的维护者外，倾向于使用虚拟环境。它在测试库时给了我更多的灵活性和力量。好的。我们再开始。大约五分钟后。我会找我的幻灯片。好的。
- en: so just a quick reminder where we left it off。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 所以只是快速提醒一下我们停在了哪里。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_129.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_129.png)'
- en: We left it out with basically， yes， that's going to come up later。 We'll go
    basically。 how we get our developer source three to a target machine that's important。
    Okay。 Now， as we get。 we're going to use their interim form， this package form
    that the thing that we're。 going to ship from one machine to another machine。
    And when it comes to the types of these packages。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们留到后面基本上是，是的，这个会稍后提到。我们基本上将讨论如何将我们的开发者源代码树转移到目标机器上，这是重要的。好的。现在，当我们获取时。我们将使用他们的中间形式，这种打包形式是我们将从一台机器运输到另一台机器的东西。关于这些包的类型。
- en: you can have two types。 There is a source distribution and there's a wheel。
    Let's start with a source， distribution。 A source distribution is basically what
    resembles what is on a developer's machine。 Okay， it basically contains all the
    files on the developer's source three， minus a few which are。 optional。 You may
    include them， but they're not necessarily needed to function as a source。
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以有两种类型。一个是源代码分发，另一个是轮子。让我们先从源代码分发开始。源代码分发基本上类似于开发者机器上的内容。好的，它基本上包含了开发者源代码树上的所有文件，减去一些可选的文件。你可以选择包含它们，但它们并不是作为源代码所必需的。
- en: distribution。 For example， you're obviously not going to need all your project
    management files。 or maintain your price。 For example， your CI configuration，
    you might include in your source。 distribution， but it's really not needed。 Or
    your project management files that you might have。 it's also again， you might
    include it， but it's not really needed for the purpose of a source distribution。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 分发。例如，显然你不会需要所有项目管理文件。或者维护你的价格。例如，你的CI配置，你可能会在源代码分发中包含，但实际上并不是必需的。或者你可能拥有的项目管理文件，也可以选择包含，但实际上对于源代码分发来说并不是必需的。
- en: And there's this other， and then it has the business logic， the packaging and
    tests。 Okay。 Now。 this is basically， if you look in our project， these are the
    files， we kind of say that this。 is part of our source distribution。 But you can
    see， for example， the CI configuration。 we excluded it and we might decide to
    not go ahead with it。 Now， just before we go further。
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他部分，然后它包含业务逻辑、打包和测试。好的。现在，如果你看看我们的项目，这些文件，我们可以说这是我们源代码分发的一部分。但你可以看到，例如，CI配置。我们排除了它，可能决定不继续使用。现在，在我们继续之前。
- en: Jurgen brought it up that there's such a thing as an egg。 And I'm going to say
    that eggs is a。 hardware to say there is such a thing from the Python packaging
    point of view。 Eggs are the past。 and they're practically not supported nowadays。
    So if you have an egg， you're most likely are。 working in a legacy environment。
    And you might want to look up a tutorial， maybe eight。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Jurgen提到过有“蛋”这种东西。我想说的是，从Python打包的角度来看，“蛋”是过去的东西。它们在现代几乎不被支持。所以如果你有一个“蛋”，你很可能是在一个遗留环境中工作。你可能想找一个教程，也许是第八个。
- en: ten years in the， past， but the Python packaging authority as a whole doesn't
    really support this egg story。 Eggs has been replaced with the wheel， kind of。
    Let's touch onto the wheel。 The wheel is what。 resembles mostly what we want on
    the target machine。 It contains the installed binary file with some， metadata。
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的十年里，但整体的Python打包权威实际上并不支持这个“蛋”的故事。“蛋”在某种程度上被“轮子”所取代。让我们谈谈轮子。轮子最能代表我们在目标机器上想要的内容。它包含已安装的二进制文件和一些元数据。
- en: but it doesn't contain the project management files and it maintain your ship
    files。 the test files and packaging files。 All these are missing。 Basically， in
    this project， the only。 thing that's going to be in the wheel from our source
    tree is going to be the Python file itself。 Plus， as you can see， it also contains
    some metadata alongside it， but none of the other files。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但它不包含项目管理文件，也不包含你的发货文件、测试文件和打包文件。这些都缺失。基本上，在这个项目中，从我们的源树中唯一会出现在轮子中的东西就是Python文件本身。此外，正如你所见，它还包含一些元数据，但没有其他文件。
- en: Okay。 So now when it keeps the difference， what's the difference between having
    a source。 distribution as a wheel from a package installation point of view？ And
    this is the direction the。 Python packaging ecosystem works。 And this is how I
    find the best way to think about it。 We always install， a wheel。 If you give me
    a source distribution。
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么当它保持差异时，从包安装的角度来看，源分发和轮子之间有什么区别？这就是Python打包生态系统运作的方向。这是我找到的最佳思考方式。我们总是安装一个轮子。如果你给我一个源分发。
- en: the first thing I'm going to do build a wheel from it。 And on the right of the
    question。 should stop files， those dot pi e files be included in a wheel？ And
    the answer to this is yes。 And this is mostly when they are used。 The Python stop
    files are used。 at runtime by the type checker。 And because they actually need
    to be present at runtime。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先要做的就是从中构建一个轮子。关于问题的右边，这些`.pi e`文件应该包含在轮子中吗？答案是肯定的。大多数情况下它们是被使用的。Python的停止文件在运行时由类型检查器使用，因为它们实际上需要在运行时存在。
- en: they need to be within your site packages， platform or platform folder， or the
    purely folder。 And because of this， they should be within the wheel also， because
    their usage is at runtime。 Again。 it's not going to be used by the interpreter
    at runtime， but the type checker uses it at runtime。 or not at runtime， but the
    type checker pulls it from the Python environment when it is running。
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 它们需要位于你的站点包、平台或纯文件夹中。因此，它们也应该包含在轮子中，因为它们在运行时使用。再说一次，虽然解释器在运行时不会使用它，但类型检查器在运行时使用它，或者说在运行时，类型检查器从Python环境中提取它。
- en: Okay。 So going from this， so basically generating a package， it means we will
    have the developer。 source tree。 We're going to build a package。 We're going to
    upload this package in the center。 package store。 Once we generated the package，
    the consume on the target machine site is going to be。 we pull this package from
    the center package store， basically by doing some discovery and download。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以从这里开始，基本上生成一个包，这意味着我们会有开发者源树。我们将构建一个包。我们将把这个包上传到中心包存储。一旦我们生成了包，目标机器上的消费者就会从中心包存储中拉取这个包，基本上是通过一些发现和下载。
- en: mechanism。 If it is a wheel， we go ahead and install the wheel。 If it is a source
    distribution。 then we build the wheel from it。 And then we just follow the same
    line， install the wheel。 and on the target machine。 Okay。 So this also answers
    what's why you should package， ship a wheel。 If you package or ship a wheel for
    your library， it means that there's a lot less work。
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 机制。如果是轮子，我们就直接安装轮子。如果是源分发，我们就从中构建轮子。然后我们只需按照同样的线路安装轮子，在目标机器上。好的。这也回答了为什么你应该打包并发布轮子。如果你为你的库打包或发布轮子，这意味着工作量会少很多。
- en: to be done on the target machine， because now the target machine doesn't need
    to build the wheel。 It can just keep that step and install the wheel straight
    ahead。 This is the reason why wheels。 are much faster to install。 There are other
    benefits that we'll get into this later that you don't need。 to worry about other
    binary dependencies， compilers being available on the machines。
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标机器上完成，因为现在目标机器不需要构建 wheel。它可以直接保留这一步并安装 wheel。这就是为什么 wheel 的安装速度更快的原因。还有其他好处，我们稍后会讨论，你不需要担心其他二进制依赖关系，编译器在机器上可用。
- en: But the primary reason， even for a pure Python project is that if you ship a
    wheel。 the installation， will be faster for the user。 Okay。 So then let's start
    on the first section。 how we build the package。 Okay。 Building a package to understand
    how building the package works。 we first have to kind of like， I'm going to give
    you a brief introduction into the history。
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 但是主要原因，即使对于一个纯 Python 项目来说，如果你发送一个 wheel，用户的安装速度会更快。好的。那么让我们开始第一部分，如何构建包。好的。构建一个包，理解构建包的工作原理。我们首先要给你一个简要的历史介绍。
- en: just so that you understand， some of this concept， understand why we are in
    the state where we are。 And yes， you're again， the Python file should be included
    in the wheel， because the Python file。 is used at the time checkers runtime， and
    it's pulled from the side package's folder。 so it needs to be available in the
    wheel。 Because remember， the only thing that shows up inside the。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了让你理解一些概念，明白我们为何处于现在的状态。是的，你再次，Python 文件应该包含在 wheel 中，因为 Python 文件在运行时被使用，并且它是从侧包的文件夹中提取的。因此它需要在
    wheel 中可用。因为记住，唯一在里面显示的内容是。
- en: side package's folder is what's in the wheel。 If it's not in the wheel， will
    not be available。 within the interpreter installation itself on that machine。
    Okay。 So now， to going back to the。 packaging history， the Python packaging started
    in the year 2000 with the disjutile package。 and the disjutile package was basically
    the predecessor to the setup that pie that we have， today。
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 侧包的文件夹就是在 wheel 中的内容。如果它不在 wheel 中，将无法使用。它是在该机器上的解释器安装中。好的。那么现在回到打包历史，Python
    打包始于 2000 年，最初的包是 disjutile。disjutile 包基本上是我们今天所拥有的 setup.py 的前身。
- en: It was introduced back then， and it was basically provided the setup that pie
    file。 which anyone can write whatever they wanted， and it allowed them to package
    together Python code。 Okay。 Now， the configuration is Python code， which made
    a lot of sense then， because it meant that。 we did not have yet a good packaging
    story， so the users could come up with their own packaging。
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当时引入的，基本上提供了 setup.py 文件，任何人都可以编写他们想要的内容，它允许他们将 Python 代码打包在一起。好的。现在，配置是 Python
    代码，这在当时是非常有意义的，因为这意味着我们还没有一个好的打包故事，所以用户可以提出自己的打包方案。
- en: story。 You had infinite flexibility by having a Python file， and you could write
    anything in。 that Python file。 Then people start to iterate on the disjutile outside
    of the Python。 standard library。 And the main one of the reasons of this is that
    it's much quicker to develop something。 outside of the standard library， because
    you can release it tested much more frequent than。
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 故事。通过拥有一个 Python 文件，你有无限的灵活性，可以在该 Python 文件中编写任何内容。然后人们开始在 Python 标准库之外对 disjutile
    进行迭代。这主要是因为在标准库之外开发某些东西更快，因为你可以更频繁地发布和测试。
- en: the Python interpreter release， release life cycle。 And because of this， one
    setup tools quickly。 became the de facto standard。 Everyone was kind of expecting
    that setup tools。 would kind of just be available on those machines。 And this
    is the reason why when we create a virtual， environment， setup tools is available
    there。
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Python 解释器的发布，发布生命周期。正因为如此，setup tools 很快成为事实上的标准。每个人都期望 setup tools 会在那些机器上可用。这就是我们创建虚拟环境时，setup
    tools 可用的原因。
- en: because everyone was expecting so much that setup tools， is available。 that
    it kind of like became part of the standard， and it's always provided by any。
    virtual environment creator。 Now， wheels were introduced much later。 They were
    introduced in 2014。 until 2014， whenever you installed a distribution， you basically
    took a source distribution。
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因为大家都期望 setup tools 可用，这种工具有点像成为了标准，它总是由任何虚拟环境创建者提供。现在，wheel 是在更晚的时候引入的。它们是在
    2014 年引入的。在 2014 年之前，无论何时你安装一个分发版，基本上都是采用源分发。
- en: and you， installed them the source distribution into your target machine。 And
    obviously。 this had the downside， that you had to run Python code to install code。
    which wasn't to perform it and also， expose some security reasons for security
    concerns。 So that's why in 2014， the wheels were introduced。
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你将源分发安装到目标机器上。显然，这有个缺点，即你必须运行Python代码来安装代码，这并不高效，而且还暴露了一些安全隐患。因此，在2014年，引入了轮子。
- en: as a way to speed up the Python installation story， and also offer more secure
    installation。 of Python packages。 Okay， and then at this point， everything was
    still basically based on the。 setup。py and running Python files and Python code
    during the packaging。 So in 2015， this project。 was started， which is called fleet，
    which started to kind of like tour around and play around with。
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 作为加速Python安装过程的一种方式，同时也提供更安全的Python包安装。好的，到这一点为止，一切基本上仍然是基于`setup.py`和在打包过程中运行Python文件和代码。因此在2015年，开始了一个名为**fleet**的项目，开始探索和尝试。
- en: can we do a declarative over dynamic type of configuration， rather than define
    what should。 happen inside Python code， which where you can write anything， let's
    allow the users to define。 their packages declaratively， kind of like configuration
    files， which is easier to understand。 especially for new users， and it's harder
    to get wrong。 Okay。 And then in 2018， Poetry came。
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否采用声明式而非动态类型的配置，而不是定义Python代码内部应该发生什么？允许用户以声明方式定义他们的包，就像配置文件那样，这对新用户来说更容易理解，也更难出错。好的，然后在2018年，**Poetry**问世。
- en: and Poetry is kind of like the best way I can explain Poetry is Poetry embraces
    the fact that。 we should favor configurability or configuration over imperative
    runtime code running， but Poetry。 also doesn't want to users to understand multiple
    things。 It wants to have a single tool that can。 achieve everything。 And as we
    see later on， inside the， even in the previous one。
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**Poetry**的最佳解释是它接受我们应该更青睐可配置性或配置，而不是命令式运行时代码，但**Poetry**也不希望用户理解多个概念。它希望有一个单一工具可以实现一切。正如我们稍后看到的，甚至在之前的例子中。'
- en: we saw that you could， broke down the packaging story into generating a package。
    uploading a package， downloading a package， installing a package， and as we'll
    see。 the Python packaging authority kind of has its own dedicated， tool for this。
    kind of in line with how the Linux do one thing， but do that one thing very well，
    philosophy。
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到可以将打包故事分解为生成包、上传包、下载包和安装包，正如我们将看到的，Python打包机构有自己专门的工具，与Linux以一种方式做好一件事的理念一致。
- en: but Poetry is the other side of the things is where I'm going to give you a
    single。 tool that can give you everything or the better of the worst。 Okay。 Oh，
    and by the way。 all these links， are actually are in the presentation are actually
    applicable。 so you can look it up and read more， about them if you're interested。
    But other than that。
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 但**Poetry**是另一种事物，我将给你一个可以提供一切或更好结果的单一工具。好的，顺便说一下，所有这些链接实际上都在演示中，都是适用的，所以如果你感兴趣，可以查阅并阅读更多相关内容。但除此之外。
- en: how the build used to work is basically， what used to happen。 let's say before
    the wheels were a thing， is that in order to， or even recently。 in order to build
    Python package， you used to use the Python interpreter， feed it the set of the。
    Python file and then just pass an argument what you wanted to do。 For example，
    this first one is。
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 构建的方式基本上是这样的，假设在轮子出现之前，构建Python包需要使用Python解释器，输入一组Python文件，然后传递你想要执行的参数。例如，第一个就是。
- en: build the source distribution， or the second line here is this is how you would
    build a wheel。 You can see I just called the Python interpreter as the this Python
    file， and then I just pass the。 comment what to do。 Now， one of the problems with
    this is that this actually depends the success of。 this story depends on the Python
    interpreter you're actually using。
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 构建源分发，或这里的第二行是如何构建轮子的。你可以看到，我只是调用了Python解释器作为这个Python文件，然后我传递了要执行的命令。现在，这个故事的成功实际上依赖于你使用的Python解释器。
- en: If the Python interpreter you're， using did not have some dependency， it would
    break。 Because maybe you require set up to 41， but the Python interpreter that
    you use there only had set up to 40。0。 This operation would break， and would break
    with horrible errors。 cryptic errors that are hard to understand for the user。
    And that's why in like 2016 or so。
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的 Python 解释器没有某些依赖，它将会崩溃。因为你可能需要 setup 版本 4.1，但你使用的 Python 解释器只具有 setup
    版本 4.0。这个操作会崩溃，并产生可怕的错误，用户很难理解的神秘错误。这就是为什么在 2016 年左右。
- en: we got into how can we improve this， and the solution to improving， this are
    simple。 We just visited earlier virtual environments rather than just letting
    the user。 use whatever Python they want to do the packaging， we give them a way
    to actually。 define their dependencies and then provision these dependencies inside
    the virtual environment。
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了如何改善这个，改善这个的解决方案是简单的。我们之前访问的虚拟环境，而不是让用户使用他们想要的任何 Python 来进行打包，我们给他们一种实际定义其依赖关系的方式，然后在虚拟环境中提供这些依赖。
- en: So instead of just typing the top one there in the background what we want is
    that we create a。 virtual environment and then we use that virtual environment
    to install the build dependencies。 And then we use this virtual environment with
    the provision build dependencies to actually run。 the packaging logic。 Okay， now
    this is what PEP 5 and 7 are standard ideas and it basically。
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们并不是仅仅在后台输入顶部的那个，我们想要的是创建一个虚拟环境，然后使用该虚拟环境安装构建依赖。然后我们使用这个虚拟环境与提供的构建依赖来实际运行打包逻辑。好的，现在这是
    PEP 5 和 7 的标准想法，基本上。
- en: introduces the pipe project the tom file。 The pipe project that tom file is
    the standard way。 or the not is the dream of the Python packaging authority is
    where all packaging related。 configuration would live， especially the standardized
    parts of the packaging story。 Part of the PEP 5 and 7 it introduced the file plus
    it defined that the require section or。
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了管道项目的 tom 文件。管道项目的 tom 文件是标准方式。或者说，这并不是 Python 打包权威所梦想的地方，所有与打包相关的配置都将在这里，特别是打包故事的标准化部分。PEP
    5 和 7 的一部分介绍了该文件，并定义了所需部分。
- en: the requires key within the build system will contain all your build dependencies。
    So if you。 want to depend on a given version of setup per field or you want any
    other dependencies doing。 your in your packaging this is where you have to define
    them。 Okay， and it uses the tom。 tom file format and mostly because this was is
    not overly complex was standardized。
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统中的 requires 键将包含所有的构建依赖。因此，如果你想依赖于某个版本的 setup.py，或者想要其他任何依赖，这就是你需要定义它们的地方。好的，它使用
    tom 文件格式，主要是因为这并不是过于复杂且已经标准化了。
- en: and that's not conflicted with any existing configuration of file。 Okay， so
    this is the。 build dependency which is great but as you could see beforehand their
    kind of like becomes the。 duality here because they were tuning someone has to
    create this virtual environment has to。 install the build dependencies and then
    invoke the packaging and then the packaging itself is。
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 幌子与任何现有的配置文件没有冲突。好的，所以这就是构建依赖，这很好，但正如你之前所见，这有点像变成了双重性，因为他们在调整，某人必须创建这个虚拟环境，必须安装构建依赖，然后调用打包，而打包本身就是。
- en: happening inside this virtual environment but now we have a backend and the
    front end of this。 operation。 The backend is the part that actually generates。
    that actually generates the package inside that visited virtual environment and
    there are a few。 Python build backends setup tools is one of them， plate is another
    them， trampoline is another them。
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 发生在这个虚拟环境内部，但现在我们有了这个操作的后端和前端。后端是实际生成包的部分，实际上是在该访问的虚拟环境内部生成包，并且有几个 Python 构建后端，setup
    tools 是其中之一，plate 是另一个，trampoline 也是其中之一。
- en: wet reason number them， PDM another hatchling as you can see every day there
    are more and more。 build backends and these are Python library packages that are
    capable of giving some configuration file。 generate me a Python store distribution
    and or a wheel and then there's a build frontends。 the build for frontends are
    the Python application or tool that is able to read the pipe project。
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能改善这个的原因是，PDM 另一个孵化器，正如你所看到的，每天都有越来越多的构建后端，这些是能够生成一些配置文件的 Python 库包，生成一个 Python
    源分发和/或 wheel，然后还有构建前端。构建前端是能够读取管道项目的 Python 应用程序或工具。
- en: tom， generate an insulated build dependency provisioning that is related。 build
    it is related build dependencies inside that environment and then invoke。 that
    backend to actually perform the packaging and build frontends you have the build
    tool which。 is like unify CLI for backend but you also have other packages which
    one and one will create one。
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: tom，生成一个与构建相关的隔离构建依赖项。它与该环境中的构建依赖项相关，然后调用后端来实际执行打包和构建前端，您有构建工具，就像后端的统一CLI，但您也有其他包，其中一个将创建一个。
- en: comment for all of them all those also are function both as a backend and as
    a front end at the same。 time for example， we had trampoline medium are a front
    end and the backend at the same time they。 take care of both of it they can also
    provision you do build dependencies but the other also want。 to build your package
    okay and pip is also a build frontend in this story so when you type in pip。
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些评论同时也作为后端和前端的功能。例如，我们有trampoline medium，既是前端也是后端。它们同时处理两者，也可以为您提供构建依赖项，但其他人也想要构建您的包。好的，pip在这个故事中也是一个构建前端，因此当您输入pip时。
- en: install something pip will be the one which actually going to create your easily
    build environment。 and then call your backend to actually build the third distribution
    or the wheel。 generally the wheel if you have a third distribution and then the
    wheel is what actually gets installed。 okay and talks is also another one we'll
    talk touch on talks a bit later so now once we have。
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 安装某些东西时，pip将会是实际创建您易于构建环境的工具，然后调用您的后端来构建第三方分发或轮子。通常情况下，如果您有第三方分发，那么轮子就是实际被安装的内容。好的，talks也是一个我们稍后会讨论的内容，所以现在一旦我们有了。
- en: this story done the next story is that okay so how does the backend and the
    front end communicate。 each other and as I showed you beforehand historically
    they communicated by the set of that pile file。 and then passing any CLI arguments
    to the set of that pile file now obviously this had some downside。 meaning that
    every interpreter every backend needed to actually implement this protocol they。
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事完成后，下一个故事是，后端和前端如何相互沟通。如我之前所示，他们历史上通过那组文件进行通信，然后将任何CLI参数传递给那组文件。显然，这有一些缺点，意味着每个解释器每个后端都需要实际实现这个协议。
- en: needed to generate a set of the file but the set of the pile file just to communicate
    with the front。 end and this kind of like man that everyone was basically reducing
    the packaging story to the set。 of the pile file and to not have to be burdened
    by that then path 5 on 7/8 was introduced which。 basically means that we define
    the programmatic API for the backend and the front end to communicate。
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 需要生成一组文件，但这组文件只是为了与前端进行沟通，这种方式基本上将包装故事简化为文件集。为了不被这些负担困扰，在7月8日引入了第5条路径，这基本上意味着我们定义了后端和前端之间进行通信的程序化API。
- en: each other mainly instead of using this Python set of the type B this wheel
    we also define a。 build backend interface this defines like a package and then
    a function or a method is what you communicate。 and then when you actually want
    to perform an operation for example you want to build the wheel。 you're able to
    actually call methods on that backend operation to communicate to the backend。
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 彼此之间主要是，除了使用这个Python类型B的集合外，我们还定义了一个构建后端接口，这定义了一个包，然后是您进行通信的函数或方法。当您实际上想要执行某个操作时，例如，您想要构建轮子，您能够实际调用后端操作上的方法与后端进行通信。
- en: basically the front end generates this Python file and call this Python file
    into the easily。 built environment when it wants to communicate with the build
    backend meaning set up to restore。 flip or any of that okay does that make sense
    questions。 okay so if no questions then basically path 5 and 7 is just a better
    interface it replaces the。
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，前端生成这个Python文件，并在想要与构建后端沟通时调用这个Python文件，即设置以恢复或任何其他内容。好的，这有意义吗？有问题吗？好的，如果没有问题，那么第5条和第7条路径就是一个更好的接口，它取代了。
- en: set of the pile invocations with something more standardized and every backend
    and I've defined。 their own key under which they are available as a build backend
    here you can see a few of them。 each location they actually define their keywords
    what means for you is that if you use。 different backends you need to define this
    different backend inside this build backend key on your。
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 定义更标准化的堆栈调用，并且每个后端都定义了自己的关键字，这意味着如果你使用不同的后端，你需要在你的构建后端关键字中定义这个不同的后端。
- en: pyproject。ton file okay so last resort how to build a package pick your build
    backend。 and then use pyproject。ton to specify your build dependencies and your
    build backend interface。 okay and then just follow the documentation of the build
    backend。 exactly have to configure the backend to do what you want it to do okay
    now obviously many of these。
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: pyproject。ton 文件，好吧，所以最后的手段是如何构建一个包，选择你的构建后端，然后使用 pyproject。ton 指定你的构建依赖和构建后端接口。好吧，然后只需按照构建后端的文档来做。显然，许多这些工具实际上也是
    Python 应用程序，因此你想要安装它们以便使用。
- en: tools actually are also Python applications so you want to install them to be
    able to use them。 and to install tools I generally recommend using ppx and to
    install ppx you can use this package。 called ppx in ppx and once you install ppx
    you can just basically use ppx install other dependencies。
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装工具，我一般推荐使用 ppx，安装 ppx 时可以使用这个包，称为 ppx 在 ppx 中，一旦你安装了 ppx，基本上可以用 ppx 安装其他依赖。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_131.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_131.png)'
- en: for example in my case we can say that if I was gonna do this so I can use ppx
    and just do install。
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 例如在我的情况下，我们可以说如果我要这样做，我可以使用 ppx 并直接进行安装。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_133.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_133.png)'
- en: flip and as you see this will basically install flitt inside easily to build
    the environment。 and ton has a question meaning does it make sense to use several
    build backends for one package or。 just choose one to like I don't think you should
    have multiple build backends in the same project。 that being said there might
    be a story of picking something one of the simpler backends。
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 翻转，正如你所见，这基本上会在构建环境中轻松安装 flitt。ton 有一个问题，使用多个构建后端对于一个包是否有意义，或者只选择一个，我认为你不应该在同一个项目中有多个构建后端。不过，可能会有选择其中一个简单后端的故事。
- en: or something that is a simpler packaging story a simple story and no more complicated
    for someone。 there is more complicated in a spirit of like you don't want to use
    the most power for more。 come most complicated build backends all the time because
    that would mean that new people。 who come to that project might find hard to follow
    it and understand it okay so。
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 或者是一个更简单的打包故事，一个简单的故事，不再复杂，对某人来说。如果有更复杂的情形，就像你不想总是使用最强大或最复杂的构建后端，因为这意味着新来的人员可能会发现难以理解和跟随它。
- en: so what is the your gonna ask what is the difference between people install
    user ppx and。 ppx in ppx or have to install ppx in ppx then the question is ppx
    in ppx and i can go back to。
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可能会问，用户安装 ppx 和 ppx 的区别是什么，或者必须在 ppx 中安装 ppx，问题就是 ppx 在 ppx 中，我可以回到。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_135.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_135.png)'
- en: this one it's kind of like a cheat in a sense so the trouble with installing
    something do you。
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有点像是一种作弊，安装某些东西时你会遇到麻烦。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_137.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_137.png)'
- en: use their side packages is so if you do just buy minism - m people list there's
    the shooter。 ppx this might work but the problem is this might break some other
    packages into your user side。 packages because remember you have a single user
    side packages it does mean that if any of the。 other packages in that environment
    require a different dependence is a different versions。
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 使用他们的用户包是这样，如果你只需购买 minism - m 人员列表，这是射手。ppx 可能有效，但问题是这可能会使你用户端的其他包受到影响。请记住，你有一个单一的用户端包，这意味着如果该环境中的任何其他包需要不同的依赖关系或版本。
- en: it means that you're gonna conflict with them and you're gonna either break
    ppx by upgrading。 another of the user side packages or you're gonna break another
    package whenever ppx requires a。 different dependency when something already does
    okay so this is why generally if you want to install。 a tool what you want to
    do like if you want to go totally sure that you're not breaking anything。
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你会与它们发生冲突，你要么通过升级其他用户端包来破坏 ppx，或者你会在 ppx 需要不同的依赖时破坏其他包，而这些包已经存在。因此，这就是为什么通常如果你想安装一个工具，最好确保你不会破坏任何东西。
- en: on your machine the best thing is to just create a virtual environment for example
    you can do。 virtual amp okay and then you can do like vm scripts pip install bpix
    okay and this works perfectly。 fine and then you can be cheeky and now that you
    have ppix on your machine you can actually。 use that to install ppx yeah and i
    can use like this this for okay so this way i installed ppx it。
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是创建一个虚拟环境，例如你可以这样做。virtual amp，然后你可以像 vm scripts pip install bpix 这样做。这样做完全正常，然后你可以聪明一点，现在你在机器上有
    ppix，你实际上可以使用它来安装 ppx，是的，我可以像这样使用这个。
- en: does not actually installing ppx as a user side packages i installed ppx inside
    the insulated。 build environment and now i can just remove this vm thing if i
    want it okay and what i showed you。 here these three lines of first create a virtual
    environment install ppx in that then use that。 virtual environment to install
    ppx and then ppx can manage itself because that's to say like i do ppx。
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上并没有将 ppx 安装为用户端包。我在隔离的构建环境中安装了 ppx，现在如果我想的话，可以随时移除这个虚拟机。这三行的操作首先创建一个虚拟环境，然后在其中安装
    ppx，接着使用那个虚拟环境来安装 ppx，之后 ppx 可以自我管理，因为这就是说像我做的那样，ppx。
- en: list you'll see that ppx actually now also installed by sclord up ppx2 okay
    so these three steps is。 basically what ppx in ppx does it basically just generates
    a virtual environment during the。 installation in which we and uses that to install
    ppx which then means that after you did this。 ppx is now self-contained and manages
    itself to update to work and the benefit of this is that。
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 列表你会看到，ppx 现在实际上也是由 sclord 安装的 ppx2。好的，所以这三步基本上就是 ppx 的功能。ppx 实际上是在安装过程中生成一个虚拟环境，在这个环境中我们使用它来安装
    ppx，这意味着在你完成这些之后，ppx 现在是自包含的，能够自我管理更新，这样的好处是。
- en: you install ppx without breaking anything on your machine and you get free upgrade
    of your ppx because。 whenever you do ppx upgrade all this will upgrade all your
    tools and we'll be make sure that it doesn't。
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在不破坏你机器上任何东西的情况下安装 ppx，并且你可以免费升级你的 ppx，因为。每当你执行 ppx upgrade，所有的工具都会升级，我们会确保它不会。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_139.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_139.png)'
- en: break anything when you use our side packages okay now obviously as i said you
    can do it manually。
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用用户端包时不会破坏任何东西。好的，现在显然如我所说，你可以手动执行这个。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_141.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_141.png)'
- en: create a virtual environment use that to install ppx and then use that virtual
    environment install。
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个虚拟环境，使用它来安装 ppx，然后在你的机器上使用那个虚拟环境。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_143.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_143.png)'
- en: ppx or you can just use this comment which does the same thing okay now once
    you install this now you。
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ppx，或者你可以使用这个注释，它的功能相同。好的，现在一旦你安装了这个，你。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_145.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_145.png)'
- en: have you just want to make sure that you put this path into your path environment
    you don't have to。
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需确保将这个路径放入你的路径环境中，你不必。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_147.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_147.png)'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_148.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_148.png)'
- en: it's perfectly fine if putting it on the path environment it's not more complicated
    it's also。 perfectly fine you can invoke it as a fully qualified path for example
    here i can do like。 i'm gonna do it like flip。exe for example you can see。 so
    that is fine you can use it as a fully qualified path but if you just want to
    type it quickly and。
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将其放入路径环境变量中没有问题，这并不复杂；你也可以将其作为完全限定路径调用。例如，在这里我可以这样做。我会像 flip.exe 这样做，例如，你可以看到。所以这样做是可以的，你可以将其作为完全限定路径使用，但如果你只想快速输入。
- en: easily it you want to put that location of that bin folder onto the your path
    environment variable。
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将那个 bin 文件夹的位置添加到你的路径环境变量上，这样做是完全可以的。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_150.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_150.png)'
- en: okay so in the next part we'll actually do some hands-on development so i would
    like to。 for you guys to try to package what we had before using a flip and for
    this i would like to make。 sure that everyone managed to install a flip by using
    ppx or any other way and they have flit available。
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在接下来的部分，我们将实际进行一些动手开发，所以我希望大家能尝试使用flit来打包我们之前的内容，为此我希望确保每个人都能够通过ppx或其他方式安装flit，并且他们可以使用flit。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_152.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_152.png)'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_153.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_153.png)'
- en: give a few seconds for people to try that out and signal back， so。 okay so i
    assume everyone managed if someone did not having issues just type it into the
    chat。
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 给大家几秒钟来尝试一下，并反馈信号。所以，我假设每个人都成功了，如果有人遇到问题，请在聊天中输入。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_155.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_155.png)'
- en: and maybe we can all pout each other but i kind of like go ahead and try to
    see how this would work。 okay so once you have flit available flit is one of these
    python packaging backends but as you can see。 from this health message it is also
    frontend because it doesn't just package or something it also。 allows me to build
    the package which is actually discussed the responsibility of a frontend okay。
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 或许我们都可以对彼此做出一些抱怨，但我其实更喜欢继续尝试看看这将如何运作。好的，一旦你有了flit，flit是这些Python打包工具之一，但正如你所看到的。从这个健康消息来看，它也是一个前端，因为它不仅仅是打包，它还。允许我构建这个包，这实际上讨论了前端的责任，好吧。
- en: it also allows me to publish it which means it's a more generic tool because
    it doesn't just。 deal with the story of the building a package it's also dealing
    with the story how do i upload that。 package once i have it it may even install
    the package okay now we'll use the in it in this case。 so we'll just do flit in
    it to create a project here we'll say p approximate that's fine enough for me。
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 它还允许我发布，这意味着它是一个更通用的工具，因为它不仅仅是处理构建包的存储，它还处理如何在我有包时上传那个包。它甚至可能安装这个包。好的，现在我们将使用in
    it，在这种情况下。我们将执行flit in it来创建一个项目，我们会说p approximate，这对我来说足够好了。
- en: as a module name auto is all right email is fine it's all right we've had a
    home page。 i'll choose an MIT license and that's it and basically what's happened
    at this point as you might see。 please generate this piperjig。ton file as you
    can see inside this piperjig。ton file it added a few lines， and a section called
    toolflit。
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 作为模块名称，auto没问题，email也可以，没问题，我们有一个主页。我会选择MIT许可证，就这样，基本上在这一点上发生了什么，如你所见。请生成这个piperjig.ton文件，正如你所看到的，这个piperjig.ton文件里添加了一些行，以及一个名为toolflit的部分。
- en: mehta which leads you to believe that this tool chooses to store。 its packaging
    metadata logic its configuration between the piperjig。ton file itself as we see
    later on， this is not always the case we had to redo the same thing and in that
    sense it's very similar。 to flit but for example setup tools have the setup。g
    or the setup。py to actually store such。
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: mehta让你相信这个工具选择在piperjig.ton文件本身之间存储它的打包元数据逻辑和配置，正如我们稍后看到的，这并不总是这样，我们不得不重新做同样的事情，从这个意义上说，它与flit非常相似。但例如，setup工具有setup.g或setup.py来实际存储这些。
- en: configuration values okay so sure once you created this i mean let me just remove
    these environments。 so they don't create issues when i try to package here things
    and i need to remove this。 actually i'm just gonna， delete some parts i basically
    don't want any of these deleted okay so i have a cleaner working。
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 配置值，好吧，当然，一旦你创建了这个，我的意思是让我先删除这些环境。这样在我尝试打包时就不会出现问题，我需要删除这个。实际上，我只是想删除一些部分，我基本上不想删除任何这些内容，好吧，所以我有一个更干净的工作环境。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_157.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_157.png)'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_158.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_158.png)'
- en: directory so i have my as you can see i have my license file i have the python
    file to create。 it and start and i have my piperjig。ton file okay so if i do a
    flit in it oh i already did that。 my bad so if i do a flit build it even you can
    see that the tool even complains what i'm missing。 for example it says cannot
    package a module without a dot string or empty dot string okay let's。
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 目录，所以我有我的，正如你所见，我有我的许可证文件，我有创建它的Python文件并启动，我有我的piperjig.ton文件。好吧，如果我执行flit
    in it哦，我已经做过了。我的错，所以如果我执行flit build，你甚至可以看到这个工具甚至抱怨我缺少什么。例如，它说不能打包没有点字符串或空点字符串的模块，好吧，让我们。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_160.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_160.png)'
- en: add a dot string if it requires one so i just had a dot string my wonderful
    package tool。 yeah or my wonderful， the approximator okay i have a dot string
    i can call again build complain that hey i don't have a。
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个点字符串，如果需要的话，所以我刚刚添加了一个点字符串，我的精彩包工具。是的，或者我的精彩，近似器。好的，我有一个点字符串，我可以再次调用构建，抱怨说我没有一个。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_162.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_162.png)'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_163.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_163.png)'
- en: version that i okay so it's a version variable available i go with version 1。0。0
    cool。
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 版本，我的版本变量可用，我选择版本 1.0.0，太酷了。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_165.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_165.png)'
- en: and once i did that you can see that it printed some outputs but importantly
    you can see in the。 disk folder now i have some wheels okay so let me go to this
    disk and you can see it created two。 things it created both a wheel and a tar
    gz let's have a peek what's inside those files。 if i peek into the wheel file
    it is a wheel it's a zip file so you end because it's a zip。
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我这样做了，你可以看到它打印了一些输出，但重要的是你可以看到在磁盘文件夹中现在有一些轮子。好的，让我去这个磁盘，你可以看到它创建了两个东西，它创建了一个轮子和一个
    tar gz，让我们看看这些文件里面有什么。如果我查看轮子文件，它是一个轮子，它是一个 zip 文件，所以你结束时就是 zip。
- en: file i can use a zip tool to actually peek into it so for example here you can
    see that。 what is inside is just some metadata and px。py file exactly what you
    wanted。 and this is what you're also going to be installing that target side package
    location now as far as the。 other files the tar gz files oh not what i wanted
    this requires a different incantation to show its。
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 文件，我可以使用压缩工具实际查看它，例如在这里你可以看到里面只包含一些元数据和 `px.py` 文件，正是你所想要的。这也是你将要安装的目标侧包的位置。至于其他文件，tar
    gz 文件，哦，这不是我想要的，这需要不同的咒语才能显示出来。
- en: content but this tar there's tdf it will show it that it contains basically
    all the files。 pyproject。com file-by-py-proximate the setup。py and the package
    info okay so cool i have all those three。 files both of them seems to contain
    what i want now that's simple and we already created our first。 package and now
    we could upload these packages and some or just somehow give them to another machine。
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 内容，但这个 tar 文件，它会显示它基本上包含了所有文件。`pyproject.toml` 文件、`setup.py` 和包信息。好的，所以我有这三份文件，它们似乎都包含我想要的。现在很简单，我们已经创建了我们的第一个包，现在我们可以上传这些包，或者以某种方式将它们提供给另一台机器。
- en: and users would be able to use it for example if i do a virtual amp i'm gonna
    make it actually here。 at the moment order and i create here a virtual environment
    i mean this virtual environment i use。 the scraped p-pack install this wheel so
    that we'll actually install the wheel and once this is installed。 it if i start
    the python interpreter let's see i can actually do the approximate import okay。
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将能够使用它，例如如果我做一个虚拟环境，我实际上会在这里创建一个虚拟环境，我使用这个虚拟环境，我用 `pip install` 这个轮子，所以这实际上会安装这个轮子，一旦安装完成。如果我启动
    Python 解释器，让我们看看，我实际上可以做这个近似导入。好的。
- en: and this file is actually now available inside this virtual environment i just
    created okay so。 that's all we need now once we have this view file pp's able
    to install it pp is also able to install。 the sword distribution and i can just
    do that it might actually skip it but you can see here what。 i was talking beforehand
    when you try to install the sword distribution the first thing that happened。
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件现在实际上可以在我刚创建的虚拟环境中使用。好的，所以这就是我们需要的，一旦我们有了这个视图文件，pp 就能够安装它，pp 也能够安装剑分发，我可以直接这样做，可能会跳过，但你可以看到这里我之前说过的，当你尝试安装剑分发时，第一件事情发生了。
- en: is that it installed build dependencies because the first thing that we do if
    you give me sword。 distribution i build the wheel from it and then once i build
    the wheel it even printed out the。 wheel it built that's what actually gets installed
    okay so that's pretty much our first package done。 and dusted now in practice
    you would obviously upload this to like ppy oh christen god so basically。
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 就是它安装了构建依赖，因为我们首先要做的就是，如果你给我剑分发，我会从中构建轮子，然后一旦我构建了轮子，它甚至打印出了它构建的轮子，这实际上就是被安装的东西。好的，所以这基本上就是我们的第一个包完成了。实际上，你显然会将其上传到比如
    ppy 哦，基督教等地方。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_167.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_167.png)'
- en: the version is basically this variable that you need to add。 inside anywhere
    inside your module file see there on 0。0 and at this point now there's one thing
    that。
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 版本基本上是你需要添加的变量。在你的模块文件的任何地方都可以看到这个在0.0的位置，现在有一件事。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_169.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_169.png)'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_170.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_170.png)'
- en: you might see for example which might be important interesting is that considered
    by default the。 name of this wheel contains p2 p3 now what this means is that
    this file this wheel will run both on。
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到，例如，这可能很重要，默认情况下，这个wheel的名称包含p2 p3，这意味着这个文件，这个wheel将在两个上运行。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_172.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_172.png)'
- en: python 2 and python 3 now obviously this is not true because if you look at
    this。 type annotation you know that this only works on python 3 so you can see
    that at the moment we。
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2和Python 3，现在显然这是不对的，因为如果你查看这个类型注解，你知道这仅在Python 3上工作，所以你可以看到目前我们。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_174.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_174.png)'
- en: have a bug in our python packaging because this should not work on python 2
    the way you specify if。 something is working only on a given python version is
    by using the python requires metadata。
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Python打包有个错误，因为这在Python 2上不应该工作。指定某个功能仅在特定Python版本上工作的方法是使用Python要求的元数据。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_176.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_176.png)'
- en: and for to actually see this i need to look up the documentation of flip。 let
    me just go because every front end may specify this dependence in a different
    way。
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际查看这一点，我需要查阅flip的文档。让我去看看，因为每个前端可能以不同的方式指定这个依赖。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_178.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_178.png)'
- en: so here it goes it just be at this and i do something like python or requires。
    or python wait i think it's config file in this one the config part section here
    you can see。 how you can configure various aspects of your package beside what
    the unit already generated。 and for example for us what's important is that there
    was a requires。
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里它就这样了，我做一些像`python`或`requires`。或者`python`等，我认为这是配置文件，在这个配置部分，你可以看到如何配置包的各个方面，除了已经生成的部分。例如对我们来说，重要的是有一个`requires`。
- en: requires python configuration here it's the way now reading the documentation
    we know that。 the way you can specify what version of python this more package
    requires is by using this notation。
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的`requires python`配置是，现在阅读文档我们知道，指定这个模块包需要哪个版本的Python的方法是使用这种表示法。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_180.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_180.png)'
- en: inside the requires python okay so let's do that we're just taking requires
    python。 and we're gonna say it requires 3。9 okay and now build again the package
    okay。
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在`requires python`里面好的，我们就这么做，我们只需添加`requires python`。然后我们将说它需要3.9，好吧，现在重新构建这个包。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_182.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_182.png)'
- en: and now we built again the package and now if i look into this we can see that
    now it actually。 generated a wheel which no longer contains the python 2 which
    is correct because now it。 dis expresses that hey this python file only works
    on python 3。
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们再次构建包，如果我查看这个，我们可以看到它实际上生成了一个wheel，不再包含Python 2，这是正确的，因为现在它明确表示这个Python文件仅在Python
    3上工作。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_184.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_184.png)'
- en: yep so that's the gist of it now。
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这就是要点。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_186.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_186.png)'
- en: in this case as you can see i use flit to build a package but flit serves also
    as a front end。 of the back end the dedicated front end for building packages
    is called build okay and i already。 have installed it so it's gonna complain without
    letting me install it and this shows you that the。 build project is actually available
    on the pyproject。
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，正如你所看到的，我使用flit构建一个包，但flit也作为后端的前端。专门用于构建包的前端叫做build，好吧，我已经安装了它，所以它会抱怨，不让我安装，这显示了构建项目实际上在pyproject上是可用的。
- en: bill executable okay so if i don't want to use the。 field build back end to
    build the wheel and the wheel build the wheel and the service vision。 we can see
    that i can also use the pyproject the deal project which is a generic python package。
    builder to specify that hey build the service middle wheel from this folder okay
    and this as。
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: bill可执行的，如果我不想使用字段构建后端来构建轮子，并且轮子构建服务视图。我们可以看到我也可以使用`pyproject`这个通用的Python包构建工具，指定从这个文件夹构建服务中间轮子。
- en: you see it's gonna take a bit longer and the reason why it's gonna take a bit
    longer is because。 it actually needs to install flit to be able to do the packaging
    beforehand when i did when i use。 flit to build a package i did not need to install
    flit because i was already invoking flit so flit。 was already available but in
    this case that's not the case and there's two runs of this and you can。
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现这会花更多时间，原因是它需要先安装**flit**才能进行打包。当我使用**flit**构建一个包时，我不需要安装**flit**，因为我已经调用了**flit**，但在这种情况下情况并非如此，这里有两次运行。
- en: see like successfully install flit core this is one run and there's another
    one here and the。 reason why there's two run is because the build front end needs
    to create separate build environments。 both for the source solution and the wheel
    distribution so that's why you see the output of this is twice。 the advantages
    of using the pyproject that builds over the built-in flit。build is that the。
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 成功安装**flit core**，这是一次运行，这里还有另一次，之所以有两次运行是因为构建前端需要为源解决方案和轮子分发创建单独的构建环境，因此你看到输出两次。使用`pyproject`构建的优势在于，它的构建超出了内置的**flit.build**。
- en: pyproject that builds will always work on any build back end some of the builds
    back end such。 as setup tools doesn't provide you a built-in front end to build
    your packages and in this case。 you can just the pyproject。build to use make sense？
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyproject.build`将始终在任何构建后端上工作，一些构建后端，如**setup tools**，不提供内置的前端来构建你的包，在这种情况下，你可以使用`pyproject.build`，明白吗？'
- en: okay so it installs flits because it's referenced by the flit yeah so the build
    front end goes into。
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，它安装**flit**是因为它被**flit**引用，所以构建前端进入。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_188.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_188.png)'
- en: this pyproject。town file checks this hey i need flit core greater than equal
    than four less than four。
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`pyproject.toml`文件检查我需要**flit core**大于等于四小于四。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_190.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_190.png)'
- en: and if you check the output of this it's actually that's what it says that collecting
    flit core。
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查输出，实际上就是在说收集**flit core**。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_192.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_192.png)'
- en: less than four greater than equal than two okay and then it uses this build
    back end。 python api to communicate it to the back end that hey build me a wheel
    build my store distribution。
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 小于四大于等于二，然后它使用这个构建后端Python API与后端通信，构建我的轮子，构建我的存储分发。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_194.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_194.png)'
- en: and that's what it's going to put it inside of this folder okay now one question
    that your。 organ has what does the non-anime means and we'll get back to that
    in a way in a short while you're。
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这将放在这个文件夹里。现在你的组织有一个问题，非动漫是什么意思，我们稍后会回到这个问题上。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_196.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_196.png)'
- en: again okay so once we have this one the next part is gonna be like maybe we
    want to we are not happy。 with the performance of our pcalculator let's speed
    it up okay as i seen beforehand python is able to。 import not just python files
    it's able to import binary libraries and this is what the python package。 provides
    it's able to take your python file generate ccode and compile the sequel into
    binary file。
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这一点，下一部分可能是我们对**pcalculator**的性能不满意，想加速。正如我之前所看到的，Python不仅能够导入Python文件，还能导入二进制库，而这正是Python包提供的，它能够将你的Python文件生成C代码并编译成二进制文件。
- en: and then use that module as this ccode and this is a quite a big how should
    i say this this is a lot。 of power because now i can get to free performance improvement
    without doing anything and what happens。 at this time is that the code i'm going
    to be running it's no longer going to be imported from。
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用那个模块作为这个代码，这真是相当大，怎么说呢，这有很多力量，因为现在我可以在不做任何事情的情况下获得免费的性能提升，发生的事情是我将要运行的代码不再会从。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_198.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_198.png)'
- en: a python file but rather from a binary file let's try to do that okay now the
    first thing。
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Python文件，而不是二进制文件，试试看，好的，现在第一件事。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_200.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_200.png)'
- en: that the first thing that we're going to run to it is that flip is not advanced
    enough to build。 c extensions it's not aimed at those users need to build c extensions
    so the first thing we're going。 to do we're going to move the project configuration
    to set up tools okay now the reason why i want to do。 this is also going to show
    us what are the different tests between flick and setup tools and just show。
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们要运行的是flip不够高级，无法构建C扩展，它并不针对需要构建C扩展的用户。因此，我们要做的第一件事是将项目配置移到setup工具中。好的，我想这样做的原因也是为了向我们展示flick和setup工具之间的不同测试，并只是展示。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_202.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_202.png)'
- en: if one of them is more complicated or not that the other okay so， let's try
    to do this。
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中一个比另一个更复杂，没关系，那么让我们尝试一下。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_204.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_204.png)'
- en: give me a second。
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 给我一秒钟。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_206.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_206.png)'
- en: do you want to stop？ okay so what do we need to do to move this to setup tools
    okay so the first thing we need to do is。 we no longer setup tools no longer contains
    this configuration in the pyproject。com。 so we'll need the setup。py file to say
    this is a setup to the users and this is just going to have。 a simpler setup we
    need okay and then we're going to extract out the configuration the static。
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 你想停止吗？好吧，那么我们需要做些什么来将这个移到setup工具？好的，第一件事是，我们不再需要在pyproject.com中包含这个配置。所以我们需要setup.py文件来告诉用户这是一个设置，这只是一个更简单的设置，我们需要的内容。然后我们将提取出配置的静态部分。
- en: information into setup。cfg file and i actually want to do this but to not to
    look up every configuration。 one by one from the documentation i'll cheat here
    a bit and we'll actually copy over the configuration。 from a pre-created one repository
    i'll post that into the chat in case you want to follow along。 or not that one
    wrong repository， but i wanted to here to。
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 信息移入setup.cfg文件，我实际上想这样做，但不想从文档中逐一查找每个配置。我会在这里稍微作弊一下，我们实际上会从一个预先创建的存储库中复制配置，我会把它发布到聊天中，以防你想要跟着做。或者不是那个错误的存储库，但我想在这里。
- en: that's the one i wanted to basically go to this is roughly what i need。 so as
    you can see the name version it's no longer in our description no longer lives
    inside the python。 file itself so now we can remove this we can remove this the
    version moved inside the setup that you。 have the description moved into the setup
    this year we also defined just the read me edit the。
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我想要去的地方，这大致是我需要的。所以如你所见，名称和版本不再在我们的描述中，不再存在于Python文件本身中，因此现在我们可以移除这个，我们可以移除这个，版本移到了setup里，你有描述移到这里，我们还定义了只读的编辑。
- en: author also moved to setup。cfg so this no longer is a thing what are the python
    files。 move the reuse this thing which means the packages are dynamically fine
    so means i can remove now。 this module i think the classifiers also move the setup
    that's gfg like this is a classifier okay。 my requires python also moved to the
    setup that's gfg you can move it over。
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 作者也将配置移到了setup.cfg，因此这不再是一个问题，那么Python文件是什么呢？移动重用这个东西，这意味着包是动态的，因此我现在可以移除这个模块，我想分类器也移动到setup里，像这样是一个分类器。好的，我的需求也移到了setup里，你可以把它移过去。
- en: yeah i'll pass it in a second yeah basically there。 so it does kind of like
    the end goal here we want to reach and then we just need to do one more thing。
    now we need to this is at this point go here and that's about it i think so at
    this point if i use。
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我会稍后传入，基本上在这里。因此，目标是我们希望达到的目标，然后我们只需要做一件事。现在我们需要在这个时候去这里，我想差不多就是这样。所以在这一点上，如果我使用。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_208.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_208.png)'
- en: let me just remove the distribution okay so there's no nothing in the distribution
    so now if i use pipe。
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我先移除分发部分，好的，所以分发中没有任何东西，所以现在如果我使用pipe。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_210.png)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_210.png)'
- en: actually oh one more thing we need to change actually we need to share the build
    system and the build。 backend because we changed that too so i'll just take these
    dependencies let me remove。 site them for now okay so now after doing all the
    changes this should basically give us the same。
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 其实哦，还有一件事我们需要更改，实际上我们需要共享构建系统和构建后端，因为我们也更改了它，所以我会把这些依赖项拿走，暂时移除它们。好的，所以现在做完所有更改后，这基本上应该给我们相同的结果。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_212.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_212.png)'
- en: thing that we had in fleet but what changed that all our configuration now doesn't
    live inside the。
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在舰队中拥有的东西，但改变的是我们所有的配置现在不再存放在这里。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_214.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_214.png)'
- en: setup。py set or doesn't live inside the pipe project the tom but instead it's
    split up between。 the setup。py file and the setup。cfg file， if this is a private
    give me a second to learn make it pop。
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.py`并不在pipe项目的内部，而是分布在`setup.py`文件和`setup.cfg`文件之间。如果这是一个私有的，给我几秒钟时间来学习一下，让它弹出来。'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_216.png)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_216.png)'
- en: change with the build， okay。
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 与构建更改，好的。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_218.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_218.png)'
- en: okay now it should work the link okay so we moved around some of the configuration
    from within the。 source of itself into the setup。cfg and setup。py and change the
    build backend inside the pipe project。
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在链接应该可以正常工作了。我们将一些配置从源文件移动到了`setup.cfg`和`setup.py`中，并更改了管道项目内部的构建后端。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_220.png)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_220.png)'
- en: the tom but pause this once we run the build packaging comment this actually
    ends up with the。 same thing if i look into this folder i have a will file and
    i have a pie approximate file now。
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 但是暂停一下，一旦我们运行构建打包命令，这实际上最终会得到相同的结果，如果我查看这个文件夹，我有一个wheel文件和一个pie近似文件。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_222.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_222.png)'
- en: the exact content of these files might be a big different because here。
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件的确切内容可能会有些不同，因为这里。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_224.png)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_224.png)'
- en: pprox， towards you see that there are some is egg info files which fleet did
    not generate。 and inside the wheel。
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: pprox，往你那边看，你会看到一些是egg info文件，这些是舰队没有生成的。在wheel内部。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_226.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_226.png)'
- en: we have a few other files actually since i actually did not include the。
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些其他文件，实际上因为我没有包括那些。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_228.png)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_228.png)'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_229.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_229.png)'
- en: python file what did i mess up here you see in the wheel you don't have any
    python file actually。
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: python文件，我在这里搞砸了什么，你会看到在wheel中实际上没有任何python文件。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_231.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_231.png)'
- en: okay oh yeah line in the differently pprox， if i do my packaging again you will
    see。
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，哦，是的，行的不同的pprox，如果我再次进行打包，你将会看到。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_233.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_233.png)'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_234.png)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_234.png)'
- en: that now it should include the file inside it。
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它应该包含内部的文件。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_236.png)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_236.png)'
- en: now setup tools is a bit more verbal it actually brings what is doing online
    online。
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在setup工具有点更详细，它实际上在线上说明它在做什么。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_238.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_238.png)'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_239.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_239.png)'
- en: so if something's broken you can actually see this output and debug it to see
    what breaks during。
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果有什么东西坏了，你实际上可以看到这个输出并进行调试，以查看在什么地方出错。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_241.png)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_241.png)'
- en: the packaging but for example you can see that it actually says i'm copying
    this file to this folder。
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 打包，但例如你可以看到它实际上在说我正在把这个文件复制到这个文件夹中。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_243.png)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_243.png)'
- en: then i'm creating a torar archive removing that all that kind of things okay
    and now if i do。
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我创建了一个tar归档，删除所有那些东西。好的，现在如果我执行。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_245.png)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_245.png)'
- en: this wheel you can see now i do have the pprox made pilot part of the wheel
    so now with this change。 we basically got the same thing we had before we migrated
    from flip to setup those okay now。
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这个轮子你可以看到，现在我确实有了 pprox 制作的轮子的一部分，所以现在有了这个更改。基本上我们得到了与之前相同的东西，我们从 flip 迁移到 setup，那就好吧。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_247.png)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_247.png)'
- en: now let's actually try to speed up our logic and the way i'm going to do that
    i'm going to create here。 via correct submit psi okay the way i the reason why
    i do this i'm going to take。 just to show you that both of these working parallel
    i'm going to take the。 this python file and also compile it as a， site and application
    okay and the way i do it and this is something you would look up the documentation。
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实际上尝试加快我们的逻辑，我将通过创建来做到这一点。通过正确提交 psi 好吧，我这样做的原因是我想给你展示这两者并行工作。我将把这个 Python
    文件也编译成一个网站和应用程序，好的，我这样做的方式，你可以查找文档。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_249.png)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_249.png)'
- en: of the site and the documentation of the site and file is you just have to specify
    it in the setup。
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网站及其文档，你只需要在 setup 中指定它。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_251.png)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_251.png)'
- en: dot file that hey by the way i require you to tightenize this extra file and
    let me go into。 setup dot pie and this is something you can do today with the
    configuration file so you must put。 it inside the inside the setup dot pie file
    supposed to have written gas but she put this one in。 and now we need to add our
    build dependencies to the site and now i also depend on the site and。
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: dot 文件，嘿，顺便说一下，我要求你把这个额外的文件紧缩一下，让我进入 setup dot pie，这是一种你今天可以用配置文件做到的事情，所以你必须把它放在
    setup dot pie 文件里，应该写 gas，但她把这个放进来了。现在我们需要将构建依赖项添加到网站，并且我也依赖于该网站。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_253.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_253.png)'
- en: now if i build let's say just a wheel save time here this will actually in the
    background go out。
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我构建一个轮子，节省一些时间，这实际上会在后台进行。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_255.png)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_255.png)'
- en: create the ccode for this application we have and compile it。
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个应用程序创建代码并编译它。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_257.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_257.png)'
- en: did i mess up the naming？ oh extension needs to be different。 i bet the site
    acts which is like the site and extension okay。 so now we try to run this we see
    that this should， work better still needs to mess up something。 here broad side
    pie doesn't change files oh really good at making typos today。
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我是不是搞错命名了？哦，扩展名需要不同。我敢打赌这个网站的行为就像这个网站和扩展名一样。好吧，所以现在我们尝试运行这个，我们看到这个应该更好，但仍然需要搞乱一些东西。这里，宽边饼没有更改文件，今天真的很擅长打错字。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_259.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_259.png)'
- en: spikes。
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 峰值。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_261.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_261.png)'
- en: there are times is the lucky charm no oh yeah you can see so if i look into
    the folder now you see。
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候这就是幸运符，哦耶，你可以看到，所以如果我现在查看这个文件夹，你会看到。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_263.png)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_263.png)'
- en: that it actually created the c file and as some of you might be available the
    python interpreter。 the one maintained by the python software foundation is actually
    written in c so if we translate the。 python to the ccode and compile it and run
    that allows us to do optimizations which make our code。
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上创建了 C 文件，正如你们中的一些人可能知道，Python 解释器由 Python 软件基金会维护，实际上是用 C 写的，所以如果我们将 Python
    转换为 C 代码并编译运行，这允许我们进行优化，使我们的代码。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_265.png)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_265.png)'
- en: faster so you can see this quite a long c file but you don't have to actually
    understand it。
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 更快，所以你可以看到这是一个相当长的 C 文件，但你不必真正理解它。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_267.png)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_267.png)'
- en: at the end of the day what's happening if you look into the。 wheel that you
    generated is just that from that python file it creates this pie defile。 and this
    pie defile is something that we can import and run and let me do that let's go
    back to our demo。 think and here i'm gonna install， i want it but i'm gonna em
    trips pip install this let's provide that wheel and now if i start this。
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 到头来，如果你查看生成的轮子，实际上就是从那个 Python 文件创建这个 pie 文件。这个 pie 文件是我们可以导入和运行的，让我来做吧，我们回到我们的演示。想想看，这里我要安装，我想要，但我要通过
    pip 安装这个，让我们提供这个轮子，现在如果我启动这个。
- en: interpreter and i do import the approach sigh sigh what happened。 i think so
    this is a good example i actually see you can always check out what was installed。
    i think i installed it right here so i think the， it could be that setup tools
    did not install it and i can check by going there and see and see like。 look it's
    not actually there so what could be here the case is the setup tool decided that
    doesn't。
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器和我导入的方法，唉，发生了什么。我觉得这是一个很好的例子，我实际上看到你总是可以检查已安装的内容。我认为我就在这里安装了它，所以我想，可能是安装工具没有安装它，我可以去那里检查一下，看看，实际上并不存在，那么这里可能的情况是安装工具决定不安装它。
- en: need to install it so i can do a four-strain install really convinced that hey。
    install it oh wait no i know what it is my bad and it do install not this version
    the。 universe of one but now i need to install this version and this is where
    your guns earlier question。 came what is that none and any meaning okay and that
    none and any is basically the abi compatibility。
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 需要安装它，所以我可以做一个四串安装，真的相信，嘿，安装它。哦，等等，我知道是什么，我的错，实际上不是这个版本，而是宇宙的一个，但现在我需要安装这个版本，这就是你们早些时候的问题出现的地方。那*none*和*any*的意思是什么？好的，*none*和*any*基本上是ABI兼容性。
- en: thing it basically specifies what python compilation and and nioness is this
    will。 compatible with and what platform is compatible with it for example this
    one states this wheel。 is good for c python 3。9 and also requires windows 64 bits
    operating system okay and not。 and any basically means that it's independent of
    the python implementation or the platform。
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这个东西基本上指定了什么Python编译和nioness与之兼容，什么平台与之兼容。例如，这个声明这个轮子适用于C Python 3.9，并且还需要64位的Windows操作系统，好的，*并且*基本上意味着它独立于Python实现或平台。
- en: any is for the platform independent it works on any platform and none means
    we don't depend on。 any python implementation and cp 39 means c python 3。9 that
    clear so if i install this one。 and i can do a four-strain install just to replace
    it and now if i do。 vm scripts python extra and import p， crooks sigh you can
    see that this actually now imported。
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 任何平台都可以使用，它在任何平台上工作，而*none*意味着我们不依赖于任何Python实现，*cp 39*意味着C Python 3.9，这样清楚吗？所以如果我安装这个，我可以做一个四串安装来替换它，现在如果我做`vm
    scripts python extra`并导入p，*crooks*，你会看到这实际上现在已经导入了。
- en: and see and it's actually backed by this pi d file which is a binary dependency
    i can also find out。 what importer was used with the loaded for example in this
    case it was actually loaded by this extension。 file loader which is a variant
    of what's capable of loading this binary files if i would。 i don't know if i would
    use the other one which was if i would import p approximate and i would check。
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 看看，它实际上是由这个pi d文件支持的，这是一个二进制依赖项，我还可以找出使用了哪个导入器加载的。例如，在这种情况下，它实际上是由这个扩展文件加载器加载的，这是能加载这些二进制文件的变种。如果我，我不知道我是否会使用另一个，如果我导入p近似并检查。
- en: the loader on this one you see that this actually uses a source file loader
    okay。 yes you can see different loaders are used to manifest different back end
    independently but。 independent of what i use now both of them are working and
    i can use for example。 just to all it is actually works and i can use。
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个加载器上，你会看到它实际上使用了源文件加载器。好的。是的，你可以看到不同的加载器被用来独立地表现不同的后端，但独立于我现在使用的这两者都在工作，我可以使用例如，实际上都可以使用。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_269.png)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_269.png)'
- en: oh not the same file approximate pile。
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，不是同一个文件，近似文件。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_271.png)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_271.png)'
- en: and this now is much faster than the previous one now here measuring it might
    be not as easy so you。 might use the by me module but basically here's probably
    around let's say 70 to 80 percent of。
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这比之前的快得多，现在在这里测量可能没有那么简单，所以你可能会使用`by me`模块，但基本上这里大概是70%到80%的提升。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_273.png)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_273.png)'
- en: performance improvement you can get if you just feed it a raw python file with
    basic type annotations。 to tighten and what you get back from it okay questions
    related to that。
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给它一个带有基本类型注释的原始Python文件，可以得到的性能提升。这样你得到的结果怎么样？好的，关于这个的问题。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_275.png)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_275.png)'
- en: no questions okay so for example here is a bit of benchmarking i did by using
    the time。
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 没有问题。好的，所以这里是我用时间做的一些基准测试。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_277.png)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_277.png)'
- en: it module but you can see from 105 millisecond for calculating the million precision
    or the。 iteration i managed to shift it down to 70 millisecond now doing this
    going down to the。 sea level does have a downside because it does mean that now
    i have to generate now the。 wheel that i'm generating it's only valid for my current
    platform and it will not work on any。
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 它模块，但你可以看到，从105毫秒计算百万精度或迭代，我成功将其降至70毫秒。现在，下降到海平面确实有缺点，因为这意味着我现在必须生成的轮子仅对我当前的平台有效，并且不适用于任何其他平台。
- en: other platform so if i want our users to not have to build their own wheel on
    their own machine。 and in order to do that you need to have a C++ compiler available
    and the header files for python。 available i need to ship a wheel for every possible
    platform and you might say that that's not that。 hard because you have like windows
    macro asset Linux whatever but it's a bit more complicated。
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 其他平台，所以如果我希望我们的用户不必在自己的机器上构建自己的轮子。为此，你需要有一个C++编译器和Python的头文件可用，我需要为每一个可能的平台提供一个轮子。你可能会说这并不难，因为你有Windows、macOS、Linux等，但这要复杂一些。
- en: than because it also includes potential future platforms which you're not even
    aware of for example。 when apple introduced their new m1 platforms last year those
    new platform because it's a。 totally different architecture did mean that none
    of the mequas previous mequas generated wheels。 work for that platform okay so
    there are some downside going down to the binary level but if。
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它还包括一些你甚至不知情的潜在未来平台。例如，当苹果去年推出他们的新M1平台时，这些新平台因为完全不同的架构意味着之前生成的mequas轮子对该平台无效，好的，因此在二进制级别确实有一些缺点。
- en: you can what it does offer also some performance benefit okay now as far as
    uploading the package。 we could already see beforehand flit offers just the upload
    comment which works but generally from a。
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 它也提供了一些性能上的好处，好的，现在就上传包而言。我们可以提前看到，flit提供了只上传的命令，它是有效的，但通常从。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_279.png)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_279.png)'
- en: pipeline point of view the tool to be used to install to the pipeline it's basically
    the。 twine package and twine be something like that oh let me actually go up one。
    i would just use twine application to hey upload this package okay and if。 oh
    sorry i can also first validate it i won't check i think it's called。
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 从管道的角度来看，用于安装到管道的工具基本上是twine包，twine可以是类似这样的东西。哦，让我实际上先往上走一步。我会用twine应用程序上传这个包，好的，如果……哦，对不起，我还可以先验证它，我不检查，我想它叫做。
- en: can you check to check my wheel looks all right for the pipeline point of view。
    but after that i can use twine to actually， and you can see it even says a warning
    that long description is main thing but after then i can just。
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查我的轮子在管道的角度看起来是否正常。但在那之后，我可以使用twine实际进行上传，你甚至可以看到它发出了一个警告，长描述是主要内容，但之后我可以直接。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_281.png)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_281.png)'
- en: twine to upload it and here you might enter your user name and password to actually
    go through with it。 or you might even set up your two-factor authentication or
    a pike depending on your level of security you。
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 使用twine进行上传，这里你可以输入你的用户名和密码以便实际进行操作。或者你甚至可以根据你的安全级别设置两步验证或其他安全措施。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_283.png)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_283.png)'
- en: wish to have the example documentation on that how to do that on the papi。org
    website okay so。
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在papi.org网站上看到如何进行此操作的示例文档，好的。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_285.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_285.png)'
- en: based on that and someone pointed out it flit published yeah but i don't have
    a flit project。
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，有人指出它是flit发布的，但我没有flit项目。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_287.png)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_287.png)'
- en: anymore so it doesn't work similarly the strength or downside of poetry would
    be that poetry is the。 same poetry also if you check the help of it has a lot
    of comments so you can use poetry itself to。 build your package to upload your
    package basically to do anything with your package。 while if you're using set
    up tools you would have to use twine you'd have to use the build project to。
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 因此它不再工作。同样，poetry的优缺点是，poetry也是如此，如果你查看它的帮助文档，会发现有很多评论，因此你可以使用poetry本身构建你的包，上传你的包，基本上对你的包进行任何操作。而如果你使用setup工具，你需要使用twine，并且需要使用构建项目来完成。
- en: build the one you have to use twine to upload one but those packages are potentially
    more powerful。 especially for cextension okay now that doesn't mean that flit
    or set up tools is not going to be。
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 构建你必须使用 twine 上传一个，但这些包可能更强大。尤其是对于 cextension。好的，这并不意味着 flit 或 setup tools 不会存在。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_289.png)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_289.png)'
- en: just as strong as someday but we are not the area okay now on the other side
    actually install packages。 we need first need to discover and download the package
    for human discovery which isn't just。
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 并不如有一天那么强大，但我们并不在这个领域。好的，现在在另一边，实际上安装包。我们首先需要发现并下载包，而人类的发现并不仅仅是。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_291.png)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_291.png)'
- en: the papi package as even here was so and you have the search one but what the
    machine does is not。
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: papi 包，甚至这里也是如此，你有搜索的那个，但机器做的事情并不是。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_293.png)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_293.png)'
- en: that it actually goes to the papi simple repository api for example to the build
    project that will。 close a few here for the build project you can see that i can
    go to this url and i can see all the。
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上它会去 papi simple 存储库 API，例如构建项目。关闭一些这里的构建项目，你可以看到我可以访问这个网址，并且我可以看到所有的。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_295.png)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_295.png)'
- en: packages uploaded to the papi by visiting this web page and this is what the
    machine check。 so if the machine doesn't see one of these packages it means that
    it's not available on this。 this url what more than that the library doesn't just
    see this one what it sees is actually。
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问这个网页上传到 papi 的包，这就是机器检查的内容。所以如果机器没有看到这些包中的一个，这意味着它在这个网址上不可用。此外，库不仅仅是看到这一点，它实际上看到的是。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_297.png)'
  id: totrans-498
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_297.png)'
- en: it's actually distinct here the html itself and as you can see this html contains
    much more than。
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上在这里是不同的 HTML，正如你所看到的，这个 HTML 包含的内容远不止。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_299.png)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_299.png)'
- en: just the links to these libraries it also contains these data requires entries
    so by the front end。 actually parts of the data requires it's even aware if some
    of these packages are compatible。 with a given python version or not okay so this
    is like what the machine actually does to discover。
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 只是这些库的链接，它还包含这些数据所需的条目，所以通过前端。实际上这些数据所需的部分，它甚至知道这些包是否与给定的 Python 版本兼容。好的，这就像机器实际是如何发现的。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_301.png)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_301.png)'
- en: and download the package and therefore it's telling a package that basically
    just boils down to extracting。 that wheel copying some files in some location
    and then just generating the console scripts or。 the entry points to the application
    potentially there are other installers available for example。 one of the reasons
    why virtual amp can be as fast creating virtual environments is because it has。
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 并下载包，因此它告诉一个包，基本上就是提取。那个 wheel，复制一些文件到某个位置，然后生成控制台脚本或。应用程序的入口点，潜在地还有其他安装程序可用。例如。虚拟环境创建得如此迅速的原因之一是因为它有。
- en: its own real installer within it that's optimized to work on the real virtual
    amps need to handle okay。 so yeah then just a bit of a bonus content how would
    you test your library oh what is this between papi and papi。 I think just for
    opagani I would encourage you to like share that one yeah I encourage you to。
    compare your python if you compiled exactly what we had here just check that this
    is what you pass。
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 它自己的真实安装程序，经过优化以在真实的虚拟环境中工作。好的，所以是的，然后有一点额外的内容，你如何测试你的库，哦，这个 papi 和 papi 之间是什么？我认为只为
    opagani，我鼓励你分享那个，我鼓励你。比较你的 Python 如果你编译的正是我们在这里所拥有的，只需检查这就是你所传递的。
- en: thing into your setup that by if not you could just download that project and
    try to make that run。 that should be correctly configured and should work I even
    set up for it some actions to validate it。 so I'm fairly confident it would work
    or just compare it with the link I posted in the chat。 to make sure it works correctly
    and you did not have any differences compared to that。
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 将内容放入你的设置中，如果没有的话，你可以直接下载那个项目并尝试让它运行。它应该被正确配置并能够工作，我甚至为它设置了一些操作来验证。所以我相当有信心它会工作，或者你可以将其与我在聊天中发布的链接进行比较，以确保它正常运行，并且你没有任何与之不同的地方。
- en: now the difference in papi and papi is that papi installs python packages while
    papi installs python。 tools in a sense that it creates a virtual environment and
    installs a tool with all its dependencies。 into that virtual environment so this
    indirection of creating a virtual environment is what papi does。 more than papi
    okay now as far as testing your library generally how you would test your library。
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，papi 和 papi 之间的区别在于，papi 安装 Python 包，而 papi 安装 Python 工具，从某种意义上说，它创建一个虚拟环境并在该虚拟环境中安装工具及其所有依赖。因此，创建虚拟环境的这种间接性就是
    papi 所做的，而不仅仅是 papi。好的，现在就测试你的库而言，通常你会如何测试你的库。
- en: you would first create a virtual environment it's kind of like what I was doing
    while presenting。 this tutorial is create a virtual environment build your will
    or store distribution installs your。 store distribution and then you would install
    your test dependencies and then run your test suite。 you can see these are like
    these four five comments that you kind of like have to keep in your mind。
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会创建一个虚拟环境，这有点像我在展示本教程时所做的。创建一个虚拟环境，构建你的 wheel 或存储分发，安装你的存储分发，然后你会安装你的测试依赖项，然后运行你的测试套件。你可以看到这些是你必须牢记的四到五个命令。
- en: and know how to do or better yet just use this cool tool called talks which
    is basically allows you。 to define all these type of steps inside the configuration
    file for example here you can define。 that i want python 3。9 as my test environment
    and i'm going to use this isolated build environment。 which is just basically
    use everything i was talking about in this tutorial and then define。
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 并且知道如何去做，或者更好的是，使用这个很酷的工具叫做 talks，它基本上允许你在配置文件中定义所有这些步骤。例如，在这里你可以定义我想要 Python
    3.9 作为我的测试环境，并且我要使用这个隔离的构建环境，这基本上就是使用我在本教程中所谈到的所有内容，然后定义。
- en: the dependency what is the comment and once you do this talks will be able to
    you can just install。 talks and then just type in talks and talks will do automatically
    all of this setup and run operation。 okay oh agony you should not run python setup。py
    build what you should do is you should run。 papi project that build will and i
    said before and earlier uh sure not real it's generally not。
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系是什么注释，一旦你这样做，talks 就能够工作。你只需安装 talks，然后输入 talks，talks 将自动完成所有设置和运行操作。好的，哦，痛苦，你不应该运行
    `python setup.py build`。你应该做的是运行 `papi project`，这个构建将会，如我之前所说，通常并不是真的。
- en: recommended to interact with the build back end directly i don't recommend you
    to call the setup。py。 okay like instead of doing python setup。py build you should
    do papi project that。 there's this real dot two and use the build tool which knows
    how to make sure everything is setup and。 working okay yeah and i recommend generally
    if you want to test your library just looking to the。
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 建议直接与构建后端互动，我不建议你调用 `setup.py`。好的，不要像这样做 `python setup.py build`，你应该做 `papi
    project`。有这个 `real.2`，并使用构建工具，它知道如何确保一切设置和正常工作。好的，是的，我一般建议如果你想测试你的库，可以看看。
- en: talks tool it's a great way to define declare inside some configuration file
    how you should set up run。 and run for multiple python environments your project
    project test suite okay now as far as。 before it always publish both will and
    the store distribution and the reason for this is that sometimes。 wheels are banned
    in various environments for example many enterprise environments don't accept。
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: talks 工具是一个很好的方式来定义和声明在某些配置文件中你应该如何设置和运行。并且可以为多个 Python 环境运行你的项目测试套件。好的，就像之前提到的，始终发布两者，wheel
    和存储分发，原因是有时在各种环境中，wheel 是被禁止的，例如许多企业环境不接受。
- en: installing wheels because they view it as a security potential security hold
    or so it's you want to。 store distribution to be available when a new platform
    comes along and or that reason you。 polish your distribution just for the sake
    of being auditable as far as the test suite and yeah and。 always ship your test
    suite with your source distribution so that whenever someone builds a。
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 wheel，因为他们将其视为潜在的安全隐患，因此你希望在新平台出现时存储分发能够可用，因此你打磨你的分发只是为了可审计性，就测试套件而言，是的，始终将你的测试套件与源分发一起打包，以便无论何时有人构建一个。
- en: wheel they can use your test suite to validate that their wheel build was correct
    okay was that。 any questions if not we'll take five minutes break everyone grab
    a coffee move your likes a bit。 and then we'll come back to wrap it up with creating
    an application。 so to answer in the break kind of like I'll put to answer your
    main questions how do you configure。
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用你的测试套件来验证他们的wheel构建是否正确，好吗？有没有问题？如果没有，我们休息五分钟，大家去喝杯咖啡，活动一下，然后我们回来总结一下创建应用程序的内容。所以在休息时，我会回答你的主要问题，如何配置。
- en: that your source distribution ships the test but the wheel does not and the
    answer is depends on your。 build back end where tree and flit has the policy that
    it ships all the files in your source directory。 so within the source distribution
    but then it uses custom logic what to ship inside the side packages。 for the within
    the wheel as far as setup tools goes setup tools is a bit more complicated。
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 你的源分发中打包了测试，但wheel中没有，答案取决于你的构建后端。tree和flit的策略是将源目录中的所有文件打包在源分发中，但然后它使用自定义逻辑决定在wheel内打包哪些内容。至于设置工具，设置工具会复杂一些。
- en: because setup tools by default doesn't ship anything and that's way with the
    setup tools what you do you。 often have another configuration files which is configuration
    file which is specific to setup tools。 only in this manifest that in file and
    if this manifest that in file where you specify what to。 include in your store
    distribution so if you do something like graph for example test。
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 因为设置工具默认不打包任何内容，所以使用设置工具时，你通常会有另一个配置文件，这个配置文件是特定于设置工具的。在这个manifest.in文件中指定你想要包含在源分发中的内容，所以如果你做一些像测试的事情。
- en: that would ship everything in your test folder into the store distribution but
    would not ship it。 into the wheel because what shipped into the wheel is governed
    by this find module or this pie modules。 here。 Opegani you want to install pipe
    project that build with pippics and make sure that it's available。 Oh and the
    third one actually everything。 There will be an answer。
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把你测试文件夹中的所有内容打包进源分发中，但不会打包进wheel，因为打包到wheel中的内容受这个查找模块或这些py模块的控制。Opegani，你想安装用pippics构建的pipe项目，并确保它可用。哦，第三个实际上，所有的内容。将会有一个答案。
- en: I can say it again because we're in the break。 Basically， it is setup tools
    the manifest。in file is the what controlling what gets installed into your。 source
    distribution or what gets included in your source distribution so if you include
    stuff。 by using the manifest。in that only goes into your store distribution what
    goes into your wheel。
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以再说一遍，因为我们在休息中。基本上，它是设置工具，manifest.in文件控制着什么被安装到你的源分发中，或者什么被包含在你的源分发中，所以如果你使用manifest.in来包含东西，那只会进入你的源分发，什么会进入你的wheel。
- en: will be what is defined by the pie modules here or the find logic。 Makes sense？
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 将会由这些py模块或查找逻辑定义。明白吗？
- en: So in case of the setup tools and these skills the manifest。in is what。 configures
    what goes into the store distribution and this goes both ways if you don't want
    to include。 something in your source distribution such as your CI files you would
    use this manifest。in file to。 exclude it。 Okay。 So I just had a question in the
    meantime that。
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在设置工具和这些技能的情况下，manifest.in就是配置什么进入源分发的文件，这两者是相互关联的。如果你不想在你的源分发中包含某些内容，比如CI文件，你会使用这个manifest.in文件来排除它。好吧。所以我在此期间有个问题。
- en: does pip install there's this editable work the same if my project is set up
    to split or set up。 tools。 Pip install there's this editable as tends to only
    work for set up tools and these。 two tools。 Pip install there's this editable
    it's a non-standard editable install mode and。 it's not it only works with setup
    tools。 Now fleet may be able to work around this and generate。
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: pip install的可编辑安装模式是否相同，如果我的项目设置为分离或设置工具。pip install的可编辑安装模式通常只对设置工具和这两个工具有效。pip
    install的可编辑安装是非标准的可编辑安装模式，仅适用于设置工具。现在，flit可能能够绕过这个问题并生成。
- en: other mechanism but is not supported by the standard ways of doing this。 Now
    we're not too far to make。
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 其他机制但不被标准方式支持。现在我们还不算太远。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_303.png)'
  id: totrans-522
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_303.png)'
- en: that reality though because the dream here is there's a pep which introduces
    editable installs。 I want to show you like 650 or something。 Let me look that
    up。 Of 650。
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 现实中这个梦是有一个引入可编辑安装的pep。我想给你展示大约650个。让我查一下。总共是650。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_305.png)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_305.png)'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_306.png)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_306.png)'
- en: Anyway， there's a discussion。 By the way if anyone wants to or not that one
    there's a discord link too but。 if anyone has any packaging questions problems
    that you're running into it your best way or location。
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，有一个讨论。顺便说一下，如果有人想要或者不想，那边也有一个Discord链接。如果有人遇到任何打包问题，最好的方法或位置就是这里。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_308.png)'
  id: totrans-527
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_308.png)'
- en: to ask help is going to be the packaging section within the Python discuss web
    server。 And for example here you can see there's a discussion going on for editable
    installs。 and this is what will allow all tools to provide editable installs。
    So not today but maybe by next。 year Pip install there's this editable will work
    the same way for all the backends。
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 请求帮助将涉及到Python讨论网络服务器的打包部分。例如，在这里你可以看到关于可编辑安装的讨论。这将使所有工具能够提供可编辑安装。因此，今天不行，但也许明年Pip安装时，这个可编辑功能将以相同方式适用于所有后端。
- en: Yeah just looking trying to find the oh maybe let's start。 But this is a pep
    I doesn't have a number， yet which actually tries to come up with a standardized
    way how to define a。 editable installs but there's not defined yet。 Yeah when
    would it end？
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，只是在寻找哦，也许我们开始吧。但这是一个PEP，目前没有编号，实际上试图提出一种标准化方法来定义可编辑安装，但尚未定义。那什么时候结束？
- en: We started a bit later so I was hoping for a 15 minute extension but if you。
    want to if you have to leave feel free to leave I'll personally will try to use
    an extra of 50。 minutes just to go to what we have left okay。 Okay is there a
    reason to still use the Py project at on file where everything is in。 setup。py。clg
    yes you can put everything in the in the setup。py and setup。clg this part。
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始得晚了一点，所以我希望延长15分钟，但如果你需要离开，请随意离开。我个人会尽量多用50分钟，尽量讲完剩下的内容。好的，还有理由继续使用Py project
    at on文件，而不是将所有内容放入setup。py。clg吗？是的，你可以将所有内容放入setup。py和setup。clg中。
- en: the build system definition the requires and the build backend must be in the
    py project。ton file。 Now you can move everything else out of it into the setup
    the cfjset。py but these two must exist here， and there's also a standard which
    was introduced a few months ago which aims that in wants to。 provide the standardized
    ways inside the py project。
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统定义中的要求和构建后端必须在py project。ton文件中。现在你可以将其他所有内容移出，放入setup。cfjset.py中，但这两个必须在这里存在，并且几个月前引入了一个标准，旨在提供py
    project中的标准化方法。
- en: ton file so all the backends may use this py project。ton。 file where they define
    their build dependencies that kind of stuff that's probably going to take a few。
    years until all the tools adopted but maybe in a year's time it will be possible
    to actually drop。 both set of the py and setup。clg and still use setup tools and
    put everything in the py project。
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: ton文件，因此所有后端可能使用这个py project。ton文件，在这里定义它们的构建依赖项等。这可能需要几年时间才能让所有工具采纳，但也许在一年的时间里，将可能实际删除py和setup。clg两个文件，同时仍然使用setup工具，并把所有内容放入py
    project。
- en: ton file， that's where we're kind of heading but we're not there yet for today
    for setup tools still。 keep using setup。py setup。clg and py project。ton together
    okay so the math i'm sorry this is so。 baganios um the question that i have is
    right now when i try to do pipx install py project build。 it says it has a version
    known do i have to put it in the manifest？
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: ton文件，我们正在朝这个方向发展，但今天仍未达到，因此对于setup工具，仍然需要一起使用setup。py、setup。clg和py project。ton。抱歉，这个问题有点复杂，我的问题是，当我尝试执行pipx
    install py project build时，它说它的版本已知，我是否需要将其放入清单中？
- en: i would have to have a look at it can you reach out to me after the tutorial
    and we can discuss。 that okay i just put it in the chat and then we can talk here
    i'm just going from did have。 exactly yeah i don't know where it will get back
    to you after the tutorial because might。 require a bit more debugging okay okay
    so going into the creating an application so as i said before。
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我得看看，你能在教程后联系我吗？我们可以讨论这个问题。好的，我刚刚把它放在聊天中，我们可以在这里讨论。我只是过来了一下，确实不知道我何时能在教程后回复你，因为可能需要更多调试。好的，好的，那么进入创建应用程序，正如我之前所说的。
- en: this is what you had for the library and this more or less works great but let's
    see what about。 an application now as for application we touched on beforehand
    is an application runs with the latest。 compatible or library runs with the latest
    compatible dependencies mostly because it might need to。 coexist with other libraries
    that have different version dependencies it need to that's why it。
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你为库所拥有的，这种方式或多或少运行良好，但我们来看看关于应用程序的情况。就应用程序而言，我们之前提到过，应用程序与最新的兼容依赖项运行，或者库与最新兼容依赖项运行，主要是因为它可能需要与具有不同版本依赖项的其他库共存。
- en: tests with the latest compatible dependencies just to make sure that it wasn't
    broken and need to。 expose all modern features as they are and needs to be installed
    actually with an application。 this is not the case it doesn't need to be installed
    because it doesn't need to be discoverable the。 Python important system and it
    can find to run with a single type set of dependencies doesn't need to。
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 测试最新兼容依赖项只是为了确保它没有被破坏，并且需要实际上与应用程序一起安装所有现代功能。这种情况并不适用，因为它不需要被安装，因为它不需要被发现。Python重要系统可以找到并运行一个单一类型的依赖项，不需要额外的依赖。
- en: run with the latest dependencies and test with the given set of dependencies
    is totally fine。 the application needs to expose the need to expose only a single
    entry point it's not the case that。 you have to run you have to be able to run
    any functions within that Python file and ideally。 should just be as simple for
    the end user just hey download this file copy this file and execute it。
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最新依赖项运行并测试给定的依赖集是完全可以的。应用程序需要只暴露一个单一入口点，并不意味着你必须能够运行该Python文件中的任何函数。理想情况下，对于最终用户来说，这应该是如此简单：只需下载这个文件，复制这个文件，然后执行它。
- en: okay so one way you can actually ship your application is to treat it as a library
    and just use the。 library's console entry points and ui entry points the downside
    with this is that you need to understand。 the user that's using your application
    needs to understand virtual environments to actually make。 it work and potentially
    to if something breaks needs to understand virtual environments to fix it。
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以你实际上可以通过将你的应用程序视为库，并使用库的控制台入口点和用户界面入口点来发货。这种方式的缺点是你需要理解使用你的应用程序的用户需要理解虚拟环境才能使其工作，潜在地，如果出现问题，需要理解虚拟环境以修复它。
- en: it needs to know where those entry points get generated the console and the
    GUI entry points。 it needs to know which might require them mangling their own
    system path which might be a bit of an。 advanced set functionality and the dependencies
    in case of if you treat it as a library are not。 pinned meaning that you might
    have a different dependency than user that's running and that might。
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 需要知道这些入口点是如何生成的，控制台和GUI入口点。需要知道这可能需要他们修改自己的系统路径，这可能是一个相对高级的功能，并且在将其视为库的情况下，依赖项是未固定的，这意味着你可能拥有与运行的用户不同的依赖项，这可能会导致问题。
- en: not work at a later time now you can still deploy your application as a library
    if you manage to solve。 these issues by using another system for example if you
    build a docker image and you give this。 docker image to the user then it's perfectly
    fine to ship your application as a library。 treat as a library install it as a
    library and then just this frozen docker image is what's gonna be。
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会在以后的时间内工作，现在如果你设法解决这些问题，仍然可以将应用程序作为库进行部署。例如，如果你构建一个docker镜像，并将这个docker镜像交给用户，那么将你的应用程序作为库发货是完全可以的。将其视为库，作为库安装，然后这个冻结的docker镜像将成为。
- en: given to the user and hey just run this docker image okay so the way the python's
    story around。 this course is basically zip apps and zip apps is basically this
    functionality which we could have。 seen before you we saw that python is able
    to import files from within a zip file okay and this is what。 the zip app allows
    you to basically i can create all the project all the files of my project put
    it。
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 给用户的是，嘿，只需运行这个docker镜像，好的，所以Python的故事就是这样。这个课程基本上是zip应用，而zip应用基本上是我们之前可能看到的这种功能。我们看到Python能够从zip文件中导入文件，好的，这就是zip应用允许你基本上可以创建我项目的所有文件。
- en: inside a zip app and if i give this zip app to the python application the python
    or not the python。 application to the python interpreter the python interpreter
    can run it because it's just gonna put。 the location of the zip app onto the sys。pad
    and after that all the files within the zip file are。 discoverable okay and a
    lot of these tools that we're gonna see just in a minute basically leverage。
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在 zip 应用程序内部，如果我把这个 zip 应用程序交给 Python 应用程序，Python 解释器可以运行它，因为它只会将 zip 应用程序的位置添加到
    sys.path 中，之后 zip 文件中的所有文件都是可发现的。好的，我们接下来要看到的许多工具基本上利用。
- en: this functionality now this is what the virtual m project also does for example
    if you want to use。 virtual m without installing it because maybe you don't have
    rights to install it you can basically。
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能现在是虚拟 M 项目所做的，比如说如果你想使用虚拟 M 而不安装它，因为你可能没有安装权限，你基本上可以。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_310.png)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_310.png)'
- en: just use download this package from virtual m and what you're gonna end up once
    you download this。 package is you can put a python interpreter at it and as you
    can see for example it runs happily。 ever after and this is like a python's zip
    application okay now if you look inside this file。
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 只需从虚拟 M 下载这个包，当你下载这个包时，你最终可以将一个 Python 解释器放入它中，如你所见，例如，它会快乐地运行下去，这就是 Python
    的 zip 应用程序。好的，现在如果你查看这个文件。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_312.png)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_312.png)'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_313.png)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_313.png)'
- en: this zip application you will see that it basically contains just python files
    as they would be on the。 file system they're just put together inside the zip
    file okay now one important thing is that the。
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 zip 应用程序，你会看到它基本上只包含 Python 文件，就像它们在文件系统中一样，只是放在 zip 文件里面。好的，现在有一件重要的事情是。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_315.png)'
  id: totrans-549
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_315.png)'
- en: zip file always has an entry point the entry point is the main。py file that
    you package within the zip。file， so the entry point for this virtual m application
    is basically the logic that gets executed when this。 main。py file gets executed
    so if you want to know what's happening in this main。py file。 I actually want
    to maybe let's see compact this and I want to look into this main。py file。
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: zip 文件总是有一个入口点，入口点是你在 zip 文件中打包的 main.py 文件，所以这个虚拟 M 应用程序的入口点基本上是当这个 main.py
    文件被执行时执行的逻辑。因此，如果你想知道这个 main.py 文件里发生了什么，我实际上想看看，我们来压缩一下，看看这个 main.py 文件。
- en: and you will see here there's a run entry point and then it just starts running
    from that point on。 other than that it behaves exactly the same as this file system
    structure would be extracted to。
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这里有一个运行入口点，然后它就从那个点开始运行。除此之外，它的行为与这个文件系统结构提取后的行为完全相同。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_317.png)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_317.png)'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_318.png)'
  id: totrans-553
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_318.png)'
- en: the file system okay so easy way we just take everything that we have inside
    our application put。 it together in a zip file send the zip file to the user and
    just tell them point your python。 interpreter as the zip file okay so simple as
    thing let's try to do this let's try to actually package。
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统，好的，简单的方法就是将我们应用程序内部的所有内容放在一起，打包成一个 zip 文件，发送给用户，并告诉他们将 Python 解释器指向这个 zip
    文件，好的，这么简单的事情，让我们尝试一下，实际上打包。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_320.png)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_320.png)'
- en: this I can for example sage I need a folder and I'm gonna create for that make
    the error。
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，我需要一个文件夹，我会为此创建一个文件夹，产生错误。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_322.png)'
  id: totrans-557
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_322.png)'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_323.png)'
  id: totrans-558
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_323.png)'
- en: the image is gonna copy the python file into this zip folder。 and I now I can
    do something such as similar as this， so I need to specify。 the folder in which
    my files are located and this is in the zip folder and then I need to specify。
    the module inside which my entry point lives and then I need to specify。
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图像会将 Python 文件复制到这个 zip 文件夹中。现在我可以做一些类似的事情，所以我需要指定我的文件所在的文件夹，这在 zip 文件夹中，然后我需要指定。
- en: a function that gets executed called when I run it something like that okay。
    now it complains that this entry point doesn't exist and for good reason because。
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时会执行一个函数，类似于我运行它时会出现的那样。好的，现在它抱怨这个入口点不存在，这是有原因的，因为。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_325.png)'
  id: totrans-561
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_325.png)'
- en: if I go into this zip folder and I do this bit of a spy I see that there's no
    running this。 because this right on the fact that this name section gets run when
    the file is executed。 but I can just move that into a run function and if I do
    now the sleeping oh actually have a dot in here。
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我进入这个压缩文件，做一些查看，我发现没有运行这一部分。因为这实际上是当文件被执行时，这部分名称会被运行。但我可以把它移到一个运行函数中，如果我现在进行休眠，哦，这里实际上有一个点。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_327.png)'
  id: totrans-563
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_327.png)'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_328.png)'
  id: totrans-564
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_328.png)'
- en: now it should work and if I do now this zip piezit this actually runs and now
    the entry point。
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该可以工作了，如果我现在执行这个压缩包，实际上它会运行，并且现在是入口点。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_330.png)'
  id: totrans-566
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_330.png)'
- en: actually runs this run method and I can investigate again this if I just do
    in zip zip piezit。
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上运行这个运行方法，如果我再次调查，执行zip piezit。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_332.png)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_332.png)'
- en: you see that it generates a main file which actually just calls that run method
    within it。 yeah if I just do like a look into this main file you see exactly that
    based on this configuration。 from here you just generate that main file and then
    put this zip file onto the pet and just run zip。 okay now the only kind of like
    problem with this is that as you say this zip file doesn't contain。
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到它生成了一个主文件，实际上只是在其中调用那个运行方法。是的，如果我查看这个主文件，你会看到正是根据这个配置生成的。从这里你只需生成那个主文件，然后将这个压缩文件放到宠物上并运行压缩。好的，现在唯一的问题是，正如你所说，这个压缩文件并不包含。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_334.png)'
  id: totrans-570
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_334.png)'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_335.png)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_335.png)'
- en: its dependencies okay so like what about my dependencies I may have a lot of
    dependencies。 which I might also need to ship to the user and the zip up as out
    of the box doesn't do this but。
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 其依赖关系。那么，我的依赖关系呢？我可能有很多依赖关系。我可能也需要将它们打包给用户，而压缩工具开箱即用并不处理这些，但。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_337.png)'
  id: totrans-573
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_337.png)'
- en: there are these other tools cause pecs and shiv which we're going to see in
    a moment which do this。 what they do offer extra besides this packaging logic
    what zip up does is that they also deal with。 the your dependencies it's going
    to look at your application it's going to discover what are my。 dependencies for
    example here's the pecs the pecs one and it's going to package your dependencies
    also。
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 还有这些其他工具，比如pecs和shiv，我们很快就会看到它们是如何做到的。它们除了包装逻辑之外还提供额外的功能，压缩文件是不会处理的。它们还处理你的依赖关系，会查看你的应用程序并发现我的依赖关系是什么。例如，这里是pecs，它将打包你的依赖关系。
- en: into the zip file and this zip file will also then provision at the start of
    the zip。 or the python interpreter so that it's able to load this for example
    here the wheel of files okay。 you have either the pecs as a solution to this and
    then you also have shiv as another solution of this。 and here if you go to for
    example you can see we'll actually let's give it a quick try to。
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 进入这个压缩文件，这个压缩文件也会在压缩文件的开头提供支持。或者是Python解释器，以便它能够加载这里的文件。例如，你有pecs作为解决方案，还有shiv作为另一种解决方案。如果你去这里，比如你会看到我们实际上来试一下。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_339.png)'
  id: totrans-576
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_339.png)'
- en: with shiv shiv actually is able to package it's able to。 they will actually
    able to package something that you already published so I can specify to the shiv。
    that hey create a zip up file for my for example for the virtual and project and
    put it into a。 virtual and the shiv and then here the second virtual means that
    my entry point is used as an。
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 使用shiv，shiv实际上能够打包，它能够。它们实际上能够打包你已经发布的东西，因此我可以向shiv指定。嘿，为我的虚拟项目创建一个压缩文件，并将其放入一个虚拟环境中，而第二个虚拟环境意味着我的入口点被用作。
- en: entry point the console entry point called virtual and okay if i run this what
    actually happens in the。 background is that now i end off with a virtual and the
    shiv and this virtual and file is a zip。 of file i mean i can feed it to a python
    interpreter and will actually work and run and if i look into。 the structure of
    it i can see that it actually took all the dependencies this application had。
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 入口点控制台入口点叫做**virtual**，如果我运行这个，实际上在后台发生的是我现在结束了一个**virtual**和**shiv**，这个**virtual**文件是一个压缩文件。我可以将其传递给
    Python 解释器，它实际上会工作并运行，如果我查看它的结构，我可以看到它实际上获取了这个应用程序的所有依赖项。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_341.png)'
  id: totrans-579
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_341.png)'
- en: and put it inside the zip up file onto the side packages and all my dependencies
    even the binary。
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 并将它放入压缩文件中，所有的包和我的所有依赖项，甚至是二进制文件。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_343.png)'
  id: totrans-581
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_343.png)'
- en: entry point executables are available there okay， so pretty much this it and
    then it just defines its own environment just some bootstrapping logic。 it just
    makes things that whatever you see here it's actually available for important。
    inside this main。py file okay so yeah if you want to just literally have a python
    file and you just。
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 入口点的可执行文件在那里可用，好吧，所以大概就是这样，然后它定义了自己的环境，只是一些引导逻辑。它只需确保你在这里看到的任何东西实际上都可以在这个`main.py`文件中导入。好的，所以是的，如果你想真的只拥有一个
    Python 文件，你就。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_345.png)'
  id: totrans-583
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_345.png)'
- en: wanted to give it to someone else to run it and you don't want to actually look
    at it。 either using pigs and shiv is great to give them this all the dependencies
    packaged into one single zip。 file they can just point at it and run it this is
    fairly simple and easy to use now there's another。 fact family of installer generation
    and this is the pie installer pie installer is different in a。
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想把它给其他人运行，而你不想真的去看它，使用**pigs**和**shiv**是个不错的选择，可以把所有依赖项打包成一个单独的压缩文件，他们只需指向它并运行，这相当简单易用。现在还有另一种安装程序生成方式，这是**pie
    installer**，**pie installer**与之不同。
- en: sense that pie installer doesn't just generate you a zip file but actually and
    it doesn't just。 packages your own application but it actually packages your application
    the python interpreter。 to get you into a single file that's executable like this
    is kind of creates literally。
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 意思是，**pie installer**不仅仅是生成一个压缩文件，它实际上不仅仅是打包你自己的应用程序，还打包了你的应用程序和 Python 解释器。它为你创建一个像这样可执行的单个文件，真的是这样。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_347.png)'
  id: totrans-586
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_347.png)'
- en: executable file that you can copy around for example if you go back okay and
    we have this。 pure approximate or approximate file this file okay I can do pie
    installer there's a thing and if I。 run this pie installer tool you'll see that
    once it finishes it actually goes out into my file system。 files my python interpreter
    files my binary dependencies and puts all them together into a single file。
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件，你可以随意复制，例如，如果你回去，我们有这个纯近似或近似文件，这个文件好吧，我可以用**pie installer**，这有一件事，如果我运行这个**pie
    installer**工具，你会看到一旦它完成，它实际上会在我的文件系统中输出。我的 Python 解释器文件、我的二进制依赖项，将它们全部放在一起成一个单一的文件。
- en: and I can check it out inside of this bush and you'll see this pie。
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在这个终端里查看，你会看到这个**pie**。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_349.png)'
  id: totrans-589
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_349.png)'
- en: can be run as an interpreter itself and now this actually doesn't work because
    here I did not。
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以作为一个解释器本身运行，但现在这实际上不工作，因为这里我没有。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_351.png)'
  id: totrans-591
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_351.png)'
- en: actually have this to run so I need to do something I need to do I did this
    there's just name。
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上需要运行这个，所以我需要做一些事情，我做了这个，这只是名称。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_353.png)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_353.png)'
- en: just copy it， I need to actually run it so you can say that it works okay so
    because it's gonna run this pie。
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 只是复制它，我实际上需要运行它，所以你可以说它是有效的，好吧，因为它会运行这个**pie**。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_355.png)'
  id: totrans-595
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_355.png)'
- en: submit file itself so if I do it again and it regenerates that executable you
    see that it actually。 gonna work and now this actually generated an executable
    I did not work what did I do wrong here。
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 提交文件本身，所以如果我再次执行并重新生成那个可执行文件，你会看到它实际上是可行的，现在这实际上生成了一个可执行文件，我不知道我做错了什么。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_357.png)'
  id: totrans-597
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_357.png)'
- en: it should at least generate。
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 至少应该生成。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_359.png)'
  id: totrans-599
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_359.png)'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_360.png)'
  id: totrans-600
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_360.png)'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_361.png)'
  id: totrans-601
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_361.png)'
- en: hmm thanks a lot but generally the idea is that it will generate you an entry
    point which you can。
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，非常感谢，但总体的想法是它会为你生成一个入口点，你可以使用。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_363.png)'
  id: totrans-603
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_363.png)'
- en: which you can then just literally give it to our ownership it can you run a
    pie installer on Linux。 to create a windows executable short answer no and it's
    even more complicated than that because what。 basically how pie installer works
    is whenever it you invoke it it goes out checks all the python。 files that you're
    using discovers all the dependencies both python dependencies and binary dependencies。
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其直接交给我们的所有权，你可以在 Linux 上运行 pie installer 来创建 Windows 可执行文件，简短回答是“不”，而且事情比这更复杂，因为基本上
    pie installer 的工作方式是，每当你调用它时，它会检查你正在使用的所有 Python 文件，发现所有的依赖项，包括 Python 依赖项和二进制依赖项。
- en: and collects them together into a single package and then it ships a single
    package。 and whenever you actually start here I started here like p。approximate。py
    it's actually on reps。 all the files this project was using into temporary folder
    and runs it from there and because it。 collects the binary dependencies from the
    platform it's running on to it means that it's only able to。
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 并将它们汇集到一个单一的包中，然后发出一个单一的包。每当你实际开始时，我是在 p.approximate.py 开始的，实际上是在 reps 中。这个项目所使用的所有文件都放在临时文件夹中并从那里运行，因为它收集了运行平台的二进制依赖项，这意味着它只能。
- en: run on the same platform where you built it okay if you just want to if you
    just want to。 and this makes it fairly easy to run I would say if your friend
    is total new and doesn't know。 Python at all I think pie installer is a great
    way to package your application there are somewhere。 as kills you might run to
    it and rough edges but generally it lands you with a single as feasible。
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建它的平台上运行，如果你只想要，如果你只想要。这使得运行相对简单，我会说，如果你的朋友完全是新手且对 Python 一无所知，我认为 pie installer
    是打包你的应用程序的好方法，虽然可能会遇到一些棘手的问题和粗糙的边缘，但总体来说，它会给你一个可行的单一应用程序。
- en: that you can just give it to someone and it's simple enough that they could
    just literally run。 it and it would do what you expect them to do if they know
    a bit of a python I think the z-paps are。 a bit more robust they are less rough
    edges even a running to them with the pie installer but it。 does mean that now
    the user has to know how to install python and how to invoke python applications。
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接把它给某人，它足够简单，以至于他们可以直接运行，并且它会按照你预期的方式执行。如果他们对 Python 有一些了解，我认为 z-paps 更加健壮，它们的粗糙边缘更少，尽管在使用
    pie installer 时也可能会遇到问题，但这意味着用户现在必须知道如何安装 Python 以及如何调用 Python 应用程序。
- en: by passing the z-pap application to it okay so my general consensus is that
    pie installer is a bit。
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 z-pap 应用程序传递给它，所以我的一般共识是 pie installer 有点。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_365.png)'
  id: totrans-609
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_365.png)'
- en: stronger in a sense that it makes the barrier of entry lower for the end users
    but it's be prepared。 to run into more issues of our using it just how intrusive
    and how it works because of that while。 the z-paps are generally much more robust
    in working and behavior but if something goes wrong it's going。 to require you
    more expertize to debug it or use it okay so this is one bonus content just kind
    of。
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上更强，因为它降低了终端用户的使用门槛，但你需要准备好面对更多问题，尤其是使用时的侵入性和其工作方式。而 z-paps 通常在工作和行为上更为健壮，但如果出现问题，需要更多的专业知识来调试或使用。所以这是一个额外的内容。
- en: like the English you might be wondering as you see beforehand the virtual amp
    actually has different。 versions depending on the python you're using it for example
    you can see on 3。9 and 2。7 totally。 different type of python dependencies are
    needed so one my ask how is capable virtual amp in packaging。
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可能会想的，正如你之前看到的，virtual amp 实际上根据你使用的 Python 版本有不同的版本。例如，你可以看到 3.9 和 2.7 需要完全不同类型的
    Python 依赖项，所以有人可能会问，virtual amp 在打包方面的能力是什么。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_367.png)'
  id: totrans-612
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_367.png)'
- en: all your dependencies inside a single zip file because as you might have seen
    before it's virtual。
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 将你所有的依赖项放在一个单独的 zip 文件中，因为正如你之前看到的，它是虚拟的。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_369.png)'
  id: totrans-614
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_369.png)'
- en: and that pie z this works the same way if I call it python 3。6 or if I call
    it with python 3。8 okay。 because both sieve and the pie installer and the zip
    and the packs they always only drag。 to the package that is guaranteed to work
    on the exact interpreter that you build it on not in a。
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 并且无论我调用python 3.6还是python 3.8，这种方式都能正常工作，因为sieve、pie安装程序、zip和包始终只拖入在构建时保证在确切解释器上工作的包，而不是在其他解释器上。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_371.png)'
  id: totrans-616
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_371.png)'
- en: different interpreter and this is just kind of like a showcase that how you
    can reuse some of the。 power within the python ecosystem how you can make this
    happen is that the python or the zip。 application that virtual and ships actually
    contains multiple versions of multiple dependencies。 decide the actual source
    code for example you can see it contains 1。1。3 of imported metadata and， 1。
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的解释器，这只是一个展示，展示如何重用Python生态系统中的一些功能。使其成为可能的是，虚拟和分发的zip应用程序实际上包含多个版本的多个依赖项，决定了实际的源代码，例如你可以看到它包含1.1.3的导入元数据。
- en: 6。2 of imported metadata and it has the distributions and models that JSON which。
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6.2的导入元数据，它具有分发和JSON模型。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_373.png)'
  id: totrans-619
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_373.png)'
- en: will write actually look at it and these distributions models pacifies for his
    python version what is。 the exact versions of the wheels that actually are used
    for for example you can see for 2。7。
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们将看看这些分发模型针对其Python版本的具体版本，例如，你可以看到对于2.7。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_375.png)'
  id: totrans-621
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_375.png)'
- en: a lot more libraries of use and different inversions that from 3。9 okay and
    the way the way。
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的库要多得多，而3.9的不同版本则要少得多。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_377.png)'
  id: totrans-623
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_377.png)'
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_378.png)'
  id: totrans-624
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_378.png)'
- en: virtual amp is able to dynamically load the correct version at runtime is that
    at start up it basically。 loads this kind of like lookup table which is defined
    inside the models and distribution of JSON。 and based on this lookup and the current
    version of the interpreter it installs custom importers。 which resolve two different
    paths depending on the pipe inversions you're running onto it。
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: virtual amp能够在运行时动态加载正确版本，启动时基本上加载一个定义在模型和JSON分发中的查找表。根据这个查找以及解释器的当前版本，它安装自定义导入器，根据你运行的管道版本解析两个不同的路径。
- en: so this way you can actually have multiple versions of the same library packaged
    into the same zip。 of application and for this you just need to have a bit of
    look into the pep 451 and 3。2。
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你实际上可以将相同库的多个版本打包到同一个zip应用程序中，为此你只需稍微关注pep 451和3.2。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_380.png)'
  id: totrans-627
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_380.png)'
- en: with the import hooks and how the import system works but if you do that and
    let me just。
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 结合导入钩子以及导入系统的工作原理，如果你这样做，让我说。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_382.png)'
  id: totrans-629
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_382.png)'
- en: quickly unzip this you'll see that and we can have a quick look at this before
    we finish this up。
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 快速解压这个，你会看到，在我们完成之前，我们可以快速浏览一下这个内容。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_384.png)'
  id: totrans-631
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_384.png)'
- en: you'll see that basically what's happening is that you can register custom importers
    that are able to。 find the models and load the models dynamically based on this
    version information and these are。 just basically registered and added to the
    system meta-importor path at the start of it whenever this。 Python interpreter
    starts up okay so this is just like a nice way of how you can mix。
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，基本上发生的事情是，你可以注册能够根据这个版本信息找到并动态加载模型的自定义导入器，这些导入器在每次Python解释器启动时被注册并添加到系统的元导入器路径中，因此这是一种很好的方式，展示如何混合使用。
- en: what we learned about the import system earlier in this talk or this tutorial
    and the meta path。 and I encourage you if you want to like understand it but you're
    looking to this it's quite it's a good。 use case to see how you can mix those
    and how you can actually create single zip files which are。
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这次谈话或教程中了解到的导入系统和元路径，我鼓励你如果想了解这些内容，这是一个很好的用例，看看如何混合使用这些内容，以及如何实际创建单个zip文件。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_386.png)'
  id: totrans-634
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_386.png)'
- en: cross-platform compatible potentially okay and after that that was basically
    all I had to take。
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 跨平台兼容性潜在地很好，基本上我能提供的就是这些。
- en: '![](img/759a25f61cc4dcebc6324f15f7d3b776_388.png)'
  id: totrans-636
  prefs: []
  type: TYPE_IMG
  zh: '![](img/759a25f61cc4dcebc6324f15f7d3b776_388.png)'
- en: so I'm happy to answer any questions or issues people around to it so yeah just
    pick up if you。 have any questions I'm happy to answer them otherwise thank you
    very much for your confidence。 and your time you gave me today in this tutorial
    I hope this was very useful for you and thank you。 Thanks for watching。
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我很高兴回答任何问题或相关的事务，如果你有任何问题，请随时问我。我很乐意回答，否则非常感谢你今天在这个教程中给予我的信任和时间，希望这对你非常有用，谢谢你。谢谢观看。
