- en: P15：Amanda Sopkin - The Refactoring Balance Beam - When to Make Changes and
    When to - leosan - BV1qt411g7JH
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P15：阿曼达·索普金 - 重构平衡木 - 何时进行更改，何时 - leosan - BV1qt411g7JH
- en: Hello everyone。 Next up we have Amanda Sapkin presenting the refactoring balance
    beam， when。 to make changes and when to leave it alone。 [Applause]。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大家好。接下来，我们有阿曼达·索普金演讲重构平衡木，何时进行更改，何时保持现状。[掌声]
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_1.png)'
- en: All right。 Thank you very much。 Welcome to， as you said， the refactoring balance
    beam。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，非常感谢。欢迎来到，如你所说的，重构平衡木。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_3.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_3.png)'
- en: The inspiration for this title is that when you're refactoring， you're sort
    of striking。 a balance between what it's worth making changes to and what， you
    know， you should just kind。 of leave well enough alone。 And I'm going to start
    out with a joke。 So you， I'll kind。 of tell you what's going on in case it's hard
    to read the print。 Basically， this developer。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标题的灵感来源于，当你进行重构时，你是在平衡值得进行更改的内容和你知道的那些应该保持现状的内容。我将从一个笑话开始。所以，我会告诉你发生了什么，以防打印内容难以阅读。基本上，这位开发者。
- en: has just cloned his master branch。 Both of the branches look like monsters。
    And the master。 branch is asking about the new branch。 And the developer says
    that it's just a refactoring， branch。 I'm removing all the bad coding。 And then
    shortly later on， the master branch。 is concerned because the refactoring branch
    has been reduced to a pile of bones and there's。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚克隆了他的主分支。两个分支看起来都像怪物。而主分支正在询问新分支的情况。开发者说这只是一个重构分支。我正在去除所有糟糕的代码。随后不久，主分支开始担心，因为重构分支已经变成了一堆骨头，几乎什么都不剩了。
- en: really not much left at all。 And he's saying， you'll never do that to the master
    branch， will you？
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 他在说，你永远不会对主分支这样做，对吧？
- en: And the developer is saying it seems not much is left after all。 So maybe you've。
    had this experience while you're refactoring， maybe not。 I found in my career
    that there。 are a lot of decisions that get made around refactoring that are kind
    of difficult to balance。 like deciding when to do it， how to prevent affecting
    changes， how to prevent affecting。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者在说，似乎最后什么都没剩下。所以，也许你在重构时有过这种经历，也许没有。我发现，在我的职业生涯中，围绕重构做出的许多决定都很难平衡，比如决定何时进行、如何防止影响变更、如何防止影响。
- en: a feature code， and even just socially navigating making substantial changes
    to something that。 someone else on your team potentially wrote。 So I'm hopeful
    that this talk will give you。 some guidance on how to make those decisions。 And
    if you're someone who likes to follow along。 with slides as the talk is going，
    I did tweet them out five minutes ago or you can go to。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特性代码，甚至在社交场合中，进行对团队其他成员可能编写的内容进行重大更改。希望这个演讲能给你一些关于如何做出这些决定的指导。如果你喜欢在演讲时跟随幻灯片，我在五分钟前发了推特，或者你可以去。
- en: this short URL， bit。ly/picon19。 And they'll also put the slides up after all
    of this is， seven done。 So I'm going to start out by talking about some of the
    motivations for refactoring。 We'll spend the meat of this talk kind of looking
    at different code smells and good ways。 to address them。 And then we'll talk about
    different approaches to refactoring and ways。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个短链接是，bit.ly/picon19。他们还将在所有这些结束后发布幻灯片。接下来，我将开始讨论一些重构的动机。我们将花大部分时间看不同的代码异味以及解决它们的好方法。然后我们将讨论不同的重构方法和方式。
- en: to answer that question of whether or not you should be doing refactoring。 So
    I want to。 start out by putting the zen of Python up here。 You've probably seen
    this several times。 this weekend alone， but I think there are a few pieces that
    are worth calling out to get。 us into the right head state for a refactoring talk。
    So in particular， beautiful is better。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答是否应该进行重构的问题，我想首先把Python的禅放在这里。你可能已经见过几次了，尤其是这个周末，但我认为其中有几条值得强调，以帮助我们进入重构演讲的正确心态。尤其是，美比丑更好。
- en: than ugly， explicit is better than implicit， simple is better than complex，
    readability， counts。 there should be one and preferably only one obvious way to
    do it。 And if the implementation。 is hard to explain， it's a bad idea。 So I think
    these are good guiding philosophical。 ideas as we go through a refactoring journey。
    The definition of refactoring from Wikipedia。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 明确比隐含好，简单比复杂好，易读性很重要。应该有一种且最好只有一种明显的方法去实现它。如果实现很难解释，那就是个坏主意。我认为这些是我们在重构过程中很好的指导哲学思想。
- en: is sufficient in my opinion。 Code refactoring is the process of restructuring
    existing computer。 code without changing its external behavior。 So I've highlighted
    without changing， if you're。 refactoring something， you're not adding or at least
    the point is not to add additional， features。 The point is to hopefully make it
    more understandable。 So why do we refactor？
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，这是足够的。代码重构是对现有计算机代码进行重组的过程，而不改变其外部行为。所以我强调了“在不改变”的情况下，如果你在重构某个东西，你并不是在添加，至少重点不是增加额外的功能。目的是希望使代码更易于理解。那么，为什么我们要重构呢？
- en: The purpose is to increase understanding and hopefully reach a more enlightened
    state。 both for you the person writing it and then also for future people who
    will look at this。 code and add to it。 So keep that purpose in mind if the refactoring
    is making it more。 complicated than we've sort of failed somewhere along the way。
    A couple other terms that I'll。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个目的在于增加理解，希望能达到一种更开明的状态，无论是对你这个写文档的人，还是对未来将查看这段代码并进行修改的人。所以如果重构使得事情变得更加复杂，请牢记这个目的，我们可能在某处失败了。
- en: be using that I want to define。 A design pattern is just a repeatable solution
    to a software。 engineering problem。 In early in my career， I used to think that
    design patterns were。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我想定义的设计模式就是对软件工程问题的可重复解决方案。在我职业生涯早期，我曾认为设计模式是。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_5.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_5.png)'
- en: something like those sewing patterns that they sell at Walmart where you've
    got these complicated。 diagrams and all these weird names and it's hard to keep
    track of them。 But I think a better。 analogy is more like a box of tools。 So it
    really doesn't matter if you know the names。 for design patterns。 There's no final
    exam here。 There are just a set of tools that you。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 就像沃尔玛出售的那些缝纫图案，里面有复杂的图示和奇怪的名称，很难跟踪。但我认为更好的类比是工具箱。所以你是否知道设计模式的名称并不重要。这里没有期末考试。只有一套你可以使用的工具。
- en: probably already use pretty frequently and if you can get used to that， then
    it'll be。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能会频繁使用一些术语，如果你能适应这些术语，那将会很好。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_7.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_7.png)'
- en: helpful for you as a developer。 Code smell is defined as a characteristic in
    the source。 code of a program that possibly indicates a deeper problem。 So if
    it's something that。 if you see this happening， it's a good clue that maybe you
    should look a little bit closer。 and see if there's something that you should
    change。 Before we get started refactoring， I。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你作为开发者来说，代码异味被定义为程序源代码中的一种特征，可能表明存在更深层次的问题。因此，如果你看到这种情况发生，那是一个很好的线索，或许你应该更仔细地检查一下，看看是否有需要更改的地方。在我们开始重构之前，我。
- en: want to issue a warning that you should have a rollback strategy。 Particularly
    if you're。 working with live code， it's very possible that you'll make changes
    even if you're just。 renaming something that will have unforeseen consequences
    on your production code。 So make。 sure you have some way to roll those changes
    back and preferably also like a test suite。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我想提醒你，应该有一个回滚策略。特别是当你在处理实时代码时，即使只是重命名某个东西，也很可能会对你的生产代码产生意想不到的后果。所以一定要确保你有办法将这些更改回滚，最好还有一个测试套件。
- en: that you can use to make sure that you haven't broken anything。 So some of the
    basic tools that we have at our disposal， renaming， that's a really good。 way
    to make things more readable， moving or splitting things in general and redefining。
    inheritance boundaries are some of the big tools that we'll be using to refactor。
    And。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用来确保没有破坏任何东西的一些基本工具。重命名是一个很好的方法，可以使代码更具可读性，移动或拆分内容，以及重新定义继承边界，都是我们在重构时将使用的一些重要工具。
- en: I'm going to go over some code smells and they basically fit into three different
    buckets。 First of all， when something is too long or too complex， second of all，
    if it's not useful， enough。 not really doing enough for us。 And third of all，
    if you've got some bad object。 oriented programming going on。 And none of this
    means that anyone really did anything， wrong。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我将讨论一些代码异味，它们基本上可以分为三个不同的类别。首先，当某些东西太长或太复杂；其次，如果它不够有用，实际上没有为我们提供足够的功能；第三，如果你有一些糟糕的面向对象编程情况。这些都并不意味着任何人真的做错了什么。
- en: It might just be that the decision made sense at the time and now in retrospect。
    it doesn't really make sense anymore。 So the basic ways that we'll address these
    problems。 if it's too long， we'll split it out。 If it's not useful enough， then
    we'll compress。 it or put it somewhere else。 And if there's bad object oriented
    programming going on。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可能只是当时的决定是合理的，而现在回头看，这个决定似乎不再有意义。所以我们解决这些问题的基本方法是，如果它太长，我们会将其拆分。如果它不够有用，那么我们会压缩它，或者放到其他地方。如果存在糟糕的面向对象编程情况。
- en: we'll restructure it somehow。 So quick note on code smells。 Just because。 there's
    a code smell does not mean that you need to change anything or even that anything。
    is necessarily wrong。 There are patterns that often indicate that something could
    have。 been done better。 But there are times when it's totally okay to have a code
    smell。 So。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会以某种方式重构它。所以简单提一下代码异味。仅仅因为存在代码异味，并不意味着你需要改变任何东西，或者说任何东西一定是错的。有些模式常常表明某些地方可以做得更好。但有时候，存在代码异味也是完全可以接受的。所以。
- en: I just want to point that out。 So the first common bucket for code smells that
    we're going。 to look at is when something is a little too long。 And I also want
    to say that these are。 going to start out kind of simple， but they'll build on
    each other。 So don't worry， it'll。 get more interesting。 So the first one that
    we see pretty frequently is when you have。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我只想指出这一点。因此，我们将要查看的第一个常见代码异味是某些东西太长了。我还想说，这些内容一开始会显得比较简单，但它们会相互积累。所以不用担心，内容会变得更有趣。我们常见的第一个问题是当你有。
- en: duplicated code。 So you're doing the same thing in several different places。
    This is。 a good clue that you should pull that out into a method or potentially
    a class。 And if。 you're pulling something into a class， at this point， I feel
    like I should ask you and。 you should ask yourself， do you really need another
    class？ Because that's a frequent cause。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 重复代码。因此，你在多个不同的地方做同样的事情。这是一个很好的线索，表明你应该将其提取到一个方法或可能是一个类中。如果你将某些内容提取到一个类中，此时，我觉得我应该问你，你真的需要另一个类吗？因为这是一个常见的原因。
- en: of other code smells。 So when you're kind of deciding whether or not you need
    a new。 class for this or whether you can just use a method， there are a couple
    of things you。 can do to make that decision easier。 So you should create a class
    if you have something。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 其他代码异味的存在。当你在决定是否需要为此创建一个新类，或者是否可以仅仅使用一个方法时，有几个方法可以帮助你做出这个决定。如果你有某些东西。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_9.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_9.png)'
- en: that looks like this where you have a similar， you have some similar arguments
    that are being。 used in multiple functions in a mix of mutable and immutable。
    So in this example， I'm initializing。 a grid structure and then I'm passing that
    grid。 Sometimes I'm making changes to it。 For check for winter， I'm not making
    a change。 So this is a pretty good indication that it。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像这样，你有一些相似的参数在多个函数中被使用，并且它们混合了可变和不可变的情况。在这个例子中，我正在初始化一个网格结构，然后我传递那个网格。有时候我会对它进行更改。在检查冬季的情况下，我不会进行更改。所以这很好地表明。
- en: would be useful for me to use a class。 In this case， it's probably better to
    use a function。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，使用一个类会更有用。在这种情况下，使用一个函数可能更好。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_11.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_11.png)'
- en: You've got only two methods here， one of which is doing initialization and then
    a second one。 And you've only got static methods。 So really this will work just
    as well as a method。 We've。 got a calculator class where we're initializing two
    operands and one operator。 And really we。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只有两个方法，其中一个是进行初始化，另一个是。你只有静态方法。所以实际上这和一个方法的工作原理是一样的。我们有一个计算器类，正在初始化两个操作数和一个运算符。实际上，我们。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_13.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_13.png)'
- en: can just do this as a function where we pass those in directly， perform the
    operation and。 then return it。 Next code smell I want to talk about is long methods。
    And in this case， when。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 可以把这作为一个函数，在其中直接传入这些参数，执行操作，然后返回。下一个我想谈的代码异味是长方法。在这种情况下，当。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_15.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_15.png)'
- en: I say the word long， there's no perfect cut off point when you know that whatever
    you've。 written has too many lines。 It's really more about the complexity of whatever
    it is。 So。 I think a good guiding principle is that if you can't come up with
    a single cohesive。 purpose for your method or even a good name that really encompasses
    what it's doing， you。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我说“长”这个词时，没有一个完美的截止点来判断你所写的东西是否有太多行。实际上，更重要的是其复杂性。所以我认为一个好的指导原则是，如果你不能想出一个单一的、连贯的目的为你的方法，甚至不能想出一个真正能概括其功能的好名称，那么你。
- en: might need to split out some functionality。 But in general， you shouldn't just
    copy and。 paste pieces just because it looks a little too long to you。 So we've
    talked about extract。 class and extract method。 A couple other things you can
    do to doctor your code。 You can replace。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要拆分出一些功能。但一般来说，你不应该仅仅因为某些部分看起来太长就复制和粘贴它们。所以我们讨论过提取类和提取方法。你可以做的另外几件事来改善你的代码。你可以替换。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_17.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_17.png)'
- en: method with method object。 So here I've got a procedure where I'm passing in
    a bunch of。 different variables and doing a lot of computations。 It's several
    lines long， so maybe I want to。 pull aspects of that out。 In this case， it might
    be a good idea to introduce a method or a class。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 方法与方法对象。所以这里我有一个过程，我传入一堆不同的变量并进行大量计算。这有好几行，所以也许我想要将其中的某些部分提取出来。在这种情况下，引入一个方法或类可能是个好主意。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_19.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_19.png)'
- en: where I can store that data and then pretty easily break it up into smaller
    pieces。 Another。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里我可以存储那些数据，然后相对容易地将其分解成更小的部分。另一个。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_21.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_21.png)'
- en: thing we can do is introduce a parameter object。 So if you have frequent groups
    of parameters。 that you're using together， like in this example， we've got start
    time and end time， then it。 might be a good idea to pull to create an object。
    In this case， it's called time range to encompass。 those parameters。 The next
    code smell I want to talk about is called data clumps。 This happens。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的一件事是引入一个参数对象。因此，如果你有频繁使用在一起的参数组，比如在这个例子中，我们有开始时间和结束时间，那么将其提取为一个对象可能是个好主意。在这种情况下，它叫做时间范围，以涵盖那些参数。接下来我想谈的代码异味称为数据块。这种情况发生。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_23.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_23.png)'
- en: if you've got frequent clumps of data appearing throughout your code。 In this
    case， it might。 make it better to pull that clump into an object。 And I want to
    point out that there's。 a reciprocal code smell for this one that we'll talk about
    later。 So for a lot of these， you。 can take an action and if you take it too far，
    then you might end up introducing a new code， smell。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在代码中频繁出现数据块。在这种情况下，将这个块提取到一个对象中可能会更好。我想指出的是，这里有一个相互对应的代码异味，我们稍后会讨论。所以对于很多这样的情况，你可以采取一个行动，如果你过于追求它，那么你可能会引入一种新的代码异味。
- en: So keep in mind that it's a balance。 The next big bucket of code smells we'll
    talk。 about is when something is not quite useful enough。 So the most common one
    is a lazy class。 or a speculative generality。 This usually happens if when I set
    out to create my project。 I thought I was going to have a bunch of parent classes
    and subclasses and maybe I went a little。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所以要记住，这是一种平衡。接下来我们要讨论的一个重要的代码异味是，当某个东西并不够有用时。最常见的就是懒惰类或者投机性泛化。这通常发生在我创建项目时，我原以为会有一堆父类和子类，也许我走得有点远。
- en: overboard in creating those。 And then later on， when I look at it， I see that
    a lot of those。 classes aren't doing anything for me。 So as an example， let's
    say I have an employee parent。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 过度创建这些类。然后当我回过头来看时，我发现很多这些类并没有为我做任何事情。所以举个例子，假设我有一个员工父类。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_25.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_25.png)'
- en: class where that has a name and a salary associated with it。 And then I've got
    an engineer， which。 is a subclass of employee and an engineer has a team。 And
    maybe when I created these， I。 thought I was going to have lots of different kinds
    of employees that were going to need。 their own information。 Maybe only engineers
    would have teams and executives wouldn't have。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名称和与之关联的薪水的类。然后我有一个工程师，这是员工的子类，工程师有一个团队。也许当我创建这些时，我认为会有很多不同类型的员工需要他们自己的信息。也许只有工程师会有团队，而高管则没有。
- en: teams or something like that。 But now that I'm looking at it， it seems like
    employee isn't。 really doing anything for me。 So there's no shame in that。 I'll
    just lift that value into。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 团队或类似的东西。但现在我在看它时，似乎员工对我并没有真正的帮助。所以这样没有什么羞愧。我只需将该值提升到。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_27.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_27.png)'
- en: the employee class and now employee can have a concept of a team。 The next code
    smell is。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 员工类现在可以有一个团队的概念。下一个代码异味是。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_29.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_29.png)'
- en: the reciprocal of the data clumps code smell that we talked about earlier。 So
    this happens。 if you end up with a lot of classes that are doing nothing but storing
    data。 So if this。 happens and it's happening in a lot of places， the best thing
    you can do is probably try。 and find methods that are often associated with those
    clumps of data so that your class。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前谈到的数据聚集代码异味的相反现象。如果你有很多类仅仅用于存储数据，就会发生这种情况。如果这种情况发生并且在很多地方都存在，你可以做的最好事情可能就是尝试找到与这些数据聚集相关联的方法，以便你的类。
- en: can be a little bit more useful for you。 And again， just because this is happening
    doesn't。 mean it's a bad thing。 It might be appropriate to have at least a few
    data holders。 But if。 it's happening pretty frequently， then you might want to
    look into it a little bit more。 So now we're going to get to the third most complicated
    and most interesting bucket of。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你可能更有用。而且，正因为这种情况发生并不意味着这是个坏事。拥有至少几个数据持有者可能是合适的。但是，如果这种情况频繁发生，那么你可能想进一步调查一下。所以现在我们要进入第三个最复杂和最有趣的类别。
- en: code smells which was related to issues with object oriented programming。 So
    the first。 one I'll talk about is divergent change。 This happens if one class
    is being changed a lot。 for different reasons。 Often this is kind of unavoidable
    to some extent， but if possible。 each object should only be changed as a result
    of one kind of changes。 A kind of similar code。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与面向对象编程相关的代码异味。我要谈的第一个是**发散变化**。当一个类因不同原因频繁变化时，就会发生这种情况。这在某种程度上常常是不可避免的，但如果可能的话，每个对象只应因一种变化而被修改。类似的代码。
- en: smell and my favorite name for a code smell is shotgun surgery。 This happens
    when every。 time you make a change you find that you have to make changes in a
    bunch of different places。 and suddenly your code kind of looks like a trauma
    victim。 So this can be made better。 by trying to encapsulate those changes in
    a particular place。 So to go through an example。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的代码异味名称是**霰弹枪手术**。每次你做出更改时，发现必须在多个地方进行更改，这时你的代码看起来就像一个创伤受害者。通过尝试将这些更改封装在特定地方，可以改善这种情况。我们来举个例子。
- en: let's say that I've got a bank and those banks have offices and then I've also
    got some type。 of financial regulating authority。 And my bank is doing really
    well， so I'm having to introduce。 new kinds of currency when I go into a new area。
    And I find that every time I have to。 do that I have to make changes in all three
    of these places。 So this is a good clue that。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有一家银行，这些银行有分支机构，还有某种类型的金融监管机构。我的银行表现很好，因此我必须在进入新地区时引入新的货币类型。我发现每次都必须在这三个地方进行更改。这是一个很好的线索。
- en: maybe I want to pull those into one currency handler so that every time I'm
    adding a new， currency。 which potentially is something I'm doing a lot， I only
    have to make that change， in one place。 A similar code smells called parallel
    inheritance hierarchies。 This happens。 when every single time you make a subclass
    of one hierarchy you're finding that you have。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我想把它们集中到一个货币处理程序中，这样每次添加新货币时，可能是我经常做的事情，我只需在一个地方进行更改。类似的代码异味称为**平行继承层次**。每当你从一个层次创建子类时，你发现自己必须。
- en: to make it in another place as well。 So as an example， let's say that I manage
    small。 businesses and I've got a dentist in a primary care office and I have to
    create a payment。 manager class for both of those。 And then I find that I have
    to split out insurance functionality。 so I find myself having to create that subclass
    again in both of those places。 So if I'm having。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在另一个地方实现这一点。例如，假设我管理小型企业，我有一个牙医在一个初级保健办公室，我必须为这两个创建一个支付管理器类。然后我发现我必须将保险功能拆分出来，因此我发现自己需要在这两个地方再次创建那个子类。如果我遇到这种情况。
- en: to do that a lot it's a good clue that maybe I want to centralize those and
    maybe have one。 single finance handler that can handle both of those for each
    of these different subclasses。 Next code smell I want to talk about is called
    feature envy。 This happens if you've got an。 object that's kind of reaching in
    very frequently to another class。 And it's very similar to。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经常这样做，那可能是一个很好的线索，表明我可能想要将这些集中起来，也许有一个单一的财务处理器可以处理这两者，以应对这些不同的子类。下一个我想讨论的代码异味称为特征嫉妒。这发生在你有一个对象频繁地深入另一个类的情况。这与。
- en: inappropriate intimacy which happens when classes know more about each other
    than they probably。 should。 So as an example， let's say I've got an entree class
    and I'm reaching into this。 junk food class pretty frequently to do things like
    get the calorie content for my entree。 find out how much sugar is in it。 And a
    good clue here that something is messed up is the。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 不当亲密关系来隐藏这个代理，这种情况发生在类之间知道的内容超出了它们应该知道的范围。例如，假设我有一个主菜类，而我频繁深入这个垃圾食品类，做一些事情，比如获取我的主菜的卡路里含量，了解其中含有多少糖。而一个好的线索是某些东西出了问题。
- en: names because an entree isn't necessarily junk food。 So it probably makes more
    sense to pull。 those functions out into a nutrition info provider so that both
    my entree and my junk food can。 access it。 The next code smell is somewhat visual。
    This happens when you've got a lot。 of different switch statements。 And generally
    the way that we address this is by taking those。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 名字，因为主菜不一定是垃圾食品。因此，将这些功能提取到营养信息提供者中可能更有意义，以便我的主菜和垃圾食品都可以访问它。下一个代码异味在某种程度上是视觉上的。当你有很多不同的
    switch 语句时，就会发生这种情况。通常，我们通过将这些语句集中处理来解决这个问题。
- en: switch statements out into a method， finding a class where we can store that
    method and。 then attempting to extract what we're switching upon into state。 So
    for example。 if you're switching， on employee type， you could create employee
    type as a class and then use that to figure。 out which employee you're looking
    at。 Next code smells called message chains。 This happens。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将 switch 语句提取到一个方法中，寻找一个可以存储该方法的类，然后尝试将我们正在切换的内容提取到状态中。例如，如果你正在切换员工类型，你可以创建员工类型作为一个类，然后用它来确定你正在查看的员工。接下来的代码异味称为消息链。这种情况发生在客户端仅与个人交互，而个人则会自主与部门互动。
- en: if you have one client that has to keep asking an object about another object
    and then maybe。 this object about another object and so on and so forth。 So there
    are a couple ways to。 address that but the one I want to talk about is called
    hide delegate。 So let's imagine that。 I have a client and it needs to figure out
    it's reaching into an object to figure out。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个客户端必须不断询问一个对象关于另一个对象的信息，然后可能再询问这个对象关于另一个对象的信息，依此类推。有几种方法可以解决这个问题，但我想讨论的方法称为隐藏代理。假设我有一个客户端，它需要确定自己正深入一个对象以弄清楚。
- en: a person and then to figure out the department that that person belongs to，
    it has to go to。 the department and maybe it's looking at both person and department，
    sometimes it looks。 at department to get the manager and that can be kind of confusing。
    So ideally the client。 should only have to have knowledge of one of those so we
    can hide this delegate by having。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个个人有关，要弄清楚该个人所属的部门，它必须去部门，有时它需要同时查看个人和部门，有时它会查看部门以获取经理，这可能会有些混淆。因此，理想情况下，客户端只应了解其中一个，以便我们可以通过。
- en: the client interact only with person which will interact on its own with department。
    And。 the reciprocal code smell here is called middle man which happens when you've
    got a bunch。 of classes that are only acting as delegates。 So if that happens
    you probably need to go。 through and delete some along the way。 This code smell
    has probably the most complicated， name。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 而这里的相应代码异味称为中介，当你有一堆仅作为代理的类时就会发生。如果发生这种情况，你可能需要逐一删除其中的一些。这个代码异味可能是最复杂的名字。
- en: This happens， it's called refused bequest and basically it just means that a
    child class。 doesn't need everything that it's inheriting。 So as a general guideline
    if a child should。 need everything that its parent is giving it and if it does
    not the best thing you can。 probably do is push down some of that functionality
    into a sibling class。 And this is getting into。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这会发生，这被称为拒绝遗赠，基本上意味着子类不需要它所继承的一切。因此，一般指导原则是，如果子类需要父类提供的所有东西，但实际上并不需要，那么你可以将一些功能推到一个兄弟类中。这涉及到。
- en: an important concept here which is the difference between inheritance and composition。
    And there's。 enough material here to go into another talk。 In fact there was a
    talk about the same subject。 yesterday so I'm not going to go into it too much
    but basically you want to ask yourself。 do I need to inherit all of the things
    this parent can do and if not is it better to just。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个重要的概念，即继承和组合之间的区别。这里有足够的材料可以深入探讨另一个主题。实际上，昨天就有一个关于同一主题的讲座，所以我不想过多展开，但基本上你需要问自己，是否需要继承这个父类能够做的所有事情，如果不需要，是否更好。
- en: contain the specific functionality I need。 So the basic smells or the basic
    categories。 of smells that we've looked at are when something is too long we split
    it out。 If it's not useful。 enough we need to compress it or move the functionality
    and if we've got bad object。 oriented programming we're restructuring。 So now
    I want to talk about specific code smells。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 包含我所需的具体功能。所以我们看过的基本气味或基本类别是，当某件事太长时，我们会将其拆分。如果它的实用性不够，我们需要压缩或移动功能，如果我们有糟糕的面向对象编程，我们会进行重构。所以现在我想谈谈具体的代码气味。
- en: for Python。 So the first one and I guess this isn't necessarily specific to
    Python is extremely。 nested code where you've got a lot of if statements。 In Python
    often there are things you can do。 to rip that out entirely。 So like for example
    if you're looking at a list and doing a lot。 of boundary checking often you can
    just use an iterator and avoid doing all of that。 But。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 针对Python。所以第一个，我想这不一定特指Python，是极其嵌套的代码，你有很多if语句。在Python中，通常可以完全去掉这些东西。例如，如果你正在查看一个列表并进行大量边界检查，通常可以只使用迭代器，避免所有这些。但是。
- en: I am going to go through a longer demo for one of these in a couple of minutes
    so we'll。 come back to this。 Unnecessary boilerplate code。 This happens if you've
    got a class that's。 basically just storing a bunch of data and maybe overriding
    a couple of things。 So if。 this happens you're probably reinventing the wheel
    a little bit。 So as an example let's。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在几分钟内进行一个更长的演示，所以我们稍后再回来。多余的模板代码。这种情况发生在你有一个基本上只是存储大量数据的类，可能还覆盖了一些内容。如果发生这种情况，你可能是在重复造轮子。作为一个例子，让我们。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_31.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_31.png)'
- en: say that I've got this math method or this math object and I'm storing a bunch
    of variables。 and then I'm redefining the wrapper method and the string method。
    So if I'm doing this。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有这个数学方法或这个数学对象，我正在存储一堆变量，然后重新定义包装方法和字符串方法。如果我这样做。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_33.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_33.png)'
- en: the odds are that I could use something else。 In particular I could do this
    with a data。 class where I pass in all the variables I need and their types and
    then it'll redefine。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能可以使用其他东西。特别是，我可以用数据类来做这个，传入我所需的所有变量及其类型，然后它会重新定义。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_35.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_35.png)'
- en: and represent string for me。 Or I could use an adder。 Kind of a similar concept
    here。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 并为我表示字符串。或者我可以使用加法器。这是一个类似的概念。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_37.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_37.png)'
- en: The next Python code sma when I talk about is when your exception handling is
    too tightly。 coupled to your business logic。 So in general we like those to be
    kind of separate because。 it's just easier to read and nicer to deal with。 So
    if this happens then hopefully you。 can push down your exception handling maybe
    like in a try and accept block。 And the last。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我谈到的Python代码是，当你的异常处理与业务逻辑过于紧密耦合时。所以一般来说，我们希望它们保持一定的分离，因为这样更容易阅读，更好处理。如果发生这种情况，希望你能将异常处理放入try和accept块中。最后。
- en: Python specific code smell talk about is if you're repeating set up and tear
    down actions。 frequently。 So if this is happening you might want to introduce
    a context manager which you。 would usually call using the with method。 Great so
    now I said I would do a demo of a。 longer example with nested if statements。 So
    that's what I'm going to do and I will。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 具体谈到Python代码的气味，就是如果你频繁重复设置和拆除操作。如果发生这种情况，你可能想引入一个上下文管理器，通常用with方法来调用。很好，所以我说我会演示一个带有嵌套if语句的较长示例。这就是我将要做的。
- en: point out what's important so if you can't read this or see it hopefully that'll
    be okay。 So let's say that I'm building a restaurant menu and I want to be able
    to decide what。 the menu looks like at a given night and I'm going to base that
    off of what ingredients。 were freshly available at the market in a given day。
    And let's also say so these are。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 指出重要的事情，如果你看不懂或看不清，希望这没关系。假设我正在制作一个餐厅菜单，我想决定某个晚上菜单的样子，而这个决定是基于某一天市场上新鲜可用的食材。我们再说一遍，这些是决定菜单的依据。
- en: the basic things I can make at my restaurant。 It's very basic。 I can make pizza
    with bread。 and sauce。 I can make grilled cheese with cheese and bread， cheese
    and fish and then， steak。 So very simple options here。 And let's say I want to
    vary my menu based on season。 So now I have to look at the ingredients I have
    available and the season that I'm in。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常基础的。我可以用面包和酱料做披萨。我可以用奶酪和面包做烤奶酪，再加上鱼和牛排。所以这里的选项非常简单。假设我想根据季节变化我的菜单。现在我必须查看我有的食材和我所在的季节。
- en: to decide a menu。 And let's also say that I'm very frugal。 I want to increase
    my profit， margin。 So I only want to offer the customer the cheapest thing that
    I'm capable of making。 So let's say I just kind of like puke this logic into code。
    I might end up with something。 that looks like this。 You don't have to read it。
    Basically I'm just going through and looking。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我也想说我是一个非常节俭的人。我希望提高我的利润率。所以我只想为顾客提供我能够制作的最便宜的东西。假设我把这种逻辑简单地写成代码，最终可能会得到像这样的东西。你不需要读懂它。基本上我只是查看我餐厅能制作的基本东西。
- en: at the season and then figuring out if I can make the first cheapest option
    for that season。 And if I can I return that。 And then I go to the next option
    and so on and so forth。 And。 you have to read it a couple of times to really parse
    what's going on。 So obviously。 this is a good candidate for refactoring。 But before
    we do that I want to show what will。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个季节，然后弄清楚我是否可以为该季节制作第一个最便宜的选项。如果可以，我就返回那个。接着我再去下一个选项，以此类推。你得读几遍才能真正理解发生了什么。所以显然，这是一个重构的好候选者。但在我们这样做之前，我想展示一下会发生什么。
- en: happen if we have to add functionality。 So let's say that now I need to track
    whether。 or not my customer ordered an alcoholic drink with their order。 And let's
    say there's a。 law that mandates that if I'm ordering an alcoholic drink I have
    to eat an entree that。 has protein in it。 So now I need to keep track of whether
    or not they ordered a drink the。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要添加功能会发生什么。假设现在我需要跟踪我的顾客是否在订单中点了一杯酒。假设有一项法律规定，如果我点了酒，我必须吃一份包含蛋白质的主菜。所以现在我需要跟踪他们是否点了一杯饮料。
- en: season I'm in and the ingredients that I have available。 So if I just add this
    parameter。 to all of the statements where I need it that's how that looks。 I have
    to make that change。 in a lot of different places and now my logic is getting
    even worse and harder to look at。 Which is bound to happen when you have code
    that needs to be refactored。 So first thing。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我所在的季节和我有的食材。如果我只在需要的所有语句中添加这个参数，就是这样的。我必须在很多不同的地方进行更改，现在我的逻辑变得更糟，更难以查看。这是重构代码时必然会发生的事情。所以我在这里要做的第一件事是改用菜单项列表。
- en: I'm going to do here is switch to using a list of menu items。 So rather than
    returning。 the first available cheapest option we will put the cheapest option
    in first and then。 return a list that's sorted by the cheapest available entree
    to the most expensive。 So here。 I'm just adding a list and then appending to it
    before I return。 The next thing I'm。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们不再返回第一个可用的最便宜选项，而是将最便宜的选项放在前面，然后返回一个按从最便宜到最昂贵的主菜排序的列表。在这里，我只是添加了一个列表，然后在返回之前向其附加。接下来我要做的事情是。
- en: going to do is pull out this kind of a key logic into methods。 For two reasons
    first。 of all because it'll make it the if statements more descriptive and second
    of all because。 as a rule these statements are going to get more complicated not
    less。 So just a couple。 of things to point out here I have a menu class where
    I am mapping each entree to the。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把这种关键逻辑提取到方法中。原因有两个：首先，这样会让if语句更具描述性，其次，作为规则，这些语句会变得更加复杂，而不是更简单。因此，这里有几点需要指出，我有一个菜单类，将每个主菜映射到。
- en: ingredients that compose it and then I'm going through and I'm just figuring
    out if I can。 make each one of those entrees and if I can then that's a possible
    dish for that night。 And if my person has ordered a drink then I know that I can
    only use entrees from the。 proteins list。 So now I have a series of methods where
    I can get the menu according to a。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 组成它的食材，然后我去逐个弄清楚是否可以制作这些主菜，如果可以，那么这就是那个夜晚的可能菜肴。如果我的人点了一杯饮料，那么我知道只能使用蛋白质列表中的主菜。因此，现在我有一系列方法，可以根据。
- en: season based on what entrees are available in that season。 And now my logic
    is a lot cleaner。 to look at。 I just check what season I'm looking at and then
    get the menu for that particular。 season。 The next thing I'm going to do is pull
    these functions into methods for a few。 different reasons。 First of all so I can
    kind of pre-compute the menu for that night rather。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 根据那个季节可用的主菜来决定季节。现在我的逻辑看起来更清晰。我只需检查我正在查看的季节，然后获取那个特定季节的菜单。接下来我要做的是将这些函数拉入方法，出于几个不同的原因。首先，这样我可以预先计算那个夜晚的菜单，而不是。
- en: than doing it in each of statement。 I'm going to override the bool method so
    that I can easily。 check which menu to use。 And then mainly really the third reason
    is it will make my unit test。 easy because now I can just create this object and
    kind of spot check a couple of things rather。 than having to like look at the
    menu and check that certain things were called internally。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在每个if语句中执行。我将重写布尔方法，以便轻松检查使用哪个菜单。主要的第三个原因是，这将使我的单元测试变得简单，因为现在我只需创建这个对象，并简单检查几个点，而不是查看菜单并检查某些内部调用。
- en: So now I'm adding a concept of season to my menu and I have subclasses that
    store the。 options for that particular night and a bool method which will tell
    me if I'm looking at。 the right season。 So now my code looks like this。 I check
    to see if it's appropriate to。 use the summer menu and if it is I grab that menu。
    This code is still not perfect。 I could。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我在我的菜单中添加了季节的概念，并且有子类存储那个特定夜晚的选项，还有一个布尔方法告诉我是否在查看正确的季节。因此，现在我的代码看起来像这样。我检查是否适合使用夏季菜单，如果适合，我就抓取那个菜单。这个代码仍然不完美。我可以。
- en: be returning directly for starters rather than grabbing the menu since I will
    only be in one。 season at a time。 But this is where we're going to leave it for
    now。 So I want to point out。 a few things。 First of all don't add your functionality
    while you're refactoring。 You want to do that， before you refactor or after you've
    refactored everything。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 直接返回开胃菜，而不是抓取菜单，因为我一次只会在一个季节中。但目前我们就先停在这里。我想指出几件事。首先，在重构时不要添加功能。你要在重构之前或重构所有内容后再进行。
- en: If you try to do them both simultaneously， it will probably be a bad time。 You
    want to make changes incrementally and then if you。 can hopefully verify that
    your tests continue to pass as you're going。 Remember that making。 progress is
    better than ending up with perfect code。 So when you're refactoring it's pretty。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试同时进行这两项，可能会很糟糕。你要逐步做出改变，并且希望在此过程中验证你的测试是否继续通过。记住，取得进展总比得到完美代码要好。所以当你重构时，情况相当。
- en: easy to go down this rabbit hole where you're like okay I need to change this
    so this class。 should really be like this and now I need a new class here and
    kind of end up changing， everything。 And it's better to just make progress incrementally
    rather than getting yourself into。 a mess or rewriting all of the code。 So how
    are we going to do the refactoring？ A few different。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易陷入这种思维定势，你可能会想“好的，我需要改变这个，所以这个类应该这样，现在我需要在这里新增一个类”，最后几乎把所有东西都改动。逐步推进总是比陷入混乱或重写所有代码要好。那么我们该如何进行重构呢？有几种不同的。
- en: strategies。 Test driven development if you have good tests then run them repeatedly
    to。 make sure things still pass between changes and if not create the tests that
    you wanted。 and then refactor until they pass。 Litter pickup if you want to do
    it incrementally along the， way。 So small things that you can do at a wrapper
    for debugging， delete or migrate unused。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 策略。测试驱动开发，如果你有良好的测试，那么反复运行它们，以确保在变更之间仍然通过，如果没有，就创建你想要的测试，然后重构直到它们通过。逐步收集垃圾，如果你想要的话，在这个过程中做一些小事。你可以为调试创建一个包装，删除或迁移未使用的代码。
- en: functionality and then one that we do on my team if you have a comment that
    indicates。 that something was not clear enough to stand by itself。 So if you can
    refactor to make it。 stand alone and then remove the comment that's an easy thing
    to do。 A comprehension if you。 want to start by understanding the code and then
    take that understanding and put it into。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性，如果在我的团队中有评论表示某些内容不够清晰，无法独立存在。那么如果你能重构使其独立，并去掉评论，那将是件简单的事。如果你想先理解代码，再将理解转化为。
- en: the codes the next person has an easier time。 Preparatory if you want to refactor
    so that。 you can do something else later。 Planned which happens if you have to
    actually schedule out。 the refactoring which probably means that you waited a
    little too long。 In red green。 refactoring which is very similar to test driven
    development where you create the tests。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以让下一个人更容易上手。如果你想重构以便将来可以做其他事情，那么就提前规划一下。如果你必须实际安排重构，可能意味着你等得有点太久了。在红绿重构中，这与测试驱动开发非常相似，你需要先创建测试。
- en: that you want and then they will fail and then you kind of refactor until they
    pass。 So now I want to throw a wrench in this。 What if we need to maintain backwards
    compatibility。 and I'll do this quickly。 Let's say we're going to use an expand
    contract pattern so we have。 the old code we'll add the new code alongside it
    and then we'll contract to just the new， code。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要的东西，然后它们会失败，你就得重构直到它们通过测试。现在我想扔一个难题进去。如果我们需要保持向后兼容。让我快速说一下。假设我们将使用扩展收缩模式，所以我们有旧代码，然后在旁边添加新代码，接着我们只保留新代码。
- en: So in Python we can split classes by passing an optional parameters and then
    issue。 warnings and the old code path。 So as an example if I have a cheeto class
    with a name and a。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以通过传递可选参数来拆分类，然后在旧代码路径中发出警告。举个例子，如果我有一个带有名称的cheeto类。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_39.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_39.png)'
- en: mountain of cost and then I start to add parameters to it like spiciness and
    kind of cheese then。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 成本的山，然后我开始为它添加参数，比如辛辣度和奶酪种类。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_41.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_41.png)'
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_42.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_42.png)'
- en: I decide to lift some of that into a parent class called snack。 So now I have
    two different。 code paths if I'm passing in my snack parent class then I'll use
    that and if not I'll accept。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定把其中一些内容提取到一个名为snack的父类中。所以现在我有两条不同的代码路径，如果我传入我的snack父类，我就会使用它，如果没有，我就接受。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_44.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_44.png)'
- en: parameters to build it myself and then I also want to issue a warning in the
    second case。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 参数由我自己构建，然后在第二种情况下我也想发出警告。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_46.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_46.png)'
- en: to tell the person that they should be using the refactored version。 Great。
    So now back。 to that same question to refactor or not when to not refactor。 If
    you can add better documentation。 instead so if that's possible to just document
    an endpoint you might want to do that。 If you're。 just showing off by showing
    that you can do like a 360 deluxe prototype refactor then。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉对方他们应该使用重构后的版本。很好。那么回到那个问题：重构还是不重构？什么时候不重构。如果你可以添加更好的文档，那就这样做。如果只是为了展示你能做一个360豪华原型重构，那。
- en: that's probably not a great idea and it won't make your coworkers like you more。
    And if you。 need to rewrite it from scratch then you might not even bother refactoring。
    So in general good。 reasons to refactor if you've regretted not doing this before
    if no one on the team has。 any idea what this does anymore then it's a good idea
    then you can be that person who。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是个好主意，并且不会让你的同事更喜欢你。如果你需要从头重写，那么你可能连重构都不会去做。总的来说，重构的好理由包括如果你后悔以前没有这样做，如果团队中没有人知道这段代码的作用，那么这就是一个好主意，那你就可以成为那个人。
- en: kind of works in understanding and then puts that into the code。 And then if
    refactoring。 this code now will definitely make it easier to change later on those
    are all good reasons。 to refactor。 And remember that our mantra here when it comes
    to refactoring is progress。 not perfection。 So we're trying to make progress with
    the code that we're writing and in fact。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这在理解中起到了作用，然后将其转化为代码。如果重构，这段代码现在肯定会使后续更改变得更容易，这些都是重构的好理由。并且请记住，在重构时我们的座右铭是进步，而不是完美。因此，我们试图在我们所写的代码上取得进展，实际上。
- en: it's better to start with a smaller change so that everyone can kind of get
    used to how。 this works rather than rewriting everything all together and now
    you might end up with。 the same issue where there's only one person who understands
    how all of this works。 So I。 want to say that I had a lot of the code smells most
    of the code smells in this talk。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最好从小的变更开始，这样每个人都可以适应这个运作方式，而不是一次性重写所有内容，否则你可能会面临同样的问题，只有一个人了解这一切是如何运作的。因此，我想说，我在这次演讲中提到的很多代码异味。
- en: are from the book refactoring which is written by Martin Fowler。 So if you're
    interested in。 learning more about code smells or design patterns then that's
    an excellent place to， start。 And if you take anything away from this talk first
    of all if you get the sense。 that there's a code smell here so if your spidey
    senses are sort of starting to tingle。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内容来自于马丁·福勒撰写的《重构》一书。如果你有兴趣了解更多关于代码异味或设计模式的内容，那么这是一个很好的起点。如果你从这次演讲中能带走任何东西，首先，如果你感受到这里有代码异味，或者你的直觉开始发觉。
- en: and you feel like there's something wrong then pay attention to that feeling
    or that。 instinct and it'll probably get sharper as you go on in your career。
    That means that。 there's something that's worth looking into and it's not a hard
    and fast rule if there's。 a code smell that doesn't mean that something necessarily
    has to change but it is worth。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 并且你觉得有什么不对劲，那么请注意这种感觉或直觉，随着你职业生涯的进展，这种感觉可能会变得更加敏锐。这意味着有值得关注的地方，并且这不是一个绝对的规则，如果有代码异味，并不意味着一定需要更改，但确实值得。
- en: paying attention to。 Remember that the true meaning of refactoring is to arrive
    at a better。 understanding ultimately and something that is easier to maintain。
    So if you've done a。 lot of refactoring and it ends up more complicated that means
    that something went amiss along。 the way。 And try and think about your strategy
    for refactoring before jumping in。 So at a。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到。请记住，重构的真正意义在于最终达到更好的理解和更易于维护的东西。因此，如果你进行了大量重构，结果却变得更加复杂，那就意味着在过程中出了问题。在跳入之前，试着考虑一下你的重构策略。因此，在。
- en: minimum this means having a rollback strategy and hopefully some kind of test
    suite that。 you can use to make sure you didn't break anything but it also means
    being deliberate。 about how you do the refactoring。 So taking the time to say
    okay if I refactor this piece。 then I need to have backwards compatibility here
    so I'm going to do that and then I'll。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最低限度，这意味着要有一个回滚策略，以及希望有某种测试套件，以确保你没有破坏任何东西，但这也意味着你要在重构时有意识地进行。因此，花时间说好吧，如果我重构这一部分，那么我需要在这里保持向后兼容性，所以我会这样做，然后我会。
- en: work on this piece and kind of break it up in a thoughtful way so that you don't
    just。 dive in and kind of get yourself into a quandary where you're not able to
    change anything anymore。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分工作上，并以一种深思熟虑的方式将其拆分，以免你只是。全力以赴，导致自己陷入困境，无法再更改任何东西。
- en: '![](img/bd4b85369cebaf42f41095741b58be4d_48.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4b85369cebaf42f41095741b58be4d_48.png)'
- en: Great， so thank you for coming。 I tweeted out these slides and I'm not going
    to be doing。 open Q&A so if you do want to talk， happy to discuss this or more
    code smells feel free。 to tweet at me or come talk to me in person and thank you。
    Have a good rest of your PyCon。 [Applause]， (applause)， (applause)。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，谢谢大家的到来。我已经在推特上分享了这些幻灯片，并且我不会进行开放的问答环节。如果你想讨论，欢迎与我交流这些或者其他代码异味，随时可以在推特上联系我或当面交流，谢谢。祝你们的PyCon余下时光愉快。[掌声]，(applause)，(applause)。
