- en: P27：Geir Arne Hjelle - Plugins - Adding Flexibility to Your Apps - PyCon 2019
    - leosan - BV1qt411g7JH
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P27：Geir Arne Hjelle - 插件 - 为你的应用程序添加灵活性 - PyCon 2019 - leosan - BV1qt411g7JH
- en: Hello everyone， it's time to get started。 Our first talk is going to be given
    by Yair Arne-Yal on plugins adding flexibility to。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大家好，时间到了，让我们开始。我们的第一场演讲将由Yair Arne-Yal进行，主题是插件为应用程序添加灵活性。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_1.png)'
- en: your apps。 Let's give them a big warm welcome。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给他们一个热烈的欢迎。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_3.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_3.png)'
- en: Thank you so much and a big thanks to the organizers for letting me speak here。
    My name is Gedon Iela， I work together with the real Python team to write articles。
    So this talk is partly based on at least some ideas in those articles。 And what
    I'm going to talk about is essentially a very simple way to add flexibility and。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢，特别感谢组织者让我在这里发言。我叫Gedon Iela，我和真正的Python团队一起撰写文章。因此，这次演讲部分基于那些文章中的一些观点。我将讨论的基本上是一种非常简单的方法来添加灵活性和。
- en: modularize your code。 So something I call plugins。 So the agenda for the talk
    is essentially I'll try to motivate a little bit why we should。 care about simple
    code。 Although I hope that's also slightly obvious。 And then the main part of
    the talk will be actually giving an example of how to build， a small app。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化你的代码。我称之为插件。因此，这次演讲的议程基本上是，我会稍微激励一下，为什么我们应该关注简单的代码。虽然我希望这也稍微显而易见。然后演讲的主要部分实际上是给出一个如何构建小应用程序的示例。
- en: We try to essentially see how we can make a small command line app that can
    plot your。 data and how we can kind of modularize this to support different data
    formats， different。 kinds of plots and those kind of things。 And then towards
    the end I'm just going to say a few words about a small package that。 kind of
    supports this kind of infrastructure。 Okay， so quick motivation。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图看看如何制作一个可以绘制数据的小型命令行应用，以及如何模块化以支持不同的数据格式、不同类型的图表等。然后在最后，我将简要提到一个小包，它支持这种基础设施。好的，快速激励。
- en: If you have modularized your code typically what you end up with is something
    that's less， complex。 You may have more functions and things like this but each
    function is doing one single， thing。 You have the single responsibility principle
    kind of built in there and it's easy to reason。 about what your code is doing。
    That also makes everything much easier to maintain。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你模块化了代码，通常得到的是一些不那么复杂的东西。你可能会有更多的函数，但每个函数只做一件事。你有单一职责原则的内建，这让你容易理解代码的作用。这也使得维护变得更加简单。
- en: easier to test those kind of things， and easier to extend later， easier to add
    extra functionality。 So what I'm kind of calling plugins here means， so essentially
    built on the system you'll。 see later that your app can be controlled easily by
    configuration settings for instance。 or options to your code。 You can easily extend
    and customize your app even you can let your users do this。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 更容易测试这些事情，更容易扩展，便于添加额外的功能。所以我所称的插件，基本上是基于系统的，稍后你会看到，你的应用程序可以通过配置设置或者代码选项轻松控制。你可以轻松扩展和自定义你的应用程序，甚至可以让用户自己做到这一点。
- en: And by having things modularized nicely things are better structured and often
    typically means。 that you can also develop faster especially if you're on the
    team you can have people。 talk doing different kind of things without really butting
    heads against each other。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过良好的模块化，事物结构变得更清晰，通常意味着你可以更快地开发，特别是当你在团队中时，团队成员可以进行不同类型的工作，而不必相互冲突。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_5.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_5.png)'
- en: Okay， so let's actually do this。 So what I want to do now is just show you how
    to build this simple plotter app and what。 I want this to be is a small command
    line application that should be able to read data。 from a CSV file and plot data
    in a simple line graph。 So nothing really revolutionary but just to kind of have
    the example going。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那我们实际上来做这个。现在我想展示如何构建这个简单的绘图应用程序，我希望它是一个小型命令行应用，能够从CSV文件读取数据，并以简单的折线图绘制数据。因此，虽然没有什么革命性的，但只是想有个示例。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_7.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_7.png)'
- en: So what I'm going to do here and let's see we can even make this slightly bigger。
    It's just code up this little plotter function that I have and what I want this
    to do is。 it's going to be a command line app so I'm just going to use this sweet
    little library。 called click。 And what this does is that I can add this small
    decorator on top and say that this is。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: a command like this and then I can go to my command line and say that I want
    to run this。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_9.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: and of course not much happened but if I do help here you can see that I already
    got。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_11.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: some help message popped in here。 So this is done just by calling this a click
    command。 And before I actually continue here because I'm going to use these decorators
    a little。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_13.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: bit so let me just stop here and take a half a minute crash course in what a
    decorator， is。 So the thing you saw with the add symbol on top there is called
    the decorator and what。 this is really just a function that you can use to wrap
    another function。 And what it does is essentially have your original function
    and then you call your decorator。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: function on it。 So a decorator is really just a function that takes a function
    as an argument and returns。 a function。 And what you kind of the thing you get
    out is the decorated function。 So why do you want to do this？ Well you can add
    common functionality across many functions and methods。 So the example here is
    that we're taking a regular function， the main function I had。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: and making it into a command that you can run on the command line。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_15.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: And as I said what Python is doing is the decorated equals decorator of the
    original。 function but the typical way that you write it is using this pie syntax
    or add symbol。 syntax like we see here。 Okay if you want to learn a lot more about
    the Python decorators we have an article that。 I wrote on real Python so you can
    go really into the dots there。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_17.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: Okay so back to our demo。 Okay I have this command and I want to read in a data
    file so that means that I need to。 take this in as an argument。 So I'll have here
    the argument of a file path and this magically pops into my main method。 then
    by handle by click。 And then I prefer my file paths to be pathlib paths so pathlib
    is a somewhat new library。 in the standard library it was introduced in Python
    3。4 and it makes it so much nicer。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: to work with file paths。 So I'll just convert the string that I'm really getting
    in here to a pathlib。 So we have the file path like this and then I want to do
    what I want to do while I want。 to read my data。 So let's just read data from
    the file path and when I have the data I want to create a plot。 So this is essentially
    the script I want but of course now we need to add in those two。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: methods read data and create plot and those are fairly simple。 So I first time
    I read data it takes in a file path and let's see what do we want this。 one to
    do I want this to read in this case actually CSV data and return a Pandas data，
    frame。 And with the magic of Pandas this is fairly simple I just need to do return
    Pandas read。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 方法读取数据和创建图表，这些都相当简单。所以我第一次读取数据，它接受一个文件路径，让我们看看我们希望这个。做什么，我想这实际上是读取CSV数据并返回一个Pandas数据框。凭借Pandas的魔力，这相当简单，我只需做返回Pandas读取。
- en: CSV of the file path。 And now I've gotten another dependency here so let's import
    Pandas like this。 Okay so now I have my data and they're stored now in the data
    frame。 So the next thing I want to do if we go back to down here is that we need
    to create the。 plot or something like this so let's add that。 So I'm getting the
    data and I want to plot them and again through magic of Pandas this。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: CSV文件路径。现在我得到了另一个依赖关系，所以让我们像这样导入Pandas。好的，现在我有了数据，它们现在存储在数据框中。接下来我想做的是，如果我们回到这里，我们需要创建图表或类似的东西，所以让我们添加这个。所以我获取数据并想绘制它们，而再次通过Pandas的魔力，这。
- en: is fairly simple we just do data plot。 And finally I want to just make sure
    that I show the plot so then I'm using Matplotlib。 so we need to import that as
    well。 So let's see Matplotlib like this。 Okay so now we created a small app let's
    be good citizens and document this one as well。 so plot the Pandas data frame。
    And when we have all of this setup we should be able to run this so this is I
    guess the。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 是相当简单的，我们只需做数据绘图。最后我想确保我显示图表，所以我会使用Matplotlib。因此，我们也需要导入它。让我们看看Matplotlib是这样的。好的，所以现在我们创建了一个小应用程序，让我们做个好公民，把这个也记录下来。所以绘制Pandas数据框。当我们设置好这一切后，我们应该能够运行这个，所以我想这是。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_19.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_19.png)'
- en: exciting part of the talk。 So first of all now we can see the click has actually
    told me that okay I need the file。 path so that's cool。 And then I should have
    some data hidden away here so have a CSV file with the iris data。 this is a fairly
    well known data set about some iris flowers。 And when we run this we get our plot
    up。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 演讲中令人兴奋的部分。所以首先，我们可以看到点击实际上告诉我，我需要文件路径，这很不错。然后我这里应该有一些隐藏的数据，所以有一个包含鸢尾花数据的CSV文件。这是一个关于一些鸢尾花的相当知名的数据集。当我们运行这个时，我们得到了图表。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_21.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_21.png)'
- en: So so far we built a fairly simple app okay no plugins nothing magic really
    happening here。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们构建了一个相当简单的应用程序，好的，没有插件，真的没有什么神奇的事情发生。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_23.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_23.png)'
- en: but just okay we have something up and running。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不过没关系，我们有一些东西正在运行。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_25.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_25.png)'
- en: So let's now expand this let's say that okay people have I have a JSON data
    I have data。 in some weird format over there and of course if we try this so let's
    say that I have the。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来扩展一下，假设人们有JSON数据，我在某种奇怪的格式下有数据。当然，如果我们尝试这样做，比如说我有的。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_27.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_27.png)'
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_28.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_28.png)'
- en: iris data also as a JSON file and if I plot this of course it won't work because
    I'm expecting。 to get the CSV file。 So I want now to be able to expand the plot
    rep so I can support more file formats I want。 to be able to support more kinds
    of plots not just the line plot I had there and possibly。 add in some control
    on which kind of data I want to plot and all those kind of things。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 鸢尾花数据同样作为JSON文件，如果我绘制这个，当然它不会工作，因为我期望得到CSV文件。因此，我现在想能够扩展图表表示，以便我可以支持更多文件格式。我想能够支持更多类型的图表，不仅仅是我之前的线图，并可能添加一些控制，以选择我想绘制的数据类型，以及所有这些事情。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_30.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_30.png)'
- en: So probably won't be able to do all of these things but a few things at least
    fairly quickly。 So let's see let's see if we can instead of just reading CSV data
    here see that we want。 to read at least CSV and JSON all kinds of data would be
    fun。 And one way to do this then is that okay I need to figure out which format
    do I have， here。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以可能无法做到所有这些事情，但至少可以比较快地做到几件事。让我们看看，如果我们不只是读取CSV数据，而是希望读取至少CSV和JSON，所有类型的数据会很有趣。这样做的一种方法是，好的，我需要搞清楚我这里有什么格式。
- en: So this is one of the neat things with this with the pathlib is that I can just
    ask for。 file suffix and that would be dot CSV or dot JSON so I'll strip off the
    dot and then I。 can just do if format is CSV then we're doing the same kind of
    thing right while if our format。 is JSON then we should do something else and
    in this case we can just create the JSON dictionary。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所以使用`pathlib`的一个很酷的地方是，我可以直接请求文件后缀，它会是`.csv`或`.json`，然后我去掉点，接着我可以做一个判断，如果格式是CSV，那我们就做同样的事情，如果我们的格式是JSON，那我们应该做其他事情，在这种情况下，我们可以创建JSON字典。
- en: or a dictionary from adjacent I guess and using the JSON library and then I
    just again。 the pathlib I can just read this in as a texturing like this and then
    pandas can create a data。 frame from this。 So if we do this and then JSON dict
    that should work now we need to import JSON like。 this and I guess again we could
    be nice citizens and race and error if this goes wrong。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 或者从JSON字典中获取，我想用JSON库，然后我再次使用`pathlib`可以这样读取它，并且`pandas`可以从中创建一个数据框。所以如果我们这样做，然后`JSON
    dict`应该可以工作，现在我们需要像这样导入JSON，估计我们还可以做个好市民，如果出错就抛出错误。
- en: Something like format not supported。 Okay so now hopefully my CSV will still
    work so I can still read the CSV file and let's。 see if I can now read the JSON
    file as well。 Yes so now we got both of these and I have just for fun we also
    have a bigger JSON file。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于“格式不受支持”。好的，所以现在希望我的CSV仍然可以工作，因此我仍然可以读取CSV文件，让我们看看我现在是否也可以读取JSON文件。是的，现在我们得到了这两者，我只是为了好玩，我们还有一个更大的JSON文件。
- en: with more data that's not really that important for now but okay。 This is fine
    I can keep doing this right。 In the typical application handling a format this
    might be more work than just the one line。 read a CSV read a JSON and so this
    will be terrible to maintain after a while。 If I have ten different formats maybe
    each of them takes five ten lines you do something。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有更多的数据，现在这并不重要，不过好的，这很好，我可以继续这样做。在典型的应用中处理格式，这可能比仅仅一行代码（读取CSV、读取JSON）要复杂得多，因此过一段时间后维护起来会很糟糕。如果我有十种不同的格式，也许每种格式都需要五到十行代码来做一些事情。
- en: with this doesn't really work。 So what we want to do is actually modularize
    this out so that the read data is not responsible。 for handling ten different
    formats but that we have one function that kind of handles each， format。 So if
    we do that let's say that we then create ourselves a readers module that can read
    data。 from different formats and if I now see I'll just go here and then I copy
    the code that。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这样并不太管用。所以我们想要做的实际上是将其模块化，以便读取的数据不再负责处理十种不同的格式，而是有一个函数处理每种格式。所以如果我们这样做，假设我们创建一个读取器模块，可以从不同格式中读取数据，如果我现在查看，我就可以在这里复制代码。
- en: we have here and throw this into this one and say that okay this should now
    be a function。 that's responsible for reading a file read CSV file and return
    data frame。 And then I have a second function that reads a file path so this should
    read JSON file。 and return data frame。 And this is almost like this let's see
    one small little thing here is that actually I。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将其放入，并说好的，这现在应该是一个负责读取文件的函数，读取CSV文件并返回数据框。然后我有第二个函数来读取文件路径，这个函数应该读取JSON文件并返回数据框。几乎就是这样，让我们看看这里还有一个小问题。
- en: get my JSON function and the JSON library kind of nameclash there so I'll just
    call the。 JSON library JSON lib do this and then we need pandas like this okay
    so now I moved the。 functionality out so I have nice small little modular functions
    that have one single thing。 that I want to do。 How do I actually now call this
    from a main code because now I don't need these things。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我有我的JSON函数和JSON库的名称冲突，所以我就称JSON库为`JSON lib`，这样做，然后我们需要像这样导入`pandas`。好的，所以现在我将功能移出，这样我就有了一些很小的模块化函数，每个函数只做一件事。我该如何从主代码中调用这个呢，因为现在我不需要这些东西。
- en: Instead I want to import my readers the module I just created and somehow I
    now need to call。 the correct function here。 So one way to do this could be that
    I get a function that tests the name of the format。 from my readers module and
    then I'll just let's see I'll call that function。 So let's see so if we do this
    now what I'm doing here is that I'm getting for instance。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我想要导入我刚刚创建的读取器模块，并且以某种方式我现在需要调用正确的函数。所以一种方法是获取一个函数，该函数测试格式的名称来自我的读取器模块，然后我就看看怎么调用那个函数。所以让我们看看，如果我们现在这样做，我在这里获取的是，例如。
- en: a CSV function from the readers module and I'm calling that with the file path
    so if we。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从读取器模块调用CSV函数，我使用文件路径调用它。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_32.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_32.png)'
- en: let's see if that still works so this now what this has just done is now actually
    called。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是否仍然有效，所以现在这个刚刚做的事情实际上是调用了。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_34.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_34.png)'
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_35.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_35.png)'
- en: the readers JSON function through this get a get a third thing。 So this is definitely
    better now we kind of move the responsibility away so now the only。 thing that's
    a little bit nasty here is that this looks a little bit critical for your。 readers
    so if you kind of comment your code and say okay what happened here so what would。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 读取JSON函数通过这个获取操作来实现。所以现在这肯定更好了，我们在某种程度上将责任转移了，所以现在唯一有点麻烦的是，这对你的读取者来说看起来有点棘手，所以如果你在代码中添加注释，说明这里发生了什么，那会更好。
- en: be lovely to do here is that we would instead in kind of main application be
    able to write。 something like readers read CSV from file path。 So if I could change
    this kind of slightly scary get a third thing and so on to something。 like this
    that would be even even nicer。 So let's see one way to do this of what I'm actually
    doing now is I'm kind of moving a。 little bit of the say the scary code that I
    have in my main application out to the out。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里做得很棒的是，我们将能够在主要应用程序中编写类似于读取者从文件路径读取CSV的内容。所以如果我能够将这种略显可怕的获取操作等转换为类似的东西，那将更好。所以让我们看看，现在我正在做的事情之一是我正在将我在主要应用程序中具有的可怕代码稍微移动到外部。
- en: to my data file or my readers file here and then I need to have a function here
    called。 read which takes in the name of format or I'll actually start calling
    this now a plugin。 and then it will take whatever arguments and keyword arguments
    that it's given and just。 pass this on to the function that it wants to call。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我的数据文件或我的读取者文件在这里需要有一个名为读取的函数，它接受格式名称，或者我现在实际上开始将其称为插件，然后它将接受任何给定的参数和关键字参数，并将其传递给它想要调用的函数。
- en: So here again I could do the same thing where I do some kind of get after to
    do this but。 instead what I want to do here is that I'll create myself just a
    dictionary that's a list。 of all the reader functions that are available。 And
    then I could look up in this dictionary for a function and then call my arguments。
    and keyword arguments。 And if we'll go back to actually do a slight。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我也可以做同样的事情，在执行某种获取操作后，但我想在这里做的实际上是创建一个字典，这个字典是一个包含所有可用读取函数的列表。然后我可以在这个字典中查找一个函数，并调用我的参数和关键字参数。如果我们回去实际上做一个小的。
- en: slight amount of error handling we can do， something like this if it's there
    and if it's not we should raise a typo saying something。 like let's see， plugin，
    now it's not available。 And let's see finally this should actually return。 So
    now I have something that can call these functions down here which is kind of
    what。 I wanted to do over here。 What's missing now is actually populating the
    dictionary。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进行轻微的错误处理，类似于如果存在则执行某个操作，如果不存在则抛出一个拼写错误提示。比如说，让我们看看，插件，现在不可用。最后，让我们看看，这实际上应该返回什么。所以现在我有一些可以调用下面这些函数的东西，这正是我想在这里做的。现在缺少的其实是填充字典。
- en: So if you see here now the reader's dictionary is empty and I never do anything
    to actually。 put the functions in there。 So now I need to just populate it and
    that's where we come back to our decorators that。 I mentioned earlier。 So I said
    a decorator is just a function that takes a function as an argument and returns。
    a function。 So what I want to do now is just create a decorator that just registers
    the plugins。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在看到，读取字典是空的，我从来没有实际做任何事情将函数放入其中。所以现在我需要填充它，这就是我们回到我之前提到的装饰器的地方。装饰器只是一个接收函数作为参数并返回一个函数的函数。所以我现在想要做的就是创建一个装饰器来注册插件。
- en: So I want to populate my， uh， a read dictionary and I'll do that by picking
    out the name of。 each function and having that point to the function itself。 And
    then as a decorator it should return a function so I just return the same function。
    without doing anything to it。 And what this allows me to do now is just say that
    I want to register the CSV and the。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我想填充我的，呃，读取字典，我会通过提取每个函数的名称并使其指向函数本身来做到这一点。然后作为一个装饰器，它应该返回一个函数，所以我只是返回同一个函数，而不对其做任何更改。这使我现在可以简单地说我想注册CSV和。
- en: JSON functions here as plugins。 So when this code now is imported what happens
    here is that the register method function is。 called here and puts the CSV into
    the reader's dictionary with the link to the， to the function。 itself and similarly
    for JSON。 So let's see。 So now we have code here that says， okay。 pick out the
    format and then call the right。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: JSON函数作为插件。当这段代码被导入时，发生的事情是注册方法函数在这里被调用，并把CSV放入读者字典中，链接到函数本身，JSON也是如此。让我们看看。所以现在我们有代码，写道，好的。挑选出格式，然后调用正确的。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_37.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_37.png)'
- en: reader and let's see if this works。 Else， race。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 读者，让我们看看这是否有效。否则，竞态。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_39.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_39.png)'
- en: Yeah， there's a colon missing there。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，那儿缺少一个冒号。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_41.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_41.png)'
- en: There we go。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 好了。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_43.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_43.png)'
- en: And there's even more stuff happening。 Uh， it's not returned。 Let's see。 Where
    did we not return？
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多事情发生。呃，它没有返回。让我们看看。我们没有返回的地方在哪里？
- en: Ah， yeah。 Sorry。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，是的。抱歉。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_45.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_45.png)'
- en: In the main。 Ah， you're correct。 There we go。 Thank you so much。 Uh， there we
    go。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在主要的。啊，你说得对。好了。非常感谢你。呃，好的。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_47.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_47.png)'
- en: Now we have it。 Um， so let's see what we actually have done here now。 Um。 so
    now I kind of moved the fun， the complexity that I started to grow as I wanted
    to support。 more formats out of my kind of main file。 I have my main structure
    going。 It's moved over to the。 uh， to my module here where I have each little
    function doing just， one single thing。 So now， uh。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有它了。嗯，让我们看看我们现在到底做了什么。嗯。所以现在我有点把我想要支持更多格式时开始增长的复杂性移到了我的主要文件之外。我有了我的主要结构。它移动到了，呃，我的模块中，每个小函数只做一件事。所以现在，呃。
- en: we have a lot of， uh， mod， mod， mod， mod， mod， mod， mod， mod， mod， mod， mod，
    mod， the code。 So it's much easier to handle。 I couldn't now， let's see。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多的，呃，模块，模块，模块，模块，模块，模块，模块，模块，模块，模块，模块，模块，代码。所以更容易处理。我现在不能，看看。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_49.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_49.png)'
- en: If we go back to what we were talking about， I want to also support more kinds
    of plots。 I could then add a plotter， uh， functionality that kind of works the
    same way。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到我们所讨论的内容，我还想支持更多种类的图。我可以添加一个绘图，呃，功能，方法与之类似。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_51.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_51.png)'
- en: And what I would end up doing is typically that， okay， these things on top here，
    I could。 just copy these guys over into say a plotter's module。 Uh， let's see
    here。 So if I have a plotter's module like this， then I could copy this thing
    into here and。 probably want to change the names to something that's， uh， plotters。
    There we go。 Um， and， uh。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常会做的事情是，把这些东西复制到一个绘图模块里。呃，让我看看。所以如果我有这样的绘图模块，我就可以把这个东西复制到这里，并且可能想把名称改成一些，呃，绘图的东西。好了。嗯，还有，呃。
- en: and then I could do the same for the plot。 So I have line plots。 I would have
    scatter plots。 all kinds of plots here。 Um， now this， this， this is a small code
    smell， right？ So I'm starting。 I have a fair bit of setup that I don't want to
    copy around and things。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我可以对绘图做同样的事情。所以我有折线图。我会有散点图。这里有各种各样的图。嗯，现在，这个，这个，这个有点代码气味，对吧？所以我开始。我有相当多的设置，我不想四处复制的东西。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_53.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_53.png)'
- en: like this。 So what， uh， we have instead is a small little package。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样。所以我们现在有的是一个小包。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_55.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_55.png)'
- en: It's called Piplugs。 That is available on PiPI， which is a simple decorator
    based plugin architecture for Python。 And it essentially works， uh， with things
    that like what you've seen here， you can create， simple。 uh， plugin packages。
    Uh， instead of stuffing everything into the same file like I did here。 what I
    typically， do is actually move it up a level so that， uh， I have a plugin， plugin
    package。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它叫做Piplugs。这个在PiPI上可以找到，它是一个基于简单装饰器的Python插件架构。它基本上适用于你在这里看到的那些东西，你可以创建简单的呃，插件包。呃，而不是像我在这里那样把所有东西都塞到同一个文件里。通常，我会把它提升一个级别，这样，我就有了一个插件，插件包。
- en: so full， directory with readers。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所以完整的目录中有读者。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_57.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_57.png)'
- en: So with this kind of setup， let me actually show it to you。 Um， Piplugs， there
    we go。 So here is a。 uh， implementation of the same thing but using the Piplugs
    package。 So in this case。 what I've done is that I've actually taken each of the
    readers and split。 them out into their own files。 Uh， so then I create a plugin
    package that I call readers and plugin package called plutters。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以通过这种设置，让我实际上给你展示一下。嗯，Piplugs，我们来了。所以这里是一个。呃，使用Piplugs包实现的相同内容。所以在这种情况下。我所做的是把每个读取器分开。分成自己的文件。呃，然后我创建了一个名为读取器的插件包和一个名为plutters的插件包。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_59.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_59.png)'
- en: And then， uh， the plugins is typically the whole module， uh， but with a called
    function， in between。 It's possible to also add in several functions if， if you
    want， but typically the way it's。 looked at is with packages and then plugins
    really。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，呃，插件通常是整个模块，呃，但中间有一个调用函数。如果你想，也可以添加多个函数，但通常看起来是与包和插件有关的。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_61.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_61.png)'
- en: Um， and the code， and so let me show you that。 So if we first look at the plutter。py。
    so this is the， uh， simple plugin application， and it's exactly the same as what
    we have done。 So you can see here our import readers。 This is now packaged， not
    just a module。 And then I call readers read with the reader I want and then， uh，
    and then it runs off。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，代码，所以让我给你展示一下。如果我们先看看plutter.py。这是一个，呃，简单的插件应用程序，和我们所做的完全一样。所以你可以看到我们的导入读取器。这现在是打包的，不只是一个模块。然后我调用读取器读取我想要的读取器，然后，呃，然后它就运行了。
- en: How does the CSV thing look？ So as you can see， this is now， uh， very small。
    Um。 the only thing you need to do is import pipe logs and use the register decorator。
    And this does essentially the same thing as the register thing we wrote。 It adds
    a little bit more bookkeeping so we can also pick out docstrings and things like。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: CSV的东西看起来怎么样？所以如你所见，这现在，呃，非常小。嗯。你只需导入pipe logs并使用注册装饰器。这基本上做的和我们编写的注册内容相同。它添加了一些额外的记账，这样我们也可以提取文档字符串等内容。
- en: this have those easily available。 And then in the readers， dunderennet file。
    so this is the one that， uh， defines the package， and then when I have the read
    function inside of there。 uh， that's just a， a call function。 So call a plugin。
    So you can see there's a call factory that just creates call functions。 So for
    readers。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是易于访问的。在读取器的dunderennet文件中。所以这是定义包的那个，当我在里面有读取函数时。呃，这只是一个调用函数。调用插件。所以你可以看到有一个调用工厂，它只创建调用函数。所以针对读取器。
- en: it's nice to call it read。 Makes it more， um， humanized， I guess。 The names
    factory would just list available names that you have。 There's other。 there's
    a doc factory and things like this。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 把它叫做读取很不错。这样使其更，嗯，更人性化，我想。名字工厂只会列出你拥有的可用名称。还有其他的。有一个文档工厂和类似的东西。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_63.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_63.png)'
- en: Okay。 Um， so with plugins like this， I've been using it now for several years
    in different projects。 And it works really nicely。 It's， um， we used it for readers
    for different file formats。 So one thing you kind of need to be careful with there
    is that you have a well defined。 interface into your readers， right？ So in this
    case we had readers should， uh。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。嗯，像这样使用插件，我在不同项目中使用了好几年。它运行得非常顺利。我们为不同文件格式的读取器使用了它。所以有一点你需要小心的是，确保你的读取器有明确的接口，对吧？在这种情况下，我们的读取器应该，呃。
- en: take in a file path and return a data frame， for instance， if you want。 if you
    don't have the same interface for all of them， it will， be a hassle to keep track
    up。 But if you have sort of like equal things that you want to call like this，
    this makes。 a lot of sense。 We used it for different models for flexible calculations。
    I can then。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，接收文件路径并返回数据框，如果你想。如果你没有相同的接口来调用所有这些，那就很麻烦。但如果你有类似的东西想要这样调用，那就非常有意义。我们为不同模型的灵活计算使用了它。我然后可以。
- en: in my config file， say that I want to use this or that's a machine learning
    library。 to call my models or things like this， filters， writers for storing data
    in different formats。 notifiers for sending notifications to different places。
    And also for components just for building my GUI。 So I can kind of say， okay，
    for this use case。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的配置文件中，说明我想使用这个或那个机器学习库。来调用我的模型或类似的东西，过滤器，用于以不同格式存储数据的写入器。通知器用于向不同地方发送通知。还有组件仅用于构建我的GUI。所以我可以说，好吧，针对这个用例。
- en: I want to have these kind of buttons， this drop。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要这些按钮，这个下拉。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_65.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_65.png)'
- en: down and things like this。 Okay。 Uh， so let's finish up。 Thank you so much for
    hanging out with me。 And if you want to know more， you find me at， yeah， yeah，
    yeah， yeah， yeah， yeah， yeah。 at most places。 The code here I'll put up on GitHub，
    uh， pipe logs is， as I said， on PIPI。 And um。 I write for real Python， so you
    can find more articles there， including some that。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 向下和类似的事情。好的。呃，所以让我们结束吧。非常感谢你和我一起度过这个时光。如果你想知道更多，可以在大多数地方找到我。这里的代码我会放到GitHub上，呃，Pipe
    logs就如我所说，在PIPI上。而且，嗯。我为Real Python写作，所以你可以在那找到更多的文章，包括一些。
- en: at least mentioned these kind of plugins。 So thank you very much。 [applause]。
    If anyone has any questions， please come up to the mic and please remember to
    put your。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 至少提到这些类型的插件。非常感谢。[掌声]如果有人有任何问题，请上麦克风，并请记得放下你的。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_67.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_67.png)'
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_68.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_68.png)'
- en: question in the form of a question。 So maybe I missed something， but， uh。 so
    in the PyPlugs readers module， or it was a， readers under a knit， uh， module，
    I think。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以问题的形式提问。所以也许我错过了什么，但，呃。在PyPlugs读取模块中，或者是在一个编织的，呃，模块下，我认为。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_70.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_70.png)'
- en: I didn't see you importing any of the sub modules there。 Um， does it， so it
    just imports it or。 because it， you seem to be kind of flipping the import。 Does
    it just dynamically import when it needs to or how does that importing process
    work？ Exactly。 Yeah， so you can see it just imports PyPlugs and then the crucial
    thing is actually that。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有看到你导入任何子模块。嗯，是不是，它只是导入它，还是。因为你，似乎在反转导入。它只是动态导入需要的时候，还是导入过程是如何工作的？确切地说。是的，所以你可以看到它只是导入了PyPlugs，关键是实际上。
- en: it's a sense of a reference to this directory essentially with the package，
    uh， reference， there。 um， to the PyPlugs， uh， thing。 So， so when things are actually
    called， it will go。 it knows that because， well， I have， the package and I'm looking
    for a file。 a module inside of this package and then it will dynamically， import
    that package。 And then what。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上是对这个目录的引用，和包的，呃，引用。在PyPlugs，呃，方面。因此，当实际调用时，它会去。它知道，因为，嗯，我有这个包，我在寻找这个包内的一个文件，一个模块，然后它会动态地导入那个包。然后什么。
- en: for instance， this names factory， which is just listing everything， it will
    just， go in the。 in the folder and actually import all the files that cease there
    so that will。 be a fairly slow process， possibly if you have lots of sub imports，
    but the call just。 goes directly to the module file。 And that's also one of the，
    an extra bonus， I guess， with， uh。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，这个命名工厂只是列出所有内容，它会直接在文件夹中导入所有文件，因此这个过程会相当缓慢，尤其是如果有很多子导入，但调用会直接指向模块文件。这也是一个额外的好处，我想。
- en: with moving everything up， to the module level instead of the function level
    is that you can go directly to。 to the， function you need。 Thank you。 Yeah。 Um，
    thank you for a talk。 If you were to allow， um。 external plugins， um， in your
    application， external as in， I can。 write a plugin for different types of files
    and， uh， plug it into your application， how。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容移动到模块级别而不是函数级别的好处是，你可以直接去。你需要的函数。谢谢。嗯，谢谢你的演讲。如果你允许，嗯，外部插件，嗯，在你的应用中，外部是指，我可以。为不同类型的文件编写插件，嗯，并将其插入你的应用，如何。
- en: would you do that with PyPlugs？ Uh， so essentially what you need to expose is
    the。 is the register thing。 So， uh， what， what I've done， I think， um， is that
    you。 you would typically just say that， have a directory for custom plugins and
    then have them just import the PyPlugs register。 there and then it will， you，
    you can set it up so that it picks up that package as well。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你会用PyPlugs来做这个吗？所以，基本上你需要暴露的是注册的内容。因此，我所做的，嗯，我想，是你通常会说，拥有一个自定义插件的目录，然后让它们导入PyPlugs的注册。在那里设置后，它会自动识别那个包。
- en: essentially。 And there is， um， a very nice example of application called glue
    for visualization。 This part of the Anaconda distribution， uh， that does exactly
    this thing。 It。 it doesn't use PyPlugs but it uses essentially the same kind of
    system in the background where。 you can add your own， uh， data readers。 So， yeah。
    Hi。 Um， what do you， how do you feel about， uh。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上。嗯，有一个非常好的应用示例叫做用于可视化的胶水。这部分是 Anaconda 发行版，嗯，正是做这件事。它不使用 PyPlugs，但在后台使用基本相同的系统，在那里。你可以添加自己的，嗯，数据读取器。所以，是的。你好。嗯，你觉得，呃。
- en: CDOC tools， uh， entry points？ We have had these for years and， um， they work
    pretty well for， uh。 setting up a plugin， system。 Right。 Uh， no， there， there
    are many different plugin systems and， uh。 I haven't， uh， I haven't， used setup
    tools entry points outside of setting up entry points essentially。 So， so I don't
    know if， uh， if that could kind of do some of these things。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: CDOC 工具，呃，入口点？我们已经有这些很多年了，嗯，它们在设置插件系统方面效果很好。对吧。呃，不，确实有许多不同的插件系统，呃。我没有在设置入口点之外使用过
    setup tools 入口点。因此，我不知道，呃，如果它可以做到这些事情。
- en: I think this is a different level。 Yeah。 The thing is， uh， with setup tools
    entry points。 you don't actually have to explicitly import， your， uh， plugins
    that they can be all the discovered。 Right。 Uh， yeah。 I don't know enough about
    that too。 Say much。 You mentioned the pie plugs works great when you have a consistent
    method signature for。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这是一个不同的层次。是的。问题是，呃，使用 setup tools 入口点。你实际上不必显式导入你的，呃，插件，它们都可以被发现。对吧。呃，是的。我对这个也不知道太多。没什么好说的。你提到的
    pie plugs 在你有一致的方法签名时效果很好。
- en: all the different plugins。 Yep。 Many real world examples， uh， that may not be
    the case。 Like the CSV reader may take in the delimiter， how strings are escaped，
    uh， where JSON those。 parameters make no sense is， is pie plugs not really extended
    that case or how would you。 go about that？ So let's see if we have this here。
    So if we， yeah。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所有不同的插件。是的。许多现实世界的例子，呃，可能并非如此。例如，CSV 阅读器可能会接受分隔符、字符串转义方式，呃，而 JSON 那些。参数是没有意义的，pie
    plugs 真的没有扩展那种情况，你会怎么处理？所以让我们看看我们这里是否有这个。如果我们，嗯，是的。
- en: let's have a look at the readers that pie。 So what really happens in the， in
    the read case is that。 uh， it， it just passes through， whatever arguments it has。
    So， so if you on the outside knows that。 okay， for CSV， I have this and that argument，
    you， can just pass it through and it， it。 it should work。 So it's just that you
    need to keep track of it on your side。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 pie 的读取器。实际上，在读取案例中发生的事情是。呃，它只是传递它所拥有的任何参数。所以，如果你在外部知道。好吧，对于 CSV，我有这个和那个参数，你可以直接传递，它，嗯。它应该能工作。所以只需在你这边跟踪它即可。
- en: You can't just switch between the formats as easily。 Yeah。 So like in a CLI。
    you might have like plug-in arcs is another parameter。 Right。 So that's a good
    thing。 Exactly。 It's like it can kind of pass them on。 Okay。 Thank you so much。
    Okay。 [APPLAUSE]， [applause]。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能那么轻松地在格式之间切换。是的。所以，比如在 CLI 中。你可能会有像插件参数这样的另一个参数。对吧。所以这是一件好事。确实。就像它可以传递它们。好的。非常感谢你。好的。[掌声]，[applause]。
- en: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_72.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc67d00d0d9834c47a466f563a4b7ac_72.png)'
