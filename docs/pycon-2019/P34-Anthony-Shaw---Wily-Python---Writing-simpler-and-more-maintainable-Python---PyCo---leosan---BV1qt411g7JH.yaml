- en: P34：Anthony Shaw - Wily Python - Writing simpler and more maintainable Python
    - PyCo - leosan - BV1qt411g7JH
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P34：安东尼·肖 - 精妙的Python - 编写更简单且易于维护的Python - PyCo - leosan - BV1qt411g7JH
- en: Hello everybody。 The next talk is Wild Python， Writing Simpler and More Maintainable
    Python。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大家好。接下来的演讲是“狂野的Python，编写更简单且易于维护的Python”。
- en: '![](img/7da318d509d441e90f69efc38e15b1a9_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7da318d509d441e90f69efc38e15b1a9_1.png)'
- en: by Anthony Shaw。 [Applause]， Hi everybody。 My name is Anthony Shaw and I'm giving
    a talk about simplicity and trying。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：安东尼·肖。[掌声]大家好，我叫安东尼·肖，我要讲关于简洁性和尝试。
- en: '![](img/7da318d509d441e90f69efc38e15b1a9_3.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7da318d509d441e90f69efc38e15b1a9_3.png)'
- en: to write more simple Python。 This is my first time speaking at PyCon。 I'm super
    nervous。 and I was researching some tips about public speaking for this kind of
    event。 I found three， rules。 Rule number one was to have frequent pauses。 Rule
    number two was to never start， with an apology。 And then rule number three was
    to never thank people for coming to your。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 编写更简单的Python。这是我第一次在PyCon上发言。我非常紧张，我正在研究一些关于公共演讲的技巧。我找到了三个规则。规则第一是要经常停顿。规则第二是绝不要以道歉开始。然后规则第三是绝不要感谢人们来参加你的演讲。
- en: talk and just assume that they're here to listen。 So thank you for coming。 We've
    got a lot to get through so I'm going to go quickly so， I apologize for that。
    And we're going to talk about code complexity today。 So what does， that mean？
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 演讲并假设他们在这里听。所以谢谢你们的到来。我们有很多内容要讲，所以我会快点，所以对此我表示歉意。今天我们将讨论代码复杂性。那么，这意味着什么呢？
- en: How would you inspect if your code is complicated？ And then we're going to look。
    at not really just how is your code complicated but how do you actually measure
    that？ Because。 everybody thinks that they write simple code because it makes sense
    to you。 But it's more。 about communicating with other people and sharing your
    code and your ideas with others。 So we're。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何检查你的代码是否复杂？然后我们将不仅仅关注你的代码如何复杂，而是你如何实际衡量这一点？因为每个人都认为他们编写的代码是简单的，因为它对你来说是有意义的。但更重要的是与他人沟通，分享你的代码和想法。因此，我们。
- en: going to talk about code metrics and we can then talk about how do you actually
    simplify。 the code once you realize whether or not it's complicated。 The title
    of the talk is about。 Wily Python。 So I'm going to introduce a talk called Wily
    which I wrote which basically。 helps you manage this process of understanding
    whether your code is complicated or not by。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我将讨论代码度量，然后我们可以谈谈如何简化代码，一旦你意识到它是否复杂。演讲的标题是关于“精妙的Python”。所以我要介绍一个我写的演讲，叫做“精妙”，它基本上帮助你管理这个过程，了解你的代码是否复杂。
- en: what measure and how do you simplify it and then basically doing that in a loop。
    I know。 there's probably quite a mixed audience here today so in terms of the
    complexity of the。 talk itself this has got a matter。 The first section is really
    kind of a beginner level。 and then the second part is intermediate to advanced。
    If anyone has any questions please。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何衡量并简化它，然后基本上在循环中执行。我知道，今天可能有相当混合的听众，所以就演讲的复杂性而言，这确实是一个问题。第一部分真的比较适合初学者，然后第二部分是中级到高级。如果有人有任何问题，请提出来。
- en: come and speak to me afterwards and if we get time later in the talk we can
    open up for， the Q&A。 Also I've written an extensive article on RealPython。com
    which takes about an hour。 and a half to read so it's probably one of my shorter
    articles。 So I encourage you to。 read that because there's a lot more detail in
    that post。 I now need to convince everyone。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 事后请来和我交谈，如果在演讲中有时间，我们可以进行问答。此外，我在RealPython.com上写了一篇详尽的文章，大约需要一个半小时阅读，所以这可能是我较短的文章之一。我鼓励你们去阅读，因为那篇文章中有很多更多的细节。我现在需要说服大家。
- en: that simple code is good so why should you care if your code is complicated
    or simple。 So remember that your code is written not just for computers it's written
    for humans and Python。 especially is almost written in a language that's easy
    for people to understand and when。 you write an application in code you're leaving
    instructions for the computer but also for。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的代码是好的，那么如果你的代码复杂或简单，你为什么要在意呢？记住，你的代码不仅是为计算机编写的，它也是为人类编写的，Python尤其几乎是用一种人们易于理解的语言编写的。当你用代码编写应用程序时，你是在为计算机留下指令，也为。
- en: your fellow developers。 So not just in code comments but in the actual code
    itself in。 the way you name your functions， your classes， your variables， the
    way you structure it， it。 should be a set of instructions for people。 So it should
    be clear that what you're trying。 to achieve and what you're trying to do with
    the code which is why you want simpler code。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你的同事开发者。因此，不仅仅是在代码注释中，而是在实际代码中。在你命名函数、类、变量的方式，以及结构方面，应该为人们提供一套指示。因此，应该清楚你想要实现什么，以及你想用代码做什么，这就是为什么你需要简单的代码。
- en: rather than more complex code。 Also code is a living thing it changes often。
    So if your。 code is complicated to understand when people want to make changes
    to it they're more likely。 to misunderstand what it was you were trying to do
    and introduce bugs。 So you want simple。 code because it's easier to maintain the
    code it's easier to adapt the code and it's easier。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是更复杂的代码。此外，代码是一个活的事物，常常会变化。因此，如果你的代码难以理解，当人们想要对其进行更改时，他们更有可能误解你原本想要做的事情，从而引入错误。因此，你需要简单的代码，因为它更容易维护，更易于适应。
- en: to add more functionality。 And then lastly complicated code is hard to test
    and testing。 is good hopefully we can all agree on that。 So you want simple code
    so that you can test。 it so that people can understand it and so that you can
    adapt it over time。 So how do。 you measure if code is complicated？ So this really
    really simple sample uses the crudest。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 来增加更多功能。最后，复杂的代码难以测试，而测试是好的，希望我们都能对此达成共识。因此，你希望代码简单，以便可以测试，方便他人理解，并且能随时间进行适应。那么，如何衡量代码是否复杂呢？这个非常简单的示例使用了最粗糙的方法。
- en: measure for measuring the size of code and that is the lines of code。 It's really
    easy。 to calculate the number of lines of code we have in this application and
    in theory you。 want fewer code so you want fewer lines of code。 But I can represent
    that same code example。 in fewer lines of code but there's one massive issue with
    this example。 So I've used a few。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 衡量代码大小的指标就是代码行数。计算我们在这个应用中的代码行数非常简单，理论上你希望代码更少，所以你希望代码行数更少。但我可以用更少的代码行表示同样的代码示例，但这个例子有一个巨大的问题。因此，我在这里使用了一些奇怪的Python语法。
- en: funky Python syntax here。 It basically does exactly the same as this but it's
    on three。 lines so there's less code so that should be a good thing。 But as Tim
    Peters famously。 said readability counts。 So lines of code is not really a measure
    of complexity but more。 about volume you're really looking at how big the application
    is and encouraging people。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上与这个完全相同，但它只用了三行，因此代码更少，这应该是好事。但正如蒂姆·彼得斯所说，可读性很重要。因此，代码行数并不是衡量复杂性的标准，而更多的是关于体积，你真正要关注的是应用的大小，以及鼓励人们。
- en: to write less code can actually encourage the wrong behavior because people
    end up condensing。 stuff down to a point where it's less readable。 So lines of
    code doesn't really talk about。 complexity it's just about volume and there are
    other measures you can use for complexity。 One of those measures is called cyclomatic
    complexity and I want to explain it in terms。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 写更少的代码实际上可能会导致错误的行为，因为人们最终会将内容压缩到不易阅读的地步。因此，代码行数并不能真正反映复杂性，它仅仅是关于数量，还有其他衡量复杂性的指标。其中一个指标称为圈复杂度，我想用在麦当劳点汉堡时的例子来解释。
- en: of ordering a burger at McDonald's at a drive-through。 So you start off with
    one decision which is。 what you actually want to eat。 So let's say you want to
    eat a big mac and there are other。 burgers available from other restaurants。 So
    you start off with a cyclomatic complexity。 of one you've made one decision。 They
    then ask you do you want to make that a meal so。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先做出一个决定，就是你到底想吃什么。假设你想吃一个巨无霸，而其他餐厅也有其他汉堡可供选择。所以你开始时的圈复杂度是1，你做出了一个决定。然后他们问你是否想将其做成套餐。
- en: that increases the complexity by one。 They then say do you want what size do
    you want。 that's another one what drink would you like and then if you want diet
    or regular coke with， that。 So the cyclomatic complexity of ordering a big mac
    from Mac is five。 So if you imagine。 you went to McDonald's and they asked you
    16 different questions at which point would。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这会增加复杂性。然后他们问你想要什么样的？再来一个，你想喝什么饮料？如果你想要的是低糖可乐还是普通可乐。那么，从麦当劳点一个巨无霸的圈复杂度是五。所以想象一下，你去麦当劳，他们问你16个不同的问题，到底是在哪个点。
- en: you say it got really complicated。 So cyclomatic complexity is like this because
    when you're。 trying to read a piece of code you've got to understand all the decisions
    and how they。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你会说它变得非常复杂。所以循环复杂度就是这样，因为当你尝试阅读一段代码时，你必须理解所有的决策及其。
- en: '![](img/7da318d509d441e90f69efc38e15b1a9_5.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7da318d509d441e90f69efc38e15b1a9_5.png)'
- en: get made。 And I picked this code example I apologize if it's a bit small。 This
    is actually。 from the Python standard library in a module called local。py。 So
    every time in Python there's。 an if an else if a for try statement it counts as
    increasing the cyclomatic complexity by。 one because that's the decision that's
    got to be made in code。 So what does that have。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: get made。然后我选了这个代码示例，如果它有点小我表示歉意。这实际上来自Python标准库中的一个模块local.py。所以在Python中每当有if、else或for、try语句时，它都会使循环复杂度增加1，因为这是代码中必须做出的决策。
- en: to do with complexity well when you read this code sample and if I ask you to
    articulate。 what this does you're not just reading down a set of statements you're
    actually looking。 at each if block and thinking okay well what would that variable
    be if it's this and that。 happens if it's this and that happens and you've got
    to store in your head basically like your。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 关于复杂性，当你阅读这个代码示例时，如果我让你表述这段代码的作用，你并不是仅仅在阅读一系列语句，而是在看每个if块并思考“如果这个变量是这样，那么会发生什么”。你需要在脑海中存储这些基本的信息，就像你的。
- en: own value stack and start to evaluate the code whereas if it's just a series
    of flat statements。 you can see one by one what that code does。 So this is a complicated
    piece of code it has。 a high cyclomatic complexity it does take a bit of time
    to read and understand but there's。 also I think an easier way to see cyclomatic
    complexity。 If you turn the code on its side。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有自己的值栈并开始评估代码，而如果它只是一个平面的语句序列，你可以逐一看到每段代码的作用。所以这是一个复杂的代码片段，它具有较高的循环复杂度，确实需要一些时间去阅读和理解，但我认为还有一种更简单的方式来看待循环复杂度。如果你把代码横过来看看。
- en: and then get a pen and draw a line around the white space you'll see this。 So
    I'd say。 that instead of just trying to calculate cyclomatic complexity if your
    code looks like a mountain。 range when you turn it on its side then it has a high
    complexity and also another quote。 from Tim Peters flat is better than nested
    so flatter code is easier to understand is。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后拿个笔在空白处画一条线，你会看到这个。所以我想说的是，与其仅仅计算循环复杂度，如果你的代码在侧面看起来像山脉，那么它的复杂度就很高，另一个引述来自Tim
    Peters，扁平优于嵌套，因此扁平代码更容易理解。
- en: easier to process and this example has a high complexity so you could walk into
    this and。 think okay well let's just make it flatter and simpler but I think you're
    missing one principle。 and that is there's actually wisdom in complicated code
    and I will talk about this as well so most。 IDEs have a Git blame tool if you've
    ever used Git blame I've turned on Git blame on。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更容易处理，这个示例的复杂性很高，因此你可能会走进来看“好吧，让我们让它更扁平、更简单”，但我认为你遗漏了一个原则，那就是复杂代码中其实有智慧，我也会谈论这一点。所以大多数IDE都有Git
    blame工具，如果你曾经使用过Git blame，我已在。
- en: the same module but just a few more lines down and you can actually see here
    who and when。 and why each piece of code was changed and we've got changes from
    19 years ago 15， 12。 every time somebody adds has to fix an issue fix a bug at
    an edge case they go in and they。 make that change so that's normally in the form
    of an if statement or a small change which。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个模块中，只是再往下几行，你可以看到每段代码的修改者、时间和原因，我们有来自19年前、15年和12年的修改。每当有人添加或修复问题、修复边缘案例时，他们都会进入并进行修改，通常以if语句或小修改的形式出现。
- en: therefore increases the complexity of the code so just trying to charge in and
    say let's。 just make this simpler you actually need to understand all the reasons
    why the code is。 like the way it is。 The other thing you might miss is if you
    don't introduce this you could。 introduce reintroduce bugs which have already
    been resolved and which could upset users so。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，代码的复杂性增加了，所以如果你试图直截了当地说“让我们简单一点”，实际上你需要理解代码之所以如此的所有原因。你可能会错过的另一件事是，如果不引入这个，你可能会重新引入已经解决的错误，这会让用户不安。
- en: to simplify what I've just said when you start off with a new application you
    typically have。 a little amount of functionality and a few users so you should
    have a little amount of。 code and a small amount of psychomatic complexity。 As
    you add more features you tend to write。 more code so the lines of code measure
    will go up。 As you have more users you have to support。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，当你开始一个新的应用程序时，通常功能很少且用户也不多，所以代码量和认知复杂性都应该较小。随着你添加更多功能，代码量往往会增加，因此代码行数的度量会提升。随着用户增加，你需要支持。
- en: more edge cases more platforms more scenarios and you tend to increase psychomatic
    complexity。 of the code as well and then the double whammy is when you've got
    a lot of users and a lot。 of functionality。 So CPython itself is a good example
    it's used by millions of people and。 it has a lot of users it's got a lot of functionality
    so it has a lot of complexity。 So if lines。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的边缘情况、更多的平台、更多的场景，代码的认知复杂性也往往会增加，然后当你有很多用户和很多功能时，会形成双重打击。因此，CPython 是一个很好的例子，它被数百万人使用，具有大量的用户和功能，因此它的复杂性很高。
- en: of code and psychomatic complexity can't really be used as measures for big
    applications。 what can you use instead。 So I'm going to talk about how Stedmetrics。
    I do warn that。 there's a bit of math in this section so if you feel like the
    math is a bit too complicated。 or outside of your comfort zone don't worry there
    are tools that can calculate this stuff， for you。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型应用程序，代码行数和认知复杂性并不能真正作为度量，那么你可以使用什么呢？我将讨论 Stedmetrics。我需要提醒的是，这一部分有点数学内容，如果你觉得数学部分太复杂或者超出你的舒适区，请不用担心，还有工具可以为你计算这些内容。
- en: This metric has actually been around since 1977 predating Python and the research。
    behind it as well is very old by this point how many years is that 50 years and
    so the。 research behind this is actually 50 years old just over 50。 Okay so let's
    introduce two， things。 There's a value called operands。 operand is the sum of
    the values you've used and the。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个度量实际上自1977年以来就存在，早于Python，背后的研究也非常古老，到现在已经有50年了，所以这个研究实际上已经超过50年。好吧，让我们介绍两个东西。有一个称为操作数的值。操作数是你所用值的总和。
- en: sum of the variables you've used so number one or a string constant would count
    as a value。 and a name would count as a variable so if you add all of those up
    you get operands。 If you add up the amount of built-in syntax you've used in the
    application that's called， operators。 If you take the sum of the operators and
    the sum of the operands you've used you。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用的变量总和，比如数字一或字符串常量将计为一个值，而名称将计为一个变量，因此，如果你把所有这些相加，就得到操作数。如果你加上你在应用程序中使用的内置语法数量，这被称为操作符。如果你把使用过的操作符和操作数相加，你会得到。
- en: end up with a measure called length and if you take the amount of unique operators
    you've。 used and unique operands you've used you end up with a measure called
    vocabulary。 So this。 probably sounds a bit complicated compared to lines of code
    which is quite an easy way。 to measure things but there's reasons behind it。 So
    if anyone's familiar with the abstract。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最终得到一个称为长度的度量，如果你计算一下你使用过的唯一操作符和唯一操作数，你会得到一个称为词汇量的度量。因此，这听起来可能比代码行数复杂得多，而代码行数是一个相对简单的度量方式，但这背后有原因。如果有人熟悉抽象的话。
- en: syntax tree it's basically what happens when your code is compiled is turned
    into a tree。 and then it's interpreted as a tree。 So this simple code example
    I've got here with a function。 with three statements I'm going to assign the value
    one to a variable called A I'm going。 to increment that by one and assign it to
    a variable called B and then I'm going to return， B。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 语法树基本上是你的代码编译后转变为树的过程，然后被解释为树。因此，我这里有一个简单的代码示例，包含一个函数和三个语句，我将把值一赋给一个名为 A 的变量，接着将其加一并赋给一个名为
    B 的变量，然后返回 B。
- en: So in the tree you've got the two assignments and then you've got the return
    statement。 In。 the first assignment you've got the name which is the variable
    A and the number which。 is the number one。 So everything in green would be added
    up and then everything in yellow。 would be added up to give you operators and
    operands and then this is where it gets slightly。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在树结构中，你有两个赋值操作，然后是返回语句。在第一个赋值中，变量是 A，值是数字一。因此，绿色部分的所有内容都会相加，然后黄色部分也会相加，得到操作符和操作数，这里开始变得稍微复杂一些。
- en: more complicated unfortunately。 We've then got volume and difficulty so you
    multiply the。 length by a logarithm of the vocabulary to get volume which is better
    than lines of code。 and then this one had me stumped for a while but basically
    it more or less tries to calculate。 how you've reused code and how much code you've
    used to achieve something and then gives。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这变得更加复杂。我们还有体量和难度，所以你需要将长度乘以词汇的对数，以获得体量，这比代码行数更好。这个让我困惑了一段时间，但基本上它试图计算你如何重用代码，以及为了实现某个功能你使用了多少代码，然后给出结果。
- en: you that as a variable with difficulty。 And then lastly you get effort which
    is a multiple。 of both of those two things。 So all of that's very theoretical
    but basically there are。 better ways of measuring the amount of code in an application
    and the amount of variables。 you've used and the amount of syntax you've used。
    So all these things are basically a way。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其视为一个难度变量。最后你得到的努力是这两者的乘积。所以所有这些都是非常理论化的，但基本上有更好的方法来衡量应用程序中的代码量、使用的变量数量以及使用的语法数量。这些基本上是为了达到一个单一的数字。
- en: of measuring the amount of code you have。 There's actually a better measure
    than this。 Don't worry too much about the equation。 There's different versions
    of this equation but this。 is called the maintainability index and the output
    is just a number from zero to a hundred。 and it's a scale。 So if you run the maintainability
    index of your code it will just give you a。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 其实有比这更好的衡量代码量的方法。不要太担心这个公式。这个公式有不同的版本，但被称为可维护性指数，输出值是从零到一百的数字，形成一个比例。因此，如果你运行代码的可维护性指数，它会给你一个数字。
- en: single number。 If that number is between zero and twenty five it means your
    code is， unmaintainable。 It's a bit of a mess。 If it's between twenty five and
    fifty it would be。 like my high school teachers say cause of the concern。 If it's
    between fifty and seventy。 five that's realistically where most applications are
    but you can still definitely see improvement。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个数字在零到二十五之间，意味着你的代码是不可维护的，稍显混乱。如果在二十五到五十之间，像我的高中老师说的那样，值得关注。如果在五十到七十五之间，那就是现实中大多数应用程序的位置，但你仍然可以看到改善的空间。
- en: And then if it's over seventy five I don't believe you。 So this is actually
    this metric。 is actually used in Microsoft applications in Java applications as
    well and in Python。 this is the equation we use in Wiley for calculating the index。
    So if you don't want。 to go and sit and calculate that by hand basically it's
    taking the house dead volume。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果超过七十五，我就不相信你了。实际上，这个指标在微软的应用程序、Java应用程序以及Python中都被使用。这是我们在Wiley中用于计算指数的公式。如果你不想坐下来手动计算，基本上它就是在计算死亡体量。
- en: the cyclomatic complexity and the number of lines of code。 So your maintainability
    index。 is going to be lower if you've used a lot of code a lot of variables a
    lot of syntax。 and a lot of nesting to achieve something。 That's when you're going
    to have something， in the red。 So it's going to be in the green where you've got
    nice flat code you don't。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 循环复杂度和代码行数。因此，如果你使用了大量的代码、变量、语法和嵌套来实现某个功能，你的可维护性指数就会降低。这时你就会发现代码位于红色区域。而如果你的代码简单扁平，就会位于绿色区域。
- en: have too many functions too many variables and there's not that much code volume
    so that's。 where it's going to be in the green。 So you don't have to calculate
    this stuff by hand。 you can use a package called radon。 On the command line you
    can run radon and then the。 algorithm that you want to use a CC is cyclomatic
    complexity and you give it the file name you。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中有太多功能和变量，而代码量并不多，所以这就是它将位于绿色区域的原因。因此，你不必手动计算这些内容，可以使用一个叫做radon的包。在命令行中，你可以运行radon，然后使用你想要的算法，CC是循环复杂度，接着给出文件名。
- en: want to run and it will basically calculate the number for you and give you
    that output。 You can also do MI which is the maintainability index I just spoke
    about and it says that my。 application was 87。42 which is pretty impressive but
    it's only four lines of code so that's understandable。 And then lastly you can
    run how is the algorithm and it will give you all of the measures I。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你想运行的内容，它会基本上为你计算这个数字并给出输出。你也可以做MI，即我刚才提到的可维护性指数，它显示我的应用程序是87.42，这相当不错，但只有四行代码，所以这是可以理解的。最后你可以运行如何算法，它会给你所有的度量。
- en: spoke about。 It also outputs another one which I've cropped from the image which
    is。 actually the number of bugs it's spotted in your code。 How is it actually
    theorised that。 you could calculate the number of bugs based on the amount of
    code but this theory was。 50 years old。 So you've got the numbers you look at
    the numbers and you think okay that's。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它还输出了另一个我从图像中裁剪下来的结果，实际上是它在你的代码中发现的错误数量。理论上你可以根据代码的量计算错误的数量，但这个理论已经有 50 年的历史了。因此，你得到了这些数字，你查看这些数字并想，好吧，这个。
- en: interesting。 I've got a vocabulary of nine and a calculated length of 20。26
    one now。 So。 does that tell you whether your code is maintainable or not？
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣。我有一个九个的词汇量和一个计算长度为 20.26 的词汇量。那么，这是否告诉你你的代码是否可维护？
- en: So really I was looking at this problem， and this is where I came up with Wiley。
    So Wiley is a tool that basically looks at the， way that the maintainability of
    your code the complexity of it changes over time。 So it assumes， that your code
    is in a Git repository and it will go back through the Git history and。 basically
    run complexity metrics over each revision and it will then store that in a flat。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我确实在研究这个问题，这就是我想出了 Wiley。Wiley 是一个工具，它基本上观察你的代码的维护性和复杂性是如何随时间变化的。因此，它假设你的代码在一个
    Git 仓库中，它会回溯 Git 历史，基本上对每个修订版本运行复杂性度量，然后将其存储在一个平面文件中。
- en: file database and it will let you query that and see trends of maintainability
    and complexity。 in your code applications。 So I'm going to give you a demo of
    this。 And because I don't。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 文件数据库，它允许你查询并查看你代码应用程序中的维护性和复杂性的趋势。所以我将给你演示这个。因为我没有。
- en: '![](img/7da318d509d441e90f69efc38e15b1a9_7.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7da318d509d441e90f69efc38e15b1a9_7.png)'
- en: '![](img/7da318d509d441e90f69efc38e15b1a9_8.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7da318d509d441e90f69efc38e15b1a9_8.png)'
- en: trust live demos I'm going to do magic hands。 So the way that you run Wiley
    is you run Wiley。 build and then give it the path to your application。 It will
    go and check out all the revisions。 in Git and then basically go and run metrics
    over them。 So the house did metrics， the cyclomatic。 and complexity metrics， lines
    of code， all of those sorts of things and put those in the， database。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 相信现场演示，我要进行魔术表演。运行 Wiley 的方式是你运行 Wiley build，然后给它你的应用程序的路径。它会检查 Git 中的所有修订版本，然后基本上对它们运行度量。所以这些度量，包括环形复杂度、代码行数等所有这些，并将其放入数据库中。
- en: So it's quite straightforward to get started with Wiley。 It's also really useful。
    to test applications which I'll talk about later。 You can just type Wiley index
    and it。 will give you a list of all the Git revisions that it's checked out。 And
    then when you run。 Wiley report with the name of a file it will give you a table
    with some metrics in it。 So。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所以开始使用 Wiley 是相当简单的。它对于测试应用程序也非常有用，我稍后会谈到。你只需输入 Wiley index，它会给你一个它已检查过的所有 Git
    修订版本的列表。然后当你运行 Wiley report 并指定一个文件名时，它会给你一个包含一些度量的表格。
- en: each line is a Git revision and then if the complexity changed for any reason
    so the maintainability。 index went down here you can see the amount that it went
    down and the cyclomatic complexity。 increased。 So this is useful for basically
    looking at specific files and seeing how they。 trend over time。 You can also use
    it as a pre-commit hook。 So when you're making changes to code。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都是一个 Git 修订版本，如果因为某种原因复杂性发生变化，维护性指数就会下降。在这里你可以看到它下降的幅度，以及环形复杂度是如何增加的。因此，这对于查看特定文件并观察它们随时间的趋势非常有用。你也可以将其作为一个预提交钩子使用。因此，当你对代码进行更改时。
- en: if you run Wiley diff it will actually go and show you how the complexity of
    the code。 has changed for that particular file。 So if you use it as a pre-commit
    hook basically。 when you run Git commit it will go and look at all the changes
    you've made in code and。 it will print out to the screen whether you've made the
    maintainability of the application， worse。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 Wiley diff，它实际上会显示该特定文件的代码复杂性是如何变化的。因此，如果你将其用作预提交钩子，当你运行 Git commit 时，它会查看你在代码中所做的所有更改，并在屏幕上打印出你是否使应用程序的维护性变得更差。
- en: the cyclomatic complexity and it will give you that down to a function level。
    So。 in this case I've just added a test function called test8 which just adds
    a few lines of。 code and another test case so it's going to go and print the information
    for me。 And。 then lastly you can graph any of these metrics so if I were to graph
    my test file and I wanted。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 循环复杂度，它会将复杂性细分到函数级别。因此，在这个例子中，我只是添加了一个名为test8的测试函数，它仅添加了几行。代码和另一个测试案例，所以它会为我打印信息。然后最后，你可以对这些指标进行图形化，所以如果我对我的测试文件进行图形化，想要。
- en: to look at the maintainability index over time then it's going to print that
    out for。 me in an interactive graph and each point on the graph will actually
    be the Git revision。 and the reasons why and also the author of the Git commit。
    So this is a small toy demo。 but for a big application you can use this let me
    try it for another one。 So I can see。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间推移查看可维护性指数，那么它会为我打印出一个交互式图形，图上的每个点实际上都是Git修订版。及其原因，还有Git提交的作者。所以这是一个小玩具演示，但对于一个大型应用程序，你可以尝试另一个示例。所以我可以看到。
- en: how the maintainability index of my code has changed with each Git commit and
    then lastly。 you can combine metrics together so if you wanted to look at maintainability
    index and。 lines of code you can give it multiple measures and it will add a second
    metric as the bubble。 size so I can basically look at how my code has changed
    over time。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每次Git提交后我的代码的可维护性指数是如何变化的，最后。你可以将多个指标结合在一起，所以如果你想查看可维护性指数和。代码行数，可以给出多个度量，它会将第二个度量作为气泡。大小添加，因此我基本上可以查看我的代码随时间变化的情况。
- en: '![](img/7da318d509d441e90f69efc38e15b1a9_10.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7da318d509d441e90f69efc38e15b1a9_10.png)'
- en: Okay so using Wiley you can track the complexity of your code and then you can
    start to refactor。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，使用Wiley你可以跟踪代码的复杂性，然后你可以开始重构。
- en: '![](img/7da318d509d441e90f69efc38e15b1a9_12.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7da318d509d441e90f69efc38e15b1a9_12.png)'
- en: it to make it simpler。 There's something else I wanted to point out which is
    that when you。 start to look at complexity in your applications you're going to
    find that some of your modules。 some of your files have a complexity which is
    far higher than some others and the reason。 behind that is that complexity has
    its own gravity。 So if you've got a function which。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使其变得更简单。我还想指出的是，当你开始关注应用程序中的复杂性时，你会发现一些模块。一些文件的复杂性远高于其他文件，其原因在于复杂性有其自身的引力。因此，如果你有一个函数。
- en: you've started to add edge cases to as your application matures you're going
    to find yourself。 adding more and more edge cases to that function。 If you've
    got what they call like a god class。 or something or a module that basically ends
    up catching every kind of situation that will。 draw more and more complexity。
    So I wanted to point out this principle because I think。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你开始为应用程序添加边界情况，随着应用程序的发展，你会发现自己。越来越多地为那个函数添加边界情况。如果你有一个所谓的“上帝类”或某种模块，基本上会处理所有情况，那么这将。带来越来越多的复杂性。所以我想指出这个原则，因为我认为。
- en: it's important when you start to refactor is that one of the things you need
    to start。 to do is to spread complexity around your code， break it up and follow
    something called the。 single responsibility principle。 The single responsibility
    principle is that any function。 or any piece of code should have one responsibility。
    You shouldn't have a piece of code which。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始重构时重要的一点是，你需要开始做的是将复杂性分散到你的代码中，拆分它，并遵循一种称为。单一责任原则。单一责任原则是指任何函数或任何代码片段应具有一个责任。你不应该有一段代码。
- en: is trying to achieve everything because then it becomes unmaintainable。 it has
    too many characteristics， and it becomes very hard to test。 This lovely creature
    is the cane code， there's anyone here， from Australia？ One at the back。 You probably
    recognize it。 So the venomous cane codes were。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正在尝试实现所有功能，因为那样就变得不可维护。它的特性太多，测试起来非常困难。这个可爱的生物是红蟾蜍，这里有来自澳大利亚的人吗？后面有一个。你可能认得它。所以有毒的红蟾蜍是。
- en: introduced in 1935 to Australia in the hope that they would control the destructive
    cane。 beetle population。 So why am I talking about this？ They turned out to be
    really bad at controlling。 beetles but remarkably successful at reproducing。 They
    also have no natural predators in Australia。 So basically they've infested Queensland，
    the northern state。 And the reason I point this。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 1935年引入澳大利亚，希望能够控制破坏性的甘蔗甲虫种群。那么我为什么要谈论这个呢？它们在控制甲虫方面表现得很糟糕，但在繁殖方面却异常成功。它们在澳大利亚没有天敌。因此，基本上它们已经感染了昆士兰州这个北部州。我提到这个的原因是。
- en: out is because when you're looking at refactoring code， if you don't have a
    good test suite because。 I think the testing coverage of the cane beetle population
    was quite poor， there really wasn't。 a good understanding of the complexity of
    the actual environment。 It just thought this would。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑重构代码时，如果没有一个好的测试套件，因为我认为甘蔗甲虫种群的测试覆盖率相当差，实际上并没有很好地理解实际环境的复杂性。人们只是认为这会。
- en: '![](img/7da318d509d441e90f69efc38e15b1a9_14.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7da318d509d441e90f69efc38e15b1a9_14.png)'
- en: be a quick fix and we could sort this problem out。 So high test coverage should
    be given。 before you start refactoring any application。 However， high test coverage
    doesn't mean you've。 checked all the behaviors。 So when you're looking at refactoring
    an application， you need。 to understand all the ways in which the application
    can behave so that the new code behaves in。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速解决方案，我们可以解决这个问题。因此，应该给予高测试覆盖率。重构任何应用程序之前，必须注意。然而，高测试覆盖率并不意味着你已经检查了所有行为。因此，当你考虑重构应用程序时，需要了解应用程序可能的所有行为，以便新代码能够表现得正确。
- en: the same way as the old code。 Testing is one way to do that。 Another way is
    to help your。 users to find the bugs for you。 And then lastly， one of the difficult
    situations you might。 find yourself in is when you're refactoring actually coming
    across a bug。 And not just。 a bug but a known bug and a bug that's expected。 So
    if anyone's ever faced this before， it's。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以与旧代码相同的方式进行测试。测试是一种方法。另一种方法是帮助你的用户为你发现bug。最后，你可能会遇到的一个困难情况是，当你重构时遇到一个bug。而不仅仅是一个bug，而是一个已知的bug和一个预期的bug。所以如果有人曾经遇到过这种情况。
- en: one of the most fun and challenging things in refactoring。 It's where you've
    refactored。 a code base and you've come across this and you think how could this
    ever work？ And you。 realize it doesn't work and it has a side effect which makes
    something else work。 And。 the only way to refactor it is to either reproduce the
    bug in your new code， solve the。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是重构中最有趣和挑战性的事情之一。你重构了一个代码库，遇到了这个问题，想怎么可能会这样工作？然后你意识到它并不工作，并且有一个副作用使其他东西能够工作。而重构它的唯一方法是要么在你的新代码中重现这个bug，要么解决这个。
- en: problem and explain to all your users why you're breaking compatibility。 And
    there's a third。 option but I don't know what it is。 So this is a tricky one to
    look out for but like I。 say testing is critical。 So I guess in conclusion， Wily
    can benefit you in tracking complexity。 in your code base and measuring that over
    time with the principle that you're going to， do。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 问题并向所有用户解释为什么你会破坏兼容性。还有第三个选项，但我不知道是什么。所以这是一个需要注意的棘手问题，但正如我所说，测试至关重要。因此，我想总结一下，Wily可以帮助你跟踪代码库的复杂性，并随着时间的推移进行测量，原则是你将会这样做。
- en: Complexity measures are long term。 Just calculating the complexity of your application。
    is interesting but the whole point is that you want it to improve。 And make sure
    you've。 got good behavior or test coverage。 There are some tools you can use to
    do this。 Pytest。 obviously is great as a test suite and there are some coverage
    tools for Pytest but they。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂度度量是长期的。仅仅计算应用程序的复杂度是有趣的，但重点在于你希望它能够改进。并确保你有良好的行为或测试覆盖率。有一些工具可以用来实现这一点。Pytest显然是一个很好的测试套件，还有一些覆盖工具适用于Pytest，但它们。
- en: just look at line coverage。 They don't actually look at the way you're testing
    different， behaviors。 There are some automated tools to do that but really the
    best way to do it。 is to look at features and functionality to describe those
    and make sure you're testing。 each one of those features。 Refactor often， this
    shouldn't be an annual event that you。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 只查看行覆盖率。它们实际上并没有查看你测试不同行为的方式。有一些自动化工具可以做到这一点，但最好的方式是查看功能和特性来描述它们，并确保你对每个特性进行测试。经常重构，这不应该是一个年度事件。
- en: sit down and say let's clean up our code base。 This should be something that's
    done frequently。 And if you refactor your code often， you'll find that the amount
    of refactoring you have， to do。 the amount of yak shaving， the amount of edge
    cases you have to deal with is far， smaller。 So if you think about measuring complexity
    using a tool like Wiley and you。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 坐下来并说让我们清理一下我们的代码库。这应该是一个经常进行的事情。如果你经常重构代码，你会发现你需要重构的数量、你需要处理的琐事和边缘情况都要小得多。因此，如果你考虑使用像Wiley这样的工具来衡量复杂性。
- en: can see sprint by sprint or day by day how that is increasing or decreasing
    in your code。 that should encourage your team to refactor。 And then lastly divide
    and conquer。 If you're。 going to refactor any substantial code base， it can be
    very daunting at first。 Some of。 my advice is to start with something small， start
    with something that's got good test。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到每个冲刺或每天代码的复杂性是如何增加或减少的。这应该鼓励你的团队进行重构。最后，分而治之。如果你要重构任何重要的代码库，一开始可能会很令人畏惧。我的一些建议是从小的东西开始，先从有良好测试的代码入手。
- en: coverage and something that you can understand and refactor that one module
    first and then。 work your way out from there。 Don't try and rewrite the entire
    code base in one go with。 the intention of improving simplicity。 Everyone starts
    out with the best intentions but you。 might find yourself with a population of
    cane toads。 So that really wraps up my talk。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率和一些你可以理解的内容，先重构那个模块，然后再从那里扩展。不要试图一次性重写整个代码库以改善简单性。每个人一开始都是怀着最好意图，但你可能会发现自己在处理一堆蝾螈。所以这实际上总结了我的演讲。
- en: If you want to read more detail on techniques for refactoring， there's an article
    on real， Python。com that I wrote to explain this。 If you want to check out my
    website， it's on， GitHub。 If you have any questions and you want to email me，
    that's my email address。 And if you want to tweet me， then that's my handle。 And
    we have five minutes remaining。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于重构技术的细节，我在realpython.com上写了一篇文章来解释这个。如果你想查看我的网站，可以在GitHub上找到。如果你有任何问题想给我发邮件，这是我的电子邮件地址。如果你想在推特上联系我，这是我的账号。我们还有五分钟。
- en: for questions。 So thank you very much。 Anyone that has questions， please come
    to this microphone。 There's actually a microphone back there too。 So go to any
    microphone。 \>\> What is Wiley？
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有问题的话。非常感谢。有任何问题的人，请到这个麦克风前。那边也有一个麦克风。所以可以去任何一个麦克风。 \>\> Wiley是什么？
- en: How do you get it？ Is that a product or？ \>\> It's a package on PIPI。 So just
    pip install Wiley and you can run it on the command line。 \>\> Awesome。 Thank
    you。 \>\> Hi。 The equation for the Halsted thing。 I can't remember what it's called。
    There was。 a constant in there。 There's like 171。 What was that？ \>\> I've got
    no idea。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何获取它？这是一个产品还是？ \>\> 这是一个PIPI上的包。所以只需运行`pip install Wiley`，你就可以在命令行上使用它。 \>\>
    太好了。谢谢。 \>\> 嗨。关于Halsted的公式。我记不得它叫什么了。里面有一个常数。大约是171。那是什么？ \>\> 我不知道。
- en: \>\> The examples that you showed with Wiley， they seem to operate on a single
    file。 Is。 it possible to run it for an entire project？ \>\> Yeah。 I toyed with
    this。 But yes， is the answer。 You typically give it the path to， your whole project。
    And if you want to run a report on a folder。 it will give you the， metrics for
    every single file or you can roll them up into a single metric。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: \>\> 你展示的Wiley示例似乎是在单个文件上操作。能否在整个项目上运行？ \>\> 是的。我玩过这个。但答案是可以。你通常只需给它你整个项目的路径。如果你想对一个文件夹运行报告，它将为你提供每个文件的指标，或者你可以将它们汇总成一个指标。
- en: It's designed， for big applications。 But I just used it for a tiny sample。 Otherwise。
    it would take too， long to compile。 Thank you。 \>\> Great talk。 I love everything。
    I agree with everything you're saying。 How do you get， team buy in？
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为大型应用程序设计的。但我只是用它处理了一个小示例。否则，编译将花费太长时间。谢谢。 \>\> 很棒的演讲。我喜欢一切。我同意你说的每一句话。你是如何让团队达成共识的？
- en: \>\> I think if you look at the times when people have to make changes and they
    appreciate that。 complexity makes it harder to make change。 If you pin them down
    then and see， see， this。 is why we need simpler code。 I think that's probably
    the opportunity to do it。 If you。 phrase it as a let's have a massive refactoring
    of our code base and you're basically going。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: \>\> 我认为如果你看看人们需要做出改变的时刻，他们会意识到，复杂性使得更改更难。如果你在那个时候让他们明白，看看这就是为什么我们需要更简单的代码。我认为这可能是一个机会。如果你把它说成是让我们对代码库进行一次大规模重构，你实际上就是在。
- en: to put yourself in a position where you're going to have unusable code or a
    branch that。 doesn't compile or however you measure that for multiple sprints，
    that's a really hard， sell。 So it needs to be a small piece of work。 \>\> Cool。
    Thank you。 \>\> Cool。 \>\> Okay。 Thank you。 Thank you。 Thank you。 Thank you。 Thank
    you。 Thank you。 Thank you。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 把自己置于会产生不可用代码或无法编译的分支的境地，或者你如何为多个冲刺进行衡量，这真的是一个很难的推销。因此，它需要是一个小的工作量。 \>\> 太好了。谢谢。
    \>\> 太好了。 \>\> 好的。谢谢。谢谢。谢谢。谢谢。谢谢。谢谢。
- en: '![](img/7da318d509d441e90f69efc38e15b1a9_16.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7da318d509d441e90f69efc38e15b1a9_16.png)'
