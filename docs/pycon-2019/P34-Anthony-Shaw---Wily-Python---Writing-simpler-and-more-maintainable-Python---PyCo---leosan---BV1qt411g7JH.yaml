- en: P34：Anthony Shaw - Wily Python - Writing simpler and more maintainable Python
    - PyCo - leosan - BV1qt411g7JH
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hello everybody。 The next talk is Wild Python， Writing Simpler and More Maintainable
    Python。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7da318d509d441e90f69efc38e15b1a9_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: by Anthony Shaw。 [Applause]， Hi everybody。 My name is Anthony Shaw and I'm giving
    a talk about simplicity and trying。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7da318d509d441e90f69efc38e15b1a9_3.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: to write more simple Python。 This is my first time speaking at PyCon。 I'm super
    nervous。 and I was researching some tips about public speaking for this kind of
    event。 I found three， rules。 Rule number one was to have frequent pauses。 Rule
    number two was to never start， with an apology。 And then rule number three was
    to never thank people for coming to your。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: talk and just assume that they're here to listen。 So thank you for coming。 We've
    got a lot to get through so I'm going to go quickly so， I apologize for that。
    And we're going to talk about code complexity today。 So what does， that mean？
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: How would you inspect if your code is complicated？ And then we're going to look。
    at not really just how is your code complicated but how do you actually measure
    that？ Because。 everybody thinks that they write simple code because it makes sense
    to you。 But it's more。 about communicating with other people and sharing your
    code and your ideas with others。 So we're。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: going to talk about code metrics and we can then talk about how do you actually
    simplify。 the code once you realize whether or not it's complicated。 The title
    of the talk is about。 Wily Python。 So I'm going to introduce a talk called Wily
    which I wrote which basically。 helps you manage this process of understanding
    whether your code is complicated or not by。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: what measure and how do you simplify it and then basically doing that in a loop。
    I know。 there's probably quite a mixed audience here today so in terms of the
    complexity of the。 talk itself this has got a matter。 The first section is really
    kind of a beginner level。 and then the second part is intermediate to advanced。
    If anyone has any questions please。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: come and speak to me afterwards and if we get time later in the talk we can
    open up for， the Q&A。 Also I've written an extensive article on RealPython。com
    which takes about an hour。 and a half to read so it's probably one of my shorter
    articles。 So I encourage you to。 read that because there's a lot more detail in
    that post。 I now need to convince everyone。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: that simple code is good so why should you care if your code is complicated
    or simple。 So remember that your code is written not just for computers it's written
    for humans and Python。 especially is almost written in a language that's easy
    for people to understand and when。 you write an application in code you're leaving
    instructions for the computer but also for。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: your fellow developers。 So not just in code comments but in the actual code
    itself in。 the way you name your functions， your classes， your variables， the
    way you structure it， it。 should be a set of instructions for people。 So it should
    be clear that what you're trying。 to achieve and what you're trying to do with
    the code which is why you want simpler code。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: rather than more complex code。 Also code is a living thing it changes often。
    So if your。 code is complicated to understand when people want to make changes
    to it they're more likely。 to misunderstand what it was you were trying to do
    and introduce bugs。 So you want simple。 code because it's easier to maintain the
    code it's easier to adapt the code and it's easier。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: to add more functionality。 And then lastly complicated code is hard to test
    and testing。 is good hopefully we can all agree on that。 So you want simple code
    so that you can test。 it so that people can understand it and so that you can
    adapt it over time。 So how do。 you measure if code is complicated？ So this really
    really simple sample uses the crudest。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: measure for measuring the size of code and that is the lines of code。 It's really
    easy。 to calculate the number of lines of code we have in this application and
    in theory you。 want fewer code so you want fewer lines of code。 But I can represent
    that same code example。 in fewer lines of code but there's one massive issue with
    this example。 So I've used a few。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: funky Python syntax here。 It basically does exactly the same as this but it's
    on three。 lines so there's less code so that should be a good thing。 But as Tim
    Peters famously。 said readability counts。 So lines of code is not really a measure
    of complexity but more。 about volume you're really looking at how big the application
    is and encouraging people。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: to write less code can actually encourage the wrong behavior because people
    end up condensing。 stuff down to a point where it's less readable。 So lines of
    code doesn't really talk about。 complexity it's just about volume and there are
    other measures you can use for complexity。 One of those measures is called cyclomatic
    complexity and I want to explain it in terms。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: of ordering a burger at McDonald's at a drive-through。 So you start off with
    one decision which is。 what you actually want to eat。 So let's say you want to
    eat a big mac and there are other。 burgers available from other restaurants。 So
    you start off with a cyclomatic complexity。 of one you've made one decision。 They
    then ask you do you want to make that a meal so。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: that increases the complexity by one。 They then say do you want what size do
    you want。 that's another one what drink would you like and then if you want diet
    or regular coke with， that。 So the cyclomatic complexity of ordering a big mac
    from Mac is five。 So if you imagine。 you went to McDonald's and they asked you
    16 different questions at which point would。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: you say it got really complicated。 So cyclomatic complexity is like this because
    when you're。 trying to read a piece of code you've got to understand all the decisions
    and how they。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7da318d509d441e90f69efc38e15b1a9_5.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: get made。 And I picked this code example I apologize if it's a bit small。 This
    is actually。 from the Python standard library in a module called local。py。 So
    every time in Python there's。 an if an else if a for try statement it counts as
    increasing the cyclomatic complexity by。 one because that's the decision that's
    got to be made in code。 So what does that have。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: to do with complexity well when you read this code sample and if I ask you to
    articulate。 what this does you're not just reading down a set of statements you're
    actually looking。 at each if block and thinking okay well what would that variable
    be if it's this and that。 happens if it's this and that happens and you've got
    to store in your head basically like your。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: own value stack and start to evaluate the code whereas if it's just a series
    of flat statements。 you can see one by one what that code does。 So this is a complicated
    piece of code it has。 a high cyclomatic complexity it does take a bit of time
    to read and understand but there's。 also I think an easier way to see cyclomatic
    complexity。 If you turn the code on its side。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: and then get a pen and draw a line around the white space you'll see this。 So
    I'd say。 that instead of just trying to calculate cyclomatic complexity if your
    code looks like a mountain。 range when you turn it on its side then it has a high
    complexity and also another quote。 from Tim Peters flat is better than nested
    so flatter code is easier to understand is。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: easier to process and this example has a high complexity so you could walk into
    this and。 think okay well let's just make it flatter and simpler but I think you're
    missing one principle。 and that is there's actually wisdom in complicated code
    and I will talk about this as well so most。 IDEs have a Git blame tool if you've
    ever used Git blame I've turned on Git blame on。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: the same module but just a few more lines down and you can actually see here
    who and when。 and why each piece of code was changed and we've got changes from
    19 years ago 15， 12。 every time somebody adds has to fix an issue fix a bug at
    an edge case they go in and they。 make that change so that's normally in the form
    of an if statement or a small change which。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: therefore increases the complexity of the code so just trying to charge in and
    say let's。 just make this simpler you actually need to understand all the reasons
    why the code is。 like the way it is。 The other thing you might miss is if you
    don't introduce this you could。 introduce reintroduce bugs which have already
    been resolved and which could upset users so。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: to simplify what I've just said when you start off with a new application you
    typically have。 a little amount of functionality and a few users so you should
    have a little amount of。 code and a small amount of psychomatic complexity。 As
    you add more features you tend to write。 more code so the lines of code measure
    will go up。 As you have more users you have to support。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: more edge cases more platforms more scenarios and you tend to increase psychomatic
    complexity。 of the code as well and then the double whammy is when you've got
    a lot of users and a lot。 of functionality。 So CPython itself is a good example
    it's used by millions of people and。 it has a lot of users it's got a lot of functionality
    so it has a lot of complexity。 So if lines。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: of code and psychomatic complexity can't really be used as measures for big
    applications。 what can you use instead。 So I'm going to talk about how Stedmetrics。
    I do warn that。 there's a bit of math in this section so if you feel like the
    math is a bit too complicated。 or outside of your comfort zone don't worry there
    are tools that can calculate this stuff， for you。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: This metric has actually been around since 1977 predating Python and the research。
    behind it as well is very old by this point how many years is that 50 years and
    so the。 research behind this is actually 50 years old just over 50。 Okay so let's
    introduce two， things。 There's a value called operands。 operand is the sum of
    the values you've used and the。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: sum of the variables you've used so number one or a string constant would count
    as a value。 and a name would count as a variable so if you add all of those up
    you get operands。 If you add up the amount of built-in syntax you've used in the
    application that's called， operators。 If you take the sum of the operators and
    the sum of the operands you've used you。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: end up with a measure called length and if you take the amount of unique operators
    you've。 used and unique operands you've used you end up with a measure called
    vocabulary。 So this。 probably sounds a bit complicated compared to lines of code
    which is quite an easy way。 to measure things but there's reasons behind it。 So
    if anyone's familiar with the abstract。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: syntax tree it's basically what happens when your code is compiled is turned
    into a tree。 and then it's interpreted as a tree。 So this simple code example
    I've got here with a function。 with three statements I'm going to assign the value
    one to a variable called A I'm going。 to increment that by one and assign it to
    a variable called B and then I'm going to return， B。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: So in the tree you've got the two assignments and then you've got the return
    statement。 In。 the first assignment you've got the name which is the variable
    A and the number which。 is the number one。 So everything in green would be added
    up and then everything in yellow。 would be added up to give you operators and
    operands and then this is where it gets slightly。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: more complicated unfortunately。 We've then got volume and difficulty so you
    multiply the。 length by a logarithm of the vocabulary to get volume which is better
    than lines of code。 and then this one had me stumped for a while but basically
    it more or less tries to calculate。 how you've reused code and how much code you've
    used to achieve something and then gives。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这变得更加复杂。我们还有体量和难度，所以你需要将长度乘以词汇的对数，以获得体量，这比代码行数更好。这个让我困惑了一段时间，但基本上它试图计算你如何重用代码，以及为了实现某个功能你使用了多少代码，然后给出结果。
- en: you that as a variable with difficulty。 And then lastly you get effort which
    is a multiple。 of both of those two things。 So all of that's very theoretical
    but basically there are。 better ways of measuring the amount of code in an application
    and the amount of variables。 you've used and the amount of syntax you've used。
    So all these things are basically a way。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其视为一个难度变量。最后你得到的努力是这两者的乘积。所以所有这些都是非常理论化的，但基本上有更好的方法来衡量应用程序中的代码量、使用的变量数量以及使用的语法数量。这些基本上是为了达到一个单一的数字。
- en: of measuring the amount of code you have。 There's actually a better measure
    than this。 Don't worry too much about the equation。 There's different versions
    of this equation but this。 is called the maintainability index and the output
    is just a number from zero to a hundred。 and it's a scale。 So if you run the maintainability
    index of your code it will just give you a。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 其实有比这更好的衡量代码量的方法。不要太担心这个公式。这个公式有不同的版本，但被称为可维护性指数，输出值是从零到一百的数字，形成一个比例。因此，如果你运行代码的可维护性指数，它会给你一个数字。
- en: single number。 If that number is between zero and twenty five it means your
    code is， unmaintainable。 It's a bit of a mess。 If it's between twenty five and
    fifty it would be。 like my high school teachers say cause of the concern。 If it's
    between fifty and seventy。 five that's realistically where most applications are
    but you can still definitely see improvement。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个数字在零到二十五之间，意味着你的代码是不可维护的，稍显混乱。如果在二十五到五十之间，像我的高中老师说的那样，值得关注。如果在五十到七十五之间，那就是现实中大多数应用程序的位置，但你仍然可以看到改善的空间。
- en: And then if it's over seventy five I don't believe you。 So this is actually
    this metric。 is actually used in Microsoft applications in Java applications as
    well and in Python。 this is the equation we use in Wiley for calculating the index。
    So if you don't want。 to go and sit and calculate that by hand basically it's
    taking the house dead volume。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果超过七十五，我就不相信你了。实际上，这个指标在微软的应用程序、Java应用程序以及Python中都被使用。这是我们在Wiley中用于计算指数的公式。如果你不想坐下来手动计算，基本上它就是在计算死亡体量。
- en: the cyclomatic complexity and the number of lines of code。 So your maintainability
    index。 is going to be lower if you've used a lot of code a lot of variables a
    lot of syntax。 and a lot of nesting to achieve something。 That's when you're going
    to have something， in the red。 So it's going to be in the green where you've got
    nice flat code you don't。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 循环复杂度和代码行数。因此，如果你使用了大量的代码、变量、语法和嵌套来实现某个功能，你的可维护性指数就会降低。这时你就会发现代码位于红色区域。而如果你的代码简单扁平，就会位于绿色区域。
- en: have too many functions too many variables and there's not that much code volume
    so that's。 where it's going to be in the green。 So you don't have to calculate
    this stuff by hand。 you can use a package called radon。 On the command line you
    can run radon and then the。 algorithm that you want to use a CC is cyclomatic
    complexity and you give it the file name you。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中有太多功能和变量，而代码量并不多，所以这就是它将位于绿色区域的原因。因此，你不必手动计算这些内容，可以使用一个叫做radon的包。在命令行中，你可以运行radon，然后使用你想要的算法，CC是循环复杂度，接着给出文件名。
- en: want to run and it will basically calculate the number for you and give you
    that output。 You can also do MI which is the maintainability index I just spoke
    about and it says that my。 application was 87。42 which is pretty impressive but
    it's only four lines of code so that's understandable。 And then lastly you can
    run how is the algorithm and it will give you all of the measures I。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你想运行的内容，它会基本上为你计算这个数字并给出输出。你也可以做MI，即我刚才提到的可维护性指数，它显示我的应用程序是87.42，这相当不错，但只有四行代码，所以这是可以理解的。最后你可以运行如何算法，它会给你所有的度量。
- en: spoke about。 It also outputs another one which I've cropped from the image which
    is。 actually the number of bugs it's spotted in your code。 How is it actually
    theorised that。 you could calculate the number of bugs based on the amount of
    code but this theory was。 50 years old。 So you've got the numbers you look at
    the numbers and you think okay that's。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: interesting。 I've got a vocabulary of nine and a calculated length of 20。26
    one now。 So。 does that tell you whether your code is maintainable or not？
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: So really I was looking at this problem， and this is where I came up with Wiley。
    So Wiley is a tool that basically looks at the， way that the maintainability of
    your code the complexity of it changes over time。 So it assumes， that your code
    is in a Git repository and it will go back through the Git history and。 basically
    run complexity metrics over each revision and it will then store that in a flat。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: file database and it will let you query that and see trends of maintainability
    and complexity。 in your code applications。 So I'm going to give you a demo of
    this。 And because I don't。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7da318d509d441e90f69efc38e15b1a9_7.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: '![](img/7da318d509d441e90f69efc38e15b1a9_8.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: trust live demos I'm going to do magic hands。 So the way that you run Wiley
    is you run Wiley。 build and then give it the path to your application。 It will
    go and check out all the revisions。 in Git and then basically go and run metrics
    over them。 So the house did metrics， the cyclomatic。 and complexity metrics， lines
    of code， all of those sorts of things and put those in the， database。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: So it's quite straightforward to get started with Wiley。 It's also really useful。
    to test applications which I'll talk about later。 You can just type Wiley index
    and it。 will give you a list of all the Git revisions that it's checked out。 And
    then when you run。 Wiley report with the name of a file it will give you a table
    with some metrics in it。 So。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: each line is a Git revision and then if the complexity changed for any reason
    so the maintainability。 index went down here you can see the amount that it went
    down and the cyclomatic complexity。 increased。 So this is useful for basically
    looking at specific files and seeing how they。 trend over time。 You can also use
    it as a pre-commit hook。 So when you're making changes to code。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: if you run Wiley diff it will actually go and show you how the complexity of
    the code。 has changed for that particular file。 So if you use it as a pre-commit
    hook basically。 when you run Git commit it will go and look at all the changes
    you've made in code and。 it will print out to the screen whether you've made the
    maintainability of the application， worse。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: the cyclomatic complexity and it will give you that down to a function level。
    So。 in this case I've just added a test function called test8 which just adds
    a few lines of。 code and another test case so it's going to go and print the information
    for me。 And。 then lastly you can graph any of these metrics so if I were to graph
    my test file and I wanted。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: to look at the maintainability index over time then it's going to print that
    out for。 me in an interactive graph and each point on the graph will actually
    be the Git revision。 and the reasons why and also the author of the Git commit。
    So this is a small toy demo。 but for a big application you can use this let me
    try it for another one。 So I can see。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: how the maintainability index of my code has changed with each Git commit and
    then lastly。 you can combine metrics together so if you wanted to look at maintainability
    index and。 lines of code you can give it multiple measures and it will add a second
    metric as the bubble。 size so I can basically look at how my code has changed
    over time。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7da318d509d441e90f69efc38e15b1a9_10.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Okay so using Wiley you can track the complexity of your code and then you can
    start to refactor。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7da318d509d441e90f69efc38e15b1a9_12.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: it to make it simpler。 There's something else I wanted to point out which is
    that when you。 start to look at complexity in your applications you're going to
    find that some of your modules。 some of your files have a complexity which is
    far higher than some others and the reason。 behind that is that complexity has
    its own gravity。 So if you've got a function which。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: you've started to add edge cases to as your application matures you're going
    to find yourself。 adding more and more edge cases to that function。 If you've
    got what they call like a god class。 or something or a module that basically ends
    up catching every kind of situation that will。 draw more and more complexity。
    So I wanted to point out this principle because I think。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: it's important when you start to refactor is that one of the things you need
    to start。 to do is to spread complexity around your code， break it up and follow
    something called the。 single responsibility principle。 The single responsibility
    principle is that any function。 or any piece of code should have one responsibility。
    You shouldn't have a piece of code which。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: is trying to achieve everything because then it becomes unmaintainable。 it has
    too many characteristics， and it becomes very hard to test。 This lovely creature
    is the cane code， there's anyone here， from Australia？ One at the back。 You probably
    recognize it。 So the venomous cane codes were。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: introduced in 1935 to Australia in the hope that they would control the destructive
    cane。 beetle population。 So why am I talking about this？ They turned out to be
    really bad at controlling。 beetles but remarkably successful at reproducing。 They
    also have no natural predators in Australia。 So basically they've infested Queensland，
    the northern state。 And the reason I point this。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: out is because when you're looking at refactoring code， if you don't have a
    good test suite because。 I think the testing coverage of the cane beetle population
    was quite poor， there really wasn't。 a good understanding of the complexity of
    the actual environment。 It just thought this would。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7da318d509d441e90f69efc38e15b1a9_14.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: be a quick fix and we could sort this problem out。 So high test coverage should
    be given。 before you start refactoring any application。 However， high test coverage
    doesn't mean you've。 checked all the behaviors。 So when you're looking at refactoring
    an application， you need。 to understand all the ways in which the application
    can behave so that the new code behaves in。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: the same way as the old code。 Testing is one way to do that。 Another way is
    to help your。 users to find the bugs for you。 And then lastly， one of the difficult
    situations you might。 find yourself in is when you're refactoring actually coming
    across a bug。 And not just。 a bug but a known bug and a bug that's expected。 So
    if anyone's ever faced this before， it's。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: one of the most fun and challenging things in refactoring。 It's where you've
    refactored。 a code base and you've come across this and you think how could this
    ever work？ And you。 realize it doesn't work and it has a side effect which makes
    something else work。 And。 the only way to refactor it is to either reproduce the
    bug in your new code， solve the。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: problem and explain to all your users why you're breaking compatibility。 And
    there's a third。 option but I don't know what it is。 So this is a tricky one to
    look out for but like I。 say testing is critical。 So I guess in conclusion， Wily
    can benefit you in tracking complexity。 in your code base and measuring that over
    time with the principle that you're going to， do。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Complexity measures are long term。 Just calculating the complexity of your application。
    is interesting but the whole point is that you want it to improve。 And make sure
    you've。 got good behavior or test coverage。 There are some tools you can use to
    do this。 Pytest。 obviously is great as a test suite and there are some coverage
    tools for Pytest but they。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: just look at line coverage。 They don't actually look at the way you're testing
    different， behaviors。 There are some automated tools to do that but really the
    best way to do it。 is to look at features and functionality to describe those
    and make sure you're testing。 each one of those features。 Refactor often， this
    shouldn't be an annual event that you。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: sit down and say let's clean up our code base。 This should be something that's
    done frequently。 And if you refactor your code often， you'll find that the amount
    of refactoring you have， to do。 the amount of yak shaving， the amount of edge
    cases you have to deal with is far， smaller。 So if you think about measuring complexity
    using a tool like Wiley and you。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 坐下来并说让我们清理一下我们的代码库。这应该是一个经常进行的事情。如果你经常重构代码，你会发现你需要重构的数量、你需要处理的琐事和边缘情况都要小得多。因此，如果你考虑使用像Wiley这样的工具来衡量复杂性。
- en: can see sprint by sprint or day by day how that is increasing or decreasing
    in your code。 that should encourage your team to refactor。 And then lastly divide
    and conquer。 If you're。 going to refactor any substantial code base， it can be
    very daunting at first。 Some of。 my advice is to start with something small， start
    with something that's got good test。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到每个冲刺或每天代码的复杂性是如何增加或减少的。这应该鼓励你的团队进行重构。最后，分而治之。如果你要重构任何重要的代码库，一开始可能会很令人畏惧。我的一些建议是从小的东西开始，先从有良好测试的代码入手。
- en: coverage and something that you can understand and refactor that one module
    first and then。 work your way out from there。 Don't try and rewrite the entire
    code base in one go with。 the intention of improving simplicity。 Everyone starts
    out with the best intentions but you。 might find yourself with a population of
    cane toads。 So that really wraps up my talk。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率和一些你可以理解的内容，先重构那个模块，然后再从那里扩展。不要试图一次性重写整个代码库以改善简单性。每个人一开始都是怀着最好意图，但你可能会发现自己在处理一堆蝾螈。所以这实际上总结了我的演讲。
- en: If you want to read more detail on techniques for refactoring， there's an article
    on real， Python。com that I wrote to explain this。 If you want to check out my
    website， it's on， GitHub。 If you have any questions and you want to email me，
    that's my email address。 And if you want to tweet me， then that's my handle。 And
    we have five minutes remaining。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于重构技术的细节，我在realpython.com上写了一篇文章来解释这个。如果你想查看我的网站，可以在GitHub上找到。如果你有任何问题想给我发邮件，这是我的电子邮件地址。如果你想在推特上联系我，这是我的账号。我们还有五分钟。
- en: for questions。 So thank you very much。 Anyone that has questions， please come
    to this microphone。 There's actually a microphone back there too。 So go to any
    microphone。 \>\> What is Wiley？
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有问题的话。非常感谢。有任何问题的人，请到这个麦克风前。那边也有一个麦克风。所以可以去任何一个麦克风。 \>\> Wiley是什么？
- en: How do you get it？ Is that a product or？ \>\> It's a package on PIPI。 So just
    pip install Wiley and you can run it on the command line。 \>\> Awesome。 Thank
    you。 \>\> Hi。 The equation for the Halsted thing。 I can't remember what it's called。
    There was。 a constant in there。 There's like 171。 What was that？ \>\> I've got
    no idea。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何获取它？这是一个产品还是？ \>\> 这是一个PIPI上的包。所以只需运行`pip install Wiley`，你就可以在命令行上使用它。 \>\>
    太好了。谢谢。 \>\> 嗨。关于Halsted的公式。我记不得它叫什么了。里面有一个常数。大约是171。那是什么？ \>\> 我不知道。
- en: \>\> The examples that you showed with Wiley， they seem to operate on a single
    file。 Is。 it possible to run it for an entire project？ \>\> Yeah。 I toyed with
    this。 But yes， is the answer。 You typically give it the path to， your whole project。
    And if you want to run a report on a folder。 it will give you the， metrics for
    every single file or you can roll them up into a single metric。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: \>\> 你展示的Wiley示例似乎是在单个文件上操作。能否在整个项目上运行？ \>\> 是的。我玩过这个。但答案是可以。你通常只需给它你整个项目的路径。如果你想对一个文件夹运行报告，它将为你提供每个文件的指标，或者你可以将它们汇总成一个指标。
- en: It's designed， for big applications。 But I just used it for a tiny sample。 Otherwise。
    it would take too， long to compile。 Thank you。 \>\> Great talk。 I love everything。
    I agree with everything you're saying。 How do you get， team buy in？
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为大型应用程序设计的。但我只是用它处理了一个小示例。否则，编译将花费太长时间。谢谢。 \>\> 很棒的演讲。我喜欢一切。我同意你说的每一句话。你是如何让团队达成共识的？
- en: \>\> I think if you look at the times when people have to make changes and they
    appreciate that。 complexity makes it harder to make change。 If you pin them down
    then and see， see， this。 is why we need simpler code。 I think that's probably
    the opportunity to do it。 If you。 phrase it as a let's have a massive refactoring
    of our code base and you're basically going。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: \>\> 我认为如果你看看人们需要做出改变的时刻，他们会意识到，复杂性使得更改更难。如果你在那个时候让他们明白，看看这就是为什么我们需要更简单的代码。我认为这可能是一个机会。如果你把它说成是让我们对代码库进行一次大规模重构，你实际上就是在。
- en: to put yourself in a position where you're going to have unusable code or a
    branch that。 doesn't compile or however you measure that for multiple sprints，
    that's a really hard， sell。 So it needs to be a small piece of work。 \>\> Cool。
    Thank you。 \>\> Cool。 \>\> Okay。 Thank you。 Thank you。 Thank you。 Thank you。 Thank
    you。 Thank you。 Thank you。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 把自己置于会产生不可用代码或无法编译的分支的境地，或者你如何为多个冲刺进行衡量，这真的是一个很难的推销。因此，它需要是一个小的工作量。 \>\> 太好了。谢谢。
    \>\> 太好了。 \>\> 好的。谢谢。谢谢。谢谢。谢谢。谢谢。谢谢。
- en: '![](img/7da318d509d441e90f69efc38e15b1a9_16.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7da318d509d441e90f69efc38e15b1a9_16.png)'
