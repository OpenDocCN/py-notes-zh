- en: P6：Andy Fundinger - 8 things that happen at the dot -  Attribute Access & Descripto
    - leosan - BV1qt411g7JH
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P6：Andy Fundinger - 在点上发生的8件事 - 属性访问与描述符 - leosan - BV1qt411g7JH
- en: Everybody， please join me in welcoming Andy Funderinger。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大家，请和我一起欢迎Andy Funderinger。
- en: '![](img/d9b78ecadbf81eb9828e4c03279b0041_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9b78ecadbf81eb9828e4c03279b0041_1.png)'
- en: '![](img/d9b78ecadbf81eb9828e4c03279b0041_2.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9b78ecadbf81eb9828e4c03279b0041_2.png)'
- en: '[applause]， \>\> Thank you。 So， eight things that happen at the dot attribute
    access and descriptors。 Kind of interesting， this talk is kind of coming full
    circle back to a conversation that。 happened at PyCon Portland where I was talking
    with Guido and I said， what''s a part of Python。 that doesn''t get enough attention
    and he said， well， maybe descriptors。'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]，>> 谢谢。那么，在点属性访问和描述符上发生的八件事。这个演讲有点回归到我在PyCon Portland与Guido交谈时的对话。我问，Python中哪个部分没有得到足够的关注，他说，也许是描述符。'
- en: And a few months later I said， well， maybe I'll try to make a talk out of that。
    And now， well。 a couple years later， this talk is here。 So， who am I？ I've been
    a Python developer since version 2。4， but descriptors are not something， that
    has changed since Python 2。2 with the new style classes。 Today we're using all
    Python 3， but the difference is basically a bunch of parenthetical objects。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 几个月后，我想，也许我会试着把这个做成一个演讲。现在，几年后，这个演讲终于来了。那么，我是谁呢？我从2.4版本开始就是Python开发者，但描述符自Python
    2.2的新增样式类以来并没有改变。今天我们使用的是Python 3，但差别基本上是一些括号对象。
- en: being removed。 And myself， I've worked in industrial automation。 metaverse development
    and the financial industry。 I've previously spoken about descriptors a few different
    places。 Py Caribbean， Py Gotham， EuroPython， PyCAS， skates and Py Tennessee。 They
    seem to keep creeping into my talks。 I don't know why。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 被移除的。而我自己在工业自动化、元宇宙开发和金融行业工作过。我之前在几个地方谈过描述符，包括Py Caribbean、Py Gotham、EuroPython、PyCAS、skates和Py
    Tennessee。它们似乎总是潜入我的演讲中，我也不知道为什么。
- en: Those are some of them are different talks。 Currently。 I'm working at Bloomberg
    in the data license group。 What we do is we deliver financial data to clients
    in large chunks。 like all the mortgages in North America， all the data about that。
    We use a diverse set of tools to do that。 I pulled out some of them there。 Flask，
    celery， PyCAS， VW。 Redis， Jenna， Hadoop， even some things that are not Python。
    Pearl， JavaScript， CC++， Fortran。 We are enterprise scale， but we are extremely
    agile。 A few of the other things Bloomberg does。 the terminals off in the Expo
    Hall。 We do trading solutions， trade book。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些不同的演讲。目前，我在Bloomberg的数据许可证组工作。我们的工作是向客户提供大量的金融数据，比如北美的所有抵押贷款及其相关数据。我们使用多种工具来完成这项工作。我列出了一些工具：Flask、celery、PyCAS、VW、Redis、Jenna、Hadoop，甚至一些非Python的工具：Pearl、JavaScript、CC++、Fortran。我们是企业级规模，但非常灵活。Bloomberg还做的一些事情包括在展览大厅的终端，我们提供交易解决方案和交易簿。
- en: enterprise data is my section。 News， media， law， new energy finance and government。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 企业数据是我的领域。新闻、媒体、法律、新能源金融和政府。
- en: '![](img/d9b78ecadbf81eb9828e4c03279b0041_4.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9b78ecadbf81eb9828e4c03279b0041_4.png)'
- en: The numbers for Bloomberg are pretty large。 We have more than 5，000 engineers。
    3。000 of them are Python developers。 150 data scientists， 150 plus。 And similarly
    staggering numbers in some of the other categories， including the largest。 private
    network in the world。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Bloomberg的数字非常庞大。我们有超过5,000名工程师，其中3,000名是Python开发者，还有150名数据科学家，150名以上。其他类别的数字同样惊人，包括世界上最大的私人网络。
- en: '![](img/d9b78ecadbf81eb9828e4c03279b0041_6.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9b78ecadbf81eb9828e4c03279b0041_6.png)'
- en: Today we are talking about the dot。 Usually we kind of look at the dot sitting
    there between O and X。 We could write a whole bunch of get add or O， X。 That is
    probably just O dundered dict index by X。 And in the simplest case， sure， sure，
    sure it is。 O equals my object and we put the value of X in the dundered dict
    as 3 and we look at dundered dict。 And there it is and O dot X and there's 3 and
    that's exactly what we expect。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 今天我们讨论点。通常我们会看看O和X之间的点。我们可以写一堆get add或O、X。那可能就是O的双下划线字典索引为X。在最简单的情况下，当然，当然，它就是O等于我的对象，我们把X的值放入双下划线字典中为3，然后查看双下划线字典。于是就有O点X，值为3，这正是我们所期望的。
- en: But of course maybe it's coming off the class。 This doesn't surprise us when
    it happens。 So here's a class。 We give my object a class of base object but we'll
    use that next。 And we set Y on my object and we look at the class dict and it's
    a mapping proxy but we。 see that Y is in there but O is still an instance of my
    object and when we do O dot Y， yeah。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: we went ahead and we found the value of Y from the class。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9b78ecadbf81eb9828e4c03279b0041_8.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: But it could also come from the parent class。 And we can look here and we can
    see that T is not in the class dict but it is in the dict。 of the first base class
    along with an increasing number of other things， most of which are。 non because
    I haven't been declaring them。 And when we call for O dot T， we get 4。 So great。
    wonderful。 That's all fairly straightforward and we just wave our hand and assume
    that works。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9b78ecadbf81eb9828e4c03279b0041_10.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: But this is Python and we know there's way more that we can do。 So we'll take
    one of the old and boring things。 DundergetAdder has been with us for a very long
    time。 I believe this was Python 2。1 even before the new object model。 DundergetAdder
    is called when there is not a definition when an attribute is not defined。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: on the instance。 And we can see that here I've declared DundergetAdder and I've
    created a class called probe which。 has it defined。 And if I call for P dot R
    before setting a value for R。 then I get back the value that， it returns。 I'm
    sorry。 it's called in prints and it returns this Rett value， getAdder called。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: But after I set a value in there that print statement is not hit， DundergetAdder
    is not， called。 the access is direct， the whole hook is skipped。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9b78ecadbf81eb9828e4c03279b0041_12.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: So there is a matching function on the other side called setAdder just to match
    that up。 SetAdder just lets us say if we're setting a value we'll call this。 And
    we'll just see that for parity。 We define setAdder on a probe。 We set P dot T
    equal to three。 And we see that that print statement is hit。 No magic takes place。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The dict does not get this value because I did not write any changes to the
    dict in my， setAdder。 Now getAdder is actually being called by get attribute。
    And we can override get attribute。 And if we do that we can control it regardless
    of whether the value is in the dict。 So here we have probe。 Probe has get attribute
    on it。 And before and after set P is called。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: So P before set we get any var which is a return from get attribute。 And after
    set we also get any var which is also the return from get attribute。 Get attribute
    is actually managing the whole process。 But we'll just gloss over that because
    it's conceptually difficult。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: But let's look at more about what get attribute is doing。 Get attribute is actually
    looking at what is found in the class dict before it decides。 what to do when
    it's resolving what's in the class dict。 So if we create this class we'll call
    it probe ND。 And we put a method on here called dunder get。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: And dunder get returns just a little string that says this was hit。 And we put
    that into the class dict of my object。 And then we have an instance of my object。
    And we access o。z on that we don't get the probe ND object back。 We get the result
    of calling dunder get back。 However。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: if we put a value into the instance dictionary， in this case none， we get that，
    value back。 Just like get add。 However， if we add a dunder set method and do the
    same。 the behavior changes again。 So we put a dunder set method onto that probe
    ND。 we just inherit from it and make probe， dd， which is exactly the same but
    has dunder set。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: We put probe dd onto my object， create a new instance and go ahead and put into
    that instance。 dictionary and then access it and it is called despite the fact
    that that dictionary has a。 value for z in it。 Just for completeness， we'll take
    a look here and we'll make sure that dunder set is。 called as a set function。
    So this is the same probe dd， exactly the same。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: We'll go ahead and put none in as the value of z， except we'll set o。z equal
    to something。 And we can see here that the set function is now finally called
    and we can see that it。 does its print command and prints out set my object and
    something the value that it got。 And if we call o。z， we see that the get function
    still runs and if we check the dunder dicked。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: we see that it hasn't even been altered because once again I didn't write anything
    to change。 the dunder dicked。 So set is a set function。 It's called when we set
    on the left side。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9b78ecadbf81eb9828e4c03279b0041_14.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: So now we have our eight things。 The first three are we use resolutions of dunder
    in the dictionary。 So first we look in the instance dictionary， we look in the
    class dictionary， we look in。 the base classes dictionary。 Then items four and
    five are our dunder methods。 dunder get adder and dunder get attribute。 Then items
    six and seven are something that's called the descriptor protocol。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: dunder get， and dunder set and the eighth thing is that dunder get attribute
    raises an attribute error。 which we have surely seen enough times。 Of course this
    is not an order of precedence。 The order of precedence is that get attribute manages
    the whole thing and as we saw whether。 we have get and set on that descriptor
    makes quite a difference。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9b78ecadbf81eb9828e4c03279b0041_16.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: So let's take a look at the descriptor protocol。 Again this is initially included
    with Python 2。2's new style classes。 We know those in Python 3 as classes。 A descriptor
    has as many as four methods， dunder get， dunder delete and dunder set name。 starting
    in Python 3。6。 Dunder get is what's accessed when it's found in the class dictionary
    and to retrieve a。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: value on the right hand side， dunder set is what's used when you set a value
    to that class。 attribute on an instance。 Dunder delete is called when you delete
    from an instance and dunder set name a new in Python。 3。6 is used during class
    creation to let the descriptor know what class and what name it。 has been assigned
    to。 The signatures here for get。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: it gets an object which is the object that is the instance it's。 being called
    on and the class for set it only gets the instance and the value that's being。
    set and deleted only gets the instance。 That's because get can be called at the
    class level in which case the instance would be。 none。 The others are only at
    instance level。 There's two kind of sub-protacles here。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: If you only define dunder get an optionally set name you have a non-dated descriptor。
    That's why we had pro-bend。 If you define dunder get and dunder set or dunder
    get and dunder delete optionally set。 of course you have a dated descriptor。 If
    anyone's actually defining dunder delete for purposes please talk to me after
    I would。 like to know about that。 I have not found people implementing that other
    than out of a sense of completeness and obligation。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: It is there and it does work。 It absolutely works。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9b78ecadbf81eb9828e4c03279b0041_18.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: What is this for？ The biggest thing to understand is this is the only reason
    that instance methods work。 at all in Python。 Grid binding works entirely because
    of the descriptor protocol。 If we define a class， we put a method on a greeting
    and it prints high。 We go ahead and look at what greeting is in the class dictionary。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: We find it's a function and that doesn't surprise us。 If we look at that and
    we go hey I wonder if that has a dunder get on there we find that。 it does and
    that may or may not surprise us。 But now after going through the previous we'll
    understand that if we create an instance of。 greeter and we access greeting from
    it that dunder get is called， we get a different object。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: we get the return of dunder get and that is a method and that is what we can
    call。 That is exactly how we bind our methods both in Python 2 and 3。 They were
    called bound and unbound methods there。 So method binding uses it。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9b78ecadbf81eb9828e4c03279b0041_20.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: What else？ Obviously normal method binding。 Variant method binding is also going
    to use it。 This is how you do static methods。 This is how you do class methods。
    This is how properties work。 As soon as we go into frameworks， SQLAlchemy uses
    it。 Flask uses it in their config module。 If you start to try to get tricky there's
    a very good chance you will start using descriptors。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: as well as whatever else you're using。 Lazy execution， proxy and monitoring。
    runtime type checking is very likely to go into descriptors。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9b78ecadbf81eb9828e4c03279b0041_22.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: So let's pull up some examples。 Here's an alias descriptor。 Would you like to
    have two names for one attribute？ Sure， wouldn't we all？
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: I wrote this up as an example for this talk and then I found some code where
    I had to。 rename an attribute。 It didn't have time to go through all the call
    sites so I put it in there。 So this is a descriptor。 When it's created I give
    it the name of the other attribute that should always have the。 same value。 And
    that's stored as alias two and under init。 In under get。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: if instance is none it does something very common for descriptor。 It returns
    itself because it's being accessed at the class level。 Otherwise it does a get
    adder on the instance and the other attribute that it's aliasing。 If it's set，
    it does a set adder and it sets the value of that other attribute。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: So let's look at a class that uses it。 Name data class， not the new data classes。
    So data x， data y。 data z， they're all aliasing legacy x， legacy y， legacy z。
    The constructor is setting x， y。 and z into those old attributes。 So we'll go
    ahead and construct one with the values of high。 picon 2019。 So and check out
    the values。 So data x and legacy x are both high。 Legacy y is picon。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: That's exactly what we set。 And data z and legacy z are both 2019。 They are
    identical by its operator。 We change the value of data x。 We see the value of
    legacy x has changed exactly to match。 And that's exactly as we would expect。
    Everything else has stayed the same。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9b78ecadbf81eb9828e4c03279b0041_24.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: Let's look at a non-data descriptor example。 I told you they were good for messing
    with method binding。 So this is both a descriptor and a decorator。 That's a fairly
    common pattern。 So in this case。 it's a binding decorator because it's going to
    mess with method binding。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9b78ecadbf81eb9828e4c03279b0041_26.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: So sorry， didn't want to preview that。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9b78ecadbf81eb9828e4c03279b0041_28.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: So in init， we're going to get a function and we're going to store that function
    because。 it's a decorator。 And then when we do a get， either we will be given
    an object or not。 This goes to the function of this decorator。 This is handling
    class methods in a different way。 Probably not a good way， but a good way for
    this example。 What this is doing is saying， hey。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: if you don't have an instance of the class and you， call this method anyway。
    instead of causing an error about it， just construct one。 Use the default parameters
    and make an instance。 Why not？ Well， probably many reasons。 Why not？
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: But it's doable and in some cases may be adequate to make your process work。
    Again。 this is something you should think about before doing。 So in the case that
    object is none。 that means it's been called at the class level。 And you can see
    that it's creating a partial。 which is equivalent to binding， to bind a， newly
    created instance of the class to the function。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是可行的，在某些情况下可能足以使你的过程工作。再次强调，这是你在做之前应该考虑的事情。所以在对象为 none 的情况下，这意味着它是在类级别被调用的。你可以看到它正在创建一个部分，这相当于绑定，将新创建的类实例绑定到函数上。
- en: constructing it and passing it as， the first argument， which is， of course，
    self。 In the normal case where there's been an instance passed， it will simply
    call get normally using。 the function that it was given and being given the object
    and the class。 So name printer is another simple class。 It takes a name and has
    two functions。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将其构造并作为第一个参数传递，当然是 self。在正常情况下，传入一个实例时，它将简单地使用提供的函数正常调用 get，并传入对象和类。因此，name
    printer 是另一个简单的类。它接受一个名称并具有两个函数。
- en: name print and print name。 They are entirely identical except one is decorated
    with defaulted method。 The defaulted method decorator is defined before。 When
    we put a name on name printer。 we can see they work identically。 Andy。printName
    and Andy。namePrint， both printout and it's fine。 But if we call it at the class
    level， print name works because the decorator goes in， sorry。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: name print 和 print name 完全相同，除了一个是用默认方法装饰的。默认方法装饰器在前面定义。当我们在 name printer 上放置一个名称时，可以看到它们的工作方式是相同的。Andy.printName
    和 Andy.namePrint 都能正常输出，这没问题。但如果我们在类级别调用它，print name 就能正常工作，因为装饰器进入了，对不起。
- en: the descriptor goes in， hits its dunder get， notices that it's being called
    at the， class level。 constructs an instance， hits the initializer of name printer，
    uses the default。 value of name to go ahead and construct that instance。 And then
    print name is called on that and we get default name and that's fine。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符进入，触发它的 dunder get，注意到它在类级别被调用。构造一个实例，调用 name printer 的初始化器，使用默认的名称值来构造该实例。然后在其上调用
    print name，我们得到默认名称，这没问题。
- en: Or maybe not great but it works。 Name print is a normal instance method and
    you can't call those on a class level。 That is not allowed。 And we get our type
    error as we would。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 或许效果不是很好，但它是可行的。Name print 是一个普通的实例方法，你不能在类级别调用它们。这是不被允许的。我们会如预期那样收到类型错误。
- en: '![](img/d9b78ecadbf81eb9828e4c03279b0041_30.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9b78ecadbf81eb9828e4c03279b0041_30.png)'
- en: Well， the question would be what should we use and when？ These are like many。
    like really any meta programming technique， a class of things that， I call shovels。
    They're good for getting you out of holes。 But you don't want to use them too
    early because if you use a shovel too early。 you will find， yourself at the bottom
    of the hole with a broken shovel。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，问题是我们应该使用什么以及何时使用？这些就像很多，实际上任何元编程技术，是我称之为铲子的一类东西。它们适合于将你从困境中救出来。但你不想过早使用它们，因为如果你过早使用铲子，你会发现自己在洞底，手里还拿着一把坏铲子。
- en: Do not go and use these until you are sure that the benefit is worth the added
    complexity。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 不要去使用这些，直到你确定好处值得增加的复杂性。
- en: '![](img/d9b78ecadbf81eb9828e4c03279b0041_32.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9b78ecadbf81eb9828e4c03279b0041_32.png)'
- en: Breaking down the techniques shown and the different ways of accessing attributes。
    Here's how I would suggest looking at it。 Normal attribute access is of course
    what you should use as long as you possibly can。 And adder is particularly useful
    for caching lazy execution。 It works because once you've set a value it won't
    be called anymore。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 解析显示的技术和访问属性的不同方法。这是我建议的查看方式。正常的属性访问当然是你在可能的情况下应该使用的。而 adder 对于缓存惰性执行特别有用。它之所以有效，是因为一旦你设置了一个值，它就不会再被调用。
- en: Get attribute however is probably something you're going to have to do if you're
    proxying。 access to some unknown remote API that you'll never know what the methods
    are。 You simply want to intercept every access。 Non-data descriptors are fundamentally
    designed for method binding。 And data descriptors， a great example usage for that
    is runtime typing。 And with that。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你在代理访问一些未知的远程 API，可能会需要使用 get attribute，因为你永远不知道那些方法是什么。你只想拦截每一次访问。非数据描述符从根本上是为方法绑定而设计的。而数据描述符的一个很好的使用例子是运行时类型。至此。
- en: I will take some questions。 I will also be at the Bloomberg booth in the next
    break if anyone wants to talk about subjects。 raised here。 Please come up to this
    microphone to ask questions。 Hi， nice talk。 Could a descriptor be designed to
    not be able for the underlying object to be accessed？
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: For the underlying object not to be able to access。 What do you mean the underlying
    object？
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: I mean like you are creating data descriptor objects。 And typically in Python
    you can't have hidden attributes that can't be accessed from outside。 the object。
    Oh， the correct answer is no。 You could do some very weird hacks that inspected
    the stack in ways that you should never ever。 ever do。 But other than that， no。
    The descriptor still doesn't know who's calling it。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The descriptor still doesn't have any way to filter so some things could access
    it and。 some couldn't。 What you can do with the descriptor is change where the
    data is stored。 So you can use a descriptor and say this data is stored in a database。
    That's how SQLAlchemy works。 Like the fields in SQLAlchemy are fundamentally storing
    something in a database rather than。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: actually on the object。 Okay， thank you。 Can you tell me any good resources
    on how to use this when you pull in inheritance into。 the mix basically where
    you want to override the set the descriptors？
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: I thought there were some quirky things that happen in some cases， at least
    from my experience。 I was wondering if you have any good resources other than
    the documentation， I guess。 There shouldn't be anything particularly quirky。 I
    mean the descriptor is going to be attached and if you replace it。 you're going
    to be， replacing it with a new behavior for everything up and down the stack。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The biggest problem is if something previously accessed it as a normal attribute
    and then。 you put in some behavior that's fundamentally incompatible with that
    or you need it to be。 initialized in order。 So you do have that problem but that's
    depending on what you're doing with your descriptor。 Are there any other questions？
    Can you come on up？
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: And I think this will be the last one running out of time。 So I just wondered。
    the examples I've seen for data descriptors for their actual use， of them just
    in an academic sense。 so for validating or maybe manipulating a value that。 you
    supply to an attribute and you may change it to something， maybe， you know， coerce
    it。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: to a certain bounds or something like that。 Is there any other common scenarios
    we want to use data descriptors？
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Yeah， the typing case is a great case but again I'll suggest the SQLAlchemy
    case is。 another excellent case where you're saying what I want to do is actually
    store this value。 in a database or maybe I would like to put it in there。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9b78ecadbf81eb9828e4c03279b0041_34.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: Yeah， maybe I would like to do some additional monitoring so you could conceivably
    put in。 a data descriptor at a critical point and say I would like to have every
    time this value， changed。 write it out to my monitoring system so I don't have
    to put a log statement on。 I don't have to rely on anyone remembering that they
    have to record they change that， value。 Again。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，也许我想进行一些额外的监控，这样你可以在关键点插入一个数据描述符，并说我希望每次这个值变化时，都将其写入我的监控系统，这样我就不需要放置日志语句了。我不必依赖任何人记得他们必须记录这个值的更改。再次。
- en: you can control where the data goes。 That's another case for that。 Thank you。
    Okay。 well thank you very much。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以控制数据的去向。这是另一个例子。谢谢你。好的，非常感谢。
- en: '![](img/d9b78ecadbf81eb9828e4c03279b0041_36.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9b78ecadbf81eb9828e4c03279b0041_36.png)'
- en: '[APPLAUSE]， (applause)。'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]，（掌声）。'
