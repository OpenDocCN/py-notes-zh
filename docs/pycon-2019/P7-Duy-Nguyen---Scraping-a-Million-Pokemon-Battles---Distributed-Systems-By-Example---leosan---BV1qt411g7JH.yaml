- en: P7：Duy Nguyen - Scraping a Million Pokemon Battles - Distributed Systems By
    Example - leosan - BV1qt411g7JH
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P7：Duy Nguyen - 抓取百万场宝可梦战斗 - 以分布式系统为例 - leosan - BV1qt411g7JH
- en: '[APPLAUSE]， OK， great。 Good afternoon， everyone。'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]，好的，很好。大家下午好。'
- en: '![](img/2422877eee958c178c29c5664788cd9d_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2422877eee958c178c29c5664788cd9d_1.png)'
- en: This is great。 Looks like a full room Instagram celebrity status。 OK。 A little
    bit by myself。 my name is Dewey。 And I am not cool enough to have a Twitter handle。
    But that's my LinkedIn custom URL， PUGS rule。 So if you want to connect with me。
    go ahead and do that。 And if you're looking for a Bitly link， it's Bitly， PyCon，
    Pookie。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了。看起来像是一个完整的房间，Instagram名人状态。好的。稍微介绍一下我自己。我叫德威。我不够酷，没有Twitter账号。但这是我的LinkedIn自定义网址，PUGS至上。所以如果你想和我联系，随时来吧。如果你在找Bitly链接，那就是Bitly，PyCon，Pookie。
- en: '![](img/2422877eee958c178c29c5664788cd9d_3.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2422877eee958c178c29c5664788cd9d_3.png)'
- en: So pronounce my name。 It's like that with all the Es afterwards， Dewey。 And
    so currently。 I live in Boulder， Colorado， and I work as a software engineer at
    Google。 We-- he's awful products。 And I work on an organization known as Core
    Systems。 So it's like this horizontal infrastructure layer。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所以请你发音我的名字。就像后面有所有的E，德威。目前，我住在科罗拉多州的博尔德，并在谷歌担任软件工程师。我们——他的产品糟透了。我在一个叫做核心系统的组织工作。所以这就像一个横向基础设施层。
- en: I particularly care about gender equality and mentorship， in tech。 These are
    just areas that are very near and dear to my heart。 Before that， though。 I used
    to lead the data team， at an edtech startup in Boston， Elevation Education。 And
    then I left to travel the world。 I lived out of a suitcase for a year and a half。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我特别关心技术领域的性别平等和导师制度。这些都是我心中非常重要的领域。在此之前，我曾在波士顿的一家教育科技初创公司Elevation Education领导数据团队。然后我离开去环游世界。我一年半的时间都在用一个行李箱生活。
- en: and I bumped off friends。 And then I wandered from hustle to hustle。 But programming
    was still a passion of mine。 So something I continued to do。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我和朋友们断了联系。然后我从一个忙碌的工作跳到另一个忙碌的工作。但编程仍然是我的热情所在。所以这是我继续做的事情。
- en: '![](img/2422877eee958c178c29c5664788cd9d_5.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2422877eee958c178c29c5664788cd9d_5.png)'
- en: And I even continued a program in a rainforest， like here。 So I lived in that
    musty van for three weeks。 Surprise， it had access to Wi-Fi。 How's that for accommodation？
    And one of the projects I worked on while traveling。 was this idea I had about
    Pokemon。 So that's what we're going to be discussing today。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至在雨林中继续了一个项目，就像这里一样。所以我在那辆发霉的面包车里住了三周。惊喜，它有Wi-Fi。这样的住宿条件如何？而我在旅行时工作的一个项目是我对宝可梦的想法。所以今天我们要讨论的就是这个。
- en: Let's get into it。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: '![](img/2422877eee958c178c29c5664788cd9d_7.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2422877eee958c178c29c5664788cd9d_7.png)'
- en: So I really do love Pokemon。 I am not referring to Pokemon Go。 So I am referring
    to the classic handheld games。 And there's a site online where you can go。 and
    you can play other people online。 But one thing that I didn't love about it。 is
    that the community is not that welcoming to newer players。 So more experienced
    players。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的很喜欢宝可梦。我并不是在指宝可梦Go。我指的是经典的掌机游戏。网上有一个网站，你可以去和其他人玩在线游戏。但我不喜欢的一件事是，社区对新玩家并不是很欢迎。因此，更有经验的玩家。
- en: they actually， go through great lengths to hide their strategies。 It doesn't
    make sense。 There's precedence for this。 So if you know a monster moveset and
    their EV spread。 it becomes very formulaic about how you deal with it。 So if you
    told me you had physically offensive， setup， sweeper， mega-charsart X， there's。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 他们实际上花费了很大的精力来隐藏他们的策略。这没有道理。这是有先例的。所以如果你知道一个怪兽的移动方式和它的EV分布，处理起来就变得非常公式化了。所以如果你告诉我你有物理攻击型、设定型、终结型的超级喷火龙X，确实有。
- en: a very finite set of checks and counters for that Pokemon。 But still， this was
    not OK with me。 I thought that we should be better， supporting to our newer players。
    and we should be able to democratize that information。 And then one day。 I noticed
    that all of the battles do not， require authentication to look at them。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那个宝可梦，我有一个非常有限的检查和计数集合。但这对我来说仍然不够好。我认为我们应该更好地支持我们的新玩家，并且应该能够使这些信息民主化。然后有一天，我注意到所有的战斗都不需要认证就可以查看。
- en: And so here I am in the middle of a rainforest， and then I signed myself up
    for that free tier AWS account。 which， is ridiculous。 And then I started scraping
    all of their battles。 So that's what we're going to do today。 We're going to talk
    about this passion project of mine。 and use it to draw specific examples， so that
    we can better understand working。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我现在身处雨林中，然后我为那个免费的AWS账户注册。这真是荒谬。然后我开始抓取他们所有的战斗。这就是我们今天要做的。我们将讨论我这个激情项目，并用它来举例，以便更好地理解工作。
- en: with distributed systems， working， with microservice architectures in the cloud。
    I will mention that when it comes to--， I refer to this as the Shippert Systems
    102。 So at the bottom there， you can see that link for LVH's， distributed systems
    101 for PyCon 2015。 Disclaimer， it is an exceedingly technical talk。 However，
    I do want to continue that discussion。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，使用云中的微服务架构工作。当提到这一点时，我称之为Shippert Systems 102。在底部，你可以看到LVH的[分布式系统101](https://example.org)的链接，适用于PyCon
    2015。免责声明，这是一个极其技术性的演讲。然而，我确实想继续这个讨论。
- en: And today， I want to talk about how， can we maybe ground some of the concepts
    for working。 with distributed systems and make them more practical。 I want you
    to leave today and think， oh。 I'm working on this new design。 They're like， hold
    on。 I've seen this pattern before。 I've seen this problem before。 How can I reproduce
    this？
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我想讨论如何将一些概念与分布式系统结合，使其更具实用性。我希望你今天离开时会想到，哦，我正在进行这个新设计。他们会说，等一下。我以前见过这种模式。我以前见过这个问题。我该如何重现这一点？
- en: So that's how I break down with distributed systems。 Oftentimes。 teams will
    pursue distributed systems， because they care about scalability。 Maybe they want
    to scale compute。 They want to scale storage。 They want to even scale human resources。
    These all make sense。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我如何解析分布式系统。通常，团队会追求分布式系统，因为他们关心可扩展性。也许他们想扩展计算。他们想扩展存储。甚至想扩展人力资源。这些都说得通。
- en: A common way you do that is with concurrency。 However， there are non-trivial
    consequences。 So two。 that I'm going to call it right away。 One， holistically，
    the system just。 becomes more difficult to reason about。 And two， you have to
    come to grips。 with the fact that your system will now fail。 So how can we compensate
    for these two things？
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的方法是使用并发。然而，这会带来非平凡的后果。因此，我马上就要指出两个问题。首先，从整体上看，系统变得更难以推理。其次，你必须接受你的系统现在会失败的事实。那么我们该如何补偿这两点呢？
- en: So today， that's the framework that we're， going to be working with。 We're going
    to be talking about distributed systems。 I'm going to show you how we can achieve
    the concurrency。 while also providing techniques for compensating for this。 How
    do we assert the correctness of our system？ In other words。 how do we test our
    distributed system？ And at the same time， how do we build in resilience。 against
    failures？ OK， so oftentimes， when we're talking about these technical， presentations。
    it's helpful to start， with an architecture overview。 On the right side here。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，这就是我们要使用的框架。我们将讨论分布式系统。我将向你展示如何实现并发，同时提供补偿技术。我们如何断言系统的正确性？换句话说，我们如何测试我们的分布式系统？同时，我们如何建立对故障的韧性？好的，通常在讨论这些技术演示时，先从架构概述开始是有帮助的。在右侧。
- en: this is what a Pokemon battle looks， like。 So as you might imagine， there are
    two players。 They have their respective teams， and they're battling each other。
    This is， yeah， Shift Gear。 Magina， and Spex Ash Greninja。 So it's actually all
    open source。 So that's also how this made it a lot easier， to reverse engineer。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是宝可梦战斗的样子。正如你想象的那样，有两个玩家。他们有各自的队伍，并且正在互相对战。这是，是的，Shift Gear、Magina和Spex Ash
    Greninja。所以这实际上都是开源的。这也是如何让反向工程变得容易的原因。
- en: So if you go take a look at their GitHub page， it turns out that the web UI，
    it's。 communicating with the server using this text protocol， that resembles a
    domain-specific language。 If you spend enough time looking at that text protocol，
    and you're able to replay all the logs。 you can exactly replicate the state of
    the battle。 OK， so now I started thinking， well。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你去查看他们的GitHub页面，事实证明，网络用户界面正在使用一种文本协议与服务器通信，这种协议类似于一种领域特定语言。如果你花足够的时间查看该文本协议，并能够重播所有日志，你就可以准确重现战斗状态。好的，现在我开始思考。
- en: what if I just create a little bot， and a bot just sat on the page。 and then
    when the battle was done， it just scrapes all the battle logs from the DOM。 It's
    like， oh。 that seems pretty reasonable to me。 But that only gets us one battle。
    How do we get all the battles？
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我创建一个小机器人，让它在页面上待着，然后当战斗结束时，它就从DOM中抓取所有战斗日志。哦，这对我来说似乎很合理。但这只得到一场战斗。我们怎么才能获得所有战斗呢？
- en: On the left side， if you go to the main chat room， there's this list of battles。
    It's something like the most recent 10 or 20 battles or so。 The reason they have
    this feature is maybe you're visiting， the site。 and you want to spectate on a
    battle， you can go check out those。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，如果你去主聊天室，会有这个战斗列表。大概是最近的10个或20个战斗。他们有这个功能的原因是，可能你正在访问这个网站，想要观看一场战斗，你可以去查看这些。
- en: It only shows the most recent 10 or 20 or so。 But that's not really a problem
    when it comes to programming。 I figured if we have a process that's， on a tight
    enough loop， then we could definitely。 collect all of those URLs without any gaps
    in them。 And then that way we would have all the battles。 on the entire site。
    So now we have a way to download the logs for a single battle。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它只显示最近的10个或20个。但在编程时，这并不是问题。我想，如果我们有一个足够紧凑的循环过程，那么我们绝对可以在其中没有任何间隙地收集所有这些URL。这样我们就能拥有整个网站上的所有战斗。所以现在我们有办法下载单场战斗的日志。
- en: and replicate the exact state。 And we have a way to get every single battle
    on the website。 And a link， if you want to play， is at the bottom。 So I implemented
    this using Python。 and they were on Docker containers in EC2。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 并复制确切状态。我们有办法在网站上获取每一场战斗。如果你想玩，链接在底部。所以我用Python实现了这一点，他们在EC2的Docker容器中。
- en: '![](img/2422877eee958c178c29c5664788cd9d_9.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2422877eee958c178c29c5664788cd9d_9.png)'
- en: But a bit higher level。 So this is the flow of the system。 So starting from
    the upper left， we。 have this component that watches the list of rooms， gets all
    of the battles。 And then as it scrapes those URLs， it pushes it onto an SQS queue。
    Then there is this some form of download bots， that will slowly pop work off this
    queue。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是一个更高层次的概念。这是系统的流程。从左上角开始，我们有一个组件监视房间列表，获取所有战斗。当它抓取这些URL时，它会将其推送到SQS队列中。然后有一些下载机器人会慢慢从这个队列中取出工作。
- en: and then sits on the battle， waits for the battle to finish， and then scrapes
    the battle logs。 The battle logs are persisted in S3。 I also had a lambda function
    that。 would be triggered on S3 puts。 And then every time there's a new blob there。
    it's going to index it in a last cache。 Yes， when you're unemployed， you have
    so much time。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它坐在战斗上，等待战斗结束，然后抓取战斗日志。战斗日志保存在S3中。我还有一个lambda函数，会在S3存放时触发。每次有新对象时，它会在最后缓存中进行索引。是的，当你失业时，你有很多时间。
- en: So much time。 OK， so for today， we're going to really focus in， on that left
    column。 So the component that watches for all the battles on the site。 it putting
    all the work onto the queue， and then a form of bots downloading those battles。
    Oops。 OK。 so take a look here。 This is the code snippet that we're going to be
    working with。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 时间真多。好的，今天我们要真正专注于左侧那一列。这个组件负责监控网站上的所有战斗。它把所有工作放到队列中，然后一种机器人从队列中下载那些战斗。哦，好的。来看这里。这是我们要处理的代码片段。
- en: I hope it's not inspiring code to anybody。 Pretty straightforward。 We have a
    roomless watcher。 It scrapes for all the battles， and it gets a list of URLs。
    We iterate through the URLs。 and then we serially download them。 This was great
    for an MVP， but then I quickly already。 ran into problems。 Already， in my head，
    I wasn't able to keep track。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这段代码对任何人来说都不是启发。相当直接。我们有一个无房间的监视器。它抓取所有战斗，获取URL列表。我们遍历这些URL，然后按顺序下载。这对MVP来说很好，但我很快就遇到了问题。我的脑海中，已经无法跟踪。
- en: of everything that was going on。 Sometimes I'm working on the bot that's just
    downloading。 the battle， and then I forget， maybe， do I need to do some special
    authentication， for SQS here。 or do I need some special retry logic， when I'm
    working with the roomless watcher？
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 了解所有正在发生的事情。有时我在处理只下载战斗的机器人，然后我忘记，或许，我需要为SQS做一些特殊的身份验证，或者在使用无房间监视器时需要一些特殊的重试逻辑吗？
- en: I always had to keep the whole breadth of the application， in my mind at the
    same time。 People here who are working with microservice architectures， you can，
    I think。 already picking up on the language here。 When the application grows too
    big to fit into your head。 this is often a good time that we should decompose
    our application。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是必须在脑海中同时保持整个应用的广度。在这里与微服务架构合作的人，你们可以，我认为，已经开始理解这里的语言。当应用程序变得太大，无法容纳在你的脑中时，这通常是我们应该拆解应用程序的好时机。
- en: There's more that we can push this， because the download bot。 it just wasn't
    achieving the throughput， that I wanted。 So these were all these indicators。 that
    I thought， OK， maybe this is time。 This maybe I should start to make this into
    a distributed。 system to get the scale that I want。 On the left side there， this
    is how I view it。 So I saw， OK。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更进一步，因为下载机器人没有达到我想要的吞吐量。这些都是我认为，好的，也许是时候了。这可能是我该开始将其转变为一个分布式系统，以达到我想要的规模。在左侧，这就是我的视角。所以我看到了，好的。
- en: the roomless watcher， the download bot， they achieved some type of business
    logic。 Whereas the URLs in the middle， this is just state。 This is just data。
    So we have components that。 when we talk about them， they get highlighted as some
    type of component。 We have a roomless watcher。 We have a queue that holds state。
    We have a download bot。 And in addition。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 无房间的观察者、下载机器人，它们实现了一种业务逻辑。而中间的URLs，这只是状态。这只是数据。所以我们有组件。当我们谈论它们时，它们会被突出显示为某种组件。我们有一个无房间的观察者。我们有一个保持状态的队列。我们有一个下载机器人。此外。
- en: there's a separation between business logic， and state。 This was not quite persuasive
    enough for me。 though。 And so I started to take a look at how my different components
    differ。 in terms of rate of work， specifically magnitude。 That's a mouthful。 Let's
    unpack it。 OK。 so the roomless watcher。 So I'm using Selenium as the web automation
    framework。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在业务逻辑和状态之间有一个分离。这对我来说还不够有说服力。因此，我开始查看我的不同组件在工作速率，尤其是数量级上的差异。这话有点多。让我们来深入探讨一下。好的，所以无房间的观察者。我在使用Selenium作为网页自动化框架。
- en: So once you've initialized the page， let's say that takes on the magnitude of
    three seconds。 or something like that， it's fine。 We have the page open。 But you
    see that refresh button in the upper left in the red rectangle？
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所以一旦你初始化了页面，假设这需要大约三秒钟，或者类似的时间，这没问题。我们打开了页面。但你看到左上角红色矩形中的刷新按钮了吗？
- en: It turns out that the list of the most recent 10 or 20 battles。 you can refresh
    it with just a simple async call。 So now that means that the magnitude， once you've。
    initialized the page， is actually on the magnitude of only 300 milliseconds。 So
    that's pretty fast。 That's like， acceptably fast。 But the download bot， it's very
    different。 It's much more erratic。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，最近10或20场战斗的列表，你可以通过简单的异步调用刷新。因此，这意味着，一旦你初始化了页面，其时间实际上只有300毫秒。所以这非常快，接受的速度。但下载机器人则非常不同，变化很大。
- en: Let's say that， I don't know， you and I were battling。 And then it might be
    that once it soon begins to the battle， I have to DC。 I have to disconnect because
    whatever my girlfriend says， we have to go eat dinner or something。 So the battle
    could just take two seconds。 But maybe in some other situations。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，你和我在对战。然后一开始战斗时，我必须断开连接。因为我女朋友说，我们必须去吃晚饭。所以这场战斗可能只需要两秒钟。但也许在其他情况下。
- en: the battle could take 45 minutes because both players brought stall。 And by
    stall。 what that means is you bring fat mons， mons， like Chan C or Venusaur or
    Clefable。 These Pokemon that have really high HP stats， and just take forever
    to wear down。 So yeah。 a battle could take 45 minutes。 But now that we've seen
    that there's a difference in responsibility。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这场战斗可能需要45分钟，因为两个玩家都带了防守。而“防守”意味着你带上高耐久值的宝可梦，比如胖丁、妙蛙种子或皮可西。这些宝可梦的HP非常高，耗时极长才能打败。所以是的，一场战斗可能需要45分钟。但现在我们看到责任之间存在差异。
- en: there's a different in the type of components， business logic or state。 And
    there's also a very significant different in how the rates of work， are operating。
    We're talking magnitudes of difference。 So this was the evidence that I needed。
    So I understood the characteristics of my system。 So you start by analyzing the
    characteristics of your system。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件类型、业务逻辑或状态之间存在不同。而且在工作速率上，也有非常显著的差异。我们谈论的是数量级的差异。这是我所需要的证据。所以我了解了系统的特征。所以你从分析系统的特征开始。
- en: And now this is when we can decompose the application。 You've probably seen
    the diagram a million times。 But you take this monolith。 which is like a blob
    of colors， and then you break it into subcomponents。 And that's basically what
    I did here。 I partitioned the application along these responsibilities。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们可以分解应用程序的时候。你可能已经看过这个图表无数次。但是你把这个单体应用，像一块色彩斑斓的块状物，然后将其拆分成子组件。这基本上就是我在这里所做的。我根据这些责任将应用程序进行了分区。
- en: And another phrase you might hear is， to draw seams through the application。
    So we've analyzed the characteristics of the system。 We've seen where would be
    appropriate to partition， along responsibilities。 And now what can we do？
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会听到另一个短语，就是在应用程序中划分边界。因此我们分析了系统的特性，看看在哪些地方可以适当地进行责任分区。现在我们能做什么呢？
- en: Well， now we can layer on top of this a model of concurrency。 OK。 On the left
    side。 what you can do is we， can have producers on the left side。 And maybe there's
    a main thread。 and it spins off， one to end child threads for the rimless watcher。
    On the right side there are some consumers。 And the same thing， maybe one to end
    child threads。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在我们可以在此基础上加上一个并发模型。好的。在左侧，我们可以有生产者。而也许有一个主线程，它会产生一个或多个子线程供无边界监视器使用。在右侧是一些消费者。同样，也许是一个或多个子线程。
- en: for these download bots。 Between them， they communicate on some thread safe
    queue。 We have this in the standard library。 It's q。q。 So this is the model of
    computation that I'm using here。 Producers on the left side， consumers on the
    right side。 communicating over a thread safe message queue。 At the bottom there，
    I draw a link to Raymond。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些下载机器人，它们之间在某个线程安全的队列上进行通信。我们在标准库中有这个。它就是 `queue`。所以这是我在这里使用的计算模型。左侧是生产者，右侧是消费者，通过线程安全的消息队列进行通信。在底部，我画了一个指向
    Raymond 的链接。
- en: Headinger's fantastic talk from PyCon Russia 2016。 If you haven't seen it， I
    strongly。 recommend that you do specifically， if you're getting started working
    with concurrency。 or you just need a refresher。 I would strongly argue this is
    the must-have first go-to talk。 Absolutely。 So he starts by positing that--， and
    I paraphrase it at the top there--。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Headinger 在 2016 年 PyCon Russia 的精彩演讲。如果你还没看过，我强烈建议你去看看，尤其是如果你刚开始接触并发编程，或者你只是需要温故知新。我认为这是必须观看的首个演讲。绝对如此。他开始时假设——我在上面进行了改述——。
- en: unless you're implementing an operating system， you should strongly favor using
    higher level primitives。 such as thread safe message queues。 And in this case，
    it would be q。q for Python。 He also includes something called Raymond rules。 And
    these are rules of thumbs。 These are best practices for working with concurrency。
    And some of them， it's not like， hey。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你在实现操作系统，否则你应该强烈倾向于使用更高级的原语，比如线程安全的消息队列。在这种情况下，它是 Python 的 `queue`。他还包括了一些被称为
    Raymond 规则的内容。这些是经验法则，是处理并发的最佳实践。其中一些并不是说，嘿。
- en: maybe you should， follow this if you feel like it。 It's really， if you don't
    follow these rules。 your algorithm is simply not correct。 So I strongly recommend
    thinking about concurrency。 by Raymond Heideger。 This gave us throughput， right？
    So on the right side there， if I wanted to。 I could more or less achieve linear
    scalability。 If I double or quadruple the number of download bots。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你应该遵循这个，如果你愿意。其实，如果你不遵循这些规则，你的算法根本不正确。所以我强烈建议考虑并发。根据 Raymond Heideger 的观点。这给了我们吞吐量，对吧？所以在右侧，如果我想，我可以或多或少地实现线性扩展。如果我将下载机器人的数量加倍或四倍。
- en: I will double or quadruple the throughput of that right side。 If， again。 for
    those of you who have experienced working， microservice architectures， you notice
    a problem。 And that's the state in the middle。 So if we're working in the cloud。
    you need to assume a node is going to drop。 It's not like maybe it's going to
    drop。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果再一次，对于那些有微服务架构经验的人，你会注意到一个问题，那就是中间的状态。所以如果我们在云中工作，你需要假设某个节点会掉线。这并不是说可能掉线。
- en: but it will definitely drop eventually， maybe， through maintenance， or maybe
    just through。 I don't know， a free storm and somebody trips over the power wire。
    If I had something like 100。000 URLs in that queue， what happens to those？ Do
    they just all disappear？
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但它最终肯定会掉线，也许是通过维护，或者只是因为我不知道，某个自由风暴导致有人绊倒了电源线。如果我在那个队列中有大约 100,000 个 URL，那它们会发生什么？它们会全部消失吗？
- en: And I just lose all those URLs。 So that's not good enough。 However。 because
    we've partitioned the application， because we've decomposed into smaller sub-compliance。
    we can swap it out really quickly。 So instead of just having Q。Q-- so instead
    of just having Q。Q。 you can swap it out for an SQS queue。 And this was a really
    easy solution。 All of a sudden。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我失去了所有这些 URL。所以这并不够好。不过，因为我们对应用进行了分区，因为我们将其解构为更小的子合规性，我们可以快速进行替换。因此，除了仅仅有
    Q。Q——你可以用 SQS 队列替换它。这是一个非常简单的解决方案，突然间。
- en: by swapping out that component， I achieved this rich feature set of cloud services。
    the message durability， the scalability， the instrumentation。 You just get that
    out of the box。 But that's only possible because beforehand， we've analyzed the
    characteristics of our system。 we've decomposed it properly， and we're focusing
    on not， like these implementation details。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过替换那个组件，我实现了丰富的云服务功能集，包括消息持久性、可扩展性和监控。这些都是开箱即用的。但这只有在我们事先分析了系统特性，适当地进行解构，并专注于这些实现细节之外的东西时才有可能。
- en: but how do we compose the problem？ How do we orchestrate the work？
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何组合问题？我们如何协调工作？
- en: I'm going to push this analogy a little further。 Take a look at Go。 So in Go。
    concurrency is a first class citizen。 So what that means is that concurrency。
    was a conscious decision to include， into the language specification。 It's not
    implemented as a library， think async。io， which is implemented as a library。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我要进一步推动这个类比。看看 Go。在 Go 中，并发是一个一流的公民。这意味着并发是一个经过深思熟虑的决定，纳入了语言规范中。它不是作为一个库实现的，想想
    async.io，它是作为一个库实现的。
- en: But concurrency is part of the runtime。 That gives us three constructs--， Go
    routines， channels。 and selects。 I'm just going to talk about Go routines and
    channels today。 And so this is how the analogy plays out。 So if I want to do the
    same solution and go。 on the left side， maybe I'll launch one to end Go routines，
    to watch that list of new battles。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但是并发是运行时的一部分。这给我们提供了三种构造——Go 协程、通道和选择。今天我只会讨论 Go 协程和通道。这就是类比如何展开。如果我想用 Go 实现同样的解决方案，也许我会启动一个
    Go 协程来监视那一系列新的战斗。
- en: On the right side， maybe I'll launch one to end Go routines， to download the
    battles。 And in the middle， they still need to communicate。 How do I get the work
    from the producers to the consumers？ So in Go。 we have a construct called channels。
    And channels， what you do is from one side。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，也许我会启动一个 Go 协程来下载战斗。在中间，它们仍然需要通信。我该如何将工作从生产者传递给消费者？在 Go 中，我们有一种称为通道的构造。在通道中，你所做的是从一侧开始。
- en: you can send in work or messages。 And from the other side， you can receive that
    work。 I want to point out that across all three of these examples， whether it
    be Python or AWS or Go。 three technologies that were written by three different
    teams， and written across multiple decades。 they all arrive at the same solution。
    So the reason for that is because we're not focusing。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以发送工作或消息。从另一侧，你可以接收这些工作。我想指出，在这三个示例中，无论是 Python、AWS 还是 Go，这三种由不同团队编写并跨越数十年的技术，最终都得出了相同的解决方案。原因在于我们没有专注。
- en: on small implementation details， but we're focusing on how we are composing
    our components。 How are we orchestrating the work？ And that's what I urge you
    to focus on as well。 Same solution。 three different technologies。 So that's great。
    And now I have the scalability in my system。 and I'm able to download like， you
    know， hundreds of thousands of Pokemon battles。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在小的实现细节上，但我们专注于如何组合我们的组件。我们如何协调工作？这也是我希望你们关注的。同样的解决方案，三种不同的技术。这很好。现在我的系统具有可扩展性，我能够下载成千上万的
    Pokémon 战斗。
- en: and it's a really good time， but I have no idea if it actually works。 So it
    introduces several problems。 Loss of determinism， let's say I had five URLs in
    the queue。 well， on one run of the test， maybe I get through all five， and the
    work is processed sequentially。 That's great。 On the next run of the test， I might
    only get halfway through。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常好的时机，但我不知道它是否真的有效。这引入了几个问题。失去确定性，假设我在队列中有五个 URL。在一次测试中，也许我能处理完这五个，工作是按顺序处理的。这很好。但在下一次测试中，我可能只能完成一半。
- en: and maybe the order is scrambled。 In exchange for the concurrency。 you give
    up the predictability of the system。 We also have longer startup times。 starting
    up an in-memory queue that is trivial， starting up an SQS resource。 that could
    take on the magnitude of minutes。 That's something to think about。 And in addition。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 也许顺序被打乱了。为了换取并发性，你放弃了系统的可预测性。我们还有更长的启动时间。启动一个内存队列是微不足道的，而启动一个 SQS 资源可能需要几分钟的时间。这是值得思考的。此外。
- en: everything， my processes are now in different memory spaces， maybe they're on
    different nodes。 and all of a sudden we've introduced flakiness。 I could have
    a network partition。 I have to deal with loss of availability， for dependent services。
    When we have these types of problems， we still can handle them。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都在不同的内存空间中，我的过程可能在不同的节点上。突然间，我们引入了不稳定性。我可能会有网络分区。我必须处理可用性丧失的问题，针对依赖服务。当我们遇到这些问题时，我们仍然可以处理它们。
- en: but they all revolve around this problem， of how do I deal with these external
    dependencies？
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们都围绕着这个问题展开，我如何处理这些外部依赖？
- en: Let's get aligned on terminology really quickly。 So I wanna talk about mocks
    and fakes。 So with mocks， mocks are these objects， that we can just extend， shan，
    on demand。 you interact with them， and then afterwards you can introspect them。
    to understand the history of the interactions。 We can understand who called you。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速统一一下术语。我想谈谈 mocks 和 fakes。 mocks 是这些对象，我们可以根据需要扩展它们，你与它们交互，之后你可以 introspect
    它们，以了解交互的历史。我们可以理解是谁调用了你。
- en: how many times were you called， with what arguments were you called？ Fakes are
    a bit different。 So with fakes， they should be able to serve， as drop-in replacements
    for the real resource。 This means that they fulfill two criteria。 One， they have
    to implement the same interface， and two。 they have to guarantee the same， invariances
    as the real resource。 For example。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你被调用了多少次，使用了什么参数？ fakes 有些不同。对于 fakes，它们应该能够作为真实资源的替代品。这意味着它们需要满足两个标准。第一，它们必须实现相同的接口；第二，它们必须保证与真实资源相同的不变性。例如。
- en: if for whatever reason， I was trying to implement a fake queue， well。 there
    has to be a way for me to put， and pull work from that queue。 In addition。 if
    the original queue were FIFO， I can't suddenly have a fake queue。 that does not
    maintain stored order。 That would break one of the invariances。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果因为某种原因，我试图实现一个假的队列，那就必须有一种方法让我从那个队列中放入和提取工作。此外，如果原始队列是 FIFO，我不能突然有一个不保持存储顺序的假队列。这将破坏其中一个不变性。
- en: So how did these come into play？ I'm gonna talk about， so testing external dependencies。
    I will say so， yeah， so currently I work at Google， and the complexity and scale
    of Google。 it is mind-boggling， and it's surprising， that testing external dependencies。
    is a challenge we deal with on a day-to-day basis。 It is that technical， it is
    that overwhelming。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 那这些是如何发挥作用的？我将谈谈测试外部依赖。我会说，目前我在谷歌工作，谷歌的复杂性和规模令人震惊，测试外部依赖是我们每天面临的挑战。它是如此技术性和压倒性。
- en: I'm gonna break this down into three different segments。 I'm gonna talk about
    how I tested。 external dependencies in my Pokemon project， how Google subscribes
    for testing external dependencies。 and how I think we as a Python community should
    do it。 All three， actually。 are our different answers。 So for me， so I went with
    fakes。 Keep in mind。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把这个分解成三个不同的部分。我将讨论如何在我的 Pokemon 项目中测试外部依赖，谷歌如何订阅测试外部依赖，以及我认为作为一个 Python 社区我们应该怎么做。实际上，这三个都是我们不同的答案。所以对我来说，我选择了
    fakes。请记住。
- en: I had no steady income and no job， and I was living in a rainforest。 and hitchhiking
    to get everywhere， so if I went past that AWS free tier， that would not be okay。
    I have no money。 So that's why when I did my testing， I really wanted to prefer
    something。 that was a bit more realistic。 Fakes give you that。 Fakes are a little
    bit more realistic。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有稳定的收入和工作，生活在热带雨林中，靠搭便车到处走，所以如果我超过了 AWS 免费套餐，那可不行。我没有钱。因此，当我进行测试时，我真的想选择一些更现实的东西。
    fakes 可以满足这个需求。 fakes 更加现实。
- en: but they cost developer time。 That's okay， I have tons of time。 I have nothing
    to do on a day-to-day basis。 So that's why I preferred fakes， I needed the realism。
    and I was willing to trade the developer time。 What do we do at Google？ At Google。
    we have this document， it's actually linked to the bottom， don't bother clicking
    on it。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们会消耗开发者的时间。这没关系，我有很多时间。我在日常生活中没什么事可做。这就是为什么我更喜欢使用假数据，我需要现实感。我愿意以开发者时间为代价。我们在谷歌做什么？在谷歌，我们有这份文件，实际上链接在底部，别去点它。
- en: it doesn't go anywhere， you don't have access to it。 But at Google。 we prefer
    using the real resources。 The reason for that is at Google。 saving developer time
    is paramount。 Just full stop saving developer time。 that's what we need to be
    doing。 And what are we willing to trade in exchange？
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有任何用途，你无法访问它。但在谷歌，我们更喜欢使用真实资源。原因是，在谷歌，节省开发者时间是最重要的。简单来说，就是节省开发者时间。这是我们需要做的。那么我们愿意以什么交换呢？
- en: Let's say that you have some tests that runs， and then you need to start up
    a Spanner instance。 that's fine， just start up a real Spanner instance。 If you
    need 1，000 of them， that's fine。 just start up 1，000 Spanner instances。 And I
    put the word they're computationally expensive。 What I mean by that is， if you
    wanna use the real resources， I can't sit here and wait for 1。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一些测试在运行，然后你需要启动一个 Spanner 实例。这没关系，只需启动一个真实的 Spanner 实例。如果你需要 1,000 个，那也没关系。就启动
    1,000 个 Spanner 实例。我提到它们在计算上是昂贵的。我的意思是，如果你想使用真实资源，我不能在这里等着启动 1。
- en: 000 Spanner instances to start up。 We just can't do that， seriously。 So what
    do we have to do？
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 1,000 个 Spanner 实例。我们真的做不到，认真地说。那么我们该怎么办？
- en: We have to bring them all up at the same time。 If you have a server farm as
    large as Google。 that is possible。 Now that does take way longer， but ultimately
    because Google is trying to save developer time。 we're willing to make those trade-offs。
    We're willing to use the real resources。 How about us as a community？ So over
    at the Instagram team， Mike Greager， the CEO and co-founder。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须同时启动所有这些。如果你有一个和谷歌一样大的服务器群，这就是可能的。现在这确实需要更长的时间，但最终因为谷歌试图节省开发者时间，我们愿意做出这样的权衡。我们愿意使用真实资源。作为一个社区，我们怎么样？在
    Instagram 团队，首席执行官兼联合创始人 Mike Greager。
- en: he mentions how， and this was a talk at Airbnb， maybe from， I don't know， 2015
    or something。 but one of the engineering philosophies over at Instagram， is do
    the simple thing first。 There's no question that will definitely fail one day，
    right？ But that's fine。 And to that point。 just do the next simplest thing。 In
    practice， what that means is I really believe that we as a Python community。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 他提到，这是一场在 Airbnb 的演讲，可能是在 2015 年或其他时候。但 Instagram 的工程哲学之一是优先做简单的事情。毫无疑问，这样做最终肯定会失败，对吧？但这没关系。对此，做下一个最简单的事情。在实践中，我真的相信我们作为一个
    Python 社区。
- en: when we're working with distributed systems， and we have all these external
    dependencies。 I believe that our default should be to start with Mox。 Now， Mox
    are fast， they're lightweight。 they're easy to reason about。 And most importantly，
    if you're a newer developer。 let's say you have an undergrad right out of college，
    it's okay。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在处理分布式系统，并且有所有这些外部依赖时。我相信我们的默认选择应该是从 Mox 开始。现在，Mox 是快速的，它们轻量且易于理解。最重要的是，如果你是一个新开发者，比如刚大学毕业的本科生，那也没关系。
- en: they could spend a day reading through the source docs， or maybe a couple days。
    but they will be able to get started， rather quickly。 And that has real tangible
    benefits。 There are drawbacks， it's the furthest from production， right？ And in
    addition。 you get some issues with interface drift。 Anything you throw at a mock
    is gonna work。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 他们可以花一天时间阅读源文档，或者可能几天。但他们能够很快开始。这有真实的切实好处。虽然有缺点，但它离生产环境最远，对吧？而且，接口漂移也会有一些问题。你扔给
    mock 的任何东西都会有效。
- en: So there are some problems with that， but I would still argue that the benefits
    of mocking in this scenario。 are well worth it。 So again， to summarize， I decided
    to go with fakes， because I needed the realism。 Google prefers to use the real
    resources， because they have oodles of money。 And then we as a Python community，
    I strongly believe， that we should just focus on Mox。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这有一些问题，但我仍然认为在这种情况下使用假数据的好处是值得的。因此，总结一下，我决定使用假数据，因为我需要现实感。谷歌更倾向于使用真实资源，因为他们有很多钱。而我们作为一个
    Python 社区，我坚信我们应该专注于 Mox。
- en: It's the simplest solution。 Good enough is good enough。 So what do we have here？
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的解决方案。足够好就好。那么我们这里有什么？
- en: So now we have this Pokemon application。 It's out， we have all these bots everywhere。
    and they're downloading tons of battles。 And we also know it's correct。 So I know
    that I'm not just burning through EC2 instances。 However， it fails all the time
    now。 The system is just getting big enough， that it fails purely through coincidence。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有这个宝可梦应用程序。它已经发布，我们在各处都有这些机器人，并且它们正在下载大量战斗记录。我们也知道这是正确的。所以我知道我并不是在无节制地消耗EC2实例。然而，现在它总是失败。系统变得足够庞大，纯粹因为巧合而失败。
- en: So we need some way to figure out that， how can we build in resilience against
    this failure？
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们需要某种方式来弄清楚，如何建立对这种失败的弹性？
- en: There is a 。NET C# framework called Poly。 Don't let me lose you。 I'm not going
    to talk about C#。 (laughs)， The reason that I found it is just that， the way that
    if you go to their GitHub page。 I link it at the bottom， the way that they help
    you digest the problem is fantastic。 If you're thinking about like， oh， I've got
    the system and it just keeps failing。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为Poly的.NET C#框架。别让我失去你。我不会谈论C#。（笑）我发现它的原因仅仅是，如果你去他们的GitHub页面。我在底部链接的方式，他们帮助你消化问题的方式非常棒。如果你在想，哦，我有这个系统，它就是不停地失败。
- en: And there are so many policies out there。 I'm sure you've heard of districts
    over at Netflix。 They have the circuit breaker pattern。 And you're thinking like。
    I don't even know when I use a circuit breaker， or when I use fallbacks or when
    I use retries。 The way that Poly describes the problem space， is really helpful
    to think about。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 外面有很多政策。我相信你听说过Netflix的那些区域。他们有断路器模式。你可能会想，我甚至不知道什么时候使用断路器，或者什么时候使用后备方案，或者什么时候使用重试。Poly对问题空间的描述方式，真的很有助于思考。
- en: So here's an example of what they'll do。 They'll have this like little witty
    saying。 on the right side like， "Don't wait forever。"， Or maybe it's just a blip。
    So now I'm going to show you how I use， timeout retries and fallbacks in my Pokemon
    project。 to make sure it's resilient。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是他们所做的一个例子。他们会在右侧放一个小俏皮话，比如“别等太久。”，或者这可能只是一个闪烁。因此，现在我将向你展示我如何在我的宝可梦项目中使用超时重试和后备方案，以确保它的弹性。
- en: '![](img/2422877eee958c178c29c5664788cd9d_11.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2422877eee958c178c29c5664788cd9d_11.png)'
- en: So starting off， this is the easiest part， right？ On the download bot， when
    you get to a battle。 it doesn't mean that the battle's immediately completed。
    I mentioned earlier that it could be going on， for 45 minutes。 So using the Selenium
    Web Automation Framework， this is what it looks like。 You can see on line two。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所以开始时，这部分是最简单的，对吧？在下载机器人上，当你进入战斗时，这并不意味着战斗马上就结束了。我之前提到过，它可能会持续45分钟。所以使用Selenium
    Web自动化框架，它的样子就是这样。你可以在第二行看到。
- en: it says element to be clickable。 So that's the condition that I'm waiting for。
    I'm waiting for that download button， on the bottom right to be done。 because
    that tells me that the battle logs in the DOM， are ready to be scraped。 That's
    the element。 That's the checkpoint that I'm waiting for。 So this one's pretty
    simple， right？
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它说要可点击的元素。所以这是我在等待的条件。我在等待右下角的下载按钮完成，因为这告诉我，DOM中的战斗日志已经准备好可以抓取。这就是我在等待的元素。这是我在等待的检查点。所以这个相对简单，对吧？
- en: I just have this at the smallest unit。 I have my download bot and I say， hey，
    go to that page。 check it out for three seconds or so。 And if you don't see anything，
    let's just wait a while。 It's probably not ready yet。 So time out， that's pretty
    simple。 At the same time。 it's not good enough。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我把这个设定在最小单元。我有我的下载机器人，我说，嘿，去那个页面。检查大约三秒钟。如果你什么都没看到，那我们就等等。它可能还没准备好。所以超时，这个很简单。同时，这还不够好。
- en: '![](img/2422877eee958c178c29c5664788cd9d_13.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2422877eee958c178c29c5664788cd9d_13.png)'
- en: So all these different external dependencies， and most importantly， the Chrome
    Web Driver。 So the Chrome Web Driver is implemented using， something called the
    gang of four command pattern。 It's a very cool looking pattern， but what it makes
    is debugability is basically impossible。 It becomes a total black box system。
    It's very possible that while my download bot。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些不同的外部依赖，最重要的是Chrome Web驱动程序。Chrome Web驱动程序使用一种称为“四人帮命令模式”的东西实现。这是一个看起来很酷的模式，但它使得调试几乎不可能。它成为了一个完全黑箱系统。在我的下载机器人工作时，很有可能。
- en: is trying to operate with this page， it just gets into a bad state。 And I just
    have no idea what's wrong。 In addition， so Pokemon Showdown， it's a chat application。
    So let's think about the characteristics of that system。 It means that a lot of
    the connections。 are very long lasting， right？ We're gonna try to persist connections
    from minutes， if not hours。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正在尝试与这个页面进行操作，它就是进入了一个坏状态。我对发生了什么完全没有头绪。此外，Pokemon Showdown是一个聊天应用程序。让我们想想那个系统的特点。这意味着很多连接。都是非常持久的，对吧？我们会尝试保持几分钟，如果不是几个小时的连接。
- en: Unfortunately， there are only two developers， or something like that for the
    website。 so reliability is not the greatest。 I could have a bot sitting on a battle，
    and they just get DC。 They just get booted by the server。 For no reason other
    than the server。 can't maintain all these connections at the same time。 So if
    you take a look at lines 10， 11。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，网站上只有两个开发人员，或者类似的情况。所以可靠性并不是很好。我可能会有一个机器人在战斗中，但他们会被断开连接。因为服务器无法同时维持所有这些连接。所以如果你查看第10、11和12行。
- en: and 12。 So online 10 connection loss， that's what that means。 So the server，
    for whatever reason。 just booted me。 But that's okay。 That's an acceptable error
    condition。 If that occurs。 just try again on another attempt。 We're not gonna
    kill the runtime because of that。 A Web Driver error。 So this is something because
    maybe， when working with a Chrome Web Driver。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第10行的连接丢失，这就是它的意思。所以服务器，无论什么原因。只是把我踢了。但没关系。这是一个可接受的错误条件。如果发生这种情况。只需在另一次尝试中再试。Web
    Driver错误。这是因为，也许在使用Chrome Web Driver时。
- en: like into a bad state， this is expected though。 So it's fine， we're gonna continue
    to try again。 And the last one's the most obvious one。 If the bot goes to the
    page and the bot finds。 that the battle's not yet completed， again， that's fine，
    we're gonna continue。 This code here。 it's inspired by， our holders， Guava Retrying。
    Guava， for people who don't know。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 处于一种不好的状态，这是预期之中的。所以没关系，我们会继续尝试。最后一个是最明显的。如果机器人去页面并发现。战斗尚未完成，再一次，这没关系，我们会继续。这段代码受到我们持有者Guava重试的启发。Guava，对于不知情的人。
- en: is it's Google's common libraries for Java。 And then our holder， he wrote it。
    He wrote A。 an extension to it。 And then inspired on his design for retrying，
    it's how I wrote this code here。 So what we had at the smallest level， we have
    a download bot that has this retry logic。 And now when it goes to the page， it
    might not work， but that's fine， we'll try again。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 是谷歌的Java通用库。然后我们的持有者，他写了它。他写了一个扩展。然后根据他的重试设计，我写了这段代码。所以在最小的层面上，我们有一个下载机器人，它有这个重试逻辑。现在当它去页面时，可能不会成功，但没关系，我们会再试一次。
- en: And this is what really brings in， the resilience at a higher level。 Now we
    account for the Web Driver， we account for the server。 we account for the Selenium
    Web Automation framework， not working well。 But lastly。 there's also a fallback。
    You can see there online nine。 So let's say that I exhaust all my retries。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在更高层面上真正带来韧性的地方。现在我们考虑Web Driver，考虑服务器。考虑Selenium Web自动化框架工作不良。但最后。还有一个后备方案。你可以看到在第九行。所以假设我耗尽了所有的重试。
- en: Let's say I expect that the battle will take 45 minutes。 and for whatever reason
    it's just gone on for an hour and a half。 Okay。 we're not gonna wait much longer。
    At a certain point， we're gonna kill the retries。 we're gonna assume that it just
    fails， and I need to return something。 So in this case。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我预计战斗会花费45分钟，但由于某种原因，它已经进行了一个半小时。好的，我们不会再等太久。在某个时刻，我们会终止重试。我们会假设它失败了，我需要返回一些东西。所以在这种情况下。
- en: I just returned an empty list， a zero-valued object on line nine。 But even cooler
    than that is on line 13。 So I learned this from PyCon 2017。 There's a talk on
    error-handling paradigms。 And there's just like this little nugget。 that she mentions
    about a project， from Microsoft called Midori。 And over in Midori。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚刚返回了一个空列表，在第九行是一个零值对象。但是更酷的是在第13行。所以我从2017年的PyCon学到了这个。那有一个关于错误处理范式的演讲。然后她提到一个来自微软的项目，叫做Midori。在Midori那边。
- en: they use this technique， called abandonment。 I've never had a term for it。 but
    so when we're working in the cloud， we assume that resources will fail。 We assume
    there will be network partition， we assume there will be loss of availability。
    and we assume that nodes will just get into a bad state。 So what do we do in those
    cases？ Well。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 他们使用了一种叫做放弃的技术。我从来没有给它起过名字。但是，当我们在云端工作时，我们假设资源会失败。我们假设会有网络分区，假设会有可用性丧失。我们还假设节点会陷入不良状态。那么在这些情况下我们该怎么办呢？嗯。
- en: it's fine。 They should be very trivial occurrences。 We just kill the node and
    instantiate a new one。 The same thing here。 So sometimes my download bot would
    just get into a bad state。 and I had no idea how to handle this。 I couldn't debug
    it because the Chrome driver is too confusing。 or maybe the number of network
    calls with the server， and maybe there's some bad state there。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这没关系。它们应该是非常微不足道的事件。我们只需杀掉节点并实例化一个新的。在这里也是同样的事情。所以有时我的下载机器人会陷入不良状态。我不知道该怎么处理。我无法调试，因为Chrome驱动程序太令人困惑。或者可能是与服务器的网络调用次数太多，可能那里有一些不良状态。
- en: And so what I did is I would force garbage collect， that download bot and then
    reconstruct。 the entire object graph。 I'm not going to go into the implementation
    details here。 but it's a technique that I think is just so， so cool。 And that
    was definitely what set this project over， in terms of just making it rock solid。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我所做的就是强制垃圾回收，那下载机器人，然后重建整个对象图。我不打算在这里深入实现细节，但这是我认为非常非常酷的一种技术。这绝对是让这个项目在稳固性上脱颖而出的原因。
- en: that abandonment strategy on line 13。 So we've seen how at first I started this
    tiny project。 and was all running in a single process， and then I needed to scale。
    I couldn't keep it all in my head， and I wasn't getting the throughput that I
    wanted。 So I sought to achieve concurrency， and I did that using the message passing。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在第13行的放弃策略。所以我们看到，最开始我开始了这个小项目，并且一切都在一个进程中运行，然后我需要扩展。我无法将所有信息都记在脑海中，而且我没有获得我想要的吞吐量。因此，我寻求实现并发，并且我通过消息传递实现了这一点。
- en: But even though I had the concurrency， I had no idea if things were working
    correctly。 So we really had to step up our game on how we test。 And we use those
    strategies。 like in my particular case， I use fakes。 So now that we have the concurrency。
    we know that the application works pretty well， and then with these resilient
    strategies。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但是即使我有并发，我也不知道事情是否正常工作。因此，我们真的需要提高测试的标准。我们使用这些策略。就我个人的情况而言，我使用虚假数据。所以现在我们有了并发。我们知道应用程序运行得相当不错，然后通过这些有弹性的策略。
- en: we also have some kind of backup strategies， for when things will fail， which
    they inevitably will。 So unfortunately， I don't have time for questions。 However。
    I hope that it's like reasonably apparent， that I'm an okay approachable person。
    So if you see me in the hallway， I'm more than happy to talk about Hawaii， or
    gender equality。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也有一些备份策略，以应对不可避免的故障。因此不幸的是，我没有时间回答问题。然而，我希望这看起来是明显的，我是一个可以接近的人。所以如果你在走廊上看到我，我非常乐意谈论夏威夷或性别平等。
- en: or if you're interested， about what it's like working at Google， or interviewing
    for Google。 it's the worst， interviewing for Google is the worst。 (laughs)。 Feel
    free to just come grab me and talk to me。 And also， if that's uncomfortable。 you're
    happy to just talk to me on LinkedIn as well。 And I did wanna leave with this
    mention though。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果你对在谷歌工作或面试谷歌的经历感兴趣。这是最糟糕的，面试谷歌是最糟糕的。（笑）。欢迎随时来找我聊聊。如果这让你感到不自在，你也可以在LinkedIn上与我联系。不过我确实想以这个提及作为结束。
- en: So Jack Dietrich from 2012， he said this on the top line there， so we don't
    ship code。 we ship features。 And I wanna build on that。 So I would also say that
    we don't solve problems。 for computers。 We're solving problems for people。 I think
    it can be very easy to forget about that sometimes。 and just wanna work on the
    newest， sexiest technology。 But we have to。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，杰克·迪特里希在2012年说过，最上面那一行，他说我们不发布代码。我们发布功能。我想在这个基础上再补充一点。所以我还想说，我们不是在为计算机解决问题。我们是在为人解决问题。我觉得有时候很容易忘记这一点，而只是想去研究最新、最炫的技术。但我们必须要。
- en: I would urge the Python community， as great as we are， to really focus in on
    the user。 And I think that's how we can deliver a great value。 So thanks for your
    time， gang。 I'll see you around。 (audience applauds)， (audience applauds)， (applause)。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我想呼吁Python社区，尽管我们很棒，但真的要关注用户。我认为这就是我们能提供巨大价值的方法。所以谢谢你们的时间，伙计们。我会再见到你们的。（观众鼓掌），（观众鼓掌），（掌声）。
- en: '![](img/2422877eee958c178c29c5664788cd9d_15.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2422877eee958c178c29c5664788cd9d_15.png)'
