- en: P12：Chris Wilcox - Shipping your first Python package and automating future
    publishi - leosan - BV1qt411g7JH
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P12：Chris Wilcox - 发布你的第一个 Python 包并自动化未来的发布 - leosan - BV1qt411g7JH
- en: And next presenter is Chris Wilcox， who will be talking about shipping your
    first Python， package。 Please make him feel welcome。 Thanks everyone for coming。
    I've been coming to PyCon for five years and this is the first time I've gotten
    to speak。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的演讲者是 Chris Wilcox，他将谈论如何发布你的第一个 Python 包。请让他感到受欢迎。感谢大家的到来。我已经参加 PyCon 五年了，这是我第一次发言。
- en: '![](img/d4354276a889b9d2e0a5ce6f8024568f_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4354276a889b9d2e0a5ce6f8024568f_1.png)'
- en: so I'm pretty excited。 So again， my name is Chris。 I live in Seattle， Washington。
    I work for this small internet startup you might have heard of called Google。
    We make a search engine and some other things。 Because I live in the P&W。 I try
    to take advantage of some of the nature we have in my personal， life。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我对此感到非常兴奋。再次介绍一下，我叫 Chris，住在华盛顿州的西雅图。我为一家你可能听说过的小型互联网初创公司工作，叫做 Google。我们做搜索引擎和其他一些事情。因为我住在
    P&W，我试图在个人生活中利用一些自然资源。
- en: so that's me hiking at Mount Rainier。 I also have a like for all things two
    wheels。 I don't know how that happened， but I bicycle a lot and one of the things
    I do in my spare。 time is I'm an amateur road racer。 But you probably didn't come
    here to hear what I do。 You're probably interested about PyPI。 So this is what
    we're going to talk about today。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是我在雷尼尔山徒步的照片。我也喜欢所有与两个轮子有关的事物。我不知道这是怎么发生的，但我骑自行车很多，我闲暇时是个业余公路赛车手。不过你可能不是来听我说这些的，你更关心的是
    PyPI。所以今天我们将讨论这个话题。
- en: We're going to start by creating a simple PyPI package that we can publish。
    Then we're going to talk about some of the more extended features you likely want
    to， use in setup。py。 And then we'll talk a bit about how you can use automation
    to make maintaining this process。 a lot easier。 So what is PyPI？ What PyPI is
    is a package repository for Python maintainers。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建一个简单的 PyPI 包开始，该包可以发布。然后我们将讨论一些你可能想在 `setup.py` 中使用的更扩展的功能。接着我们会讨论如何利用自动化来简化维护这个过程。所以，什么是
    PyPI？PyPI 是一个供 Python 维护者使用的包存储库。
- en: It's one of the things that makes Python a joy to use。 It's the ecosystem that
    we all came to Python for。 And it's because of this ecosystem that Python developers
    can learn and build great and interesting。 things。 But over time， Python has evolved。
    And along with Python， PyPI has evolved。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是让 Python 变得愉悦的原因之一。正是我们所有人来到 Python 的生态系统。正因为这个生态系统，Python 开发者能够学习并构建出伟大而有趣的东西。但随着时间的推移，Python
    也在不断演变。与此同时，PyPI 也在发展。
- en: And with these evolution changes came。 This has made PyPI seem mysterious to
    many people。 My hope here today is prove that there is no mystery。 It's simple。
    And everyone in this room should be able to deploy a package to PyPI。 And with
    any luck。 by the end of this talk， every one of you will be a Python package，
    author。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些演变的变化使得 PyPI 对许多人来说显得神秘。我今天希望证明，这没有什么神秘之处。它很简单。这个房间里的每个人都应该能够将包部署到 PyPI。希望在这个演讲结束时，大家都能成为
    Python 包的作者。
- en: So what is a Python package？ A Python package is a module， a class。 some functions
    that you have that you can deploy， for other users。 And here is a really simple
    one。 We have a module called My Package。 It has a knit and a module。 The module
    has a simple function called spam that always returns eggs。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那么什么是 Python 包？Python 包是你可以为其他用户部署的模块、类或一些函数。这里有一个非常简单的例子。我们有一个名为 My Package
    的模块。它有一个初始化函数和一个模块。该模块有一个简单的函数叫做 spam，总是返回 eggs。
- en: This is enough for us to demonstrate how you might deploy to PyPI。 The first
    thing we need to do is make a set up。py file。 There are only four fields required
    in order to deploy to PyPI。 You need a name for what this package is。 You need
    a version， a brief description。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以展示你如何部署到 PyPI。我们需要做的第一件事是创建一个 `setup.py` 文件。为了部署到 PyPI，仅需四个字段。你需要为这个包提供一个名称，一个版本，以及一个简短的描述。
- en: You need to know what things you need in the package。 The line at the bottom，
    set up tools。find packages is a helper function provided by set。 up tools that
    will discover the necessary things inside that folder for you。 And the first thing
    we do， because we're good software engineers， is we test first before。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要知道在包中需要哪些东西。底部的那一行，设置工具。`find packages` 是由 `setuptools` 提供的辅助函数，它将为你发现该文件夹中的必要内容。作为优秀的软件工程师，我们首先要做的是测试。
- en: doing anything else。 So we can make a virtual environment。 We can install using
    pip。 So this is a little more unusual than the way you might use pip now。 We use
    dot which specifies to install this directory， we're set up to pyas， and dash
    e。 which is editable or development mode。 The reason we do this is when we make
    changes to our package。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不做其他任何事情。所以我们可以创建一个虚拟环境。我们可以使用 pip 安装。这比你现在使用 pip 的方式稍微不寻常一些。我们使用点，指定安装此目录，我们设置为
    pyas，以及 dash e，表示可编辑或开发模式。我们这样做的原因是，当我们对包进行更改时。
- en: we don't have to keep reinstalling， it。 After we've done that， we can open a
    Python REPL。 importer package， and prove it works。 Yay。 The next thing we do is
    we can upload this to test PyPI。 It probably wouldn't be a great idea to do this
    right to PyPI since it's likely being。 your first time doing this， you're going
    to have some stumbling blocks。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必不断地重新安装它。在完成后，我们可以打开一个 Python REPL。导入包，证明它能正常工作。太好了。接下来我们可以将其上传到测试 PyPI。直接上传到
    PyPI 可能不是个好主意，因为这可能是你第一次这样做，你可能会遇到一些障碍。
- en: So we start by installing some dependencies。 We need twine and we need wheel。
    Then we run Python set up to py estist beatist wheel。 What does that mean？
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们开始安装一些依赖项。我们需要 twine 和 wheel。然后我们运行 Python 设置以进行 py estist beatist wheel。这是什么意思？
- en: Estist is a source distribution。 We're just going to bundle up the Python scripts
    that we have so that way they can be。 shipped to PyPI and downloaded by our users。
    Redist wheel is a binary distribution in the wheel format。 This is the accepted
    and expected way of shipping binary distributions。 For pure Python packages。 this
    isn't strictly necessary， but it is seen as good practice， to provide wheels for
    your packages。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Estist 是源代码分发。我们将捆绑我们拥有的 Python 脚本，以便它们可以被发送到 PyPI 并被我们的用户下载。Redist wheel 是以
    wheel 格式提供的二进制分发。这是发送二进制分发的公认和预期的方式。对于纯 Python 包，这并不是绝对必要的，但被视为良好的实践，为你的包提供 wheel。
- en: It's easy to do， so we'll do it here。 Once we've done that， we can use twine
    to upload。 Once we're not doing this to the default endpoint， PyPI， we specify
    test PyPI as the repository。 The argument after that is a glob pattern that will
    collect everything under dist。 Dist is the folder where everything built by the
    setup。py process on the line previous， will be put。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，所以我们在这里就这样做。一旦我们完成，就可以使用 twine 上传。一旦我们不在默认端点 PyPI 上操作，我们指定测试 PyPI 作为仓库。之后的参数是一个
    glob 模式，将收集 dist 下的所有内容。Dist 是 setup.py 过程生成的所有内容将放置的文件夹。
- en: At the end， we can install from test PyPI using pip in the way you expect， but
    we have。 to specify the index URL because again it's not the default。 From doing
    this to PyPI。 very much the same process。 It's a little simpler here because we
    don't need to reinstall all of our dependencies。 but again we build from setup
    and we upload with twine。 And here we are。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 pip 从测试 PyPI 安装，方式如你所期待的，但我们必须指定索引 URL，因为这不是默认设置。将此与 PyPI 的操作非常相似。这里稍微简单一些，因为我们不需要重新安装所有依赖项，但我们仍然从设置开始构建，并用
    twine 上传。我们准备好了。
- en: We have a package now that we can install and we can use。 So that's it。 The
    talk is over。 You can now deploy to PyPI。 Congratulations， everyone。 You are now
    package authors。 But you might have noticed this is pretty bare minimum。 And if
    you saw this coming to PyPI。 you might think this is a bit sketchy。 It is the
    bare minimum。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以安装和使用的包。所以就这样。演讲结束了。你现在可以部署到 PyPI。恭喜大家。你们现在是包的作者。但你可能注意到这还是相当基础。如果你看到这个到达
    PyPI，你可能会觉得这有点可疑。这确实是最基本的。
- en: You can do the bare minimum if you like。 That's okay。 That's up to you。 But
    I think here we like to do more than the bare minimum for our users。 What do you
    think？
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以做到最基本的。没关系，这取决于你。但我认为我们希望为用户做的比最基本的更多。你怎么看？
- en: All right。 More flare。 So the first thing we want to talk about is adding author
    information。 If you ran setup。py estus on your computer， you get a few warnings。
    And the warnings tell you that it's expected that you have an earl， an author，
    and an author， email。 And these are pretty good expectations。 We are putting something
    on the internet。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，更多的细节。那么我们首先想谈的是添加作者信息。如果你在电脑上运行了 setup.py estus，你会收到一些警告。这些警告告诉你，预期你有一个
    URL、一个作者和一个作者邮箱。这些都是相当合理的期望。我们正在将某些东西放到互联网上。
- en: People should know how to get in touch with us。 So giving a repository earl
    and what our name is is going to build some trust。 So we can add these things
    here。 There's another really important thing in PyPI for discovering packages
    we're interested。 in and understanding what these packages are。 And those are
    classifiers。 PyPI provides over 600 different classifiers for you to use that
    help you describe packages。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 人们应该知道如何与我们联系。因此提供一个代码库的链接和我们的名字将建立一些信任。我们可以在这里添加这些内容。在PyPI中还有另一件非常重要的事情，帮助我们发现感兴趣的包，并理解这些包的内容，那就是分类器。PyPI提供了600多种不同的分类器供你使用，帮助你描述包。
- en: On the screen now are some of the more common things you might see。 First we
    talk about the development state。 Where are we in the process of this package？
    Is it alpha？
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在屏幕上展示的是一些你可能会看到的更常见的内容。首先我们谈论开发状态。这个包目前处于什么阶段？是alpha吗？
- en: It hasn't matured？ Do we consider production？ The next thing you'll usually
    see are some specifiers around programming languages。 This package I just made
    it today。 So I'm going to support the current Python three versions that haven't
    been end of life。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 还没有成熟吗？我们考虑生产环境吗？接下来你通常会看到一些编程语言的规范。我今天刚刚制作了这个包。因此，我将支持当前还没有结束生命周期的Python 3版本。
- en: So that's 35， 36， and 37。 Because this package has nothing specific to an operating
    system。 we can say it works， on all of them。 There's no reason I would believe
    that printing eggs would have a problem on any OS today。 The last thing we can
    do is we can talk about topics。 And so here I said this is a utility。 There are
    a lot of these。 Scientific computing is one， for instance。 One of them for internet。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是35、36和37。因为这个包与操作系统没有特定关系，我们可以说它在所有操作系统上都能运行。我没有理由相信在任何操作系统上打印鸡蛋会有问题。我们可以谈论的最后一个事情是话题。因此我说这是一个工具，类似的工具有很多，科学计算就是其中之一，还有一些与互联网相关的。
- en: And so you can really begin to describe your package to users。 This is probably
    the most important thing， though， that was missing previously。 There was no license。
    Licenses aren't required to upload to PyPI。 but I would strongly recommend them。
    It's the case for a lot of users in the Python community that they can't use your
    package。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你真的可以开始向用户描述你的包。不过，这可能是之前缺失的最重要的事情。没有许可证。上传到PyPI并不要求有许可证，但我强烈建议这样做。在Python社区，很多用户无法使用你的包。
- en: without a license。 And not to turn this into a licensing talk。 But if you have
    no license。 that's not the equivalent of a free-for-all。 Some people might think
    that if you just don't give a license。 I can do whatever I want。 That's not true。
    For a lot of us in the corporate world。 we need a license to understand what rights
    we're， being given and what rights we're giving。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有许可证，而不把这变成一个许可证的讨论。如果你没有许可证，那并不等于可以随意使用。一些人可能认为，如果你不提供许可证，我可以随心所欲。这并不正确。对于我们许多在企业界的人来说，我们需要许可证来理解我们被赋予了什么权利以及我们给予了什么权利。
- en: And without that， we're dead in the water。 So there are a bunch of classifiers。
    There's around 80 of these。 And I called out three of the most common licenses
    from my perspective using Python packages。 You'll see a lot of MIT， Apache， and
    GPL。 MIT and Apache are both fairly unrestricted licenses。 They do have differences。
    You should read about them on your own before choosing one。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这些，我们就无路可走。因此有很多分类器，大约有80种。我从我使用Python包的角度提到三个最常见的许可证。你会看到很多MIT、Apache和GPL。MIT和Apache都是相对不受限制的许可证，但它们之间确实存在差异。在选择之前，你应该自己阅读一下。
- en: But those are probably the most common with GPL coming in next。 The other thing
    that was missing is any sort of meaningful description or getting started。 installation
    information。 And we can provide that via a longer description。 The code on the
    slide shows you how we could read in the readme from our repository and。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些可能是最常见的，GPL紧随其后。另一个缺失的东西是任何有意义的描述或入门安装信息。我们可以通过更长的描述提供这些内容。幻灯片中的代码向你展示了我们如何从我们的代码库读取readme文件。
- en: then put it into the long description。 So long description takes text。 Long
    description content type allows us to tell it what that text is。 And that's pretty
    important。 Because without the content type， it just assumes it's plain text，
    which probably isn't。 what you intended to get。 There are a lot of supported formats。
    Plain text is one of them。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后把它放入长描述中。因此，长描述需要文本。长描述内容类型允许我们说明这些文本是什么。这一点非常重要。因为如果没有内容类型，它会假设是纯文本，这可能并不是你想要的结果。有很多支持的格式，纯文本就是其中之一。
- en: along with common mark， restructured text。 And the most recent one is GitHub
    Markdown。 which I find very convenient since it's kind， of the default for that
    world。 So after all that。 this is what our setup to Pi looks like。 It's not anything
    too crazy。 but what this results in is a more reasonable looking Pi， Pi package。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以及常见的标记、重构文本。最新的是GitHub Markdown，我发现这非常方便，因为它是那个领域的默认选项。因此，经过这一切，我们的Pi设置看起来就是这样。这并不疯狂，但这将导致一个更合理的Pi
    Pi包。
- en: It goes a bit beyond the minimum we need， but it's enough that our users can
    understand。 what our package is about， where it can be used， et cetera。 But I
    want to talk about some other things。 These things are general improvements beyond
    the things that you tend to look at first。 on Pi Pi。 But they're going to make
    maintaining your package easier and better communicate things。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它超出了我们需要的最低限度，但足以让我们的用户理解我们的包是什么，在哪里可以使用，等等。但我想谈谈其他一些事情。这些事情是超出你通常首先关注的内容的一般改进，关于Pi
    Pi。但它们将使维护你的包更容易，更好地传达信息。
- en: to your users。 So I want to start by talking about a thing called Python requires。
    Pi Pi right now doesn't enforce Python versions for your installs。 So let's say
    I went today and shipped this package without Python requires， and a Python， 3。4
    user came along， or a Python 2。7 user came along and tried to install the package。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 给你的用户。因此，我想先谈谈一个叫做Python要求的东西。现在，Pi Pi并不强制安装你的包时使用特定的Python版本。假设我今天发货了这个包而没有Python要求，而一个使用Python
    3.4或Python 2.7的用户来尝试安装这个包。
- en: And it doesn't work， and they have a problem。 Now we might expect that the user
    would go back to the package page and notice that。 oh， it says the supported version
    is 3。5 plus。 But there's pretty much an equally likely chance that that same user
    files a bug about。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它不工作，他们就会遇到问题。现在我们可能期待用户会返回包页面并注意到，哦，它说支持的版本是3.5及以上。但同样有可能的是，该用户提交了一个关于这个的错误报告。
- en: how it doesn't work， doesn't tell you they're on 2。7。 You spend the next three
    hours of your life trying to figure out why this is doing some。 weird thing to
    eventually realize three days later that the problem is there using an unsupported。
    version that you'd never tested。 And that's not a good situation for anyone。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 它不工作，也没有告诉你他们使用的是2.7。你接下来的三个小时都在试图弄清楚为什么会出现一些奇怪的情况，最终三天后才意识到问题在于他们使用的是一个你从未测试过的不受支持版本。这对任何人都不是好情况。
- en: It's not good for your customer because they've wasted time trying to use something
    that was。 never going to work。 You spent time trying to debug。 And so at the end
    of the day。 the best thing we can do for everyone is be transparent and。 honest
    about what it is we do and don't support。 And Python requires allows us to do
    that。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你的客户不好，因为他们浪费了时间尝试使用根本无法工作的东西。你花时间进行调试。因此，归根结底，我们能为每个人做的最好事情就是对我们所支持和不支持的内容保持透明和诚实。而Python要求使我们能够做到这一点。
- en: So because， again， I shipped this today， I'm going to support 3。5， 3。6， and
    3。7， and this。 takes care of that。 Another thing that isn't happening in this
    small package but is far more common in real。 world packages are dependencies。
    So imagine for a moment that you had a package that needed to get content from
    the Internet。 If you're going to do that， you're likely using Erlib3 using requests。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所以再次强调，我今天发货了，我将支持3.5、3.6和3.7，这样就能解决这个问题。另一个在这个小包中没有发生但在现实世界的包中更常见的事情是依赖项。所以想象一下，你有一个需要从互联网上获取内容的包。如果你要这样做，你很可能会使用Erlib3或requests。
- en: These are pretty common packages for doing this sort of thing。 And so here's
    an example of how you might do that。 Install requires takes an array。 We give
    it the packages。 And this way， PiPI， when it installs a set up Pi。 can go ahead
    and install dependencies， for the user so they don't end up in a weird place where
    things don't work。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是进行此类操作的常见包。因此，这里是一个你可能如何实现的示例。Install requires接收一个数组。我们给它包。在这种方式下，当PiPI安装一个设置Pi时，可以继续为用户安装依赖项，这样他们就不会陷入一个奇怪的地方，导致事情无法工作。
- en: The last thing I wanted to talk about adding to set up Pi is the reduction，
    the exclusion。 of certain things from our package。 This turns out to be a little
    more controversial because some users really do want everything。 They want your
    tests。 They want your docs。 They want it all to come down right away。 This is
    really common in audit workflows。 So if someone wants to be able to run your tests
    once they've installed to verify it works。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我最后想谈谈添加到设置Pi中的内容，即某些东西的减少和排除。这有点有争议，因为一些用户确实想要所有内容。他们想要你的测试。他们想要你的文档。他们想要所有东西立即下载。这在审计工作流程中非常常见。所以如果有人希望在安装后能够运行你的测试以验证它是否工作。
- en: they want the unit tests。 The problem is these things can also be seen as bloat
    for pretty much every other user。 And for a lot of packages that I've worked on，
    tests make up a significant portion of。 the code base。 Docs take up a lot of space。
    And so I don't really want to have to distribute those every time and increase
    the size of my。 install， which might be problematic for people with slow Internet
    or on platforms that have。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 他们希望单元测试。问题是，这些内容对于几乎所有其他用户来说也可能被视为臃肿。而且对于我参与的许多包来说，测试占据了代码库的相当大一部分。文档也占用了很多空间。因此，我并不想每次都分发这些内容，增加我的安装包大小，这可能对网络速度慢的人或在一些平台上造成问题。
- en: limited disk space。 And so you can limit some of these things。 You can exclude
    them so that they don't come down。 Another thing that we sort of glossed over
    is I talked about publishing without everyone's。 talking about having credentials。
    PiPI works on a username password model。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 限制的磁盘空间。因此你可以限制这些内容。你可以排除它们，这样它们就不会被下载。我们略过的另一件事是，我谈到了在没有每个人的情况下发布，即谈论拥有凭据。PiPI基于用户名和密码的模型。
- en: And there's talk to add new source of authentication for them， but this is the
    state of the art。 today。 And there are a few ways to manage this。 The most obvious
    one is when you run from the CLI。 it'll prompt for a username， it'll prompt， for
    a password。 And this is really easy to get started with。 You store your password
    and username combination in your password manager。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有关于为它们添加新的认证源的讨论，但这是目前的先进技术。今天有几种方法可以管理这个。最明显的一种是当你从CLI运行时，它会提示你输入用户名，也会提示你输入密码。这非常容易入门。你可以将你的密码和用户名组合存储在密码管理器中。
- en: And when you need to publish， you dispatch it and then you type it in。 Another
    common way is a file called 。pipirc。 This file tends to live in your home directory。
    And we can form it as you see here。 The repository URL would be for piPI。 user
    name would be in my case CR Wilcox， and then， I'd have a password。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要发布时，你可以调度它，然后输入它。另一种常见的方法是一个名为`.piprc`的文件。这个文件通常位于你的主目录。我们可以像你看到的那样进行设置。存储库的URL应该是piPI。用户名在我这里是CR
    Wilcox，然后我会有一个密码。
- en: There's one other way that is becoming more popular among people， and they seem
    to like， this。 Keyring。 So we can install keyring。 Keyring is a password manager
    that when given a endpoint。 so in our case a URL to test， piPI or to piPI， and
    a username， it will provide the password。 I think it's important to mention by
    default this isn't all that secure。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方式在越来越多的人中变得流行，他们似乎喜欢这个。Keyring。因此我们可以安装keyring。Keyring是一个密码管理器，当给定一个端点（在我们的例子中是一个URL用于测试piPI）和一个用户名时，它会提供密码。我认为值得一提的是，默认情况下这并不是特别安全。
- en: It might seem on the surface like this is better。 It does allow you to look
    the things up by your application。 but in this case the application， is Python，
    so it's actually open to a lot of the world。 I think it's a little better than
    piPIRC。 The reason for that is it's pretty easy to accidentally commit your piPIRC。
    And it's also in plain text and a predictable location on a computer that you
    likely use。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，这似乎更好。它确实允许你通过应用程序查找事物。但是在这个例子中，应用程序是Python，因此它实际上向很多领域开放。我认为这比piPIRC稍好一点。原因是你很容易不小心提交你的piPIRC。而且它是纯文本格式，并且存放在你可能使用的计算机上的一个可预测的位置。
- en: for things other than publishing packages。 So if you were to have any sort of
    infection or anything。 you'd really have to worry that， your piPI credentials
    have been in some ways compromised。 So this is what I figured of this point I
    would be feeling in the audience， so I've。 shown you a bunch of different settings
    that you can do， but in what way am I supposed to。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于发布包以外的事情来说。如果你遇到任何类型的感染或者其他问题，你确实要担心你的 piPI 凭据在某种程度上被泄露。所以这是我想到了的这一点，我会感到在场观众的感受，因此我给你展示了一些不同的设置，但我应该以什么方式去做呢。
- en: retain a dozen different things that go in the setup。py file。 My suggestion
    would be to not try to do that。 You're going to have a hard time。 So what you
    could remember instead is that the piPI publishes a sample project。 And the sample
    project has a ton of comments on every one of these settings that helps。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 保留进入 setup.py 文件的十几个不同的内容。我建议不要尝试这样做。你会很难。因此你可以记住的是，piPI 发布了一个示例项目，而这个示例项目对每一个设置都有大量的注释，帮助你理解。
- en: you understand better how you might use it and why you might use it。 And they
    have extensive documentation beyond this sample that you can use。 The other thing
    you might find is that as you develop packages beyond your first and。 second one
    is that you start to rely on your own work。 So you've now done this a few times。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你会更好地理解你可能如何使用它以及为什么使用它。他们有比这个示例更全面的文档可以使用。你可能发现的另一件事是，当你开发的包超过你的第一个和第二个包时，你开始依赖于自己的工作。所以你现在已经做了几次。
- en: You just go grab your old setup。py and you copy it into your new package。 You
    change some things。 the name of the package and whatnot。 But likely things like
    your URLs are going to be mostly the same。 Your email is going to be the same。
    And so you can sort of just borrow from your past self。 Another way to do this
    I wanted to mention is a thing called cookie cutter。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需取旧的 setup.py 文件并将其复制到新的包中。你改变一些内容，比如包的名称等等。但像你的网址这样的东西大多数情况下是相同的。你的电子邮件也会是相同的。因此你可以从过去的自己那里借用一些东西。还有一种我想提到的方法叫做
    cookie cutter。
- en: Cookie cutter is a really powerful templating tool that you can install via
    piPI that。 will help lay out your entire repository。 And this goes far beyond
    just the setup。py file。 We're talking about your get ignore files， documentation
    layouts， testing infrastructure。 at least the start of it。 It can be very helpful。
    On the other hand。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie cutter 是一个非常强大的模板工具，你可以通过 piPI 安装，它将帮助你布局整个仓库。这远不止于 setup.py 文件。我们还在谈论你的
    gitignore 文件、文档布局、测试基础设施，至少是它的起始部分。这可能非常有帮助。另一方面。
- en: it also can come off as kind of opinionated because it has already。 made all
    of these decisions for you。 And so if you can agree with it， very helpful。 if
    you disagree with it， that might stop you， in the water。 The good news， it is
    extensible。 So if you wanted to make your own template， you could。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可能显得有点主观，因为它已经为你做出了所有这些决定。如果你能同意，它非常有帮助；如果你不同意，那可能会让你感到困扰。好消息是，它是可扩展的。因此，如果你想要创建自己的模板，你可以。
- en: That would fit the way you wanted to do things。 The one I tend to choose is
    the bit about copying your previous work。 I tend to start my packages by taking
    one I have and deleting a bunch of the content。 and then starting from there。
    But you can choose your own way。 I think my way is probably a bit messy， but it
    works for me。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将符合你想要做事情的方式。我倾向于选择的是关于复制你之前工作的那部分。我通常会通过取一个已有的包，删除一些内容，然后从那里开始来启动我的包。但你可以选择自己的方式。我觉得我的方法可能有点杂乱，但对我来说有效。
- en: '![](img/d4354276a889b9d2e0a5ce6f8024568f_3.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4354276a889b9d2e0a5ce6f8024568f_3.png)'
- en: So now that we've done that， I would like to talk about how we can never do
    most of， it again。 And that's my goal。 I as part of my day job support around
    four dozen piPI packages。 And so trying to manually publish them would get to
    be a bit of a drag。 So we can talk about ways we can automate this to make this
    a little less bad。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这一点，我想谈谈我们如何能避免再次大部分工作。这是我的目标。作为我日常工作的一部分，我支持大约四十多个 piPI 包。因此，试图手动发布它们会变得有点乏味。我们可以讨论一些方法来自动化这个过程，使其不那么糟糕。
- en: '![](img/d4354276a889b9d2e0a5ce6f8024568f_5.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4354276a889b9d2e0a5ce6f8024568f_5.png)'
- en: So why might we automate？ The first one I thought of had to do with the credentials
    I talked about。 Managing those credentials is a risk。 It also doesn't work well
    past one person。 which is likely the case for most projects， after a little bit
    of time。 The other thing that it brings is consistency。 These are very good at
    following instructions。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们为什么要自动化呢？我想到的第一个原因与我提到的凭据管理有关。管理这些凭据是一个风险。而且一个人管理的情况通常不适用于大多数项目，时间长了之后就会如此。它带来的另一个好处是一致性。这些工具在遵循指令方面表现得非常出色。
- en: Human beings less so。 I think most of us in grade school or sometime about then
    took an instructions test where。 you walked through it and you get to the end
    and they're like， you didn't need to do， this at all。 So quietly， at least they
    did that to me。 It was torture。 And they did that and you messed it up。 But computers
    will follow every step you give them exactly every time。 So automation is repeatable。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 人类则没有那么多。我想我们大多数人在小学时或那段时间参加过一次指令测试，你走到最后，结果他们告诉你，根本不需要这样做。对我来说，这简直是折磨。即使你搞砸了，但计算机会每次都精确地遵循你给出的每一步。因此，自动化是可重复的。
- en: The other thing is it gives you scale。 And you're one person having a bespoke
    development environment is perfectly fine。 The second you have two people that
    doesn't work anymore。 And so if we have automation to do this。 we simplify our
    dev environment， we make it， easier to onboard and we allow ourselves to grow
    our team。 So the first thing I'd like to talk about automating is some of our
    test work。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好处是它能给你规模。当你是一个人时，拥有一个定制的开发环境是完全可以的。可是一旦有两个人，这就行不通了。如果我们有自动化来处理这个问题，我们简化了开发环境，降低了上手难度，并且允许我们扩展团队。所以我想首先讨论的自动化是我们的测试工作。
- en: One of the interesting thing about Python packages over， say， a web service
    is you have。 to support multiple platforms。 If you're just running， let's say，
    a flask app。 you probably only care about a single version， of Python at a time。
    With packages。 you almost always care about all of the currently supported versions
    of， Python。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Python包与网络服务的一个有趣之处是，你必须支持多个平台。如果你只是运行一个Flask应用，你可能只关心一个Python版本。使用包时，你几乎总是关心所有当前支持的Python版本。
- en: which tends to be three， four， five things at once that you have to worry about。
    And so using testing tools that help us to parameterize this， to support four
    to five。 test runs at once that are all the same， other than the Python version，
    is very helpful。 So there are two I want to mention。 I couldn't talk about test
    automation without talking about talks because it's by far the。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖通常是三个、四个或五个，同时需要担心。因此，使用测试工具来帮助我们参数化，支持同时进行四到五次测试，除了Python版本之外都是相同的，这非常有帮助。所以我想提到两个工具。如果不提到`talks`，我就无法谈论测试自动化，因为它是最重要的。
- en: most popular test automation tool in Python。 It's based on I and I files where
    you can specify the Python versions you need to test。 what a test scenario might
    look like。 But there's another one I want to talk about that I find myself using。
    It's called Knox。 Knox is very much inspired by talks。 but it claims to be more
    flexible and it's based， in Python。 So rather than having an I and I file。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中最流行的测试自动化工具是基于`I`和`I`文件的，你可以在其中指定需要测试的Python版本和测试场景的样子。但我想讨论另一个我常用的工具，它叫做Knox。Knox受到`talks`的启发，但它声称更加灵活，并且是基于Python的。因此，它不需要`I`和`I`文件。
- en: we end up with Python functions that we can run to， execute tests。 Because talks
    has such a big presence already and there's a lot of documentation in the community。
    I'm going to show you how Knox works since it has a much smaller corpus， but definitely。
    look into both tools。 So here is a basic Knox file that will run our unit tests。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终会有可以运行的Python函数来执行测试。因为`talks`已经有了很大的影响力，社区中也有很多文档，我将展示Knox的工作原理，尽管它的资料相对较少，但绝对值得了解这两种工具。这里是一个基本的Knox文件，它将运行我们的单元测试。
- en: Above the function declaration， there's a session decorator that takes in an
    array of。 Python versions。 What this will do is when we run Knox。 it will run
    this function three times once for each， version of Python。 And what do we do
    inside the function？ We install some test dependencies。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数声明上方，有一个会话装饰器，它接收一个Python版本的数组。当我们运行Knox时，它会对这个函数执行三次，每次针对一个Python版本。那么我们在函数内部做什么呢？我们安装一些测试依赖。
- en: so we install mock and we install PyTest。 We install our package and then we
    run PyTest with some arguments。 The bit at the end， the session。possargs， that
    is a way to extend unit。 So we're not really using that here and I don't have
    this on the screen， but we can。 pass additional parameters to unit at runtime
    if we want via this。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们安装mock和PyTest。我们安装我们的包，然后用一些参数运行PyTest。最后的部分，session.posargs，是扩展单元的一种方式。所以我们这里并没有真正使用这个，虽然我没有在屏幕上显示，但如果我们想的话，可以通过这个在运行时传递额外的参数给单元。
- en: And so this can be useful if you have additional test flags that you want to
    use or if there。 are a lot of other tasks you might do from let's say， docs running
    and where you might。 want to pass more run arguments。 This is one of the other
    cool things I like about things like Knox and talks over just using。 PyTest directly
    is we can make a docs target that runs every time we run our tests。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有额外的测试标志想要使用，或者有许多其他任务需要执行，比如运行文档，可能希望传递更多的运行参数，这就很有用了。这是我喜欢Knox和talks等工具的另一个酷点，因为我们可以创建一个文档目标，每次运行测试时都会执行。
- en: All this does is install Sphinx， installs our module， builds the docs。 It's
    not too complicated。 But it brings us that this really great side effect。 Without
    this。 most people find themselves building their docs when they go to release。
    And I don't know about you。 but I like to find my problems much closer to when
    they。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些只是安装Sphinx，安装我们的模块，构建文档。这并不复杂。但它带来了一个非常好的副作用。没有这一点，大多数人在发布时会发现自己在构建文档。我不知道你怎么想，但我喜欢在问题出现时就尽早发现。
- en: happen than let's say a month later and then wonder why I'm having an issue。
    When you change your code because the docs are generated， you can break the docs
    and Sphinx。 will have an issue。 But if you run it as part of your test。 you will
    know the moment you made that change。 You'll know why it broke and you'll be able
    to address it right then。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 比如一个月后才发生的情况，然后再想为什么我会遇到问题。当你更改代码时，由于文档是生成的，可能会破坏文档，Sphinx也会出现问题。但如果你将其作为测试的一部分运行，你会在修改的那一刻就知道。你会知道为什么它出错，并能立即解决。
- en: And so by bringing our docs into our test run， we can end up with a much more
    stable documentation。 situation。 This very much doesn't go as deep as Knox and
    talks go。 Luckily。 there was a talk on Friday by my core， on these tools。 And
    the slides will be up on the PyCon 2019 YouTube channel later。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过将我们的文档引入测试运行，我们可以获得更加稳定的文档情况。这与Knox和talks的深入探讨有很大不同。幸运的是，我的核心团队在周五进行了一场关于这些工具的演讲。演示文稿稍后会上传到PyCon
    2019的YouTube频道。
- en: '![](img/d4354276a889b9d2e0a5ce6f8024568f_7.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4354276a889b9d2e0a5ce6f8024568f_7.png)'
- en: The next thing we're going to talk about is moving this to CI。 It's all great
    to automate this locally。 That's a lot better。 We don't have to worry about managing
    all that and making sure everyone's running PyTest。 multiple times。 Let's find
    a way to get that into the cloud somewhere where it runs on pull requests。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要讨论的是将这个移到CI上。将其本地自动化当然很好。这要好得多。我们不需要担心管理这些内容，也不需要确保每个人都多次运行PyTest。让我们找一个方法，将其放到云中，运行在拉取请求上。
- en: on， religious to master。 There are a lot of different CI services that we can
    use。 There are a lot of popular ones people know。 Circle is the one I'm going
    to talk about。 There's also Travis， there's AppVare， there's many more。 So what
    is CI？
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 继续，严格遵循主分支。有很多不同的CI服务可以使用，也有很多人熟知的热门服务。我将讨论Circle。此外，还有Travis，AppVare，以及更多。那么什么是CI呢？
- en: CI is continuous integration。 So every time we merge to master， every time we
    make a pull request。 we can get a run。 The nice thing about this is， again。 it
    simplifies what we require of our developers。 They no longer need to have as much
    figured out on their machine in order to contribute。 to a project。 We can also
    use CI for another task。 We can use it to publish our package。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: CI是持续集成。因此每次我们合并到主分支，每次我们发起拉取请求时，都可以进行运行。这个好处在于，它简化了我们对开发者的要求。他们不再需要在自己的机器上搞定那么多内容以便为项目做贡献。我们还可以利用CI来执行其他任务，比如发布我们的包。
- en: '![](img/d4354276a889b9d2e0a5ce6f8024568f_9.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4354276a889b9d2e0a5ce6f8024568f_9.png)'
- en: So to use something like Circle， you need a GitHub or a Bitbucket account。 And
    you can sign in with it。 And it knows how to discover your repositories。 So the
    page I have up now is what you'll see once you log in。 You can go to add projects。
    It will have already discovered your repositories。 And in my case， I pointed out
    my pipi package。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要使用像 Circle 这样的工具，你需要一个 GitHub 或 Bitbucket 账户。你可以用它登录。它知道如何发现你的代码库。所以我现在打开的页面是你登录后看到的内容。你可以去添加项目。它将已经发现了你的代码库。在我的情况下，我指出了我的
    pipi 包。
- en: It instructs us to create a folder called CircleCI and put a config。yaml in
    it。 The config。yaml specifies two distinct things-- workflows and jobs。 So a workflow
    is a step of jobs。 It's a list。 And a job defines a discrete task that needs to
    be done as part of continuous integration。 The sample yaml at the bottom is pretty
    good for Python programs。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 它指示我们创建一个名为 CircleCI 的文件夹，并在其中放置一个 config.yaml。这个 config.yaml 指定了两个不同的内容——工作流和任务。因此，工作流是一个任务的步骤。这是一个列表。一个任务定义了作为持续集成一部分需要完成的离散任务。底部的示例
    yaml 对于 Python 程序来说非常不错。
- en: But it's not really tailored to pipi。 You can try to start from this。 But I'm
    going to put up the link to my GitHub at the end for this project。 And you can
    start from that one。 It's a little easier。 There are some things unique to making
    Python packages from， say， a web app。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是专门为 pipi 定制的。你可以尝试从这个开始。但我将在最后提供我这个项目的 GitHub 链接。你可以从那个开始。那会简单一些。有些东西是独特的，比如从网页应用程序制作
    Python 包。
- en: '![](img/d4354276a889b9d2e0a5ce6f8024568f_11.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4354276a889b9d2e0a5ce6f8024568f_11.png)'
- en: So let's start by looking at what is in a CircleCI configuration file。 First。
    let's talk about the workflows。 Workflows are a list of jobs。 And that's the same
    here。 We have three test groups。 We have a 3。5， a 3。6， and a 3。7。 And we have
    a deploy task。 And that deploy task is what we're going to use to publish our
    content to pipi。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们先看看 CircleCI 配置文件中的内容。首先，让我们谈谈工作流。工作流是一系列任务。在这里也是一样。我们有三个测试组。我们有一个 3.5，一个
    3.6 和一个 3.7。还有一个部署任务。这个部署任务是我们将用来将内容发布到 pipi 的。
- en: There are a few extra things there。 If you look under 3。7， you'll see it has
    a filter。 And that filter says on tags， only run this on all tags。 The reason
    I'm doing this is this way on a tag run， which is how we're going to publish。
    will run our 3。7 tests。 So before we try to publish。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些额外的内容。如果你查看 3.7，您会看到它有一个过滤器。这个过滤器在标签上只对所有标签运行。这么做的原因是为了在标签运行时，我们将进行发布。将运行我们的
    3.7 测试。因此在我们尝试发布之前。
- en: we'll make sure at least one of our test runs work。 Under deploy， again， we
    have filters。 We have the tags filter， which has a regex， which can roughly be
    described as it looks。 like a version number。 And it also ignores branches。 This
    is important so that way we don't try to build on master。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会确保至少有一个测试运行成功。在部署下，我们再次有过滤器。我们有标签过滤器，它有一个正则表达式，大致可以描述为它看起来像一个版本号。它也忽略分支。这一点很重要，这样我们就不会尝试在主分支上构建。
- en: Because the last thing I would want is merging some pull request and then having
    it decide。 now is a good time to try to publish。 This way we have full control
    over when we publish。 And let's look at the test job a little bit。 The test job
    looks very much like we would have done manually。 If we ignore some of the extra
    stuff， check out which clones are repository and some of。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我最不想要的就是合并某个拉取请求，然后让它决定。现在是尝试发布的好时机。这样我们就能完全控制何时发布。让我们稍微看一下测试任务。测试任务看起来非常像我们手动完成的工作。如果我们忽略一些额外的内容，查看一下哪些克隆了代码库和一些。
- en: the virtual integration， we install Nox and we run Nox。 Deployment is very much
    the same story。 We check out the repository， we make a virtual environment， we
    install our dependencies twine。 and wheel， and we run the two steps we did earlier
    when we manually uploaded to pipi。 There are some extra steps that we need to
    think about with upgrading that we didn't really。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟集成，我们安装 Nox 并运行 Nox。部署的过程也是如此。我们检查代码库，创建一个虚拟环境，安装我们的依赖项 twine 和 wheel，然后运行我们之前手动上传到
    pipi 时所做的两个步骤。关于升级还有一些额外的步骤，我们实际上并没有真正考虑过。
- en: talk about before。 We need to change the version number。 The good thing is if
    you forget to do this。 nothing really exciting happens because pipi， won't let
    you overwrite version numbers but you might be surprised that you never get。 a
    new package。 We started at zero。0。1， so I'm going to increment this to zero。0。2。
    And once you've merged this to your master branch， you're going to create a tag。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 之前谈到过。我们需要更改版本号。好的一点是如果你忘记这样做，实际上不会发生什么激动人心的事情，因为 pipi 不会让你覆盖版本号，但你可能会惊讶于你从未得到新的包。我们从零。0。1
    开始，所以我将把它递增到零。0。2。一旦你将其合并到你的主分支，你将创建一个标签。
- en: You can create a tag using git tag or any of the CLI tools you use forget。 But
    I prefer to use the releases system on GitHub。 So releases will give you an archive
    of your current savior repository and they will also。 give you a tag。 So in this
    case， we're going to make a tag called zero。0。2。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 git tag 或任何你用来获取的 CLI 工具创建标签。但我更喜欢使用 GitHub 上的发布系统。发布将给你当前保存的代码库的归档，同时也会给你一个标签。所以在这个案例中，我们将创建一个名为零。0。2
    的标签。
- en: I'm going to name the release zero。0。2。 And if I'd like。 I could provide a description
    of this release， additional change like information。 And as I said。 it's going
    to automatically create an archive at this point that is downloadable， from GitHub。
    And this might be useful if users don't want to use pipi or are trying to bundle
    things。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我要把这个版本命名为零。0。2。如果我愿意，可以提供这个版本的描述和额外的更改信息。正如我所说，它将在此时自动创建一个可从 GitHub 下载的归档。这对那些不想使用
    pipi 或者试图捆绑东西的用户可能很有用。
- en: to go somewhere else。 It's just convenient。 And it doesn't take a lot extra
    for us。 And once I click that， Circle is going to notice the tag。 It's going to
    kick off a build called zero。0。2。 It's going to run test three， seven。 And upon
    a successful run， deploy is then going to run and publish the pipi。 And that's
    it。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 去别的地方。这很方便。而且对我们来说并不需要太多额外的工作。一旦我点击，Circle 就会注意到标签。它会启动一个名为零。0。2 的构建。它将运行测试三，七。在成功运行后，部署将运行并发布
    pipi。就这样。
- en: With that， you can publish the pipi。 You can automate the CI。 You can automate
    your test runs。 And with any luck， a few of you， hopefully all of you， are now
    package authors in Python。 And I sincerely look forward to whatever you can bring
    to our ecosystem。 [APPLAUSE]， Thank you。 Chris。 If there are any questions， we
    have a couple of microphones in the aisle。 So please queue up。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，你可以发布 pipi。你可以自动化 CI。你可以自动化测试运行。希望你们中的一些人，甚至所有人，现在都是 Python 的包作者。我真诚期待你们能为我们的生态系统带来什么。[鼓掌]，谢谢你，克里斯。如果有任何问题，我们在过道上有几个麦克风。请排队。
- en: And please ask questions in the form of a question。 Comments can be saved for
    the whole way after。 Thank you。 Would you structure your setup。py differently
    for applications versus libraries？
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请以问题的形式提问。评论可以在之后的过程中保存。谢谢。你会为应用程序和库结构化你的 setup.py 不同吗？
- en: I'm sorry， I couldn't。 Would you structure your setup。py？
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对不起，我无法做到。你会如何结构化你的 setup.py？
- en: Would you do anything different for libraries versus your application？
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你会对库和应用程序做不同的处理吗？
- en: Because it's a command line application versus it's a library。 And if I was
    making a CLI based thing for a pip， like something that you just click。 not particularly，
    there are some considerations when you start to do things beyond those packages。
    There are additional tools that exist to make sure everything is included。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它是一个命令行应用程序，而不是一个库。如果我在为 pip 创建一个基于 CLI 的东西，比如你只需点击的东西。并不是特别的，开始做超出那些包的事情时，有一些考虑。还有额外的工具来确保一切都包括在内。
- en: So it's not so much that I would structure it differently， but I might consider
    more。 exactly specifying the content I need。 So there are multiple ways to do
    this in Python。 You can include package data。 You can also use a thing called
    a manifest。in file to help make sure you get all the content。 But as far as the
    setup， the pie goes， no。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我并不是说我会以不同的方式来结构化它，但我可能会考虑更准确地指定我需要的内容。在 Python 中有多种方法可以做到这一点。你可以包含包数据。你也可以使用一种叫做
    manifest.in 的文件来帮助确保你获得所有内容。但就 setup.py 而言，没有。
- en: it's mostly the same。 And you mentioned you have a bunch of packages that you
    maintain。 How do you release them when there are interdependencies across packages？
    So there's a long answer。 but the short answer is very carefully。 You do your
    best to not have the situations。 Really you just have to stage releases。 And sometimes
    it means releasing things twice。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上是一样的。你提到你维护很多包。那当这些包之间有互依赖时，你是如何发布它们的？这个问题的答案很长，但简短的答案是非常小心。你尽量避免这种情况。实际上，你只能阶段性发布。有时这意味着要发布两次。
- en: if I'm completely honest。 Sometimes it does mean that package A has to go out。
    so package B can go out， and then， package A has something else again。 That is
    a talk。 How did you handle credentials in CircleCI for the upload？ Yeah， so in
    CircleCI。 I alighted that because it made this slide entirely too long。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我完全诚实，有时这确实意味着包A必须发布，以便包B可以发布，然后包A又有其他内容。这是一个话题。你是如何处理CircleCI中上传的凭证的？是的，在CircleCI中，我省略了这个，因为这使得幻灯片变得过长。
- en: The easiest way to do it is CircleCI has the ability to have environment variables。
    And so as an environment variable， you can put your password。 And then you can
    echo into a pie PIRC at runtime inside the virtual environment。 That's the most
    common way to do that。 It works pretty well。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是CircleCI具有环境变量的能力。因此，作为环境变量，你可以放入你的密码。然后你可以在虚拟环境中运行时echo到一个PIRC。这是最常见的做法，效果很好。
- en: but it would have taken up about half of the slide to show that。 And it's not
    really interesting to look at。 My hope moving forward， one of the features。 kind
    of a plug here。 Anyone coming for sprints， one of the topics is adding API keys
    to pie PI and the system。 So if you're interested in that， please stop by。 It's
    something we'd like to get to， for me。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但这大约需要占用幻灯片的一半来展示。而且看起来并不特别有趣。我希望在未来的一个功能上，有一个补充。任何参与冲刺的人，其中一个主题是将API密钥添加到pie
    PI和系统中。如果你对此感兴趣，请过来一下。这是我们希望实现的事情。
- en: I would feel a lot more comfortable doing that， than giving my user name and
    password to my full account。 Yeah， good question。 So how do you deal with having
    multiple test runs in， say。 CircleCI or Jenkins when you， have Nox， which runs
    all of the different versions at once？ Yeah。 so the way it was dealt with here
    is that we had three different Docker containers。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我会觉得这样做更让人放心，而不是把我的用户名和密码给我的完整账户。是的，好问题。那么你是如何处理在CircleCI或Jenkins中进行多个测试运行的呢，比如当你有Nox时，它同时运行所有不同版本？是的，这里处理的方法是我们有三个不同的Docker容器。
- en: one of which would be three five， one of which would be three six， one of which
    would be three。 seven， and Nox would run in all of them。 And if Nox doesn't detect
    a Python environment。 it just skips the run。 It doesn't fail。 It just assumes
    it shouldn't have bothered running。 The way I handle this in my day job is we
    manage a custom image that has all of the versions。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个将是3.5，另一个将是3.6，还有一个将是3.7，Nox会在它们中运行。如果Nox没有检测到Python环境，它就会跳过运行。它不会失败，它只是认为不应该运行。在我的日常工作中，我的处理方法是我们管理一个包含所有版本的自定义镜像。
- en: of Python， so we run it once。 And then Nox runs all of them。 There isn't really
    a strong reason to do one or the other besides the fact that you end。 up having
    to maintain Docker containers if you do it the way we do for my projects。 We did
    it the way we did it for mine is that it does result in a speed up in test runs。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们只运行一次。然后Nox运行所有版本。实际上，除了你最终需要维护Docker容器之外，做其中一个或另一个并没有强烈的理由。我们之所以以我的方式来做，是因为这确实加快了测试运行。
- en: and we run a lot of tests。 So it was just an optimization。 Hi， yeah。 With setup
    tools。 you have the ability to use a setup。config to set all those in a plain。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行了很多测试。所以这只是一个优化。嗨，是的。使用设置工具，你可以用一个setup.config在简单的环境中设置所有这些。
- en: '![](img/d4354276a889b9d2e0a5ce6f8024568f_13.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4354276a889b9d2e0a5ce6f8024568f_13.png)'
- en: text file。 Is there any drawbacks to doing it that way or benefits that you
    know of？
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 文本文件。你知道这样做有什么缺点或好处吗？
- en: Not particularly。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不是特别。
- en: '![](img/d4354276a889b9d2e0a5ce6f8024568f_15.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4354276a889b9d2e0a5ce6f8024568f_15.png)'
- en: For a beginning project， I don't think it's strictly necessary。 It depends a
    little bit too on if you're working on a binary distribution。 So everything I
    talked about here was about a pure Python world in which we're just writing。 Python
    code。 But it's not as common， but it's not uncommon to have a C extension in which
    the binary。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个初学项目，我认为这并不是严格必要的。这也取决于你是否在处理二进制分发。因此，我在这里讨论的都是关于纯 Python 世界的内容，我们只是编写 Python
    代码。但虽然不常见，但在某些情况下会有 C 扩展，其中的二进制。
- en: distributions， they get a bit hairier。 So the setup to config a very common
    thing to add is to specify what kind of B-dist we're。 going to do。 And it's a
    very specific thing like we want a universal wheel that's pretty common。 Like
    I said， you can also use manifest。in。 Some of this is personal style。 I find myself
    using those more when the setup to plug it's kind of long。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 分发会变得有些复杂。因此，设置以配置一个非常常见的事情是指定我们要做什么样的 B-dist。这是一个非常具体的东西，比如我们想要一个通用的 wheel，这很常见。正如我所说，你也可以使用
    manifest.in。部分内容是个人风格。当设置插件的过程比较长时，我发现自己更常使用这些。
- en: So if things start to feel unwieldy， I'll kind of tuck them out of the side。
    But for a lot of packages， it's just not strictly necessary。 A lot of them are
    rather simple and well contained。 You have a few methods on the public surface。
    So thank you。 Are there any more questions？ Thank you again， Chris。 [APPLAUSE]，
    (applause)。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事情开始感觉笨重，我会把它们稍微藏到一边。但对于很多包来说，这并不是严格必要的。它们中的很多相对简单且自成一体。你在公共表面上有几个方法。所以谢谢你。还有其他问题吗？再次谢谢你，克里斯。[掌声]，（掌声）。
- en: '![](img/d4354276a889b9d2e0a5ce6f8024568f_17.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4354276a889b9d2e0a5ce6f8024568f_17.png)'
