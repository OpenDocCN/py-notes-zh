- en: P66：Talk Russell Keith-Magee - Snakes in a case Packaging Python apps for distributi
    - 程序员百科书 - BV1rW4y1v7YG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P66：演讲者拉塞尔·基思-梅吉 - 装在箱子里的蛇 Python 应用程序的打包 - 程序员百科书 - BV1rW4y1v7YG
- en: Hi there， my name is Russell Keith McGearn。 I'm here today to talk to you about
    putting。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 嗨，大家好，我是拉塞尔·基思·麦基尔。今天我在这里谈论。
- en: '![](img/4fc7db36558521739c21bf7d5e291ee3_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fc7db36558521739c21bf7d5e291ee3_1.png)'
- en: your snakes into a briefcase for easy transportation。 I am speaking to you today
    from Wajuknunga。 Puchar， otherwise known as Perth Western Australia and I would
    like to recognise the。 Wajuknunga as the traditional owners of the land where
    I'm recording to recognise their。 continuing connection to their land， waters
    and culture and to pay my respects to their。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你的蛇放入公文包中以便于运输。我今天在 Wajuknunga Puchar 讲话，也就是西澳大利亚的珀斯，我想承认 Wajuknunga 是我录音时土地的传统拥有者，承认他们与土地、水域和文化的持续联系，并向他们致以我的敬意。
- en: builders past， present and emerging。 So last year at PyConUS in Cleveland， I
    had the very。 distinct honour of being the opening keynote and in that talk I
    spoke about the challenges。 facing Python as a language and the gaps that exist
    in our communities' tools。 One of those。 gaps relates to something that seems
    like it should have an obvious solution。 If you're。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 过去、现在和新兴的构建者们。所以去年在克利夫兰的 PyConUS 上，我有幸担任开幕主题演讲，在那次演讲中我讨论了 Python 作为一种语言所面临的挑战，以及我们社区工具中存在的差距。其中一个差距与似乎应该有明显解决方案的事情相关。如果你是。
- en: an author of some Python code and the time comes to give that code to somebody
    else so。 that they can run it， how do you do that？ There isn't a single simple
    answer to this。 problem and part of the reason is that distribution means different
    things to different people。 If you are an author of a library of code that is
    a collection of Python code that has。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为某些 Python 代码的作者，当需要将这些代码交给其他人以便他们运行时，该怎么做？对此问题没有单一简单的答案，部分原因是分发对不同的人意味着不同的东西。如果你是一个库的作者，那个库是一个
    Python 代码的集合，它有。
- en: a well-defined API that you want other people to embed into their own projects，
    Python does。 have a reasonably good answer for you and it's built in。 A project
    like Requests for。 example has a clear distribution story。 The project is configured
    with a set up。py and， a set up。cfg file and when the maintainers want to publish
    a new version they build a。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明确的 API，希望其他人能嵌入到他们自己的项目中，Python 对此有相当好的解决方案，并且它是内置的。例如，像 Requests 这样的项目有明确的分发故事。该项目配置了一个
    setup.py 和一个 setup.cfg 文件，当维护者想发布新版本时，他们会构建一个。
- en: wheel for that new version and upload the wheel to ppy。 As an end user you can
    then。 pip install requests and then import requests in your code and then start
    making requests。 Okay。 Python's packaging ecosystem occasionally has some rough
    edges but for the most part。 for most use cases thanks to the amazing efforts
    of the Python packaging authority tools like。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为那个新版本构建 wheel 并将其上传到 ppy。作为最终用户，你可以然后通过 pip 安装 requests，然后在你的代码中导入 requests，然后开始发起请求。好的。Python
    的打包生态系统偶尔会有一些粗糙的边缘，但在大多数情况下，得益于 Python 打包机构的出色努力，像。
- en: ppy and pip and twine work really reliably。 A second use case for distribution
    is a Python， project。 A project might have a version control repository or it
    might just be a collection。 of code in a directory somewhere but it won't be uploaded
    to ppy。py。 You get the code from。 the repository where you get a copy of the directory
    and you effectively run the repository。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ppy、pip 和 twine 的工作非常可靠。分发的第二个用例是一个 Python 项目。一个项目可能有版本控制仓库，或者它可能只是某个目录中的代码集合，但它不会被上传到
    ppy.py。你从你获取代码的仓库那里获得代码，或者获取目录的副本，然后有效地运行该仓库。
- en: or the directory。 A website like the pike on us website would be the classic
    example here。 but it's not a website specific phenomenon。 Other software can be
    distributed as a project。 A lot of Jupyter notebooks are projects in this sense。
    They are collections of code that。 aren't designed for commodified reuse。 They
    serve a single purpose。 These projects are。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 或者目录。像 pike on us 网站这样的例子在这里是经典的，但这并不是一个特定于网站的现象。其他软件也可以作为项目分发。许多 Jupyter 笔记本在这个意义上是项目。它们是代码的集合，并不是为了商品化的重用而设计。它们服务于单一的目的。这些项目是。
- en: distributed by copying and then deployed in some way。 The project isn't installed
    in。 any conventional sense。 They don't have a single Python mandated configuration
    either。 They may have some configuration in a requirements file but even that
    name is a little bit more。 than a convention and the problem of how you set up
    your execution environment is left。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过复制分发，然后以某种方式部署。项目并没有以任何传统意义上被安装。它们也没有单一的 Python 强制配置。它们可能在要求文件中有一些配置，但即使那个名字也只是一个约定，而如何设置执行环境的问题被留给用户。
- en: as a documentation issue and usually presumes some degree of familiarity with
    the Python。 development ecosystem。 Another use case for developer tools in the
    Python ecosystems tools。 like a Python Python test。 Python test for example is
    distributed on a library。 You can。 pip install in your development environment
    and you can import pip test to add fixtures。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个文档问题，通常假设用户对 Python 开发生态系统有一定的熟悉度。Python 生态系统中的开发工具的另一个用例是像 Python 测试这样的工具。例如，Python
    测试是通过一个库分发的。你可以在开发环境中 `pip install`，并可以导入 Python 测试以添加夹具。
- en: or parameterised test cases to your code base but because of metadata in the
    pip test。 will pip will also install an entry point that will let you invoke pip
    test from the， command line。 However it's not always as straightforward as this。
    If you've used GitHub。 pages you might have come across a static site generator
    called Jekyll。 Jekyll is written。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 或者将参数化测试用例添加到你的代码库，但由于 pip 测试中的元数据，pip 还将安装一个入口点，让你可以从命令行调用 pip 测试。然而，这并不总是那么简单。如果你使用过
    GitHub 页面，你可能遇到过一个叫 Jekyll 的静态网站生成器。Jekyll 是用。
- en: in Ruby and the quick starting instructions on the Jekyll homepage say that
    you should。 run gem install bundler jekyll。 Now I'm not a Ruby developer so what
    does that mean？ And。 when I find another Ruby tool that tells me to bundle other
    tool have I already installed。 bundle will the version that I have or be compatible
    with this new tool tells me that。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，Jekyll 首页的快速启动说明说你应该运行 `gem install bundler jekyll`。我不是 Ruby 开发者，这是什么意思？当我发现另一个
    Ruby 工具告诉我捆绑我已经安装的其他工具时，`bundle` 会与我拥有的版本兼容吗？
- en: I need to update my Ruby interpreter is Jekyll going to keep working。 Jekyll
    is written in。 Ruby but this isn't a problem about Ruby。 Python tools have exactly
    the same problem。 It's a distribution problem。 The language of implementation
    is of almost no significance。 to the end user。 The authors of pip test can be
    reasonably sure that you know something。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要更新我的 Ruby 解释器，Jekyll 还会继续工作吗？Jekyll 是用 Ruby 编写的，但这不是 Ruby 的问题。Python 工具也有完全相同的问题。这是一个分发问题。实现语言对最终用户几乎没有意义。pip
    测试的作者可以合理地确定你了解一些内容。
- en: about the Python ecosystem because pip test users are pretty much all going
    to be Python。 developers。 But what if your users aren't Python developers saying
    oh create a virtual。 environment and run pip install my tool that makes no sense
    to anybody who isn't already。 an experienced Python developer and to someone who
    is just starting with Python it's a consistent。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Python 生态系统，因为 pip 测试用户几乎都是 Python 开发者。但如果你的用户不是 Python 开发者，建议创建一个虚拟环境并运行
    `pip install my tool` 对于不熟悉的人来说毫无意义，对刚开始学习 Python 的人来说，这很一致。
- en: source of confusion。 And frankly it's not even a good user experience if your
    users。 are Python developers。 Take a tool like black for example with some exceptions
    you probably。 just need one copy on your computer。 When an update comes out you
    probably want to use。 that update everywhere。 But how do you install a Python
    tool like black globally if you install。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这让人感到困惑。坦率地说，如果你的用户是 Python 开发者，这甚至不是一个好的用户体验。以黑色工具为例，除了某些例外，你可能只需要在电脑上保留一份。当更新发布时，你可能想在所有地方使用该更新。但如果你安装一个
    Python 工具，比如黑色，怎么才能全局安装呢？
- en: it into your system Python then it won't be available or won't be reliable if
    you ever。 activate a virtual environment。 And what about graphical applications？
    Pick a random。 user space application on your laptop say slack。 What languages
    are written in？ Who cares？
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将它安装到系统 Python 中，那么如果你激活一个虚拟环境，它将不可用或不可靠。那么图形应用程序呢？在你的笔记本电脑上随机选择一个用户空间应用程序，比如
    Slack。它是用什么语言编写的？谁在乎？
- en: I'm not looking to engage with slack as a library。 I'm not looking to import
    slack。 I。 just want to use it。 I want to install it in a familiar way， click on
    an icon and have。 the application start reliably every time。 And if I update another
    application say Firefox。 I don't want my slack installed to break because Firefox
    updated a shared interpreter。 What。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不想将Slack作为一个库来使用，也不想导入Slack。我只是想使用它。我希望以熟悉的方式安装它，点击图标，每次都能可靠地启动应用程序。如果我更新另一个应用，比如Firefox，我不希望我的Slack安装因为Firefox更新了共享解释器而中断。
- en: an end user of these applications these apps does care about is ease of installation，
    ease。 of uninstallation， having the app appear in the start menu of the launchpad
    and potentially。 having that app appear and be downloadable via an app store and
    having it regularly updated。 via that channel。 Each of these types of tools has
    a different distribution requirement。 They。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用的最终用户关注的是安装的简便性、卸载的方便性、在启动菜单或启动板中出现，以及可能通过应用商店下载和定期更新的应用。每种类型的工具都有不同的分发要求。
- en: all need Python at a runtime but the only the first of these use cases really
    has a good。 answer for the Python ecosystem。 And even then that development story
    essentially presumes。 your Python developer who has a Python development environment
    and that you're comfortable manipulating。 it。 The question of how you give Python
    code to an end user when that end user doesn't。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都需要在运行时支持Python，但这些用例中只有第一个对Python生态系统有一个良好的答案。即使如此，该开发故事本质上假定你是一个拥有Python开发环境的Python开发者，并且你对操作它感到舒适。当最终用户不具备Python知识时，如何将Python代码提供给他们，这是一个重要的问题。
- en: care about Python or when they're not experts in setting up and configuring
    a Python environment。 that's a bit of an open question。 But it's a really important
    question。 It affects how。 users experience our code and it's great that we have
    a solution for the first use case。 but we need reliable solutions for the other
    three。 Personally， I'm especially interested。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可能对Python不太关心，或者在设置和配置Python环境时并非专家。这是一个有待探讨的问题。但这是一个非常重要的问题，它影响着用户体验我们的代码。我们对于第一个用例有了解决方案，但对于其他三个用例，我们需要可靠的解决方案。就个人而言，我对此特别感兴趣。
- en: in the last one and to a lesser extent， the third。 I'm the founder of the Bwe
    project。 which is an attempt to make sure that Python remains relevant in a computing
    world that。 is increasingly mobile focused。 If you are building applications for
    iPhone and Android。 the only unit of distribution is the app。 You can't pip install
    on an iPhone。 You can't。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一种情况下，以及在较小程度上的第三种情况。我是Bwe项目的创始人，旨在确保Python在一个越来越以移动为中心的计算世界中保持相关性。如果你正在为iPhone和Android构建应用程序，唯一的分发单元就是应用。你无法在iPhone上使用pip
    install。
- en: install a system copy of Python on your Android device and tell users to create
    a virtual environment。 If Python wants to remain relevant in a mobile world， we
    need a story that encompasses the。 distribution of apps and increasingly， while
    my primary interest is mobile platforms， the。 same story actually applies to desktop
    platforms to Mac。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Android设备上安装一个系统版Python，并告诉用户创建一个虚拟环境。如果Python想在移动世界中保持相关性，我们需要一个涵盖应用分发的故事。虽然我的主要兴趣在于移动平台，但同样的故事也适用于桌面平台，比如Mac。
- en: awesome windows have always had applications， but those platforms are increasingly
    encouraging distribution of apps as standalone sandbox。 bundles by app stores。
    What I'm going to do today is introduce you to the Bwe project solution。 for this
    problem。 And that solution is briefcase。 Briefcase is a tool for packaging， Python。
    applications。 It takes your Python code， wraps it up as a standalone unit that
    can be given。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊叹的Windows平台一直有应用程序，但这些平台日益鼓励将应用程序作为独立沙盒打包并通过应用商店分发。今天我将向你介绍Bwe项目的解决方案。这个解决方案就是Briefcase。Briefcase是一个用于打包Python应用程序的工具。它将你的Python代码打包成一个可以独立分发的单元。
- en: to an end user with no Python experience so that they can install it on their
    platform。 of choice without ever knowing that they're running Python code。 Briefcase
    is a PEP 518。 compliant build tool。 If you don't know what that means， I recommend
    checking out this。 blog post from Brett Cannon。 But the short version is that
    it means that it is a build。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是让没有Python经验的最终用户能够在他们选择的平台上安装它，而无需知道自己在运行Python代码。Briefcase是一个符合PEP 518的构建工具。如果你不知道这意味着什么，我建议你查看Brett
    Cannon的这篇博客文章。但简短版本是，它意味着这是一个构建工具。
- en: tool that uses PyProject。tonnel for configuration。 It produces MSI installers
    for Windows， DMG。 or raw app bundles for MacOS， app images on Linux， and it produces
    iOS and Android projects。 that can be uploaded to the Apple App Store or the Google
    Play Store。 It's also highly， extensible。 If you wanted to add a flat pack or
    snap back in for Linux， you could， or if。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具使用 PyProject 进行配置。它为 Windows 生成 MSI 安装程序，为 MacOS 生成 DMG 或原始应用捆绑包，为 Linux
    生成应用镜像，并为 iOS 和 Android 生成可以上传到 Apple App Store 或 Google Play Store 的项目。它还具有很高的可扩展性。如果你想为
    Linux 添加 Flatpak 或 Snap，你可以做到，或者如果。
- en: you wanted to support an entirely new platform like a set top box or watches，
    you could do。 that too。 Now， while it pairs well with Bwe's GUI framework toga，
    it doesn't require it。 You can wrap PySide or TK interapps with Briefcase。 The
    caveat on that claim is that Briefcase's。 capabilities are only as good as the
    frameworks themselves。 Briefcase is a packaging tool。 It。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想支持一个全新的平台，比如机顶盒或手表，你也可以做到。现在，虽然它与 Bwe 的 GUI 框架 toga 配对良好，但并不要求使用它。你可以用 Briefcase
    包装 PySide 或 TK 应用。这个说法的警告是，Briefcase 的能力仅与框架本身一样好。Briefcase 是一个打包工具。
- en: won't make your TK interapp work on mobile because TK hasn't been ported to
    mobile。 Briefcase also isn't a good match for command line tools， at least not
    yet。 It could potentially。 be adapted for command line use and I'm personally
    very interested in seeing that use case supported。 but it's not obvious to me
    at the moment exactly what that support would look like。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不会让你的 TK 应用在移动设备上工作，因为 TK 还没有移植到移动平台。Briefcase 对于命令行工具也不太适合，至少目前还不是。它有可能被调整为命令行使用，我个人非常希望看到这种用例得到支持，但目前我还不清楚这种支持会是什么样子。
- en: This is mostly a function of how Briefcase works under the hood。 The approach
    used by。 Briefcase is essentially the dumbest thing that could possibly work for
    the problem of。 app distribution。 A Briefcase application is a full copy of your
    Python code， a full copy。 of all your code's dependencies， and a full copy of
    a full Python interpreter bundle in。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是 Briefcase 如何在后台工作的功能。Briefcase 所采用的方法本质上是解决应用分发问题的最简单方式。一个 Briefcase 应用是你
    Python 代码的完整副本、所有代码依赖的完整副本，以及一个完整的 Python 解释器捆绑包的副本。
- en: a way that makes sense for the platform you are supporting。 And that's it。 Briefcase
    is。 mostly a templating tool combined with wrappers around PIP to install your
    Python dependencies。 and wrappers around whatever native platform tools are necessary
    to build DMG or MSI files。 or sign applications for distribution。 Now， Briefcase
    isn't the only application packaging。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以适合你所支持的平台的方式进行。这就是了。Briefcase 主要是一个模板工具，结合了围绕 PIP 的包装器来安装你的 Python 依赖，以及围绕构建
    DMG 或 MSI 文件所需的任何本地平台工具的包装器，或者签署分发的应用程序。现在，Briefcase 并不是唯一的应用打包工具。
- en: tool that exists in Python， so why should you use Briefcase and not one of the
    other， options？ Well。 firstly， it doesn't try to be clever。 Some alternatives
    to Briefcase like。 Pyoxidizer or Py installer and some modes of operation can
    involve getting a working app。 with making an executable。 And if the support，
    the aim of making the executable， they play。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具是 Python 中存在的，那么你为什么要使用 Briefcase 而不是其他选项呢？首先，它并不试图显得聪明。Briefcase 的一些替代品，比如
    Pyoxidizer 或 PyInstaller 和一些操作模式，可能涉及通过生成可执行文件来获得一个工作应用。如果支持的目标是生成可执行文件，它们的表现。
- en: all sorts of trip trips with your code， bundling it into a zip archive， it's
    embedded into the。 data block and then executable， it's unpacked into memory at
    runtime。 And when that works。 it's great。 But it doesn't always work because fundamentally
    Python code is designed to be。 run by passing an interpreter over a directory
    of code。 Okay， if you know enough about Python's。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它会对你的代码进行各种打包，将其捆绑成一个 zip 压缩档案，嵌入到数据块中，然后可执行文件在运行时被解压到内存中。当这一切顺利时，它非常棒。但它并不总是有效，因为从根本上讲，Python
    代码是通过将解释器传递给代码目录来运行的。好吧，如果你对 Python 的知识足够深入。
- en: import system or you know， you know that that's not strictly true。 But if you've
    got enough。 practical experience with Python in the real world， you know that
    it is close enough to。 being true in practice and makes no difference。 If you
    don't believe me， all I have to say。 is zip save X。 And on the other hand， Briefcase
    runs Python the way Python was designed to。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 导入系统，或者你知道，这并不完全正确。但如果你在现实世界中对 Python 有足够的实践经验，你会知道在实际应用中这足够接近真实，并且没有区别。如果你不相信我，我只需说“zip
    save X”。另一方面，Briefcase 以 Python 被设计的方式运行 Python。
- en: be run an interpreter running over a directory of source code。 The only thing
    Briefcase does。 is automate the process of getting that working interpreter to
    an end user in a way that doesn't。 require them to know anything about Python。
    Briefcase is also cross platform， which means。 that you have a single configuration
    file that produces in stores for MacOS， Windows， Linux。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一个解释器，该解释器在源代码目录上运行。Briefcase 所做的就是自动化将工作解释器交付给最终用户的过程，这样他们无需了解任何关于 Python
    的知识。Briefcase 也是跨平台的，这意味着你有一个单一的配置文件，可以在 MacOS、Windows、Linux 上生成和存储。
- en: iOS and Android。 And that means you don't have duplicated configurations for
    distributing， your app。 removing a potential source of error。 Okay， so enough，
    Jack shaving， show me the， code。 What I'm going to do today， we'll do now is walk
    you through the life cycle of。 packaging a project with Briefcase。 If you want
    a more detailed walk through the be where。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 和 Android。这意味着你不需要为分发应用程序而重复配置，从而消除潜在的错误来源。好吧，够了，Jack，给我看看代码。今天我要做的是带你了解使用
    Briefcase 打包项目的生命周期。如果你想要更详细的说明，be where。
- en: tutorial at docs。bwe。org has a fully walked work demo that gives a lot more
    explanation。 that I'm going to be able to give you in 25 minutes。 So let's start
    a new project。 We。 had a new virtual environment and we installed Briefcase。 I
    am giving the instructions here。 with unique conventions， but Briefcase does also
    work on Windows。 The be where tutorial。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 docs.bwe.org 的教程中有一个完整的演示，提供了比我在 25 分钟内能够给你的更多解释。那么，让我们开始一个新项目。我们创建了一个新的虚拟环境，并安装了
    Briefcase。我在这里提供的指令使用了独特的约定，但 Briefcase 也可以在 Windows 上运行。这个教程。
- en: gives the commands for both if you've got how to convert。 If you want to start
    a completely。 new project， Briefcase has a wizard to help you run Briefcase new
    and you'll be presented。 with a list of questions with some explanatory text。
    And you'll be prompted for a bunch of， details。 You'll be prompted for a formal
    name。 That's the name that you show to humans as。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了两者的命令，如果你知道如何转换。如果你想从头开始一个全新的项目，Briefcase 有一个向导来帮助你运行 Briefcase new，系统会给出一系列问题及一些解释文本。你将被提示输入一些详细信息。你将被提示输入正式名称。那是你向人们展示的名称。
- en: the name of your app and an app name， which is the Pythonized version of your
    name， something。 you would pip install。 You'll be asked for a bundle。 Let's use
    for namesbasing to separate。 my hello world from your hello world。 But the bundle
    ID is a common format used by app， stores。 It's usually a reversed ordering of
    a domain name that you control。 That bundle。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序的名称，以及一个应用程序名称，这是你名称的 Python 版本，类似于你会 pip install 的东西。你将被询问一个捆绑 ID。我们使用命名空间来区分我的
    hello world 和你的 hello world。但是捆绑 ID 是应用商店使用的常见格式。通常是你控制的域名的反向排序。该捆绑。
- en: is then combined with an app name to make a full bundle ID for your app。 So
    org。bware。hello， world。 for example。 You'll be asked for a project name。 A Briefcase
    project can include。 multiple distributed apps。 So you can build multiple app
    bundles from a single code repository。 But if you're only going to have one app，
    you can use the formal name as your project， name。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其与应用程序名称结合，形成应用程序的完整捆绑 ID。例如，org.bware.hello，world。系统会要求你输入项目名称。Briefcase
    项目可以包含多个分布式应用程序。因此，你可以从一个代码库构建多个应用程序包。但如果你只打算有一个应用程序，可以使用正式名称作为项目名称。
- en: You'll be asked for a one line description of the project。 You'll be asked for
    the author's。 name and emails as used in help text and copyright labels。 A URL
    for the project。 A license because。 of his derivative code。 You need a license。
    And lastly， a GUI framework。 Briefcase provides。 a template for toga。 Bewares
    own GUI framework。 But there's also a pie side template as well。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会要求你提供项目的一行描述。你将被询问作者的姓名和电子邮件，用于帮助文本和版权标签。项目的 URL。由于其衍生代码，你需要一个许可证。最后，一个 GUI
    框架。Briefcase 提供了一个 toga 的模板，这是 Bewares 自己的 GUI 框架。但也有一个 pie 侧模板。
- en: as an empty app that you can fill with whatever framework you happen to want
    to use。 And what。 you'll get at the end of the day is a complete stub project，
    including enough code to start， an app。 application icons and a variety of formats
    and some project metadata。 You'll also。 notice that the DASH， the application
    name here has been normalized and underscored。 So the app。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个空应用程序，你可以填充任何你想要使用的框架。最终你将得到一个完整的模板项目，包含足够的代码来启动应用程序，应用程序图标和多种格式以及一些项目元数据。你还会注意到，DASH，即这里的应用程序名称，已经被规范化并下划线处理。因此该应用程序。
- en: name Hello Dash world has been converted into Hello Underscore world when it
    becomes a source code。 directory。 You also get the same files， regardless of what
    GUI framework you pick。 The only difference， with the contents of the app。py，
    the main。py。 and some of the values in the PyProject。com。 The， metadata that is
    of particular interest here is in PyProject。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 Hello Dash world 在转换为源代码目录时变为 Hello Underscore world。无论你选择什么 GUI 框架，你都将获得相同的文件。唯一的区别在于
    app.py、main.py 和 PyProject.com 中的一些值。特别感兴趣的元数据在 PyProject 中。
- en: com。 That's the file that contains， all the details about your app。 The contents
    of this file will match the answers that you gave， in the wizard。 There's a build
    system section which is a requirement of PEP518 that declares。 that this is a
    briefcase project。 And all the briefcase options are then defined in a tool。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: com。这是包含你应用程序所有细节的文件。该文件的内容将与你在向导中提供的答案相匹配。有一个构建系统部分，这是 PEP518 的要求，声明这是一个 briefcase
    项目。所有 briefcase 选项在工具中定义。
- en: briefcase， section。 The project level options are defined in that root level
    tool。briefcase。 Individual， applications then have their own sections。 So this
    configuration file defines Hello Dash world， as an app。 That's the app name with
    a formal name of Hello world and so on。 The configuration。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: briefcase 部分。项目级选项在根级工具 briefcase 中定义。各个应用程序有自己的部分。因此，这个配置文件将 Hello Dash world
    定义为一个应用程序。那是应用程序名称，正式名称为 Hello world 等等。配置。
- en: for the Hello world app is comprised or is composed out of the project settings
    overridden by the。 application settings。 So the Hello world app will inherit the
    project level version definition。 And if you wanted to have a different author
    name for this application。 you could do so by adding an， author name into the
    app's configuration block。 And to be clear。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Hello world 应用程序由项目设置和应用程序设置覆盖而组成。因此，Hello world 应用程序将继承项目级版本定义。如果你想为这个应用程序设置不同的作者名称，可以在应用程序的配置块中添加一个作者名称。为了明确。
- en: this is a briefcase specific， behavior。 Not something you'll see and necessarily
    see anyway。 Another PEP518 tools。 There are two， exceptions to this overriding
    behavior， source and requires。 Sources defines the list of directories， of source
    code that you want to include in your application。 So here we're saying that the
    source， Hello world directory is part of this application。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特定于 briefcase 的行为。并不是你会看到的，或者一定会看到的其他 PEP518 工具。对于这种覆盖行为，有两个例外，source 和
    requires。Sources 定义了你想要包含在应用程序中的源代码目录列表。所以这里我们说 source 目录 Hello world 是这个应用程序的一部分。
- en: That entire folder will be copied recursively， into our packaged application。
    The only requirement on this is that one of your source directories。 needs to
    match the name of your application itself。 Requires defines the Python requirements
    for。 your application。 Again， this is just as a list using the same format that
    you'd use as an argument。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 整个文件夹将递归复制到我们打包的应用程序中。唯一的要求是你的源目录之一需要与应用程序的名称匹配。Requires 定义了你应用程序的 Python 需求。同样，这只是一个列表，使用你作为参数时相同的格式。
- en: to pip install。 Sources and requires a cumulative setting。 So if you specify
    a sources definition。 at the project level， any application level sources will
    be appended to that list defined。 at the project level。 Icons also deserve a special
    mention here。 You'll notice that the icon setting， doesn't include a file format
    extension。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 pip。Sources 和 requires 是累积设置。因此，如果你在项目级别指定 sources 定义，任何应用程序级别的 sources 将附加到项目级定义的列表中。图标在这里也值得特别提及。你会注意到图标设置不包含文件格式扩展名。
- en: That's because briefcase uses the provided value as a。 base name and appends
    the format depending upon the platform。 So 。ico for windows。png for the。 next
    and so on。 Of some platforms， you have to provide multiple icons in multiple resolutions。
    and those size modifiers will be appended to the file name as well as the extension。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 briefcase 使用提供的值作为基本名称，并根据平台附加格式。因此，Windows 用 .ico，其他平台用 .png，等等。在某些平台上，你必须提供多个分辨率的图标，这些尺寸修饰符将附加到文件名以及扩展名上。
- en: You can also specify options that are platform specific by adding a configuration
    section for。 that platform。 The generated pip project。tom will include a section
    for all of the supported platforms。 MacOS， Linux， Windows， iOS and Android。 So
    here we've specified a pytool。briefcase。app。helloworld。macos， section。 Those options
    will only apply to MacOS builds of this app。 Now again。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过为该平台添加一个配置部分来指定平台特定的选项。生成的 `pip project.toml` 将包含所有受支持平台的部分，包括 MacOS、Linux、Windows、iOS
    和 Android。因此在这里我们指定了 `pytool.briefcase.app.helloworld.macos` 部分。这些选项将仅适用于该应用的
    MacOS 构建。现在再一次。
- en: sources and requires a cumulative or other settings will override an app level
    or project level。 that values。 The content here is what you get if you pick toga
    in the wizard， but you'll get。 different content if you pick PySide or no。 You
    can actually even go and lay it deep。 Still。 if you define a tool。briefcase。app。helloworld。macos。dng，
    those settings will only apply to。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码和需求的累积或其他设置将覆盖应用级或项目级的值。如果你在向导中选择了 Toga，这里是你得到的内容，但如果你选择了 PySide 或其他选项，你会得到不同的内容。实际上你甚至可以深入进行设置。如果你定义一个
    `tool.briefcase.app.helloworld.macos.dng`，这些设置将仅适用于。
- en: dng builds on MacOS。 You might do this to specify an icon for the dng installer，
    for example。 And if you wanted to add a second app to your project definition，
    you can define a tool。briefcase。app。secondapp， section and then so on for platform
    and packaging formats and so on。 Now this stub pyproject。pomel file has been generated
    for you by briefcase new， but you don't。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: DNG 在 MacOS 上构建。例如，你可能会这样做来为 DNG 安装程序指定一个图标。如果你想将第二个应用添加到你的项目定义中，你可以定义一个 `tool.briefcase.app.secondapp`
    部分，然后依此类推，适用于平台和打包格式等。现在，这个存根的 `pyproject.toml` 文件是由 `briefcase new` 为你生成的，但你不需要。
- en: have to use that wizard。 If you've got an existing project， you can roll your
    own py project。pomel。 from scratch。 So however you've created it， you've now got
    a briefcase configuration file。 How do we use it？ Well， the first thing you probably
    want to do is just see if your app runs。 Briefcase includes a developer mode，
    which lets you rapidly iterate on your configuration。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不必使用那个向导。如果你有一个现有项目，你可以从头开始滚动自己的 `pyproject.toml`。所以无论你是如何创建的，现在你都有一个 Briefcase
    配置文件。我们如何使用它？好吧，你可能想做的第一件事就是查看你的应用是否能运行。Briefcase 包括一个开发者模式，让你可以快速迭代你的配置。
- en: If you run briefcase dev， briefcase will use your pyproject。pomel to work out
    how to run your project， and then run it in your local virtual environment。 First
    time you do this， it will look at your， configuration file。 install all of your
    declared requirements， and then it will install your app。 Now。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 `briefcase dev`，Briefcase 将使用你的 `pyproject.toml` 来确定如何运行你的项目，然后在你的本地虚拟环境中运行它。第一次这样做时，它会查看你的配置文件，安装所有你声明的依赖项，然后安装你的应用程序。现在。
- en: keep in mind the design motivation for briefcase。 The dumbest thing that can
    possibly work。 Briefcase dev is nothing more than shorthand for a pip install
    for a list of requirements for。 your current platform， followed by Python minus
    M hello world running your application。 On subsequent runs， the dependency step
    won't be executed by default。 Briefcase will only start。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住 Briefcase 的设计动机。能够工作的最简单事情。`Briefcase dev` 仅仅是你当前平台的需求列表的 `pip install`
    的简写，接着是 `python -m hello world` 来运行你的应用程序。在后续的运行中，依赖步骤默认不会被执行。Briefcase 只会启动。
- en: the project， just by itself。 If you add or modify dependency， you'll need to
    add it minus D flag to。 force an updated dependencies。 And if you've used the
    wizard， what you'll get is a working。 application。 It will be an empty window，
    but it'll be a working application。 And you can now iterate， on the code in your
    app， adding features， fixing bugs。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 项目，仅此而已。如果你添加或修改了依赖项，你需要添加 `-D` 标志以强制更新依赖项。如果你使用了向导，你得到的将是一个工作中的应用程序。它将是一个空窗口，但它将是一个工作应用程序。现在你可以在你的应用中迭代，添加功能，修复错误。
- en: whatever you need to do。 Eventually， though， the time will come when you're
    ready to package your app for distribution。 The first step， will be to create
    your app。 And to do this， you need to invoke briefcase create。 This will do a，
    bunch of things。 First， it will look at the platform you're currently on and get
    an application template。 for that platform。 So I'm running on MacOS， so it will
    use the MacOS DNG template。 Secondly。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你需要做什么。不过，最终会有一天你准备好将你的应用打包以供发布。第一步将是创建你的应用。为此，你需要调用 `briefcase create`。这将执行一系列操作。首先，它会查看你当前使用的平台并获取该平台的应用模板。因此，我正在
    MacOS 上运行，所以它会使用 MacOS 的 DNG 模板。其次。
- en: it will obtain a support package。 A support package is a version of Python that
    can be embedded into。 your app。 For Windows， we use the officially distributed
    Python embedded package for every other platform。 be where maintains a support
    package。 Whatever your platform， Briefcase will download the support。 package，
    unpack it into the application template that was just created。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它将获取一个支持包。支持包是可以嵌入到您的应用程序中的Python版本。对于Windows，我们使用官方分发的Python嵌入包，对于其他每个平台，都会维护一个支持包。无论您的平台如何，Briefcase将下载支持包，将其解压到刚刚创建的应用程序模板中。
- en: Briefcase then downloads and， installs your app's dependencies。 but it doesn't
    install them into your local virtual environment。 installs them into the application
    template。 Briefcase then installs the application specific bits。 all the source
    code for your app and all the application resources like icons。 And then it's，
    done。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Briefcase接着下载并安装您应用程序的依赖项，但它并不将它们安装到您的本地虚拟环境中，而是安装到应用程序模板中。Briefcase然后安装特定于应用程序的部分，包括您应用程序的所有源代码和所有应用程序资源，如图标。然后一切就完成了。
- en: You've now got a complete application template。 Your project directory will
    now contain a platform。 folder。 So a folder called MacOS in this case， inside
    that folder will be a folder for every app。 in your project。 The next step is
    to build that app。 And I'm sure you'll be shocked to hear the。 commander do this
    his briefcase build。 Now on MacOS。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在有了一个完整的应用程序模板。您的项目目录现在将包含一个平台文件夹。因此在这种情况下，会有一个名为MacOS的文件夹，在这个文件夹内将有您项目中每个应用程序的文件夹。下一步是构建该应用程序。我相信您会震惊地听到指挥官做这个briefcase构建。现在在MacOS上。
- en: this actually does nothing because an application。 or the application template
    that was generated is actually executable as is。 A MacOS app is nothing。 more
    than a directory in a particular format with some metadata in a known location。
    On other。 platforms， there may be some compilation that needs to be done here。
    Briefcase manages invoking。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上这并没有做任何事情，因为生成的应用程序或应用程序模板实际上是可以执行的。一个MacOS应用程序不过是一个特定格式的目录，包含一些位于已知位置的元数据。在其他平台上，可能需要在这里进行一些编译。Briefcase负责调用。
- en: that compiler。 And at this point， there will be a folder in your project matching
    a platform and。 that folder will be an application along with any files created
    as part of that build process。 In this case， it's a MacOS app。 If you were to
    click on that icon， an application would start。 Or you could keep it all console
    based and use briefcase。 You can run your app with， you missed it。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 那个编译器。到此为止，您的项目中将有一个与平台匹配的文件夹。这个文件夹将是一个应用程序，以及作为构建过程一部分创建的任何文件。在这种情况下，它是一个MacOS应用程序。如果您点击那个图标，一个应用程序将启动。或者您可以保持所有操作在控制台中，使用briefcase。您可以运行您的应用程序，您错过了它。
- en: briefcase run。 And what you should see is a running application。 Now。 it is
    not a very interesting application， but it is a running application， whatever
    that means。 on your platform of choice on MacOS。 That means an icon in your taskbar，
    an application menu。 matching your application name。 The last step is to package
    your app with briefcase package。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: briefcase run。您应该看到一个正在运行的应用程序。现在，这不是一个非常有趣的应用程序，但它确实是一个正在运行的应用程序，无论这在您选择的平台上意味着什么。在MacOS上。这意味着在您的任务栏中有一个图标，应用程序菜单与您的应用程序名称匹配。最后一步是用briefcase
    package打包您的应用程序。
- en: This does any final packaging that has to be done before distribution， so creating
    an installer。 doing code signing and so on。 Code signing support is currently
    in the early stages of development。 Only MacOS apps are currently signed and they're
    currently only signed， not not， notarized。 If you know what that means， this is
    an area where more work is needed， but the pieces。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在分发之前完成所有最终打包工作，因此创建安装程序，进行代码签名等等。目前，代码签名支持还处于开发初期阶段。目前只有MacOS应用程序被签名，并且它们仅仅是签名，而不是公证。如果您知道这意味着什么，这个领域仍需要更多的工作，但这些部分。
- en: are all in place。 But after packaging， the platform folder in your project will
    contain。 an artifact that could be uploaded for distribution， a DNG file， an MSI。
    whatever is appropriate for， the platform of choice。 So we have packaged our app
    and we discover a problem。 We need to update， our code。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都已就绪。但是在打包之后，您项目中的平台文件夹将包含一个可以上传进行分发的工件，可能是一个DNG文件，MSI文件，或其他适合您选择的平台的文件。因此，我们已经打包了我们的应用程序，并发现了一个问题。我们需要更新我们的代码。
- en: Do we need to go through this whole process again？ No， for that， there is briefcase，
    update。 By default， this will reinstall just the code for the app。 If you want
    to update the。 dependencies as well， you can specify -d。 If you want to update
    the application resources like。 icons， you can specify -r。 Some other features
    of briefcase that are worthy of note。 Briefcase。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否需要再次经历整个过程？不，针对这一点，有**briefcase**，更新。默认情况下，这将仅重新安装应用程序的代码。如果您还想更新依赖项，可以指定-d。如果您想更新应用程序资源，比如图标，可以指定-r。**briefcase**的一些其他值得注意的功能。
- en: create is a shorthand。 Your platform is implied from the platform where you
    are currently running。 the code。 The output format is the default output format
    for that platform。 If you want a Mac。 briefcase create is shorthand for briefcase
    create MacOS DNG。 Now。 if you wanted to create a different， output format， say
    you wanted a raw app， not a DNG file。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: create是一个简写。您的平台是从您当前运行代码的平台隐含得出的。输出格式是该平台的默认输出格式。如果您想要一个Mac，**briefcase create**是**briefcase
    create MacOS DNG**的简写。现在，如果您想创建一个不同的输出格式，比如您想要一个原始应用，而不是DNG文件。
- en: you can invoke briefcase create MacOS， app。 And if you wanted to target a completely
    different platform。 briefcase create platform。 Now， in practice， that's not especially
    useful because you can't create a MacOS DNG or Windows。 or a Windows MSI or Mac
    because the tools required are platform specific。 But there is one important，
    use case for it and we'll come to that in a moment。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 调用**briefcase create MacOS app**。如果您想要针对一个完全不同的平台，可以使用**briefcase create platform**。但在实践中，这并不是特别有用，因为您无法创建MacOS
    DNG或Windows，或Windows MSI或Mac，因为所需工具是平台特定的。但这有一个重要的用例，我们马上会提到。
- en: Briefcase will also imply early steps if they are， needed。 If you have a completely
    fresh project straight out of briefcase new and you run briefcase， run。 briefcase
    will detect that there is an attempt late and create it and then build it and
    then run。 it。 Briefcase run also allows for a -u-oxy that updates the app before
    execution。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**briefcase**还会在需要时隐含早期步骤。如果您有一个完全新项目，直接从**briefcase new**中创建并运行**briefcase
    run**，**briefcase**将检测到存在延迟尝试，创建它，然后构建并运行它。**briefcase run**还允许使用-u-oxy，在执行前更新应用。'
- en: So your development， cycle could be as short as briefcase run -u over and over
    again。 Briefcase also checks whether you've， got the necessary tools to compile
    and if possible。 manages downloading those tools for you， accepting， any licenses
    and so on。 If you can't install the tools for you， like it can't on MacOS， you've。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您的开发周期可以简短到不断重复**briefcase run -u**。**briefcase**还会检查您是否具备编译所需的工具，并在可能的情况下为您管理下载这些工具，接受任何许可等。如果您无法为自己安装工具，比如在MacOS上无法安装，您可以。
- en: got to get Xcode through the app store， it will at least tell you explicitly
    which tools you need。 to get and where you go to get them。 And if you're ever
    unsure what your options are， you can add。 -help and get a full rundown。 Now，
    the other thing that briefcase does that I haven't mentioned so far。 deploying
    to mobile platforms。 This is the one place where specifying a platform does work
    and。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 必须通过应用商店获取Xcode，它至少会明确告诉您需要获取哪些工具以及去哪里获取。如果您对选项不确定，可以添加-help并获取完整概述。现在，**briefcase**还有一个我尚未提到的功能，即部署到移动平台。这是指定平台有效的唯一地方。
- en: is necessary。 If you want to create an iOS app， the steps are exactly the same
    as creating any。 other app you just add iOS to all the commands to specify a different
    platform。 Briefcase create。 iOS， briefcase build iOS and so on。 Similarly for
    Android， briefcase create Android。 iOS builds only， work on MacOS because of the
    underlying tooling requirements but Android builds will work on。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建一个iOS应用，步骤与创建其他任何应用完全相同，您只需在所有命令中添加iOS以指定不同的平台。**briefcase create iOS**、**briefcase
    build iOS**等等。对于Android也是如此，**briefcase create Android**。iOS构建仅在MacOS上有效，因为底层工具要求，但Android构建将有效。
- en: MacOS， Linux all in those。 The build and run steps are also slightly different。
    When you compile an。 application， you need to target a specific device。 If you
    run briefcase run iOS。 briefcase will inspect， your system， find out what devices
    are available。 ask you what device you want to target。 If you， shortcut that。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: MacOS、Linux等平台的构建和运行步骤也略有不同。当您编译一个应用时，需要针对特定设备。如果您运行**briefcase run iOS**，**briefcase**将检查您的系统，找出可用的设备，并询问您想要针对哪个设备。如果您。
- en: if you want to shortcut that question， you can specify -d to give a device id
    or a device。 description like an iPhone 11， iPhone 11 running iOS 11。3。 There's
    any ambiguity， say if you've got。 multiple iPhone 11 simulators running， you'll
    be asked to resolve the discrepancy。 Android does the。 same thing， creating Android
    simulators for you or emulator for you， starting as emulator as it。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想简化这个问题，可以指定 -d 来提供设备 ID 或设备描述，例如 iPhone 11，运行 iOS 11.3 的 iPhone 11。如果有任何歧义，比如你有。多个
    iPhone 11 模拟器在运行，你将被要求解决这个不一致。Android 也做同样的事情，为你创建 Android 模拟器或模拟器，从模拟器开始。
- en: necessary。 Once your app is running， it is running as normal Python code running
    in the normal Python。 way。 But it might be useful to get access to some of this
    packaging metadata at runtime and to support。 this briefcase generates PEP 566
    compliant packaging metadata。 If you've got a hello world app。 you can， use importlib。medadata
    to access your briefcase metadata。 Importlib。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的应用运行，它就以正常的 Python 代码在正常的 Python 中运行。但在运行时获取一些打包元数据可能是有用的，支持这个 briefcase
    生成符合 PEP 566 的打包元数据。如果你有一个 Hello World 应用，你可以使用 importlib.metadata 来访问你的 briefcase
    元数据。Importlib。
- en: medadata was added in Python 3。8， but there is a backwards compatibility shim
    that you can use for older Python versions。 The keys aren't exactly the same as
    they are in briefcase specification。 App name， for example。 is named with capital
    N。 That's done for PEP 566 compatibility。 All right， so briefcase sounds。 awesome，
    what's the catch？ Well， there are plenty of aspects of the individual platforms
    that could。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: metadata 是在 Python 3.8 中添加的，但你可以为旧版本的 Python 使用向后兼容的 shim。键的名称与 briefcase 规范中的不完全相同。例如，应用名称以大写
    N 命名。这是为了兼容 PEP 566。好的，briefcase 听起来很棒，有什么陷阱呢？嗯，个别平台有很多方面可能会。
- en: definitely be improved。 Linux app images don't currently support desktop entries
    at present。 Windows apps aren't currently code signed。 They currently report that
    the system inspector has。 Python。exe。 iOS can't currently deploy to physical devices。
    Android support doesn't do code signing。 MacOS doesn't do notarization。 These
    are all solvable problems though。 They need time， attention。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 确实可以改进。Linux 应用程序镜像目前不支持桌面条目。Windows 应用程序当前没有代码签名。它们目前报告系统检查器已存在。Python.exe。iOS
    目前无法部署到物理设备。Android 支持没有进行代码签名。MacOS 不进行公证。不过，这些都是可以解决的问题。它们需要时间和关注。
- en: in some cases a little bit of expertise or at least a little bit of research
    to work out。 what extra options we need to pass into our compile command。 The
    biggest downside， pun intended。 is the size of the support package。 The default
    briefcase support package includes。 a full Python install， which means a briefcase
    app for MacOS is about 200 megabytes。 Now。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下需要一点专业知识，或者至少需要一点研究，以弄清楚我们需要在编译命令中传递哪些额外选项。最大的缺点，双关语。是支持包的大小。默认的 briefcase
    支持包包括。完整的 Python 安装，这意味着 MacOS 的 briefcase 应用约为 200 兆字节。现在。
- en: that's not unheard of when it comes to applications in the world。 Slack is 174
    megabytes， but。 they're doing it too isn't really a good excuse。 The good news
    though is that this can also be。 fixed。 This Hello World app contains an entire
    Python standard library。 It includes bzip2 and。 h2dplib and all of this due to
    and much more。 And they're never used in many most apps。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这在世界范围内的应用程序中并不鲜见。Slack 的大小是 174 兆字节，但。它们也在这样做，这并不是一个好的借口。不过好消息是，这也可以。修复。这个
    Hello World 应用包含整个 Python 标准库。它包括 bzip2 和 h2dplib，以及由于其他许多原因。这些在许多应用中根本没有使用。
- en: So there is a lot that can be optimized here。 The immediate workaround is the
    briefcase will allow。 you to specify your own support package。 So once you know
    that your app only needs a specific。 subset on the standard library， you can build
    a hand-tuned version of a support package and use that。 And with that approach，
    Hello World easily reduces to around 30 megabytes， as little as 15 if you。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里有很多可以优化的地方。直接的解决方法是 briefcase 允许。你指定自己的支持包。因此，一旦你知道你的应用只需要标准库的特定子集，你可以构建一个手动调整的支持包并使用它。通过这种方式，Hello
    World 的大小轻松减少到大约 30 兆字节，如果必要的话可以小到 15 兆字节。
- en: try really hard。 That does require hand tuning though。 And the hand tuning process
    isn't very user-friendly， at present。 There is a lot that could be done to improve
    that user experience。 There is also an。 intermittent discussion on the Python
    core team about a kernel Python， the idea of an official。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽力而为。这确实需要手动调整。然而，目前的手动调整过程并不是很用户友好。还有很多可以做的事情来改善用户体验。此外，Python核心团队中还偶尔讨论关于内核Python的想法，即一个官方的。
- en: Python distribution that is the minimum viable Python with the rest of the standard
    library being。 imported as needed。 That would be absolute gold for briefcase。
    Briefcase isn't feature complete by。 any stretch。 It works well， but there are
    lots of ways that it could be improved or enhanced。 I've already flagged some
    of the obvious potential improvements for existing platforms。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Python分发，这是最小可行的Python，其余的标准库根据需要导入。这对公文包来说将是绝对的金矿。公文包的功能并不完整。它运行良好，但还有很多可以改进或增强的地方。我已经标记了一些现有平台明显的潜在改进。
- en: But we could also add support for new platforms like set up boxes and smartwatches
    or add support。 for other packaging formats like flatpack or snap on Linux。 Adding
    these backends actually isn't。 that much work。 It mostly requires a little expertise
    or research on how to drive the packaging。 tools for those platforms。 I'd also
    like to be able to provide an answer for command line apps。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以增加对新平台的支持，例如机顶盒和智能手表，或添加对其他打包格式的支持，比如在Linux上使用flatpak或snap。添加这些后端其实并不需要太多工作。主要需要一些专业知识或研究，了解如何为那些平台驱动打包工具。我也希望能为命令行应用程序提供解决方案。
- en: That's mostly a design question at this point rather than a technical limitation。
    What does the briefcase model of app distribution mean for command line apps？
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这主要是一个设计问题，而不是技术限制。应用程序分发的公文包模型对命令行应用程序意味着什么？
- en: Most of my testing has also been based on Toga， but one of the biggest areas
    of potential improvement。 is testing that the support works for other GUI frameworks。
    Personally， I am especially interested。 in seeing tests of gaming libraries like
    Pi Game or Pursued Pi Bear because I think Python gaming。 is one of the biggest
    areas where briefcase has potential， making it easy to distribute games to。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我的大部分测试也基于Toga，但潜在改进的最大领域之一是测试对其他GUI框架的支持。就个人而言，我特别感兴趣的是看到对游戏库（如Pi Game或Pursued
    Pi Bear）的测试，因为我认为Python游戏是公文包潜力最大的领域之一，使得分发游戏变得容易。
- en: gamers， not to developers and potentially to mobile app stores as well。 Lastly，
    app publication。 Briefcase currently stops with the process of packaging your
    app。 However， app stores all have。 APIs to support automated publications。 So
    potentially briefcase could manage that process too。 Does a one-command publication
    process pushing to steam？ Does that interesting to anyone？
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家，而不是开发者，并且可能也适用于移动应用商店。最后，应用程序发布。公文包目前只处理打包你的应用程序的过程。然而，所有应用商店都有支持自动发布的API。因此，公文包也可能管理这个过程。是否有一个命令发布过程推送到Steam？这对任何人来说有趣吗？
- en: Adding all those features though， that's dependent upon someone having the time
    to implement them。 I would like to be able to spend a whole lot more time working
    on briefcase and。 be where as a whole， but at the moment， this is something I
    do mostly in my spare time。 If you'd like to support my work on briefcase and
    the be where project。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，添加所有这些功能依赖于有人有时间来实现它们。我希望能花更多的时间来工作在公文包和“随处可用”项目上，但目前，这主要是我在业余时间做的事情。如果你想支持我在公文包和“随处可用”项目上的工作。
- en: you can join the project as a financial member。 You can also back me on GitHub
    sponsors。 That income is currently enough to cover stickers， hosting and things
    like that。 but it's nowhere near， enough to make this a full-time gig。 If you've
    got ideas or experience that might help an open-source。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以作为财务成员加入这个项目。你也可以在GitHub赞助商上支持我。目前的收入足以支付贴纸、托管等费用，但远不足以让我将其变成全职工作。如果你有可能帮助开源项目的想法或经验。
- en: project funders development or you'd like to know more about the project or
    get involved。 please get in touch。 Thank you all very much and I hope I'll see
    you online then。 hopefully in person next year。 [silence]。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 项目资助者开发，或者如果你想了解更多关于这个项目或参与，请与我联系。非常感谢大家，希望我能在网上见到你们，然后明年希望能亲自见面。[沉默]。
- en: '![](img/4fc7db36558521739c21bf7d5e291ee3_3.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fc7db36558521739c21bf7d5e291ee3_3.png)'
