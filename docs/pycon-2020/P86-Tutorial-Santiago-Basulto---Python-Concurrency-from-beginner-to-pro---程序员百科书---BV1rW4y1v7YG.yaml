- en: P86：Tutorial Santiago Basulto - Python Concurrency from beginner to pro - 程序员百科书
    - BV1rW4y1v7YG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P86：教程 Santiago Basulto - Python 并发从入门到精通 - 程序员百科书 - BV1rW4y1v7YG
- en: Welcome to our Python concurrency tutorial。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们的 Python 并发教程。
- en: '![](img/d47b771f29319a5dab186fef57705ab6_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d47b771f29319a5dab186fef57705ab6_1.png)'
- en: My name is Santiago and even though I love to be in the same room with all of
    you， sharing。 this tutorial in the same room in Pittsburgh， it's great to try
    it out in this format。 so I'm very happy we can do it in this way。 I have adapted
    this tutorial from the regular。 version that I have prepared that had a ton of
    stops in the middle， checking out exercises。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我的名字是 Santiago，尽管我喜欢和你们在同一个房间里分享这个教程，在匹兹堡的同一个房间里很棒，但以这种方式尝试也很不错。所以我很高兴我们可以这样做。我已将这个教程从常规版本进行了调整，原版本中有很多中途停顿以检查练习。
- en: to this online version。 We have separated the exercises in a second chunk， so
    we're going。 to do all the lessons in this recording and then you will have the
    time to check out the。 assignments and the projects。 So as I told you， my name
    is Santiago and from Argentina。 I work for remotor。com。 I actually， co-funded
    remotor。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个在线版本。我们将练习分成第二部分，所以我们将在这次录音中完成所有课程，然后你将有时间查看作业和项目。正如我告诉你的，我的名字是 Santiago，来自阿根廷。我为
    remotor.com 工作。实际上，我是 remotor 的联合创始人。
- en: com some time ago and it was by acquire by I&E。 We do courses， so we。 are used
    to recording lights and all that。 We do online courses， we do data science courses。
    networking courses， cloud computing courses， check us out， I&E。com。 And right
    now I'm。 working in my personal time in this library， which is Parlil。 The objective
    is to provide。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，我们被 I&E 收购。我们提供课程，因此我们习惯录制课程等。我们开设在线课程，数据科学课程，网络课程，云计算课程，欢迎访问 I&E.com。现在我在个人时间里正在开发这个库，即
    Parlil。目标是提供。
- en: high level， high level interface for concurrent code， even higher level and
    concurrent and， futures。 which is the library we're going to see in this tutorial，
    of course。 So let's dive straight into the content of this tutorial。 In the first
    section， we're。 going to do a little bit more of a conceptual understanding of
    how computer works， computer。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 高级的并发代码接口，更高层次的并发和 futures，这是我们将在这个教程中看到的库，当然。所以让我们直接深入本教程的内容。在第一部分，我们将更深入地理解计算机如何工作。
- en: architecture， what's the role of each one of the pieces we have in our computer
    and also。 the role of the operating system。 And then we're going to get right
    into coding， we're going。 to see multi-threading， multi-processing， we're going
    to see a thread synchronization。 we're going to see problems with deadlock， the
    guild， multi-processing concurrent and， futures。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 架构，我们计算机中每个部分的角色，以及操作系统的角色。然后我们将直接进入编码，学习多线程、多处理，我们将看到线程同步，处理死锁问题，以及多处理并发和 futures。
- en: and finally an interaction to Parlil， the library that I'm working on。 But again。
    it's important first to understand why we need to do concurrency， what we need
    to write。 concurrent programs。 Let me start first telling you what this tutorial
    is not about， okay。 because it's important for me to set the expectations and
    you know what we're going to be talking。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要介绍的是 Parlil，这是我正在开发的库。但是，首先理解我们为什么需要并发以及我们需要编写什么并发程序很重要。让我先告诉你这个教程不涉及的内容，好吗？因为设定期望对我来说很重要，你知道我们要讨论什么。
- en: about and what it's going to be out of this scope。 So the first thing is we're
    not talking。 about a Cinco or all these other alternative libraries。 It's a different
    model。 It's also。 useful to create concurrent code， Cinco， but it's not this subject
    of these two tutorials。 A little bit more classic， we're going to do multi-threading，
    multi-processing and that's， it。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 还有哪些内容不在这个范围之内。首先，我们不讨论 Cinco 或其他这些替代库。这是一个不同的模型。Cinco 也可以用于创建并发代码，但这不是这两个教程的主题。我们将进行更经典的多线程和多处理，就是这样。
- en: Again， Cinco is a potential substitute for everything we're doing in this tutorial。
    but it's not in this scope。 We will not be doing low level programming， thread
    programming。 even though I mentioned something like the fork process or the fork
    process， spawner process。 we will not be doing low level programming。 This is
    multi-threading， multi-programming。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，Cinco是我们在本教程中所做的一切的潜在替代品，但不在本教程的范围内。我们不会进行低级编程、线程编程。尽管我提到了一些像fork进程或fork进程生成进程的东西，但我们不会进行低级编程。这是多线程、多程序。
- en: multi-processing is not a replacement for distributed architectures， all right。
    So if you have a。 website， for example， and whenever you get a request， you need
    to do a couple of things。 concurrently， usually that's better place in a job queue，
    a typical task queue。 You know。 you can use RabbitMQ or this provided service
    like SQS。 If you're using Django， you can check。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 多处理并不是分布式架构的替代品，好的。因此，如果你有一个网站，例如，每当你收到请求时，你需要并发地做几件事情，通常将其放在任务队列中是更好的选择，典型的任务队列。你知道，你可以使用RabbitMQ或像SQS这样的提供服务。如果你使用Django，可以查看。
- en: out Celery， but this is not about that and you should not confuse it。 It's important
    to。 understand the need that you have and what's the right tool to solve that
    problem。 This is。 not about pipeline clustering or distributive computing。 That's
    better suited for something。 like Dask or Spark， which you have multiple computers
    processing something in Parlo， okay。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Celery，但这不是重点，你不应该混淆这一点。了解你的需求以及解决该问题的正确工具是很重要的。这与管道集群或分布式计算无关。这更适合像Dask或Spark这样的东西，你可以让多台计算机并行处理某些内容，好的。
- en: This is not。 This is just one computer， multi-threading， multi-processing。 And
    even in the same computer， you can do GPU parallelism。 There's not about that。
    You can check that out in rapids。io。 It's， a very interesting library on top of
    CUDA。 which is NVIDIA， but it has a Python API to work with， data frames。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是。这只是一个计算机，多线程、多处理。即使在同一台计算机上，你也可以进行GPU并行处理。这也不是重点。你可以在rapids.io查看，这是一种非常有趣的库，基于CUDA，这是NVIDIA的，但它有一个Python
    API来处理数据框。
- en: They have like a synonym for each of the important data science libraries， like，
    painters。 They have data frames， scikit-learn。 They have Q&ML。 So it's interesting，
    but there's。 not about that either。 It's interesting to understand where you're
    sitting at。 There is this very。 interesting model， very simple， which is you can
    do， you can have a task that needs to be performed。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 它们为每个重要的数据科学库提供了一个同义词，比如画家。他们有数据框，scikit-learn。他们有Q&ML。所以这很有趣，但这也不是重点。了解你所处的位置是很有趣的。有一个非常有趣的模型，非常简单，你可以执行需要完成的任务。
- en: or can be performed in just one core in a single thread， single process code，
    just any script。 95% of the tasks you have will probably fall in this category
    of just one core。 And that's great。 There is then one step moving forward one
    step。 It's two to eight cores。 We could say today two。 to 16， 32 cores， something
    that fits in your computer。 You have this intensive task。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 或者可以在单个线程的单个核心中执行，单进程代码，只需任何脚本。你拥有的95%的任务可能都属于这一核心类别。这很好。接下来向前迈出一步。是两到八个核心。我们可以说今天是两到16、32个核心，适合你电脑的东西。你有这个密集的任务。
- en: but you put your computer to run。 It takes 30 minutes an hour， two hours， and
    it's done。 And it's。 possible to do it in your own computer。 So that's the second
    step。 And then you have the other step。 when you have more than this threshold
    of CPUs， which is， in this case， it says nine plus can be。 16 plus 32 plus again。
    It doesn't fit a large computer， a large commercial。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以让你的电脑运行。它需要30分钟、一个小时、两个小时，然后完成。并且可以在你自己的电脑上完成。所以这是第二步。接下来，你有另外一步。当你拥有超过这个CPU阈值时，在这种情况下，它说九个以上可以是16个以上、32个以上，再次，它不适合大型计算机，一个大型商用。
- en: a commercially available， computer。 And that's when you need distributed processing。
    But in this tutorial， we're gonna， be focusing in point number two， two to a two
    to 16。 two to 32 cores， whatever you can do in your own， computer。 Why do we need
    concurrent programming？
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 商用电脑。而这时你需要分布式处理。但在这个教程中，我们将专注于第二点，两到16、两到32个核心，任何你可以在自己电脑上做到的。为什么我们需要并发编程？
- en: What's the usage of it？ Well， the idea of the， evolution of CPUs and computing，
    it's interesting。 This chart， which is great。 The source is included in， this
    light。 shows how the CPUs have progressed throughout the time。 And what you will
    see is that。 the frequency of CPUs right here， it's has tail， right？ So that's
    just all flat in this number of。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它的用途是什么？嗯，CPU和计算的发展理念很有趣。这张图很棒，来源包含在这个光线中。它展示了CPU如何随着时间的推移而发展。你会看到，CPU的频率在这里，它有一个尾巴，对吧？所以在这个数字上几乎是平坦的。
- en: of megahertz is just staying there and it's not moving。 CPUs are not getting
    faster。 We have kind。 of sort of reached the maximum level in terms of frequency
    because of a number of reasons， because。 hitting the overhead because of power
    consumption， because they don't fit in the tiny place we have。 to put them。 So
    we have reached some sort of a limit in there。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 兆赫兹的速度保持不变，没有提升。CPU并没有变得更快。我们在频率方面已经达到某种最大水平，这有很多原因，包括功耗开销，和它们不适合我们要放置的微小空间。所以我们在这方面达到了某种限制。
- en: But what we haven't reached the limit of， yet is the number of cores。 So number
    of logical cores。 you see that it's going up very fast。 So in that， in this past
    20 years。 it has evolved from single core machines to 100 cores， for， examples，
    perfectly possible。 When I started doing computing related things， everything
    was one core。 It。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们尚未达到的限制是核心的数量。因此，逻辑核心的数量，你会看到它在快速增长。在过去20年中，它已经从单核机器演变为100个核心，比如说，这完全是可能的。当我开始从事与计算相关的工作时，一切都是一个核心。
- en: was crazy to think about two cores。 A dual core was a crazy theoretical thing
    that we knew had。 existed。 Nobody had one。 In today's world， it's not crazy to
    get a 64 logical core computer or CPU。 right？ It's completely possible。 So we're
    getting into this second order of magnitude and that will。 probably keep increasing。
    I don't know what's the limit。 At some point we will hit an asymptote。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 想到两个核心是疯狂的。双核是一个我们知道存在的疯狂理论概念。没有人拥有。在今天的世界，获得一个具有64个逻辑核心的计算机或CPU并不是疯狂的，对吧？这是完全可能的。所以我们进入了这个数量级的第二个阶层，并且这可能会持续增加。我不知道限制是什么。某个时候我们会遇到渐近线。
- en: right？ We will hit some sort of limit， but so far it's still increasing。 So
    the objective is， with。 concurrent programming， is to make use of all these cores
    whenever it's possible。 All right， so。 we want all these， we want to take advantage
    of all these cores。 The speed isn't going up。 We have。 the same speed。 So we have
    to distribute our work into multiple cores as many cores as possible for。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧？我们会遇到某种限制，但到目前为止仍在增长。所以目标是，通过并发编程，尽可能利用所有这些核心。好的，我们希望利用所有这些核心。速度并没有提升。我们还是保持相同的速度。因此，我们必须将工作分配到多个核心中，尽可能多的核心。
- en: that to work。 That's objective。 That's why we need concurrent to write concurrent
    programs。 And。 usually the tasks will be different for each one of you。 I think
    games are a very good example of。 a multi core architecture in which you have
    multiple things happening at the same time。 You have the， character running。 You
    have a rain happening。 You have bullets being fired by enemies。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了工作。这是目标。这就是我们需要并发编程的原因。通常每个人的任务会有所不同。我认为游戏是多核架构的一个很好的例子，其中有多个事情同时发生。你有角色在跑。你有雨在下。敌人发射子弹。
- en: You have， multiple things happening at the same time， right？
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多个事情同时发生，对吧？
- en: And you can take advantage of all these cores to， provide a smoother experience。
    Let's start with computer architecture。 This is the basics。 0。1， basics。 Let's
    go back into the basics computer architecture。 And this is the von Neumann architecture。
    It's just very plain old， very standard architectures。 All our computers today
    are using these。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用所有这些核心来提供更流畅的体验。让我们从计算机架构开始。这是基础。0.1，基础。让我们回到计算机架构的基础。这是冯·诺依曼架构。这只是非常普通、标准的架构。我们今天的所有计算机都在使用这些架构。
- en: architectures based on a CPU memory unit。 In this case， it's RAM and IO， everything
    which is within。 IO。 And it's again， it's the simplest model we can have。 And
    basically， what we have is that。 given the operations we have in our code or the
    instructions we have in our code， they're usually。 going to fall if you want in
    each one of these categories。 Some operations will be CPU， they will。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 CPU 内存单元的架构。在这种情况下，它是 RAM 和 IO，所有在 IO 之内的内容。这又是我们可以拥有的最简单模型。基本上，我们的代码中给定的操作或指令，通常会落入这几个类别中的每一个。一些操作将是
    CPU 密集型的，它们将。
- en: be performed by the CPU。 Some other operations will store something in memory。
    Some other operations， will connect to IO。 It's important to relate this to the
    access time of all these resources。 So， for example， accessing something the CPU
    is a lot faster than accessing something in memory or even。 IO。 And I want you
    to keep an eye on this because this is going to be very important later。 So， for。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由 CPU 执行的某些操作，其他一些操作会存储在内存中，还有一些操作会连接到 IO。将这些资源的访问时间与之相关联非常重要。例如，访问 CPU 的速度远快于访问内存或
    IO。我希望你关注这一点，因为这在后面会非常重要。
- en: example， this is a very interesting comparison in human relative times。 If one
    CPU cycle is one。 second， accessing memory memory， which we know it's fast， accessing
    memory takes four minutes。 That's， how slower， how much slower is memory compared
    to CPU。 Accessing your hard drive。 even if it's a， solid state drive， it's going
    to take 1。5 to four days。 That's how slow it is。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 示例，这是一个非常有趣的人类相对时间的比较。如果一个 CPU 周期是 1 秒，访问内存（我们知道它很快）需要四分钟。也就是说，内存与 CPU 相比慢了多少。访问你的硬盘，即使是固态硬盘，也要花费
    1.5 到四天。这就是它的慢速。
- en: Hard drive access all， hard drive plate mechanical drive， it's going to take
    one to nine months。 Accessing requests， network， requests can take five years
    to 11 years， again。 relative times compared to a CPU cycle。 So， this， is important。
    It's going to be very important when we know what parts of our code we have to
    make。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 硬盘访问，机械硬盘的访问时间可能需要 1 到 9 个月。访问网络请求可能需要 5 年到 11 年，再次是相对于 CPU 周期的相对时间。所以，这一点很重要。当我们知道代码的哪些部分需要优化时，这将变得非常重要。
- en: run concurrently。 In that case， we're going to decide if our code is IO heavy，
    it makes a ton of。 network requests， we will know when to parallelize that。 Or
    the same thing if our code is CPU heavy。 it makes a ton of CPU computation， CPU
    bound。 This is going to be important later， trust me。 We're。 going to jump now
    to the operating system and the role of the operating system。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 同时运行。在这种情况下，如果我们的代码是 IO 密集型，产生大量网络请求，我们会知道何时进行并行化。或者如果我们的代码是 CPU 密集型，进行大量 CPU
    计算，也同样如此。这在后面会很重要，信我。现在我们要跳转到操作系统及其角色。
- en: It's very interesting， to learn about the history of operating systems and how
    they evolved。 It's very， I personally love it。 I have write a couple of books
    and it's very interesting to understand the process that humanity took to。 understand
    how much we needed an operating system and why。 But basically。 an operating system
    is just a， program。 It's just someone sat and wrote an operating system。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 学习操作系统的历史及其演变非常有趣。我个人非常喜欢。我写过几本书，理解人类为了解我们需要操作系统而经历的过程是非常有趣的。但基本上，操作系统就是一个程序。就是有人坐下来编写了一个操作系统。
- en: It's a program。 But what we have understood， with time is that computers are
    a very precious resource that we can just execute random programs on。 top having
    direct access to CPU memory and IO。 It's very common for me to download an application
    from。 the internet and run it on my computer。 But in my computer also。 I have
    a ton of privilege information。 And without the operating system。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个程序。但我们随着时间的推移理解到，计算机是非常宝贵的资源，我们不能随意执行随机程序，直接访问 CPU、内存和 IO。对我来说，从互联网下载应用并在我的计算机上运行是非常常见的。但在我的计算机中，我也有很多特权信息。而没有操作系统的话。
- en: let's imagine for a second that there is no operating systems and。 each program
    you download can just access anything， any resource they want。 It's very hard
    to trust。 those programs。 So that's why we have created operating systems。 We
    have created a layer that sits on， top of our hardware。 Right。 So on the right。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设想一下，如果没有操作系统，每个你下载的程序可以随意访问任何资源，这很难让人信任这些程序。所以我们才创造了操作系统。我们在硬件之上创建了一个层次。
- en: we have all our hardware like our precious resources。 And we have put a layer
    in between any random code you can think of， you can execute on those。 resources。
    So the operating system is the guardian of those resources。 Any。 any operation
    you want to， perform is actually going through the operating system and the operating
    system is going to have。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有所有的硬件，就像我们珍贵的资源一样。我们在任何你能想到的随机代码和这些资源之间放置了一层。因此，操作系统是这些资源的守护者。任何你想要执行的操作实际上都是通过操作系统进行的，而操作系统将会有。
- en: control over that。 What memory you can write or what memory you can read， where
    you can write or。 read files， et cetera。 That's all part of the protective nature
    of the operating system。 And of course， the operating system have many more usages
    like paging。 paginating algorithms and handling disk， drives and all those things。
    In our， in our， in this case。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对此的控制。你可以写入或读取哪些内存，在哪里可以写入或读取文件，等等。这都是操作系统保护性质的一部分。当然，操作系统还有许多其他用途，比如分页、分页算法以及处理磁盘驱动器等。在我们的这个例子中。
- en: it's important to understand the， protective nature of the operating system。
    In order to run your code， the operating system will use， the concept of a process。
    Remember。 you can't just execute your code directly。 You have to hand over。 your
    code and say to the operating system， hey， I want to run this piece of code。 Can
    you do it for。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 理解操作系统的保护性质是很重要的。为了运行你的代码，操作系统将使用进程的概念。记住。你不能直接执行你的代码。你必须把你的代码交给操作系统，并说，嘿，我想运行这段代码。你能为我做吗？
- en: me？ And the operating system is going to put that in what we call a process。
    So these are code。 And the operating system is going to put it in these right
    here in these container， which is the。 whole process that will contain a separate
    number of things。 It's going to have your code。 It's going， to have a reference。
    It's actually going to load your code in memory。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我？操作系统将把它放入我们所称之为进程的东西中。因此这些是代码。操作系统将把它放在这里这些容器中，这整个进程将包含一系列不同的内容。它将包含你的代码。它将有一个引用。它实际上会将你的代码加载到内存中。
- en: It's going to have a reference， there。 It's going to allocate run or memory。
    It's going to say these process has these many， bytes allocated of memory to use。
    It's going to have all the local variables， file scripts， file scripts， sorry。
    all the things we need to access。 So for example， here， when it started with X
    equals one。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 它将有一个引用在那里。它将分配运行或内存。它将说这些进程已分配了多少字节的内存可供使用。它将拥有所有的局部变量、文件脚本，抱歉，所有我们需要访问的内容。因此，例如，当它以
    X 等于 1 开始时。
- en: we incremented it， the operating system is keeping track， done memory。 We open
    a file。 we asked the operating system to ask the file for us。 And we have a。 reference
    to that final descriptor。 So the operating system is creating this abstraction。
    the process。 So our code can interact with the system through this process interaction。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们增加了它，操作系统在内存中跟踪这一点。我们打开一个文件。我们请求操作系统为我们访问该文件。并且我们有一个最终描述符的引用。因此，操作系统正在创建这个抽象，进程。这样我们的代码就可以通过这种进程交互与系统进行交互。
- en: '![](img/d47b771f29319a5dab186fef57705ab6_3.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d47b771f29319a5dab186fef57705ab6_3.png)'
- en: So whenever we execute code， in this case， whenever you do Python， your command，
    what。 it's actually happening is that the operating system is creating a new process。
    And it's injecting。 that you're coding there， and it's executing that。 So you
    can actually run the same program you have， written， the same dot pi file。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所以每当我们执行代码时，在这种情况下，每当你进行 Python 编程时，你的命令，其实发生的事情是操作系统正在创建一个新的进程。并且它正在注入你所编写的代码，并执行它。因此你实际上可以运行你所编写的同一个程序，即同一个
    .pi 文件。
- en: you can execute it in multiple， you can execute it multiple times。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以多次执行它，你可以多次执行它。
- en: '![](img/d47b771f29319a5dab186fef57705ab6_5.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d47b771f29319a5dab186fef57705ab6_5.png)'
- en: You have multiple processes running concurrently in the same computer。 That's
    what we can see right。 here。 So that's those are all the processes that I have
    in my computer running after running。 after restarting all those processes。 And
    again， there are all different instances。 of those processes。 You can see right
    there， process ID， that means that there is a different。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你在同一台计算机上可以同时运行多个进程。这就是我们在这里所看到的。因此，这些是我在重新启动所有这些进程后在计算机上运行的所有进程。再次强调，这些都是这些进程的不同实例。你可以在这里看到进程
    ID，这意味着有一个不同的。
- en: instance of each one of these processes。 They're all executing the same code，
    but they are all。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个进程的实例。它们都在执行相同的代码，但它们都是。
- en: '![](img/d47b771f29319a5dab186fef57705ab6_7.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d47b771f29319a5dab186fef57705ab6_7.png)'
- en: different processes。 So what about process concurrency？ And this is the very
    interesting part about。 learning about operating system history。 At the beginning，
    let me just go with the slides， but。 let's say we have only one CPU。 I'm gonna
    take you back。 I'm not that old， but I'm from an era。 where there was only one
    CPU。 Let's say you have only one CPU in your computer。 That's not what。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的进程。那么进程的并发性又如何呢？这正是学习操作系统历史时非常有趣的部分。开始时，我将展示一些幻灯片，但假设我们只有一个 CPU。我会带你回到过去。我虽然不算老，但我来自一个只有一个
    CPU 的时代。假设你计算机里只有一个 CPU。这并不是。
- en: happens today， but let's assume it's what you have。 We have only one CPU in
    your computer。 One CPU is one worker， just one worker。 How many processes can
    you run in one CPU at the same time？
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的情况就是这样，但假设你的计算机只有一个 CPU。一个 CPU 就是一个工人，只有一个工人。你能在一个 CPU 上同时运行多少个进程？
- en: That's the question。 Of course， you can run only one task at a time。 There's
    only one worker。 you can run only one task。 But even when I was a child and I
    had a one core computer， I still had。 interesting smooth enough experience。 I
    could play， I could play Doom， for example， the first。 version of Doom， and I
    had only one core。 So I fire a bullet， I move， my enemy dies， I get fired at。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个问题。当然，你只能一次运行一个任务。只有一个工人，你只能运行一个任务。但即使在我小时候，我有一台单核计算机，我依然有。相当流畅的体验。我可以玩，比如第一版的
    Doom，尽管我只有一个核心。所以我开枪，我移动，我的敌人死了，我被攻击。
- en: So how is that experience happening with only one CPU？
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，仅有一个 CPU 时，这种体验是如何发生的？
- en: If the CPU can have process one thing at a time， I fire a bullet。 And how is
    the CPU just keeping track of the bullet and everything else is frozen？ I can't
    move。 my enemy can't move。 Because of what we're going to call time slicing or。
    the scalar of the operating system。 So even with one CPU， let's keep these high
    policies here。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 CPU 只能处理一件事情，我开一枪。那么 CPU 是如何跟踪子弹而其他一切都被冻结的？我不能移动，我的敌人也不能移动。这是由于我们将称之为时间切片或操作系统的轮转。所以即使只有一个
    CPU，让我们保持这些高级策略在这里。
- en: we're working with a computer that has only one CPU。 Even if there are multiple
    processes。 being executed at the same time， the operating system is going to scalar
    them in and out， right？
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用一台只有一个 CPU 的计算机。即使同时有多个进程在执行，操作系统也会将它们按顺序处理，对吗？
- en: And it's going to give them a little bit of CPU time to each one of them。 Just
    one CPU。 the operating system is going to claim the CPU， it's going to give it
    a sign sometime to process one。 it's going to reclaim it， it's going to sign sometime
    to process two， it's going to reclaim。 it's going to sign sometime to process
    three。 So it will give you the impression that there are。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统会给每个进程分配一点 CPU 时间。只有一个 CPU，操作系统会索取 CPU，给它分配时间处理一个进程，然后回收，接着分配时间处理第二个，最后回收，再分配时间处理第三个。因此，它会给你一种同时有多个进程在运行的错觉。
- en: things happening at the same time when in reality， everything is happening not
    at the same time。 sadly。 So in our example of a game， a simple shooter in a one
    CPU， in a one core era。 basically you fire a bullet， the bullet travels for a
    piece of a second。 then the CPU is transferred， to a character， then the CPU is
    transferred to the enemy and everything is there。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切在同一时刻发生时，实际上，所有事情并不是同时发生的。遗憾的是。在我们的游戏示例中，一个简单的射击游戏在一个 CPU、一个核心的时代。基本上，你开一枪，子弹飞行了一段时间。然后
    CPU 转移到角色，接着转移到敌人，所有事情都在那。
- en: It's a very， very fast context switching for each one of the， in this case they
    are not processed。 but yeah， between the processes， there is a very fast context
    switching。 which gives you the impression that， things are being run in parallel。
    And this is the difference between concurrency and parallelism。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常非常快速的上下文切换，在这种情况下，它们不是进程，但在进程之间确实有非常快速的上下文切换。这让你感觉事情是在并行运行。这就是并发性与并行性之间的区别。
- en: Concurrency is handling multiple tasks at the same time， not at the same time，
    literally。 that would be parallel， but starting multiple things and have to manage
    things that potentially。 can't run at the same time， parallelism is actually when
    two things run at the same time。 In a one CPU computer， you can't have parallelism，
    you can have concurrency。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是同时处理多个任务，但并不是字面上的同时。那将是并行，但启动多个任务并管理可能无法同时运行的任务。并行性实际上是指两件事同时运行。在单 CPU 计算机中，你不能有并行性，你只能有并发。
- en: you can't have parallelism。 That's basically the difference with parallelism。
    So this is what parallelism couldn't look like。 Right， so if we go back to this
    slide。 there are no two moments in time when there are two， tasks being executed
    at the same time。 There's always the OS， right， it's changing， switching， the
    main CPU， the CPU not main。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能有并行性。这基本上是并行性与并发的区别。这是并行性可能的样子。对，如果我们回到这个幻灯片。在任何两个时刻都没有两个任务同时执行。总是有操作系统，它在切换，主
    CPU，非主 CPU。
- en: the only CPU time from process to process。 And this。 introduces complexity because
    the operating system is also a program by itself。 So whenever the moment， that
    the operating system is switching， the context of a process。 the operating system
    itself， it also needs some time to run。 So that's interesting。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在进程之间使用 CPU 时间。这引入了复杂性，因为操作系统本身也是一个程序。因此，每当操作系统切换一个进程的上下文时，操作系统本身也需要一些时间来运行。这很有趣。
- en: So this is a parallel system。 We have this is another hypothesis。 We have two
    cores now。 we have two CPUs， and each CPU is one of these blue lines。 And basically
    what it's happening。 is that now in these moments in time， we have actual parallelism
    because one core is taking care。 of this task and the other core is taking care
    of the other task。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个并行系统。我们有另一个假设。我们现在有两个核心，有两个 CPU，每个 CPU 是这些蓝色线之一。基本上发生的情况是，在这些时刻，我们实际上有了并行性，因为一个核心在处理这个任务，而另一个核心在处理另一个任务。
- en: So now this is actually parallelism。 You will see also that at some points the
    CPU is idle。 This is very common。 I don't， it's very common。 So again， what we're
    saying here is that the CPU。 the operating system is the one deciding when， each
    one of the processes will run。 It has full authority to which CPU， which process
    is going to， be run at a given time。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在这实际上是并行性。你会看到在某些时刻 CPU 是空闲的。这是非常常见的。我觉得这非常常见。所以再一次，我们在这里说的是 CPU。操作系统决定了每个进程何时运行。它完全有权决定哪个
    CPU，哪个进程将在给定时间运行。
- en: And that's a very important thing is moving back and forth the process that，
    can't run。 The operating systems， and again， history of operating systems are
    kind of a neural， net。 but operating systems realized that there were different
    type of tasks。 And there were multiple。 time slicing algorithms created in order
    to understand when an operating system should grant。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常重要的是来回切换无法运行的进程。操作系统的历史可以看作是神经网络，但操作系统意识到有不同类型的任务。为此创建了多种时间片算法，以理解操作系统何时应授予资源。
- en: access to the CPU to a process or not， when it should schedule it in or out，
    right？ Take it out。 take it in。 And basically， there was one big realization that
    was related to the nature of the。 task that was being run。 Remember our access
    times， if a process is， is CPU is I/O heavy。 you want to give it a ton of CPU
    whenever it needs it。 So whenever the CPU needs。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对进程的 CPU 访问，何时应该安排进程进入或退出，对吗？拿出来。再放进去。基本上，有一个与正在运行的任务的性质相关的重要认识。记住我们的访问时间，如果一个进程是
    CPU 和 I/O 密集型的，你希望在它需要时给它大量的 CPU。因此，每当 CPU 需要时。
- en: whenever the process， needs to run an I/O task， you want to give that process
    to CPU。 because you know， it's not going， to take long， it's just going to fire
    up the request。 For example。 it's going to say， you give this， the process time，
    it's going to say， Oh， thank you。 Now I need to read a file。 Just that's it。 You
    take， out the CPU， you assign it to another process。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每当进程需要运行 I/O 任务时，你希望将该进程分配给 CPU。因为你知道，它不会花很长时间，它只会启动请求。例如。它会说，给这个进程一些时间，它会说，哦，谢谢。我现在需要读取一个文件。就这样。你将
    CPU 拿出，把它分配给另一个进程。
- en: and then start reading the file。 And that's going to， take a lot of time。 We
    saw it already。 You have four days now to read that piece of the file， for the
    process。 So different processes。 given their nature， if they are I/O bound or
    CPU bound。 the operating system is going to treat them differently。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后开始读取文件。这将花费很多时间。我们已经看到过。你现在需要四天来读取文件的一部分，以进行处理。所以不同的进程。根据它们的性质，如果它们是 I/O 密集型或
    CPU 密集型，操作系统将以不同的方式对待它们。
- en: It's going to give them more priority or not。 And and what might be counterintuitive，
    usually。 I/O bound， I/O heavy processes should get more， priority in their CPU
    allocation。 Again。 this is going to be important later。 So how are we going to
    make our code concurrent or even parallel。 ideally？ We were talking about， multiple
    processes。 So I could tell you， you know。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给他们更多的优先级吗？通常来说，I/O 密集型的进程应该在 CPU 分配中获得更高的优先级。这一点在后面会很重要。那么我们要如何让我们的代码实现并发甚至并行呢？理想情况下？我们谈论的是多个进程。所以我可以告诉你，你知道的。
- en: you have a problem， you need to process a large， file。 It has， I don't know，
    a billion rows。 And you need to process that。 When you process that， you write
    your code， it says， for lining lines。 blah， blah。 So you'd realize that it's sequential，
    it's very slow。 And you know。 you should make that program concurrent。 I could
    give you an answer， right now。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个问题，你需要处理一个大文件。它有，我不知道，一十亿行。你需要处理这个。当你处理它时，你写你的代码，可能是，逐行处理。等等。所以你会意识到这是一种顺序处理，非常缓慢。而且你知道，你应该让这个程序并发。我现在可以给你一个答案。
- en: just write your program。 So you can receive a parameter right here。 And just
    create。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 只需编写你的程序。在这里，你可以接收一个参数。然后创建。
- en: '![](img/d47b771f29319a5dab186fef57705ab6_9.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d47b771f29319a5dab186fef57705ab6_9.png)'
- en: multiple processes， instantiate multiple processes at the same time process
    file from one from line。 zero to 100 million。 I don't know， run program from 100
    million to 200 million rows。 So you instantiate， 10 times the same process with
    different pieces。 And you're done。 Right？
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 多个进程，同时实例化多个进程，从第一行处理文件，从零到一亿。我不知道，从一亿行运行程序到两亿行。所以你实例化十次相同的进程，处理不同的部分。然后就完成了。对吧？
- en: That's a good answer。 It's， going to get the job done。 Of course。 that you want
    to run everything concurrently in your program。 You wanted to create one program
    that can spread its work across multiple threats or processes。 That's。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个好答案。它能完成工作。当然，你希望在程序中并发运行所有内容。你想创建一个可以在多个线程或进程之间分配工作的程序。这就是。
- en: '![](img/d47b771f29319a5dab186fef57705ab6_11.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d47b771f29319a5dab186fef57705ab6_11.png)'
- en: what we want to do。 So the first part of， we could say intra program concurrency
    is going to be。 working with threats。 And that's what we're going to talk about
    right now。 The objective， again， is。 going to make is going to is going to be
    turning a sequential code into a potentially parallel code。 So let's see an example。
    Let's say we have to pull data from three different websites。 So it's。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的是什么。所以我们可以说程序内部的并发将是与线程一起工作。这就是我们现在要讨论的内容。目标，再次是。将顺序代码转换为潜在的并行代码。让我们看看一个例子。假设我们需要从三个不同的网站提取数据。那么。
- en: slow website， and it takes two seconds for each one of those requests。 In a
    traditional code。 these are traditional code。 We make everything sequential。 It's
    going to take two seconds to get。 the first website， two seconds， two more seconds
    to get the second one， two more seconds to get。 the third one。 In total， it's
    going to be at least six seconds。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 网站加载缓慢，每个请求需要两秒。在传统代码中，这些都是传统代码。我们将所有操作都设为顺序执行。获取第一个网站需要两秒，再加上第二个需要两秒，再加上第三个需要两秒。总共至少需要六秒。
- en: if it can be even more if you have to， combine it。 At least six seconds to process
    the sequential program。 And this is a visual representation。 First website， second
    website， third website， and at the end of processing。 So you can't。 the key part
    here is that you're not， you don't start fetching the second website until you
    haven't。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你可以将它们结合起来。顺序程序至少需要六秒来处理。这是一个视觉表示。第一个网站，第二个网站，第三个网站，在处理结束时。所以你不能。关键是你不会在没有获取到的情况下开始抓取第二个网站。
- en: finished the first website。 This is the idea of multi-threading。 It's going
    to be instantiating。 or start everything at once， right？ So everything can hopefully
    run in parallel， and then reach a。 common point to synchronize everything back。
    This is the idea of multi-threading。 So if we can do that， if we can spin multiple
    threads， and they all run concurrently or in parallel。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了第一个网站。这是多线程的想法。它将实例化，或者同时启动一切，对吗？因此，希望一切都能并行运行，然后达到一个共同点以同步一切。这是多线程的理念。所以如果我们能做到这一点，能启动多个线程，并让它们都并发或并行运行。
- en: we're going to， first wait for all of them to finish。 It's going to be around
    two seconds。 and then we can do the， combination at the end。 Our code has going
    to look like， it's ideal。 it's going to look something like， this。 It's not the
    reality， it's just pseudocode。 But we're going to see the obstruction of a thread，
    to understand it a little bit better。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先等待所有线程完成。这大约需要两秒钟，然后我们可以在最后进行组合。我们的代码将会像这样，看起来理想。这将看起来像这样。它并不是现实，只是伪代码。但我们将会看到线程的阻塞，以便更好地理解它。
- en: The threading module is what we're going to be using。 And I'm。 going to just
    give you a very quick introduction first。 We're going to be saying some code。
    It's。 in a Jupyter notebook。 We're going to do a very simple introduction， and
    then we're going to dig。 into the more important parts， threads， synchronization，
    and all that。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用线程模块。我将先给你一个非常简短的介绍。我们将运行一些代码，它在Jupyter笔记本中。我们会进行一个非常简单的介绍，然后深入探讨更重要的部分，线程、同步等。
- en: What I want you to remember is， we are working in an intra programming setup。
    We're creating our own code， our program， it's going to be using multiple threads。
    and we're going to make that hopefully concurrent。 So， let's just jump directly
    into our code。 and let's start working with threads。 It's finally time to， see
    some actual Python code。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你记住，我们正在一个内部编程环境中工作。我们在创建自己的代码，程序将使用多个线程。我们希望让它并发。因此，让我们直接跳入我们的代码，开始处理线程。终于是时候查看一些实际的Python代码了。
- en: We've done the whole conceptual introduction to about computer， architectures，
    operating systems。 processes， threats conceptually。 But now it's time to talk
    about， real code， creating threats。 get them to run， etc。 So a couple of important
    nodes here， we are。 going to be using the thread class。 This is our major， the
    major class we're going to be using。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了关于计算机架构、操作系统、进程和线程的整个概念介绍。但现在是时候谈谈真正的代码，创建线程，让它们运行等。因此，这里有几个重要的节点，我们将使用线程类。这是我们将要使用的主要类。
- en: throughout these first couple of lessons， in which we're going to create threads，
    we're going to。 instantiate them， and we're going to start them， we're going to
    get them running。 and we're going to， analyze them， check out their status， etc。
    But everything is going to happen in this thread class。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这几节课中，我们将创建线程，实例化它们，启动它们，让它们运行。我们将分析它们，检查它们的状态等。但一切都将在这个线程类中发生。
- en: And this thread class is contained in the threading module。 So this is a very
    important thing。 because we also have a underscore thread module in Python three。
    But this is a very low level module， that you should not be using。 We don't use
    it。 I have never used it。 The threading module is one， that is using underneath
    the underscore thread。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个线程类包含在线程模块中。这是一个非常重要的事情，因为我们在Python 3中还有一个下划线线程模块。但这是一个非常底层的模块，不应使用。我们不使用它。我从未使用过。线程模块是使用在下划线线程模块之下的。
- en: and it's providing us with a much high level， interface。 right for us to create
    and manipulate threats。 So the thread class， again， this is a major， class。 most
    important one we're going to be using to create and start the threads。 When you
    create it。 you're going to pass a target。 This target is the function that it's
    going to be run in a separate。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它为我们提供了一个更高级的接口，以便我们创建和操作线程。因此，线程类再次是一个主要的类。这是我们将要使用的最重要的类，用于创建和启动线程。当你创建它时，你将传递一个目标。这个目标是将在单独线程中运行的函数。
- en: thread， right？ So the remember that when you have your main process， your main
    process。 you're going to be creating a separate thread that it's going to run
    by its own。 This thread needs some sort of callable， needs some action to perform。
    So we're going to say。 which action we wanted to do or to run based on this target。
    So we're going to first instantiate。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 线程，对吧？所以请记住，当你有主进程时，你的主进程。你将创建一个将独立运行的单独线程。这个线程需要某种可调用的，需要执行某个动作。所以我们将说。我们希望做或运行的动作基于这个目标。所以我们将首先实例化。
- en: the thread。 There's going to basically create these the container of the thread。
    Let's say this is the， thread。 And we're going to be passing the target。 So in
    this case。 we're going to be saying target， equals simple workers。 So it knows，
    right。 that it has to run the function simple worker。 Let's say。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 线程。基本上将创建这些线程的容器。假设这是线程。我们将传递目标。所以在这种情况下。我们将说目标等于简单工作者。这样它就知道，对吧。它必须运行函数简单工作者。假设。
- en: the function simple worker decode a simple simple worker is defined here。 And
    then we're going to。 start the thread。 The moment we start the thread， it's when
    actually the thread is starting and it's。 performing its job。 It depends what
    your function is about the target function， what it's doing。 And， that is going
    to say if the thread finishes automatically finish at some point or it runs。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 函数简单工作者解码一个简单的简单工作者在这里定义。然后我们将启动线程。当我们启动线程的那一刻，实际上线程就开始了，并且它在执行任务。它取决于你的目标函数是什么，以及它在做什么。然后，这将表明如果线程完成，会在某个时刻自动结束，或者它运行。
- en: forever， it's very common to have threads that have a while true here。 So basically。
    we want to have， a background a background worker that is checking on some status
    as long as our application is alive。 In that case， you might see here one true，
    we're going to keep running this thread forever。 It's。 going to be in the background，
    it's going to be do some computation。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 永远，这里很常见的是有一个 while true 的线程。所以基本上。我们希望有一个后台工作者，监控某些状态，只要我们的应用程序存活。在这种情况下，你可能会看到一个
    true，我们将永远运行这个线程。它将在后台，它会进行一些计算。
- en: some checking in the background。 But again， the important part here is we have
    our whole process。 these are Python process。 And we're， going to create a few
    threads， let's say。 as soon as we're creating several of the threads， instantiating
    them， just creating instance， T one。 T two， T three equals thread on a target。
    We're going to pass the target， right。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台进行一些检查。但这里重要的是我们有整个过程。这些是 Python 进程。我们将创建几个线程，假设说。当我们创建多个线程，实例化它们时，创建实例 T
    一，T 二，T 三等于线程目标。我们将传递目标，对吧。
- en: that it's going to point to a function， in this case， simple worker， right，
    that's the target。 The thread is there， it's stale， it hasn't started running。
    it's going to start running when we actually evoke the start method。 In that moment，
    the thread is。 going to start its performance。 So let's actually do the code here，
    I'm going to define the simple。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它将指向一个函数，在这种情况下，简单工作者，对吧，那就是目标。线程在这里，它处于闲置状态，还没有开始运行。当我们实际调用启动方法时，它将开始运行。在那一刻，线程将开始它的执行。所以让我们实际编写代码，我将定义简单。
- en: worker function， I'm going to instantiate the thread。 Remember， nothing is happening。
    What you。 can expect here， what's going to happen is that when we start the thread，
    when we actually start。 the thread， we're going to see a hello printed out， it's
    going to slip for two seconds， and we're。 going to see a hello printed out。 So
    I'm going to start the thread， we see the hello。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者函数，我将实例化线程。记住，什么都没有发生。你可以期待这里发生什么，当我们启动线程时，当我们真正开始。线程时，我们将看到“你好”被打印出来，它将睡眠两秒，我们将看到“你好”被打印出来。所以我将启动线程，我们看到“你好”。
- en: we're going to， wait， and now you see the world。 But the important part here
    is that I can。 I still have a full control， while these thread is running。 So
    let me put this thing to。 for example， five seconds， I'm going to， redefine the
    function。 I'm going to instantiate the thread。 I'm going to do here a simple computation，
    two plus two， and I'm going to start the thread。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将等待，现在你可以看到世界。但这里重要的是我可以。在这些线程运行时，我仍然拥有完全的控制。所以让我把这个设置为。比如说五秒，我将重新定义函数。我将实例化线程。我将在这里进行一个简单的计算，二加二，然后我将启动线程。
- en: and I'm going to， I can keep working on my computations。 that the thread is
    running in the background。 And in this case， it is slipping， right？
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续进行我的计算，而线程在后台运行。在这种情况下，它正在休眠，对吧？
- en: But at some point， there you go， it returned back， it run that final function
    that it had。 And that in this， in this， particular moment， the thread is dead，
    we say we're gonna see about the。 yeah， is a live method， the thread died， right？
    It just completed its work， and it's now stopped。 So a usual common thing to do，
    is to create several threads altogether。 So in this case。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 但在某个时刻，它返回了，执行了它的最终函数。在这个特定时刻，线程已经死亡，我们说我们要看看是的，alive 方法，线程死了，对吧？它刚刚完成了工作，现在已经停止了。因此，通常的做法是创建多个线程。在这种情况下。
- en: we have all these threads here， I'm going to， put a semicolon here， so we don't
    see any output。 And I start all the threads and the threads start， slipping for
    some time。 we're actually generating some random values， slipping for that time，
    and working again。 everything is happening on the background。 I still have full
    control in the main。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有所有这些线程，我要在这里加一个分号，这样我们就不会看到任何输出。我启动所有线程，线程开始休眠一段时间。我们实际上在生成一些随机值，休眠这段时间，然后再工作。一切都在后台进行。我在主线程中仍然拥有完全的控制。
- en: thread to do whatever I want。 So let's do that again， I can keep running this
    thing。 and the thread is， outputting the result。 So let's talk in more detail
    about thread stage。 As I told you， when we， create the thread， it's there， it's
    stale， we could say， is it alive？ No。 it's not alive， yet。 It's there ready， but
    it's not alive。 The moment that I started thread。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可以做我想做的任何事情。所以我们再做一次，我可以继续运行这个东西。线程正在输出结果。现在让我们更详细地讨论线程的状态。正如我告诉你，当我们创建线程时，它在那里，可以说是停滞的，它活着吗？不。它还没有活。它在那里准备着，但还没有活。当我启动线程的那一刻。
- en: now the thread is， alive， and you're gonna see the alive method is true。 Something
    important is that remember， we， when we start the thread， the main thread。 when
    we start the worker thread to put it away， the main thread still has full control。
    What happens if you want to pause and wait for the， thread to stop or to finish？
    So actually。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在线程是活的，你会看到 alive 方法返回 true。重要的是要记住，当我们启动线程时，主线程仍然完全控制。当你想暂停并等待线程停止或完成时，会发生什么？实际上。
- en: let's say you have these process， right？ And you're， aggregating data or whatever。
    and you started all these threads， right， they are all working with， data。 but
    you need to stop and unpause until all of them finish。 And once once all of them
    are， finished。 now you can process the data。 In that case， you do want the main
    thread to block。 You do。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有这些过程，对吧？你在聚合数据或其他什么。你启动了所有这些线程，它们都在处理数据。但你需要暂停，直到它们全部完成。一旦它们都完成了，你就可以处理数据。在这种情况下，你确实希望主线程阻塞。确实如此。
- en: want the main thread to wait until that given thread or several threads， they
    all finish。 And to do that， we have the join method。 So I'm gonna instantiate
    the same thread again。 I'm gonna start it。 I'm gonna， jump directly join。 And
    as you can see here。 my main thread now is paused。 It has just stopped。 We are。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 希望主线程等待给定的线程或多个线程全部完成。为此，我们有 join 方法。所以我将再次实例化同一个线程。我要启动它。我将直接调用 join。正如你所看到的，我的主线程现在被暂停。它刚刚停止。我们是。
- en: waiting for the for the thread we started to finish。 The join method， again，
    is what's gonna。 pause the main thread and wait until that thread or that given
    set of threads。 they all have finished。 Once the thread has finished， multiple
    methods will raise a runtime error。 In this case， the thread has already been
    stopped or it has actually finished already。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 等待我们启动的线程完成。join 方法会暂停主线程，并等待那个线程或给定的一组线程全部完成。一旦线程完成，多个方法会引发运行时错误。在这种情况下，线程已经停止，或者它实际上已经完成了。
- en: So it can't be started， again。 You have to create a new instance of the thread
    if you want to start the same task again。 Let's talk about thread identity。 And
    this can be very helpful for debugging to understand better。 your code or to organize
    your code in a better way。 Thread identity means that we can set a name。 for our
    thread。 Right， we can， in this case， the thread， the name is set automatically。
    But if I。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它不能再次启动。如果你想再次启动相同的任务，你必须创建一个新的线程实例。我们来谈谈线程身份。这对调试非常有帮助，可以更好地理解你的代码或更好地组织代码。线程身份意味着我们可以为线程设置名称。对吧，在这种情况下，线程的名称是自动设置的。但如果我。
- en: show you again， the constructor of name of the thread， you're gonna see that
    names equals。 in this case， by default is known。 So the thread class。 a threading
    module is gonna give it a random name， not random。 but a sequential name thread
    something。 And each thread will be assigned a unique identifier。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 再次给你展示线程名称构造函数，你会看到名称等于。在这种情况下，默认是已知的。因此，线程类，一个线程模块会给它一个随机名称，不是随机的，而是一个顺序名称线程。每个线程将被分配一个唯一标识符。
- en: a unique ID， we are gonna say just identity in the event in this case。 So I'm
    gonna say。 in this case， the event parameter or attribute is known。 But once I
    start the thread。 we're gonna see that now it， has been set up to a given value。
    Now that the thread has started。 at that point， it has this ID， which is just
    numeric for us to identify that particular thread。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个唯一的ID，我们将在这种情况下称之为身份。所以我会说。在这种情况下，事件参数或属性是已知的。但一旦我启动线程。我们将看到现在它已经设置为一个给定的值。现在线程已经启动。在那时，它有这个ID，对于我们识别特定线程来说只是数字。
- en: No two threads are gonna have， the same ID， right？ That's an important thing。
    We can set up our own custom name when we're starting， the thread。 And we can
    actually consult that information from the main thread， we can check what's。 the
    threads name in that particular case or ID。 Something interesting is that we can
    also check。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 没有两个线程会有相同的ID，对吧？这是一个重要的事情。当我们启动线程时，可以设置自定义名称。我们实际上可以从主线程中查询该信息，检查在特定情况下线程的名称或ID。有趣的是，我们还可以检查。
- en: these values from within the thread。 So here is an important conceptual thing。
    And let me go back。 again to our drawing board。 If I have this is my remember
    the outside box is my process Python process。 The inside box is the Python thread，
    which is gonna run a given function simple worker in this case。 We can create
    several of these threads， right？ So I'm gonna define all these threads。 Let's
    say we。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从线程内部获取这些值。所以这里有一个重要的概念性问题。让我再回到我们的绘图板。如果我有这个，记住外面的框是我的Python进程。里面的框是将运行给定函数简单工作者的Python线程。我们可以创建多个这样的线程，对吧？所以我将定义所有这些线程。假设我们。
- en: have three threads， and they are all pointing， they're all gonna be executing
    the same function。 right？ The way we define a function is by just by defining
    the function is gonna be running in the thread is。 by just defining a simple function，
    right？ I'm not saying anything crazy here， just basics， right？
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个线程，它们都指向同一个地方，它们都会执行同一个函数，对吧？我们定义一个函数的方式就是定义这个将在线程中运行的函数，只需定义一个简单的函数，对吧？我说的并没有什么奇怪的，只是基础知识，对吧？
- en: It's just a regular Python function。 But what I want to say here is that we're
    not making this。 function prepare to know which thread it's gonna be running。
    The same function has to be defined in a， way that it's useful for all the threads
    we create。 One。 two， three， 1000 threads， they can all run， the same Python code
    in the form of that function。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个普通的Python函数。但我想说的是，我们并不是在让这个函数准备好知道它将在哪个线程中运行。同一个函数必须以对所有创建的线程都有用的方式定义。一个，两个，三个，1000个线程，它们都可以以该函数的形式运行相同的Python代码。
- en: So what I mean by this is that the function， if we， need to use the name of
    the thread。 and if we need to use the ID of the thread， we have to make it。 generic
    enough that each thread running here， potentially in parallel， right， or concurrently。
    to be more precise， they are all executing the same code， but they're all gonna
    have different， IDs。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意思是，如果我们需要使用线程的名称，如果我们需要使用线程的ID，我们必须使其足够通用，以便在这里运行的每个线程，可能是并行的，对吧？更准确地说，它们都在执行相同的代码，但它们都将有不同的ID。
- en: And that is what we're gonna achieve with these two very useful functions， current
    thread。 and thread and get dent， which are generic dynamic methods that are gonna
    give you the。 the particular， let me stop this thing， that are gonna give you
    the particular。 value of the thread itself。 In this case， gonna give you the whole
    thread， current thread。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将通过这两个非常有用的函数，当前线程和获取dent来实现的，它们是通用的动态方法，将给你特定的，等我停止这个东西，它们将给你特定的线程本身的值。在这种情况下，将给你整个当前线程。
- en: the function， current thread， it's gonna give you the whole thread by itself，
    in which you can then。 ask for the name， as we're doing here t。name。 And you also
    can get the identity， the ID that was。 generated。 And in that case， just get ident，
    it's gonna be the number we have。 So let's actually。 use the same code to create
    three different threads， three different threads。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当前线程的函数，它将给你整个线程，在这个线程中你可以询问名称，如我们在这里做的t.name。你还可以获取生成的ID。在这种情况下，获取ident，它将是我们拥有的那个数字。那么我们实际上使用相同的代码来创建三个不同的线程，三个不同的线程。
- en: each one with a custom， that we're providing， and we're gonna start all of them。
    And now we are waiting for them to finish。 So， bubbles， blossom， buttercup， they
    all finished。 And when they started， they had， internally， each one， of them，
    they had their own IDs。 So so far。 we've worked with very simple functions， they
    are not， receiving any parameters。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个都有一个自定义，我们提供，并且我们将启动所有这些。现在我们在等待它们完成。所以，bubbles、blossom、buttercup，他们都完成了。当他们开始时，他们每一个内部都有自己的ID。到目前为止，我们处理的是非常简单的函数，它们没有接收任何参数。
- en: we're just starting there， and they are running。 And this is not， of course，
    realistic。 usually a function receives parameters。 It's very simple to pass parameters
    to the thread。 class to pass arguments， we could say， it's a little bit more difficult
    to work with dynamic。 situations， like， for example， keyword arguments， or， yeah，
    different type of parameters。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是从这里开始，他们正在运行。当然，这并不现实。通常，函数接收参数。将参数传递给线程非常简单。可以说，处理动态情况，比如关键词参数，或者不同类型的参数会稍微复杂一些。
- en: we need to， create dynamically based on the use case。 And that's why one of
    the reasons that I have created the， parallel library。 but we're gonna talk more
    about that later。 For now， I'm gonna show you， show you。 how simple it is to pass
    a few arguments to a given function。 In this case， we have defined。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要基于用例动态创建。这就是我创建并行库的原因之一，但我们稍后会详细谈论。现在，我将向你展示，将一些参数传递给给定函数是多么简单。在这种情况下，我们已定义。
- en: the simple worker function again， which receives now a time to slip。 So far，
    we've always defined。 this case randomly how much the function was slipping。 In
    this case。 we're gonna pass that value as a， parameter。 The way we're gonna do
    that is， as usual。 we create an instance of the thread class， we pass a target，
    we pass the name of the of the thread。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的工作函数再次接收一个睡眠时间。到目前为止，我们总是随机定义函数的睡眠时间。在这种情况下，我们将该值作为参数传递。我们将这样做，像往常一样，我们创建线程类的实例，传递目标，传递线程的名称。
- en: and we're gonna pass a set of arguments。 And in these arguments class， our sorry。
    not class parameter， we're gonna pass all the values are， gonna serve as arguments
    for the function。 In this case， it has to be a topple。 And as we have only， where
    is the only one parameter。 I have to put this comma right here。 So I don't want
    you to get， confused about that。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将传递一组参数。在这些参数类中，抱歉。不是类参数，我们将传递所有的值，作为函数的参数。在这种情况下，它必须是一个元组。由于我们只有一个参数，我必须在这里放一个逗号。所以我不希望你对此感到困惑。
- en: But here's basically a list of all the different parameters you want to pass，
    to your function。 So in this case， I am running it again。 And you know here， for
    example， bubbles。 right here is slipping for three seconds， blossom here， here
    is slipping for 1。5 seconds。 A different alternative way of creating and instantiating
    a thread and running it， etc。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里基本上是你想传递给函数的所有不同参数的列表。所以在这种情况下，我再次运行它。你知道，比如，bubbles，这里正在睡眠三秒，blossom，这里正在睡眠1.5秒。创建、实例化线程并运行它的另一种不同的替代方法，等等。
- en: is not by providing a target function by itself， but creating a subclass of
    thread。 and defining the behavior of the thread in the run method。 So this is
    also very common。 And if you。 have a good architecture， a good design based on
    object-oriented programming in your code。 these could potentially organize your
    code a little bit better。 For example， if you have this。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 不是通过单独提供目标函数，而是通过创建线程的子类并在`run`方法中定义线程的行为来实现的。这也是非常常见的。如果你的代码中有良好的架构和良好的面向对象编程设计，这些可能会稍微更好地组织你的代码。例如，如果你有这个。
- en: background thread we've talking about， instead of defining a function separately
    in a different module。 on the thread in a different module， you can just put the
    thread， you can give it a very。 obvious name， what's the purpose of the thread，
    and get it to run without defining any external。 functions。 Usually the function
    we use for a thread， usually， I'm going to say 80% of the time。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈论的后台线程，而不是在不同模块中单独定义一个函数，你可以直接放置这个线程，给它一个非常明显的名字，说明线程的目的，然后让它运行，而不需要定义任何外部函数。通常，我们用于线程的函数，大约80%的时间我会说。
- en: it's a very particular function that is not used anywhere else。 So it doesn't
    make sense to define。 the function in a global scope if it's going to be just
    used by a thread。 That's why again。 you can define the same functionality within
    the run method。 The run method receives nothing。 just self， the only parameter。
    We usually pass all the parameters in the constructor of the， class。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常特定的功能，其他地方没有使用。因此，如果这个功能只是由一个线程使用，定义在全局范围内就没有意义。这就是为什么你可以在`run`方法中定义相同的功能。`run`方法什么都不接收，只有`self`，这是唯一的参数。我们通常在类的构造函数中传递所有参数。
- en: the initialization method of the class。 And you hear you have to be careful
    not to step over。 the parameters of threads。 So you can usually， if you're passing
    a variable number of arguments。 etc。 how to pass it all here。 The good news about
    defining your own classes that you can do。 pretty much whatever you want in the
    need method， and that means that any short comments you have。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类的初始化方法。你需要小心不要覆盖线程的参数。如果你传递可变数量的参数等，应该怎么在这里全部传递。关于定义自己的类的好消息是，你可以在`run`方法中几乎随心所欲，这意味着你任何短小的带参数的评论都可以用自定义类来修复。
- en: with arguments can be fixed if you want with a custom class。 Particularly， I
    prefer to create。 subclasses， because again， it organizes my code better。 I prefer
    to have this thread that has this。 particular functionality and everything is
    encapsulated in the run method。 During this tutorial。 and I， have to be completely
    honest with you， I am not going to be doing two classes。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，我更喜欢创建子类，因为这能更好地组织我的代码。我更喜欢有这个具有特定功能的线程，一切都封装在`run`方法中。在这个教程中，我必须对你完全诚实，我不会创建两个类。
- en: but I will use a lot， more the target one， because it's easier to see the function
    define separately。 So just for the， clarity of this tutorial， I'm not going to
    be using subclasses so often。 But let's see how it works。 I'm just going to instantiate
    the class。 There you go。 T now is an instance of my thread， and I have， passed
    an only parameter， the number。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但我会使用更多目标函数，因为这样更容易看出函数是单独定义的。因此，为了这个教程的清晰起见，我不会经常使用子类。但让我们看看它是怎么工作的。我现在就要实例化这个类。好了，`t`现在是我的线程的一个实例，我只传递了一个参数，那个数字。
- en: the time to slip。 I'm defining or I'm setting that parameter as， an instance
    attribute。 And now in the run method， I can use that parameter right in the run
    method。 So， I do t dot start。 t dot start is running the run method。 And here
    I can access all the attributes， that I need。 The name attribute， for example，
    it's interesting。 Remember that the name attribute is。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 时间不多了。我正在定义或设置那个参数作为实例属性。现在在`run`方法中，我可以直接使用这个参数。所以，我调用`t.start`。`t.start`正在运行`run`方法。在这里，我可以访问我需要的所有属性。例如，`name`属性是有趣的。记住，`name`属性是。
- en: set even before the thread starts。 So I can just use it directly。 Not the same
    as with the identity。 ID of the thread， which needs to be consulted in kind of
    a real time， I don't know， in an live。 dynamic manner。 So let's talk about something
    very， very important conceptually。 And it's this。 property we have discussed a
    little bit already about threats using or having the having access。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程启动之前就设置。这样我可以直接使用它。与线程的身份ID不同，后者需要以某种实时的动态方式进行查询。我想讨论一个非常重要的概念。这是我们已经讨论过的，关于访问共享数据的属性。
- en: to shared data。 All right。 So using our previous conceptual analysis picture
    of our processes and。 threads， we said this is our whole process， the yellow box。
    And it has some code to run， and it has。 defined a few local variables。 Again，
    this is the whole process。 The whole process will then。 instantiate a few threads。
    And those threads will start。 In that moment， all the threads within a。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧。使用我们之前的概念分析图，我们的进程和线程，我们说这是我们的整个进程，黄色框。它有一些代码要运行，并且定义了一些局部变量。再次强调，这是整个进程。整个进程将实例化几个线程。这些线程将在那一刻启动。所有线程在其中。
- en: process have access to every defined variables in that given process by itself。
    So in this case。 we have time to slip was defined outside of the function。 And
    it's of course defined in the main。 process。 When I create my threads， and I'm
    gonna start only the first one。 So you can check it。 so you can see it。 You see
    that here is sleeping for two seconds， because it's what we have just。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以访问该进程中每个已定义变量的自身。因此在这种情况下，我们的时间延迟是在函数外部定义的。当然，它是在主进程中定义的。当我创建我的线程时，我只会启动第一个。所以你可以检查一下。你可以看到这里正在睡眠两秒，因为这正是我们刚才所做的。
- en: defined。 So let's re-insensate them and run them all again。 And you see that
    all of them， all our。 threads are running by two seconds。 Let's change this thing。
    I'm gonna put three seconds， 1。5。 shorter。 And we define and start all of them。
    And you see that they're all starting by 1。5 seconds。 This is interesting， but
    you because you can change the behavior of your threads by altering the state。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 定义。所以让我们重新激活它们并再次运行。你会看到所有的线程都在运行，间隔为两秒。让我们改变这个设置。我将设为三秒，1.5秒，缩短。然后我们定义并启动所有线程。你会看到它们都在提前1.5秒启动。这很有趣，因为你可以通过改变状态来改变线程的行为。
- en: of a global variable。 So let's say we have an exit， exit underscore threads
    equals false。 Right。 So here inside， we could do something like while not exit
    threads。 we're gonna keep doing a background， process。 All right， just run。 When
    we want all the threads to stop， we can signal that by changing， this variable。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个全局变量。所以假设我们有一个exit，exit underscore threads等于false。对吧。在这里我们可以做一些像while not
    exit threads的事情。我们将继续进行一个后台进程。好吧，就这样运行。当我们想让所有线程停止时，我们可以通过改变这个变量来发出信号。
- en: In the main process， you'd say， you say， exit threads equals true。 And now the
    next time。 this thing runs， it's gonna find that variable changed。 We can modify
    the state or the work of a。 thread by modifying these global variables。 That's
    an important thing。 This actually will introduce。 of course， the problem of rice
    conditions and stepping over shared data。 We're gonna talk about。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在主进程中，你会说，exit threads等于true。现在下次运行时，这个东西会发现那个变量已经改变。我们可以通过修改这些全局变量来修改线程的状态或工作。这是一个重要的事情。这实际上会引入，当然，竞争条件和共享数据的干扰问题。我们将讨论这个。
- en: Mark about that in our following lesson。 So this was a very quick introduction
    to how Python threads。 work。 I don't want you to memorize everything。 We're gonna
    be doing a lot of work。 So it's gonna be。 very familiar by the end of this tutorial，
    how threads work， how to create them， how to instantiate。 how to start them， etc。
    So I want to finish this part。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一节课中谈论这个。因此，这只是一个非常快速的介绍，关于Python线程是如何工作的。我不希望你记住所有内容。我们将进行大量的工作。所以到本教程结束时，线程是如何工作的，如何创建它们，如何实例化，如何启动它们等等，会非常熟悉。我想结束这一部分。
- en: just our first approach to threads with a real， example of our threads and the
    way they run and all that。 To do that， we're gonna be using a， web server that
    I have included in this repository that is basically gonna give us。 prices of
    Bitcoin。 So I'm gonna be instantiated here。 I'm gonna， if you check the structure
    of。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们对线程的第一次接触，展示了线程的实际例子以及它们的运行方式。为此，我们将使用我在这个库中包含的一个网络服务器，它基本上会给我们提供比特币的价格。所以我将在这里实例化。如果你检查一下结构。
- en: '![](img/d47b771f29319a5dab186fef57705ab6_13.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d47b771f29319a5dab186fef57705ab6_13.png)'
- en: your repo， you're gonna see crypto examples right here。 And this is a flask
    application that I can。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你的仓库中，你会看到这里的加密示例。这是一个我可以使用的 flask 应用。
- en: '![](img/d47b771f29319a5dab186fef57705ab6_15.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d47b771f29319a5dab186fef57705ab6_15.png)'
- en: show you real quickly。 It's crypto examples， flask hack， this one right here。
    And what this。 application is gonna be doing is returning prices from different
    cryptocurrencies and exchanges and。 all that。 The reality is that we could have
    consulted a real service by doing this tutorial。 but to be honest， I don't want
    to hit an external service by doing our tutorial because potentially。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 快速展示一下。这是加密货币示例，flask 黑客，就在这里。这个应用将返回来自不同加密货币和交易所的价格。实际上，我们可以通过这个教程咨询一个真实的服务，但老实说，我不想在做我们的教程时请求外部服务，因为可能会没有。
- en: you can be loading， overloading a server just for the sake of the education。
    So it took the time。 to recreate the application for only for this tutorial。 So
    let's start the app。 And we're gonna put。 we're gonna put slip， no， no slip。 There
    you go。 And it's running in this URL。 There you go。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为了教育的目的去过载一个服务器。因此我花时间只为这个教程重建应用。所以让我们启动应用。我们将设置。我们将不设置延迟，没错。好了，它在这个 URL
    上运行。就这样。
- en: '![](img/d47b771f29319a5dab186fef57705ab6_17.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d47b771f29319a5dab186fef57705ab6_17.png)'
- en: And it's a very simple app。 And what we're gonna have is all the exchanges that
    are part of our app。 they are all here， all the symbols or all the currencies
    we support。 And then we can consult。 prices of given dates。 Let's see if there
    is a price here。 I don't know。 There is a price here。 So for Vith Finex， BDC，
    this is the price of that given date。 The way I have created。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的应用。我们将有所有参与我们应用的交易所。它们都在这里，所有我们支持的符号或货币。然后我们可以咨询给定日期的价格。让我们看看这里是否有价格。我不知道。这里有一个价格。所以对于
    Vith Finex，BDC，这就是那个给定日期的价格。我创建的方式。
- en: this simple app， aside from the code， is by getting information from where is。
    I think it's right here， in this notebook from CryptoWatch API。 You can follow
    all these notebooks if you want to see the， process that I follow to create the
    app。 But basically， I downloaded the information from this， public API。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的应用，除了代码外，是从哪里获取信息的。我想就在这里，在这个 CryptoWatch API 的笔记本中。如果你想查看我创建应用时遵循的过程，可以查看所有这些笔记本。但基本上，我是从这个公共
    API 下载了信息。
- en: and I download them all in CSV files。 And then I instantiated SQLite database。
    So the。 flask app is rating the price from the database。 So that method price
    is actually performing this。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我将它们全部下载为 CSV 文件。然后我实例化了 SQLite 数据库。所以这个 flask 应用是从数据库中获取价格的。因此这个方法实际上是在执行这个操作。
- en: '![](img/d47b771f29319a5dab186fef57705ab6_19.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d47b771f29319a5dab186fef57705ab6_19.png)'
- en: query。 You are gonna get the price for a given exchange， given symbol， and a
    given date。 We。 perform that query， and we return the results。 If any， if there
    are no results， we will just return。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 查询。你将获取给定交易所、给定符号和给定日期的价格。我们执行那个查询，并返回结果。如果有的话，如果没有结果，我们将只返回。
- en: '![](img/d47b771f29319a5dab186fef57705ab6_21.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d47b771f29319a5dab186fef57705ab6_21.png)'
- en: none。 So that's again， a quick introduction of how our app works。 So it's running，
    we can sit。 we can sit right here。 And what we're gonna do is we're gonna instantiate
    by base URL， we're gonna。 use the requests， math module that it's used to perform
    HTTP requests。 I'm sure you're all familiar。 with it。 And we're gonna perform
    a simple query here to see what's the price。 Actually。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这又是我们应用工作原理的简要介绍。应用正在运行，我们可以坐在这里。我们将通过基础 URL 实例化，然后使用请求和数学模块来执行 HTTP 请求。我相信你们都很熟悉这个。我们将在这里执行一个简单的查询，看看价格是多少。实际上。
- en: let's let's follow the same price here。 We're gonna see bitfennox， bdc。 but
    we're gonna change the date。 And we're gonna get the same price potentially。 Oh，
    let's see。 close 7247， close 7247。5。 So it's the， same price price， sorry， again，
    for both of them。 So now。 why are we using this app？ We're gonna be， using it
    throughout the entire tutorial。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续关注相同的价格。我们将查看 bitfennox，bdc。但我们将改变日期。我们将获得相同的价格。哦，看看。收盘7247，收盘7247.5。所以是相同的价格，抱歉，再次对它们说。现在，我们为什么使用这个应用？我们将在整个教程中使用它。
- en: What I what we want to do here， is we want to check。 prices of a few different
    cryptocurrencies on a few different exchanges。 But to make things more。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里想要做的是检查几个不同交易所的几种不同加密货币的价格。但为了让事情更有趣。
- en: '![](img/d47b771f29319a5dab186fef57705ab6_23.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d47b771f29319a5dab186fef57705ab6_23.png)'
- en: interesting， what I'm gonna do is gonna restart the server by providing a sleep
    parameter。 And this。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我将通过提供一个休眠参数来重启服务器。这。
- en: '![](img/d47b771f29319a5dab186fef57705ab6_25.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d47b771f29319a5dab186fef57705ab6_25.png)'
- en: is an artificial time for the server to sleep。 So we check right here， if sleep，
    we're gonna。 sleep each after each request is gonna be delayed for this given
    number of seconds。 And this， which。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个人为设置的服务器休眠时间。所以我们在这里检查，如果休眠，每个请求后都将延迟给定的秒数。而这个，
- en: '![](img/d47b771f29319a5dab186fef57705ab6_27.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d47b771f29319a5dab186fef57705ab6_27.png)'
- en: is informed right here， will help us simulate the process of a slow server。
    And that's why we need。 threats。 If you remember from our conceptual explanation，
    we said， let's say we want to consult。 three prices， we want to consult， what
    do we have here， we're gonna check always for bdc。 And we have bitfennox， bf，
    we have bitstump， stamp。 And we have Kraken。 These three exchanges。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的信息将帮助我们模拟一个缓慢的服务器过程。这就是我们需要线程的原因。如果你记得我们的概念解释，我们说，假设我们想咨询三个价格，我们想咨询，看看我们有什么，我们将始终检查BDC。我们有Bitfinex，BF，我们有Bitstamp，STAMP。还有Kraken。这三个交易所。
- en: If each request is delayed by two seconds， right， two seconds， because we have
    artificially slow。 down the server， if we make this sequentially， in that means
    no threats at all， just as you know it。 you're gonna， you can do a for loop， you
    can do a less comprehension， whatever， the total time that。 is gonna take you
    to run all these things is gonna be six seconds。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个请求延迟两秒，对吧，延迟两秒，因为我们人为地减慢了服务器速度。如果我们顺序执行，这意味着根本没有线程，正如你所知道的。你可以做一个for循环，可以做一个列表推导，无论如何，运行所有这些东西所需的总时间将是六秒。
- en: or at least six seconds around six， seconds， right， because you're gonna make
    this request。 slip for two seconds， slip， make this， request， slip for two seconds，
    make this request。 slip for two seconds， and finally， the process， is gonna be
    done。 If we run all these tasks of getting the price concurrently， that means
    an， kind of imperlil， right。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 或者至少是六秒，大约六秒，对吧，因为你将发出这个请求。延迟两秒，延迟，发出这个请求，延迟两秒，发出这个请求。再延迟两秒，最后，过程就会完成。如果我们同时运行所有这些获取价格的任务，那就意味着某种程度上的并发，对吧。
- en: I'm using these two interchangeably until we see the concept of the， girl and
    all that。 but if we run all these concurrently， and we say these are all running，
    hopefully。 let's say they're all running imperlil， that means that the whole process
    is gonna be。 finished in about two seconds， and that's the idea of using threats。
    So let's try it out now。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这两者之间交替使用，直到我们看到女孩的概念和所有相关内容。但如果我们并发运行所有这些，并且我们说它们都在运行，希望如此。假设它们都在并发运行，这意味着整个过程将会在大约两秒内完成，这就是使用线程的想法。那么现在我们来试一下。
- en: I'm gonna， uh， instantiate the threats with the exchange is gonna use， we're
    gonna use these three。 exchanges， and we're gonna measure how much time it takes
    us to do the whole request。 So for each one， of the exchanges， we're gonna be，
    this is sequential， the sequential process。 by the way， we first ask， for bitfonex，
    then forbid some and then for cracking。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我将实例化线程，使用交易所，我们将使用这三个交易所，我们将测量完成整个请求需要多少时间。因此对于每一个交易所，我们将，这个是顺序的，顺序过程。顺便提一下，我们先询问Bitfinex，然后是Bittrex，最后是Kraken。
- en: this is taking us say 6。84 seconds， all right， this， is sequential， we check
    a price first。 we sleep， it just， you know， blocks， we then check the other， one，
    then check the other one。 this is sequential one that takes 6 seconds。 But now
    let's do it concurrently。 we're gonna define a function which is check price that
    receives a exchange symbol date， and a base。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这大约需要6.84秒，没问题，这个是顺序的，我们先检查一个价格。我们等待，它只是，嗯，阻塞，然后检查另一个，再检查另一个。这是一个需要6秒的顺序过程。但现在让我们并发执行。我们将定义一个函数，检查价格，它接收一个交易所符号日期和一个基础。
- en: URL we were gonna use from the default one， it's just gonna check that price。
    So now I can start one， thread per each exchange that I have set。 So they have
    three exchanges。 they're gonna be creating， three threats。 And what I'm gonna
    do is I'm gonna start the time。 start the threats， start counting， and now we
    see that all the prices， bitfonex， Kraken。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的URL是默认的，它只是会检查那个价格。所以现在我可以为我设置的每个交易所启动一个线程。因此他们有三个交易所。将会创建三个线程。我将做的是开始计时。启动线程，开始计数，现在我们看到所有的价格，Bitfinex，Kraken。
- en: and bitstump， they have all finished in about 2。35， seconds。 And this is what
    we are expecting from threats， we're expecting sequent， not sequential。 sorry
    concurrent， close to parallel execution to speed things up。 Now a few things here，
    we can't。 we can't be sure which one is finishing first， to be honest， in this
    case Kraken finished first。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 并且Bitstamp，他们都在大约2.35秒内完成。这是我们对线程的期待，我们希望它们是并行的，不是顺序的，抱歉，是并发的，接近于并行执行以加快速度。现在这里有几点，我们不能。我们不能确定哪个先完成，老实说，在这种情况下，Kraken首先完成。
- en: if we run this thing， maybe another one can finish first。 Not everything is
    so linear in。 in the work， you have to do in real life， in this case where artificial
    is living for two seconds。 in real life， this request may be slower than this
    request， so you don't know how it's gonna end up。 And you， also see that in this
    case these two things were written in the same line。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个，也许另一个可以先完成。并不是所有事情在工作中都是线性的，你在现实生活中要做的事情，在这种情况下人工运行了两秒。在现实生活中，这个请求可能比这个请求慢，所以你不知道它会如何结束。你也会看到在这种情况下这两件事是在同一行写的。
- en: that's because there is， some， there are some issues， right。 some shared state
    or side effects that are affecting that。 we're gonna see more about that in our
    next lesson。 But again， the idea here is that we're。 spitting things up by concurrently
    running the three threats to console the prices of those。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为存在一些问题，对吧。一些共享状态或副作用影响着这个过程。我们将在下一课中进一步了解这一点。但再次强调，这里的想法是通过并发运行三个线程来加快获取这些价格的速度。
- en: three exchanges。 So this is wonderful， right， let's say we have。 let's say let's
    follow this example and， say we wanna get。 we wanna get prices for all the 10x
    exchanges we have in our system， the three， symbols， BTC。 LTC ether， ether， and
    we wanna get all the past 30 days。 In total， we're gonna be making。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 三个交易所。这太棒了，假设我们有，让我们按照这个例子来，假设我们想要获取我们系统中所有10个交易所的价格，三种符号，BTC，LTC，ETH，我们想要获取过去30天的所有数据。总之，我们将进行。
- en: 900 requests。 Can we start 900 threats following this pattern creating one thread
    per work？ Can we。 create all those 900 threads？ The answer is usually no， we cannot，
    because threads will。 if we go back， again to this picture， they will consume
    resources in the process。 So we don't wanna clog the entire， process with a ton
    of threats working concurrently。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 900个请求。我们可以按照这个模式启动900个线程吗？每个工作创建一个线程？我们可以。创建这900个线程吗？答案通常是否，我们不能，因为线程会。如果我们再次查看这张图，它们会在过程中消耗资源。所以我们不想用大量线程同时工作来堵塞整个过程。
- en: So we're gonna see how we can fix this with multiple， ways。 Mainly。 we're gonna
    use the producer consumer model， we're gonna follow this exact example。 in which
    we will create a pool of threats， let's say 10， and they're gonna take care of
    running all。 the requests。 But again， what I'm saying here is be careful， right。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将看看如何通过多种方式来解决这个问题。主要是，我们将使用生产者-消费者模型，按照这个确切的例子进行，我们将创建一个线程池，假设是10个，它们将负责处理所有请求。但再一次，我要说的是要小心，对吧。
- en: the summary of this is be careful， how many threats you're gonna create。 it
    depends a lot on the system you're using， and we're gonna talk， more about that。
    There's a formula that the Python module uses to calculate how many threats is
    optimal。 but that is it。 Finally， as a summary， remember， threading is the module
    we're using， do not use。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这段话的总结是要小心你要创建多少线程。这很大程度上取决于你使用的系统，我们将进一步讨论这一点。Python模块使用一个公式来计算最佳线程数，但就是这样。最后，总结一下，记住，我们使用的模块是线程，不要使用。
- en: threads， underscore threads， sorry， because it's a very low level module you
    don't wanna get。 messed up in there。 So let's move forward with thread data and
    read and raise conditions。 Let's talk now about what are the implications of having
    shared data in our threads。 In our previous， in our previous notebook， we saw
    how multiple threads can access given local variables or actually。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 线程，_线程，抱歉，因为这是一个非常低级的模块，你不想在里面搞糟。那么让我们继续讨论线程数据以及读取和引发条件。现在让我们谈谈在我们的线程中拥有共享数据的影响。在我们之前的笔记本中，我们看到了多个线程如何访问给定的局部变量。
- en: global variables in a process， right， they're actually local to the main threads。
    The notation。 is confusing， but basically， threads can access shared data。 This
    is interesting， because we saw。 we could control the behavior of threads by just
    all by mutating different variables that are set in。 the global scope of the process
    that can be convenient。 But it will also introduce a few problems。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 进程中的全局变量，实际上是局部于主线程的。这个表述有些混淆，但基本上，线程可以访问共享数据。这很有趣，因为我们看到。我们可以通过仅仅改变设置在进程全局作用域中的不同变量来控制线程的行为，这可能很方便。但它也会引入一些问题。
- en: That's， what we're gonna talk about right now。 The first problem we're gonna
    see is the issue with raise。 conditions in which， conceptually speaking， and this
    is very conceptual。 raise condition is gonna be， and I have here linked to the
    wiki PD article， but basically。 a raise condition is problematic condition， something
    we don't wanna have in a program in which the。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们现在要讨论的内容。我们将看到的第一个问题是与竞争条件有关的问题，从概念上讲，这非常抽象。竞争条件是一个问题条件，这在程序中是不希望出现的。
- en: outcome of the program will depend on the way that or the order that some instructions
    are。 executed。 And that's something we don't want。 Let's say today， our program
    outputs five， because。 I don't know， thread one run runs before runs thread two，
    and tomorrow， it outputs seven。 because thread two run first， and thread one run
    later。 So we don't want to have just sort of。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的结果将取决于某些指令的执行方式或顺序。这是我们不想要的。假设今天，我们的程序输出五，因为。我不知道，线程一在线程二之前运行，而明天，它输出七，因为线程二先运行，线程一后运行。所以我们不想只是有一个固定的迭代次数。
- en: random behavior in our programs， because one thread bit the other and run first，
    right？ We want。 a third-term and stick approach。 We want things we are sure about。
    We don't want our program to。 run successfully today， because thread one won in
    the raise competition， and tomorrow， it fails。 transferring money incorrectly，
    or， I don't know， granting access to a user that hasn't paid。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序中的随机行为，因为一个线程比另一个线程先运行，对吧？我们想要一个确定性和一致性的方法。我们想要那些我们能够确信的东西。我们不希望我们的程序今天成功运行，因为线程一在竞争中获胜，而明天却失败了，错误地转账，或者，我不知道，错误地授予一个未付款用户的访问权限。
- en: because another thread run first， right？ We want our programs to be deterministic。
    So。 I'm gonna show you the problem of raise conditions with this example。 We have
    a global。 counter-varval that it sets zero， and we're gonna define this function
    increment in which。 we're gonna run in threads。 We're gonna create 10 different
    threads， and we're gonna make them run。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因为另一个线程先运行，对吧？我们希望我们的程序是确定性的。所以，我将通过这个例子向你展示竞争条件的问题。我们有一个全局计数器变量，它被设置为零，我们将定义这个增量函数，在其中我们将在线程中运行。我们将创建10个不同的线程，并让它们运行。
- en: a given number of iterations。 We're gonna pass， we're gonna say each thread
    to run a thousand times。 So， right， we're gonna create just to follow， we're gonna
    create， we have a global counter-varval。 starting in zero， and we're gonna instantiate
    10 different threads。 10 here， we're gonna do 10。 different threads right there。
    These are 10 threads。 And each thread is gonna run 1000 iterations。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让每个线程运行一千次。所以，对，我们将创建一个全局计数器变量，从零开始，我们将实例化10个不同的线程。这里的10，我们要做10个不同的线程。这些是10个线程。每个线程将运行1000次迭代。
- en: here of this code。 1000， we're passing that as a parameter， but in this case，
    we have to find 1000。 1000 repetitions of that given iteration， incrementing the
    counter by one， right？ So， they're all。 incrementing the share counter by one。
    Right， that's what they are all doing。 Um。 what could be the expected output of
    this？ Let's say， forget about threads for a second。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们传递1000作为参数，但在这种情况下，我们必须找到1000。1000次给定迭代的重复次数，将计数器增加一，对吧？所以，它们都在将共享计数器增加一。对，这就是它们所做的。嗯。那么这会产生什么样的预期输出呢？暂时忘记线程。
- en: let's say you run this thing sequentially。 You run first the first thread here，
    you run 1000。 iterations， so the output is gonna be 1000 or sorry， not the output。
    The value of counter。 after these first thread runs is 1000。 Then you run the
    second thread， and this one increments。 all the counter by 10 by 1000 again， sorry，
    because you have 2000 here， and then this finishes。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你顺序运行这个程序。你先运行第一个线程，进行1000次迭代，所以计数器的值在第一个线程运行后是1000。然后你运行第二个线程，这个线程将计数器增加1000，再次是1000，因为你这里有2000，然后这个线程完成了。
- en: and we have another thread 1000 iterations， now it's 3000， right？ So the output
    at the end of this。 thing is gonna be equals to the number of threats we have，
    we're gonna say number of threats times。 the number of iterations。 In our example，
    we have 10 threads， 10 times 1000 iterations。 So our result is gonna be 10，000。
    That's gonna be the result。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有另一个线程进行1000次迭代，现在是3000，对吧？所以最后这个事情的输出将等于我们拥有的线程数量，我们将说线程数量乘以迭代次数。在我们的示例中，我们有10个线程，10乘以1000次迭代。所以我们的结果将是10,000。这将是结果。
- en: the final result that we are expecting， in a correctly executed but slow， it
    doesn't matter。 but correctly executed program， we're gonna have， 10，000 is gonna
    be the output。 What we're gonna see in the wrong behavior in the problematic。
    race condition behavior is that these threats will be stepping into onto each
    other。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望的最终结果是，在正确执行但较慢的情况下，这无关紧要。但是在正确执行的程序中，输出应该是10,000。我们在有问题的情况下会看到错误的行为，竞态条件的表现是这些线程将会互相交错。
- en: and they will be， mutating data here and there， and the output will be different
    than 10，000。 That's of course， problematic， we don't want that to happen。 So let
    me clear up all this thing。 and we're gonna run， the example， we're gonna find
    the increment function， iterations， variable。 we're gonna， instantiate the threads
    and we're gonna start them all to run。 They all finished。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它们会在不同地方改变数据，输出将与10,000不同。这当然是有问题的，我们不希望发生这种情况。那么让我来澄清一下所有这一切。我们将运行示例，找到增量函数、迭代和变量。我们将实例化线程并开始让它们运行。它们都完成了。
- en: this was very fast， we're slipping them for just a few milliseconds。 And now，
    well， it all worked。 Now， sorry， the threads fail。 So this is interesting。 In
    the first example。 not something that usually， doesn't happen， and I was actually
    thinking about trying to replicate it。 In the first example， it worked， you know，
    and that's the problem with race conditions。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常快速，我们只间隔了几毫秒。现在，一切都工作了。抱歉，线程失败了。这很有趣。在第一个示例中，并不是通常发生的事情，我实际上是在考虑尝试复制它。在第一个示例中，它工作了，你知道，这就是竞态条件的问题。
- en: And this is a great thing that， happened。 You might run your code， I need my
    run correctly。 like the first example， it worked， but then you try it in production
    and it breaks。 The worst thing is it doesn't break。 In this case， I am making
    it break on purpose。 The problems that you have an incorrect result， which if
    you're， confident about the code。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一件很棒的事情。你可能会运行你的代码，我需要正确运行。就像第一个示例一样，它有效，但随后你在生产中尝试时却崩溃。最糟糕的是，它并没有崩溃。在这种情况下，我故意让它崩溃。你有一个不正确的结果，如果你对代码充满信心。
- en: because you run it locally and it worked or the tests are passing， in production。
    you will trust this value of counter。 Although， again， it's a faulty one。 So let's
    do， it again。 Let's try creating the threads and see how they work。 Well， it seems
    like it keeps， failing now。 And check the results， the counter variable， it's
    always different， it's completely， random。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你在本地运行它并且它有效或测试通过，但在生产环境中，你会相信这个计数器的值。虽然，再次强调，这是一个有缺陷的值。那么我们再试一次。让我们尝试创建线程，看看它们是如何工作的。好吧，似乎现在它一直在失败。检查结果，计数器变量总是不同，完全是随机的。
- en: just whatever 32，000。 In this case， it's 47，000。 It's just， oh， I'm not changing
    the counter。 There you go。 So I thought， a thousand and seven hundred sixty， 60，
    60， yes。 So again。 another value， and resetting the counter and it always changes
    the value。 It's completely random。 It's completely， random。 You don't know what
    the value it's going to be。 Right。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 随便说说32,000。在这个例子中是47,000。只是哦，我没有改变计数器。看到了吗？所以我认为是1,760，60，60，是的。所以再次，另一个值，重置计数器，值总是变化。它完全是随机的。你不知道这个值将会是什么，对吧？
- en: This is the result of a race condition。 And why does this thing happen？ Well。
    it happens because if you look into the details of， this operation， counter plus
    equals one。 what you're going to see is that internally， there is no way of performing
    this operation in just one step。 In reality， what we do， if we have a， value z，
    the C， sorry， that it's zero。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是竞争条件的结果。为什么会发生这种情况？嗯。如果你查看这个操作的细节，counter加一。你会发现内部没有办法在一步中执行这个操作。实际上，如果我们有一个值z，C，抱歉，是零。
- en: and we want to increment C， what we do is we create an。 artillery variable with
    the value or the code equals C plus one。 So that is now one。 And then we set，
    the value here， we do see is equals to oops。 That's the usual process that computers
    are， going to follow。 So that again， that's like two。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要递增C，所做的就是创建一个**炮兵**变量，其值或代码等于C加一。因此现在是1。然后我们设置这里的值，看到的是等于oops。这是计算机通常会遵循的过程。所以这又是二。
- en: three operations at least。 The fine ox， created some risk gave this result and
    then set it back again to see。 In this moment， if you have， if you have parts
    of these being run by different threats。 they might be stepping， onto each other's
    data。 Let's say we have counter equals zero。 This is a whole， the whole counter。
    And we have these two threads that are starting concurrently。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 至少三次操作。fine ox产生了一些风险，得到了这个结果，然后再把它设置回C。在这个时刻，如果你有这些部分由不同的线程运行，它们可能会相互干扰数据。假设我们有counter等于零。这是整个counter。我们有这两个线程同时启动。
- en: Three， this is T one。 And they start， with this operation， create ox and counter。
    That's going to be the same for them。 Ox is going to be。 equals to C plus one
    for them for both of them is going to be the same equal C plus one for both。 them。
    But these two run at the same moment， exactly the same moment in parallel。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是T1。它们以这个操作开始，创建ox和counter。这对它们来说是相同的。ox将等于C加一，对它们两个来说是相同的C加一。但这两个线程在同一时刻完全并行运行。
- en: That means that C for， T one， it's going to be zero。 So it's going to be zero
    plus one。 But it's also going to be， here zero for number four three threads or
    a number two。 So in this moment， the result of A， is going to be equals for the
    same for both of them。 It's going to be one here。 That's going to be， one here。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对于T1，C将为零。所以它将是零加一。但对于编号为四或二的三个线程来说，这里也将是零。因此在这个时刻，A的结果对它们来说都是相同的。这里将是1。这里也将是1。
- en: Then it doesn't matter which one wins setting back the value here。 But basically。
    we run two operations and they both got the same value。 Right？ At the end is going
    to be just one。 What we want here， I'm going to clear this thing up。 We won't
    see。 What we want is that these two。 threads， if when A reads the value C zero
    plus one， we want the first thread， which is C plus one。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 那么无论哪个先返回这里的值都没关系。但基本上，我们执行了两个操作，它们都得到了相同的值，对吧？最后只会是1。我们想要的是，我要澄清这一点。我们想要的是这两个线程，当A读取C的值零加一时，我们希望第一个线程是C加一。
- en: We want it to wait until A equals one until this one puts the value here。 And
    now this can go and read， it。 We want the threads to be isolated and we don't
    want them to collide at the moment of reading or。 writing data。 And we are going
    to achieve that with what we call thread synchronization。 This is a very big deal
    in computing。 It's a very big deal。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望它等待直到A等于1，直到这一项把值放在这里。现在它可以去读取它。我们希望线程是隔离的，我们不希望它们在读取或写入数据时发生碰撞。我们将通过我们称之为**线程同步**来实现这一点。这在计算中是非常重要的。
- en: It's going to happen in operating systems， database systems。 If you want to
    read more about it。 there are tons of books， read anything about them， about it。
    You can get any operating system textbook and it's going to。 talk about there's
    going to be a chapter about synchronization。 I guarantee it。 So it's a very。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在操作系统、数据库系统中发生。如果你想了解更多，可以阅读很多书，了解任何相关内容。你可以得到任何一本操作系统教材，它会谈论同步，会有一章专门讨论。我保证。因此，这是一个非常重要的主题。
- en: big deal in computing。 And the way synchronization works， basically。 but in
    a very conceptual manner， is by signaling states， signaling that I am in this
    moment。 I am accessing to counter。 So please stay away by signaling that I have
    just finished updating counters。 So now you can write， it， etc。 just by creating
    signals and informing that someone is currently using something and。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 计算中非常重要。同步工作的方式基本上是，从非常概念的角度来看，就是通过信号状态，信号我在这个时刻。我正在访问计数器。所以请保持距离，通过信号我刚刚完成更新计数器。所以现在你可以写，它，等等。只是通过创建信号并通知有人正在使用某样东西。
- en: that something that shared resource is currently busy。 It's already being used。
    And a very good。 example is this recording light。 This is from our own studios
    in reality。 I took this photo in which， as a human， if I want to use the recording
    studio。 which is a shared resource， there are several， instructors and we all
    use the same recording studio。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 共享资源当前正忙碌。这已经在使用中。一个很好的例子就是这个录音灯。这来自我们自己的工作室。我拍了这张照片，作为一个人，如果我想使用这个共享资源的录音室，有几个教练，我们都使用同一个录音室。
- en: If I want to use it， the share resource， and then approach and I reach the door
    and I see that the light has been turned on。 I will not use the resource。 I will
    not use the recording studio because that means that someone。 else is using this
    studio。 I will work。 I will wait， sorry， for the light to go off and then。 I will
    step into the studio because I know that someone has just finished using that
    resource and。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想使用这个共享资源，然后走到门口，我看到灯已经亮了。我就不会使用这个资源。我不会使用录音室，因为这意味着其他人正在使用这个录音室。我会等，抱歉，等灯熄灭，然后我才会走进录音室，因为我知道刚才有人刚用完这个资源。
- en: now I can get in。 Potentially， there are going to be multiple instructors waiting
    outside。 And the question is which one is going to reach the studio and turn the
    light on first。 That's。 another issue with synchronization。 Conceptually speaking，
    synchronization is protecting shared。 resources by providing these signals， by
    providing these hints。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以进去了。潜在地，外面会有多个教练在等待。问题是，哪个教练会先到录音室并打开灯。这就是同步的另一个问题。从概念上讲，同步是通过提供这些信号，提供这些提示来保护共享资源。
- en: saying someone has already used these， resources。 And the big deal about it
    is that synchronization is usually cooperative。 It's not that the light has a
    physical power that it's stopping me from getting into the studio。 If I'm a bad
    instructor， if I'm a bad thread， I can open the door anyways and interrupt the。
    instructor in the middle of his or her recording session。 And that's catastrophic。
    They're going to。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 说已经有人使用了这些资源。问题在于，同步通常是合作性的。并不是说灯有某种物理力量阻止我进入录音室。如果我是一个不好的教练，如果我是一个糟糕的线程，我可以无论如何打开门，打断教练正在进行的录音会话。这是灾难性的。
- en: be losing two hours of recording because I stepped into it in the middle of
    it。 For example。 if they're， in a live webinar， I'm completely destroying their
    work。 But I'm stopping and waiting outside， because I am a cooperative instructor。
    I decide to stay outside， but nothing is stopping me from， actually walking in。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我在中间打断了他们，他们将会失去两个小时的录音。例如，如果他们正在进行直播网络研讨会，我完全在破坏他们的工作。但我在外面停下来等，因为我是一个合作的教练。我决定待在外面，但没有什么能阻止我实际走进去。
- en: And the same thing is going to happen with our threats。 Our threats will use。
    synchronization methods， but they're all cooperative。 That's cooperative。 That's
    because we have decided， to write the code in that way in the best of our intentions。
    We're writing the code to use， synchronization。 But if you have a malicious piece
    of code or a sloppy programmer。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的事情也会发生在我们的线程上。我们的线程将使用同步方法，但它们都是合作的。这是合作性的。这是因为我们决定以这样的方式编写代码，出于我们的最佳意图。我们在编写代码以使用同步。但如果你有一段恶意代码或一个马虎的程序员。
- en: someone， forgot to use that synchronization mechanism。 then nothing will prevent
    the shared data to be corrected。 So let's start now in particular。 We're going
    to see our first synchronization mechanism， which is a lock。 It's a very simple。
    it's probably one of the oldest sort of synchronization， primitives that we use。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人忘记使用那个同步机制，那么没有什么会阻止共享数据被修改。所以让我们现在开始，特别是。我们将看到第一个同步机制，即锁。这是一个非常简单的，它可能是我们使用的最古老的同步原语之一。
- en: And there are multiple synchronization mechanisms like Glocks， semaphores， there
    are multiple ones。 In this case， we're going to be using lock。 Again， it's one
    of the simplest， ones。 Usually a mutual inclusion lock。 It's also called mutex，
    has several names。 Basically。 a lock works as a real lock。 There is this shared
    resource and there is an open， we're going to。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 还有多种同步机制，比如锁、信号量，还有很多其他的。在这种情况下，我们将使用锁。再说一次，这是一种最简单的锁。通常是互斥锁。它也被称为互斥体，有几个名字。基本上，锁的工作原理就像一个真正的锁。有这个共享资源，并且是开放的，我们将要。
- en: I'm going to try drawing a lock。 It's an open lock。 Someone uses the resource。
    So they just shut down， they close the lock。 When they are ready。 when they're
    finished using the lock， they're going to open。 the lock and now it's going to
    be available for someone else to go and take it for someone else to。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我打算尝试画一个锁。它是一个开锁。有人使用这个资源。所以他们只是关闭，锁上这个锁。当他们准备好了，当他们完成使用这个锁时，他们会打开这个锁，现在它将对其他人可用，供其他人去使用。
- en: go and use it。 So the way it works is by we create one instance of the lock。
    the lock will be shared。 We're all using the same lock。 And the thread that is
    going to work on that lock will try first， acquiring the lock。 This is basically，
    I want to use these resource， these resources， what we're。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 去使用它。所以它的工作原理是我们创建一个锁的实例。这个锁将是共享的。我们都使用同一个锁。而将要在该锁上工作的线程会首先尝试获取锁。这基本上是，我想使用这些资源，我们正在这里做的。
- en: doing right here in between。 So I want to use this resource。 I'm going to acquire
    the lock。 So now。 I owned this lock。 So nobody else， by using by doing this， I
    will be guaranteed that nobody else。 no other thread will be able to acquire the
    lock。 So the operation acquire on a lock is atomic。 If I get a true output out
    of this， that means that I am the sole owner of the lock。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我想使用这个资源。我将获取锁。所以现在。我拥有这个锁。因此没有其他人，通过这样做，我将得到保证，没有其他人。没有其他线程能够获取这个锁。所以在锁上执行获取操作是原子的。如果我得到一个真正的输出，这意味着我是锁的唯一拥有者。
- en: Then I can do and work with any， I can do whatever I want。 Usually once you
    acquire the lock。 you're， going to perform some operations on that shared resource
    you have。 So let's say it's a counter， variable， the moment to increase the valid
    counter is in that particular moment when you have。 acquired the lock。 Any work
    that is not potentially。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我可以做任何事情，我可以做我想做的任何事情。通常一旦你获取了锁。你将对你拥有的共享资源执行一些操作。那么假设这是一个计数器变量，在你获取锁的那个特定时刻，增加有效计数器的时刻就在那个时候。任何不可能的工作。
- en: it's not going to suffer from a raised condition， potentially， is going to stay
    out of the lock。 Because the lock operation can potentially slow， you down。 If
    the resource is busy。 you will not be able to acquire the lock and you will not
    be， able to do that work。 So usually anything that is not dealing with shared
    data that's going to stay， outside of the lock。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 它不会遭受潜在的竞争条件，将会保持在锁之外。因为锁操作可能会拖慢你的速度。如果资源忙碌。你将无法获取锁，你将无法完成工作。因此，通常任何不涉及共享数据的工作将保持在锁之外。
- en: Once you acquire the lock， again， you do whatever you want。 hopefully it's just
    going to be related to shared data， shared resources。 And then once you're done。
    you release the lock。 You say， I am done， whoever wants to do this work， now they
    can acquire the。 lock。 So let's see how that works。 I acquired the lock， I did
    something and then the lock finished。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获取了锁，再一次，你可以做任何你想做的事情。希望这只是与共享数据、共享资源相关的事情。然后一旦你完成了，你释放锁。你说，我完成了，任何想做这个工作的人，现在他们可以获取锁。那么我们来看看这是如何工作的。我获取了锁，我做了一些事情，然后锁完成了。
- en: There you go， sorry， the lock finished。 The I slept for 10 seconds。 So that
    means that I'm going to be， sharing or sorry， I will have the lock acquired in
    this thread。 I will keep it busy for 10 seconds。 And then I am releasing it。 So
    what happens if I try to acquire the lock while this thread has， locked acquired？
    Well。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 来吧，抱歉，锁完成了。我睡了10秒钟。所以这意味着我将在这个线程中共享或抱歉，我将保持锁在这个线程中被获取。我将保持它忙碌10秒钟。然后我释放它。那么，如果我尝试在这个线程已获取锁的情况下获取锁，会发生什么呢？好吧。
- en: it's going to block。 So let me show you that。 t。start started acquiring the，
    lock。 The lock is acquired。 Is the lock locked？ Yes， it's locked。 What happens
    if I try acquiring it？
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 它将被阻塞。所以让我给你展示一下。t.start 开始获取锁。锁被获取。锁被锁定了吗？是的，它被锁定了。如果我尝试获取它会发生什么？
- en: I'm going to run the code again。 I'm going to increase the time here。 So you
    can see very clearly。 what's going to happen。 I'm going to start the thread again。
    It's locked。 And now we'll try acquiring， it。 And as you can see， the process
    is has just stopped。 It's waiting to acquire the lock。 The acquire， operation
    is going to block until the thread。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我将再次运行代码。我将增加这里的时间。这样你就可以非常清楚地看到将会发生什么。我将再次启动线程。它被锁住了。现在我们会尝试获取它。正如你所看到的，进程刚刚停止。它在等待获取锁。获取操作会阻塞，直到线程。
- en: whatever， whatever thread actually successfully acquires， the lock。 Okay。 Now
    the main thread has a lock and we can use a drawing to simplify this。 So we have，
    this thread。 We have， let's put a share lock right here。 And we're going to have
    this is open。 Let's。 say this is open。 And what happened here was that in this
    line， start the thread acquired the lock。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 不管怎样，实际上成功获取锁的线程。好的。现在主线程已经获得了锁，我们可以用图示来简化这一点。我们有这个线程。我们在这里放一个共享锁。这个锁是开放的。假设这个是开放的。发生在这一行的事情是，开始的线程获取了锁。
- en: Right。 So in this case， is this one is the let's put t as the owner of the lock。
    So when the main thread， our main code in the process tries to access the lock
    again here。 it tries to lock and it's locked。 So it's just waiting there。 It's
    waiting。 It's waiting until the lock is released。 Once the there you go， I'm going
    to clean this up。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对。所以在这种情况下，假设这个是锁的拥有者。当主线程，也就是我们主要的代码在这个过程中再次尝试访问锁时，它尝试上锁，但锁是锁住的。所以它在那等待。它在等待。它在等待，直到锁被释放。一旦锁被释放，我会清理一下。
- en: Once the thread here releases the lock， it's empty。 Now the main thread can
    take ownership of that lock。 So now the lock is owned by this main thread。 But
    now I have this thread finished。 It's done。 I have created a new thread here。
    I'm going to put it， here。 Again， this is done。 When it if I run it again。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这里的线程释放了锁，它就是空的。现在主线程可以获得那个锁的所有权。所以现在这个锁由主线程拥有。但现在这个线程完成了。它完成了。我在这里创建了一个新线程。我会把它放在这里。同样，这已经完成。如果我再运行一次。
- en: and it goes here in this line， it tries to acquire， the lock， that thread is
    going to block forever。 at least until I release it。 So that's what we're， going
    to do。 I'm going to start the thread。 It has it's trying to acquire the lock。
    It's， slept there。 Just stop there。 This is blocking。 The thread is waiting。 And
    what I can do， the thread is waiting there。 It's waiting。 It's waiting。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 它在这一行尝试获取锁，那个线程将永远被阻塞。至少在我释放之前。所以这就是我们要做的。我将启动线程。它正在尝试获取锁。它在那里休眠。就在那停住。这是阻塞的。线程在等待。我的做法是，线程在那儿等待。它在等待。它在等待。
- en: It's waiting。 It's waiting。 What I can do， is from the main thread， I can say，
    well。 now release the lock。 Just release it。 And I'm going to do that。 I'm going
    to release the lock。 Immediately， the lock acquire said right here， lock acquire。
    And then it finished sleeping and all that because I didn't pass any time。 But
    the idea is。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 它在等待。它在等待。我能做的就是从主线程中说，现在释放锁。就释放它。我会这样做。我会释放锁。锁的获取就在这里，锁获取。然后它完成了休眠等所有事情，因为我没有传递任何时间。但这个想法是。
- en: that the thread was stopped and waiting。 It was blocked because I the main thread
    had the locked。 acquired。 The moment I released it， that other thread was able
    to run it。 So using all this。 that might be confusing， we're going to use a real
    example。 And we're going to fix our counter。 Remember， after 1000 operations，
    10 different threats， we're waiting， we're expecting to have， 10。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 线程被停止并在等待。它被阻塞了，因为主线程已经获得了锁。当我释放锁的那一刻，那个线程就能够运行了。所以使用这一切，可能会让人困惑，我们将使用一个真实的例子。我们将修复我们的计数器。记住，在1000次操作后，10个不同的线程，我们在等待，我们希望能得到10。
- en: 000 out in the final result in the final counter。 So the way we're going to
    do that is for each。 iteration before we modify this shared data， this important
    shared data。 we're going to acquire lock。 So at that moment， we know that nobody
    else will update that counter。 We will have sole ownership， of that counter。 We're
    going to update it。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果中会出现000。所以我们将通过每次迭代在修改这个重要的共享数据之前，先获取锁来实现这一点。此时，我们知道没有其他人会更新那个计数器。我们将拥有那个计数器的唯一所有权。我们将进行更新。
- en: And then we will immediately release the lock。 So anybody。 else waiting to get
    and get the dog will be able to do it。 So I will initially。 I initialize counter，
    initialize increment or define increment。 I define a lock。 Remember that a lock
    is a share resource， to we all have to use the same lock。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们会立即释放锁。这样任何其他等待获取锁的人都能够做到。因此，我将最初初始化计数器，初始化增量或定义增量。我定义了一个锁。记住，锁是一个共享资源，我们都必须使用同一个锁。
- en: If we are using different locks， doesn't make any sense。 And， I'm going to create
    all the threads。 And now I'm going to start all the threads。 And they're working。
    I'm going to show in and wait until they finished， they'll finish pretty quickly。
    And let's see。 the result of counter。 Counter is 10，000 as expected。 Let's do
    the whole thing again。 10，000。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用不同的锁，那是没有意义的。我将创建所有线程。现在我将启动所有线程。它们正在工作。我将显示并等待它们完成，它们会很快完成。让我们看看计数器的结果。计数器是10,000，符合预期。我们再做一次。10,000。
- en: I can do this 1000 times and I can guarantee you now that these will work。 because
    no two threats will be modifying counter at the same moment。 Now。 let's go back
    again to the problems that we could potentially face with threats and， colonization。
    The first one is the issue with， and we say that this was a， corporate task that
    we were running。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以做到这一点1000次，现在可以保证这些会有效，因为没有两个线程会同时修改计数器。现在，让我们再次回到可能面临的线程和资源管理问题。第一个是与我们所说的公司任务相关的问题。
- en: I wrote this code and I was thoughtful enough to put a lock， before access encounter。
    But again。 that will require that me understanding the problem。 me being careful
    enough to include the lock or my co-worker also being。 awake at the moment of
    co-reviewing to let me see that I'm forgetting a lock， etc。 So there are。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我写了这段代码，并且很周到地在访问计数器之前放置了一个锁。但这需要我理解问题，足够小心地包括锁，或者我的同事在复审时也要清醒，让我看到我忘记了锁等等。所以这有很多不确定性。
- en: multiple things that can go wrong。 Now， four listed problems right here。 The
    first thing is you might， forget to use locks at all。 If you're just in a hurry
    and you're modifying some global variables。 you might not realize that you might
    be stepping into a raised condition。 So not understanding。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 可能出现多种问题。现在，这里列出了四个问题。首先，你可能会完全忘记使用锁。如果你匆忙修改一些全局变量，可能没意识到自己进入了一个竞态条件。因此，不理解这一点。
- en: raised conditions correctly， not understanding shared data correctly。 Just might
    be an issue of。 lack of experience。 When you're starting to write your first concurrent
    programs， you will lack。 that experience。 So that's a problem by itself。 The second
    problem is that you might forget to。 acquire the lock。 If I remove this line，
    and I haven't tried this， just go ahead and do it。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 正确理解竞态条件和共享数据，可能只是经验不足的问题。当你开始编写第一个并发程序时，你会缺乏那种经验。因此这本身就是一个问题。第二个问题是，你可能忘记获取锁。如果我移除这一行，而我还没尝试过，干脆去试试吧。
- en: if I remove this line， I will not execute the code。 If I remove this line and
    nobody actually。 acquires the lock， it's like， you know， having an open lock is
    like having no lock at all。 So the problems will arise anyway。 In this case， we
    are required to acquire the lock at the moment。 needed。 And on top of that， the
    lock is kind of a philosophical word we have in our code。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我移除这一行，我将不会执行代码。如果我移除这一行，而实际上没有人获取锁，就像，知道的，开着的锁就像根本没有锁。因此，问题依然会出现。在这种情况下，我们需要在需要的时候获取锁。此外，锁在我们的代码中算是一种哲学术语。
- en: but it's not protecting counter。 Nothing is protecting counter。 I could have
    modified counter。 before the lock。 And you know， they asked me， hey， did you use
    the lock？ Yes， I did use it。 But nobody is saying where I used it。 And this is
    a pretty dumb example。 Sorry， it's just like。 five lines of code。 But in a more
    complicated program in which you have a ton of shared data。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 但它并没有保护计数器。没有任何东西在保护计数器。我可能在获取锁之前就修改了计数器。他们问我，嘿，你用锁了吗？是的，我用了。但没有人说我在哪里用了。这是一个相当愚蠢的例子。抱歉，这只是五行代码。但在一个更复杂的程序中，你有大量共享数据。
- en: multiple locks， all scattered around， this is going to be a problem。 You might
    put the lock。 acquire in the wrong place， or you might forget it to put it at
    all。 Then it's the problem of your。 critical section， again， doing something that
    the lock is protecting or not。 And finally。 what happens is a big deal。 What happens
    if you forget to release a lock？ If I forget to release。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 多个锁分散在各处，这将成为一个问题。你可能会把锁的获取放在错误的位置，或者可能根本忘记放置它。那么这就是你临界区的问题，是否在做锁保护的事情。最后，忘记释放锁会发生什么？如果我忘记释放。
- en: the lock， all the other threats will be blocked forever。 If I have a bug in
    my program and I'm not。 releasing the log lock， sorry， all the other programs
    or threats， sorry。 they will all be blocked forever。 Let's actually see a problem
    with that。 I'm going to create a new lock， and I'm going to define this， function
    right here。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 锁，所有其他线程将永远被阻塞。如果我的程序中有一个错误，我没有释放日志锁，抱歉，所有其他程序或线程，抱歉。它们将永远被阻塞。让我们看看这个问题。我将创建一个新的锁，并在这里定义这个函数。
- en: going to start it。 And what is going to happen here is that I'm going to pause，
    faulty。 I'm going to say an error when in the sleep parameter。 So what is going
    to happen here is that。 this code is going to run， it's going to acquire the lock。
    I have a release。 So let's let me let's say， I submit a pull request， you review
    this code。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我将开始它。这里将会发生的是我将暂停，出现错误。我将在睡眠参数中出现错误。那么这里会发生什么呢？这段代码将运行，它会获取锁。我有一个释放。所以让我们说，我提交了一个拉取请求，你审核了这段代码。
- en: and you see the lock here release， and you see here， the choir and everything
    makes sense。 And you say， Hey， the code this code runs perfectly。 But， there is
    a problem。 What happens if this sleep parameter is invalid， as it's going to be
    here？
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到锁在这里释放，你会看到合唱团，一切都很有意义。你会说，嘿，这段代码运行得很好。但是，有一个问题。如果这个睡眠参数无效，会发生什么呢，就像这里那样？
- en: The moment that these code runs is going to raise an exception。 And the thread
    is going to be。 stopped altogether。 So that means that we will never reach this
    section， and that will never。 release the lock。 So now let's run it。 It blew up
    an exception。 The lock was acquired。 So now this。 lock is still in this acquisition
    process state that nobody else can acquire。 Just it's going to。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段代码运行时，将会引发一个异常。线程将会完全停止。这意味着我们永远无法到达这一部分，也永远不会释放锁。现在让我们来运行它。它引发了一个异常。锁已被获取。因此现在这个锁仍然处于获取过程的状态，没有人可以获取。它只会……
- en: hang there forever。 My code is now hanging forever。 I'm going to interrupt this
    artificially。 There is， no way of doing this in your code live。 But again。 these
    things locked can't do anything about it。 So the way we can fix this is by passing
    a timeout in the acquisition process。 So let's say I want， to acquire the lock，
    but I say， I'm only wanting to wait here for two seconds。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一直挂在那里。我的代码现在挂起了。我打算人为地中断这一点。在你的代码实时中，没办法做到这一点。但再说一次，这些被锁住的东西无法处理。所以我们可以通过在获取过程中过滤掉超时来修复这个问题。假设我想获取锁，但我说，我只想在这里等待两秒钟。
- en: Because if the lock， hasn't hasn't been released in two seconds， that is potentially
    a problem。 You can put whatever， value you want here， or you can even go ask us
    to the point to say。 I want to acquire the block， the lock， I do not want a block。
    So now the result is false。 If the lock was not acquired， and true， if you have
    successfully acquired the lock。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因为如果锁在两秒内没有释放，那就可能是个问题。你可以在这里放任何你想要的值，或者你甚至可以询问我们，明确地说。我想获取锁，不想被阻塞。所以结果是假的。如果锁没有被获取，是真的，如果你成功获取了锁。
- en: So this will not block。 We can release the lock and now all works。 So this is
    a very common problem。 You， breathe the code。 There is an acquire call and there
    is a release code call。 But anything in between， anything in between before the
    release， if something fails。 the lock will be acquired forever。 It will， be acquired
    forever because the exception will prevent this line to run。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这不会阻塞。我们可以释放锁，现在一切正常。这是一个非常常见的问题。你看过代码。有一个获取调用，还有一个释放调用。但是在这两者之间，在释放之前的任何事情，如果有什么失败，锁将永远被获取。它将永远被获取，因为异常将阻止这行代码运行。
- en: So that's a very common， pattern in programming in general。 When accessing accessing
    databases。 when accessing files， when accessing， networks， when accessing these
    important costly resources。 And there is a way in Python to， overcome those difficulties
    with the usage of context managers。 So the with statement is a context， manager
    in Python。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这在编程中是一个非常常见的模式。当访问数据库时，当访问文件时，当访问网络时，当访问这些重要且昂贵的资源时。Python中有一种方法可以克服这些困难，那就是使用上下文管理器。因此，`with`语句是Python中的一个上下文管理器。
- en: And what it's going to do is going to run basically this pattern right here。
    It。 will acquire the lock。 It will try running this critical section。 And if anything
    fails， it doesn't。 matter if it fails。 It will always release the lock， regardless
    of the condition。 If it works。 or if it doesn't， if it blows up because of an
    exception or if it doesn't blow up， it will always。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 它将运行基本上这个模式。它将获取锁。它会尝试运行这个关键部分。如果任何事情失败，不管它是否失败，它都会释放锁，无论条件如何。如果成功或失败，如果因为异常而崩溃，或没有崩溃，它都会始终。
- en: release the locks。 That's a pattern that the with statement is following。 So
    we're going to do that。 I'm going to instantiate the lock。 I'm going to start
    it。 The lock was acquired。 Lock was acquired。 And now we're going to run the example
    with the problem， if the one that blows up， the code blew up。 So that means that
    at this moment， it stopped。 But as we are using the context， manager。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 释放锁。这是`with`语句遵循的模式。因此我们将这样做。我将实例化锁。我将启动它。锁已被获取。锁已被获取。现在我们将运行这个有问题的例子，如果是那种崩溃的代码崩溃了。这意味着此时它停止了。但由于我们正在使用上下文管理器。
- en: we will see that the code is not locked。 And we can acquire the lock immediately。
    Again。 this is the pattern that we are using right here。 So finally。 to fix the
    code with the with statement， with the context manager。 the only thing we're doing
    is before our increment encounter， we're just， using lock with lock。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会看到代码并没有被锁定。我们可以立即获取锁。再次，这是我们在这里使用的模式。因此，最后，为了用`with`语句修复代码，使用上下文管理器，我们所做的唯一事情是在我们的增量遇到之前，我们只是使用`with
    lock`。
- en: we are ensuring that we will acquire the lock in this point。 We do whatever
    we， want to do。 And then right here， the lock has been released。 And this should
    all work as expected。 There you go。 10，000。 Everything is working。 So even though
    we started our lesson using， acquire and release。 this is actually not recommended。
    Where I recommend the way to acquire and release a。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保在这一点上会获取锁。我们可以做任何想做的事情。然后在这里，锁已经被释放。这一切都应该按预期工作。就这样，10,000，一切都正常。所以即使我们开始我们的课程时使用`acquire`和`release`，这实际上并不推荐。我建议的获取和释放的方式是。
- en: lock is with the with statement is a lot shorter。 And you will never forget
    to release a lock。 It's a， lot simpler， just to say with lock and use the context
    manager。 As a summary of this lesson。 or this notebook， we've talked about shared
    data。 We talked about raised conditions and the problems。 with them。 And we've
    also talked about threats synchronization。 There are multiple mechanisms。
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`with`语句的锁要简洁得多。你将永远不会忘记释放锁。仅仅说`with lock`并使用上下文管理器就简单得多。作为本课或本笔记的总结，我们讨论了共享数据，讨论了竞争条件及其问题，也讨论了线程同步。这里有多种机制。
- en: there are multiple tools that have been built to improve with the to synchronize
    multiple threats。 All these tools， they are manual tools to put it in a way。 They're
    all cooperative。 And。 there is no free lunch， we could say。 There is it's not
    that by using the tools， you will ensure。 forever that all your code will be cracked。
    That's not reality。 And sadly， it can also go wrong。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 已经构建了多种工具来改善线程之间的同步。这些工具都是手动工具，可以这么说。它们都是协作的。而且，正如我们所说的，没有免费的午餐。使用这些工具并不能永远确保你的代码不会出错。这并不是现实。可悲的是，它也可能出错。
- en: even if you use those synchronization mechanisms。 And that's why to be honest，
    we will try to stay。 away from synchronization as much as possible。 Once we reach
    this point right here， it's going to。 make a little bit more sense。 But first，
    we're going to see another issue with threats synchronization。 Which is the big
    deal of getting into a deadlock。 As promised， we're going to now talk about。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你使用这些同步机制。这就是为什么坦白说，我们尽可能避免使用同步。一旦我们到达这一点，它就会更有意义。但首先，我们将看到线程同步的另一个问题，这是进入死锁的大问题。正如承诺的那样，我们现在将讨论。
- en: deadlocks。 And you should be scared because a pretty， pretty scary thing happening
    in real life。 And we should avoid it。 We're going to start first by understanding
    when deadlocks will happen。 The first thing we're going to do is we're going to
    simulate another raised condition。 So I'm going。 to just run this thing right
    here。 Let's explain what happens。 There are two accounts。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁。你应该感到害怕，因为在现实生活中会发生非常可怕的事情。我们应该避免它。我们将首先理解何时会发生死锁。我们要做的第一件事是模拟另一个提高的条件。所以我将直接运行这个。让我们解释一下会发生什么。有两个账户。
- en: each one of them with $1，000。 And we're going to start two threats， which what
    they will do is move。 money around。 They will take $10 out of this account and
    put it here。 So now this one is going to be， $990。 And this is going to be $1，000。
    And it's going to take。 I don't know， $500 out of this。 It's， going to be $409。
    It's going to be $1，510。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 每个账户有$1,000。我们将启动两个线程，它们将转移资金。它们将从这个账户中取出$10并放到这里。现在这个账户将是$990，而这个账户将是$1,000。然后，它将取出$500，剩下$409，最终将是$1,510。
- en: And here it's going to move money around。 There can't， be money created。 All
    the money we move from here， we place it here。 And all the money we move from，
    here。 we place it here。 It's a way a regular transaction works。 So the threat
    is starting with。 a from account and a to account。 And we say move from a1 to
    a2 for the first threat。 And we say。
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将在账户间转移资金。不能创造新的资金。我们从这里转移的所有资金都放到这里，从这里转移的资金也放到这里。这是一种常规交易的方式。因此，线程从一个账户开始，到另一个账户。我们说对于第一个线程，从a1转到a2。然后我们说。
- en: move from a2 to a1 for the second threat。 When they're moving money around，
    what happens is at some。 point a raised condition arises and they find incorrect
    balances。 I am not preventing negative。 numbers， but again， an incorrect balance
    happens。 Basically， the total money in these accounts。 they has to be $2，000。
    So we're going to take an approach to fix those that issue， that raised。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从a2转到a1以应对第二个威胁。当他们转移资金时，某个时刻会出现提高的条件，他们会发现不正确的余额。我并没有阻止负数的出现，但不正确的余额确实发生了。基本上，这些账户中的总资金必须是$2,000。因此，我们将采取一种方法来解决这个问题。
- en: condition with locks。 Basically， we're going to create two locks， one for each
    account。 So we're going to say lock from and lock to from and to as a count。 So
    a1 to a2。 And the lock for。 a1 is going to be a log from and the look for a2 is
    going to be locked to。 And the code in order to。 run the code， what it's going
    to do is it's going to first acquire the first lock。
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定条件。基本上，我们将为每个账户创建两个锁定。所以我们将说从a1到a2的锁定。a1的锁定是从，a2的锁定是到。为了运行代码，它将首先获取第一个锁。
- en: then acquire the second lock。 And it's going to move money around。 It's going
    to create the sum。 check the sum， everything。 And then it's going to move forward。
    If at any moment it finds the。 incorrect behavior or condition of money being
    created， basically， it's going to stop。 We will find that potentially this will
    work to put it in a way， run it。 And seems like there is no。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后获取第二个锁。它会转移资金，计算总额，检查总额，一切正常。然后它会继续。如果在任何时刻发现不正确的行为或资金被创造的情况，它基本上会停止。我们发现这可能会正常运行。似乎没有问题。
- en: money created until we reach the iteration limit， at least。 We run for a million
    times。 at least until that moment everything seems to work。 We can do a second
    test and see if everything。 works。 It's waiting for a million operations。 There
    you go。 It finished the iteration and。 the sum is still $2，000。 There was no money
    created or lost。 The state is the same。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 资金会在达到迭代限制之前创建，至少会运行一百万次。至少在那一刻，一切似乎都正常。我们可以进行第二次测试，看看是否一切正常。它在等待一百万次操作。好了，它完成了迭代，和总额仍然是$2,000。没有资金被创造或损失，状态保持不变。
- en: Everything seems， to be correct。 If I check the logs， they're both unlocked。
    This again seems to be working， but there is a potential very dangerous situation
    that it's waiting for us。 And I'm going to show you， that right now。 The only
    thing that I'm going to do。 I'm going to reset the accounts， is I am going to
    change the way the logs are passed。 Log one。
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都正确。如果我检查日志，它们都是解锁状态。这似乎正常，但有一个潜在的非常危险的情况在等待我们。我现在就要给你展示。我要做的唯一事情是重置账户，改变日志的传递方式。日志一。
- en: log two， I was passing before from on two。 So I was using the same log for each
    account。 I'm going to change that。 I'm going to say log one， log two， log two，
    log one。 And。 I'm going to start those threats and we're going to see that this
    will never end。 I can sit here。 for a thousand hours and this will never end。
    I'm going to interrupt this for now。 And I'm going to。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 日志二，我之前是从两个日志中传递的。所以我对每个账户使用了相同的日志。我将改变它。我会说日志一，日志二，日志二，日志一。而且。我将启动这些线程，我们将看到这将永远不会结束。我可以在这里坐上千个小时，这将永远不会结束。我现在要中断这个。然后我将要。
- en: check the balance of the accounts。 Seems that they are still balanced， but，
    both logs are locked。 They're both acquired。 The issue that we have just faced，
    and again， I can try running this again。 It's going to block forever。 The issue
    that we have just faced is what。 we know as a dead lock in which two resources
    are locking， right？ Share resources and no lock can。
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 检查账户的余额。看起来它们仍然是平衡的，但这两个日志都是锁定的。它们都被占用。我们刚面临的问题，再次，我可以尝试再次运行它。这将永远阻塞。我们刚面临的问题就是我们所知道的死锁，其中两个资源在锁定，对吧？共享资源，没有锁能够。
- en: move forward because the other locked has the resource that they need。 There
    is a。 when I was in regular， software engineering school more than 10 years ago。
    in our operating system class， we were using this， very popular book。 It's a very
    good book about operating systems， very conceptual， very low level。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 向前移动是因为另一个线程锁定了它们所需的资源。当我在十多年前的常规软件工程学校时，在我们的操作系统课程中，我们使用了一本非常流行的书。这是一本关于操作系统的非常好的书，非常概念化，非常底层。
- en: You need to write it if you're not terribly interested about it。 It had this
    quote that says。 "Perhaps the best illustration of a dead lock can be drawn from
    a low pass by Kansas， legislature。" Sorry， that worked。 It's not good for me。
    "Early in the 20th century， it said， in part。 when two trains approach each other
    at a crossing， both shall come to a full stop。
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太感兴趣，你需要把它写下来。它有这样一句话：“也许死锁的最佳插图可以从堪萨斯立法机构的低通道中得出。”抱歉，这没用。对我来说不好。“20世纪初，它提到：当两列火车在交叉口相遇时，双方都应完全停下。
- en: and neither shall start up again until the other has gone。" So， there are two
    threats approaching。 an intersection。 They both have to go to a full stop。 and
    no train can move until the other has left。 But if no train can move。 that means
    they're going to be sitting there waiting there forever。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 而且在另一方离开之前，两个线程都不会重新启动。"所以，有两个线程接近一个交叉口。它们都必须完全停下来，直到另一方离开才能移动。但如果没有火车能够移动，那就意味着它们会永远在那里等待。
- en: So this is a good explanation of what's happening right here in our code。 The
    first。 threat acquires the first lock。 It's good。 Remember， for a second， I'm
    going to actually copy the。 code。 I'm going to paste it。 Do we have it again？
    Here。 There。 So， remember what's happening。 The first， when it tries to acquire
    the first lock， it succeeds， acquires the first lock。
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是对我们代码中发生的事情的一个很好的解释。第一个线程获得了第一个锁。很好。记住，稍等，我实际上要复制这段代码。我会粘贴它。我们再次有它吗？在这里。那里。所以，记住发生了什么。第一个线程在尝试获取第一个锁时成功了，获得了第一个锁。
- en: threat to try and acquire the second lock， it succeeds， but then threat once
    needs both locks。 in order to proceed。 So， when it goes to get the second lock，
    it was already owned by threat， to。 so it can't， and it sits and waits。 But when
    threat to goes to this place and to。 block one and tries to acquire the first
    lock， it was firstly acquired by threat one。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 线程尝试获取第二个锁，它成功了，但然后线程一需要两个锁才能继续。因此，当它去获取第二个锁时，它已经被线程二占有，所以它无法获得，只能停在那里等待。但是当线程二去这个地方并阻塞线程一并尝试获取第一个锁时，它首先被线程一获得。
- en: so it sits and， waits。 So they both have a share resource， and they're waiting
    for the other one。 and no threat can， move because they both are blocking something
    that the other threat needs。 So this is a very， bad situation。 It's very common
    in computer science to talk about deadlocks。 also about， starvation and a few
    others we're going to talk about deadlocks mainly。
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它停下来了，等待。因此它们都有一个共享资源，并且在等待另一个线程。没有线程能够移动，因为它们都在阻塞对方所需的某些东西。所以这是一个非常糟糕的情况。在计算机科学中，讨论死锁非常常见，也包括饥饿等其他几个问题，我们主要会讨论死锁。
- en: The issue again with， deadlock is when share resources， they are acquired by
    one。 by one threat in this case， and the other one needs it， but that other one。
    the needs that the lock is also waiting for some， other piece， and it's a very
    common problem。 The usual procedures to prevent locks or deadlocks， sorry。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 再次出现的问题是，死锁是当共享资源被一个线程获得，而另一个线程需要它，但那个线程需要的锁也在等待其他某个资源时。这是一个非常常见的问题。通常的程序是防止锁或死锁，抱歉。
- en: is ideally not to synchronize code at all。 We're going to again see more about
    that here。 but not to synchronize code at all。 And if you need to use locks manually，
    never lock on something。 forever。 Okay， so remember that your acquire method had
    a timeout， never lock on something， forever。 Always give it a chance to clean
    up， roll everything back and start over。 So in this， case。
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，不要完全同步代码。我们将在这里再次看到更多，但不应完全同步代码。如果你需要手动使用锁，永远不要锁定某个东西。好的，所以请记住，你的获取方法有一个超时，永远不要锁定某个东西，永远。始终给它一个机会进行清理，回滚一切并重新开始。在这种情况下。
- en: what we're going to do is we're going to thread one is going to acquire the
    first lock。 thread two is going to acquire the second lock， thread one is going
    to try acquiring this lock。 It's going to just give it up， I don't know， one second
    chance。 If at that time， one second。 it hasn't been able to acquire the lock，
    it's going to release this lock， it's going to go back。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是，线程一将获得第一个锁。线程二将获得第二个锁，线程一将尝试获得这个锁。它将放弃，我不知道，给它一次一秒的机会。如果在那段时间内，一秒，它没有能够获得这个锁，它将释放这个锁，然后返回。
- en: release this lock and start the whole thing again。 That's not fast， to be honest。
    we're introducing a， ton of inefficiencies， but it's going to prevent the deadlock。
    No thread will sit waiting forever， on the lock if they see that after some time
    it hasn't progressed。 If they haven't been able to， acquire all the locks they
    need， they will just stop。
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 释放这个锁并重新开始整个过程。老实说，这并不快。我们引入了很多低效，但这将防止死锁。如果线程发现在某段时间后没有进展，它们就不会永远等待这个锁。如果它们没有能够获得所需的所有锁，它们就会停止。
- en: roll everything back， release everything， and move back again。 So that's what
    we're going to do here。 We're going to define a very tiny， timeout。 We're going
    to wait only for this amount of time。 What the code follows， these we're going
    to。 do the regular thing we did before， we're going to define this locked variable
    and that the thread。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 回滚一切，释放所有内容，然后再次返回。所以这就是我们要在这里做的。我们将定义一个非常小的超时时间。我们将只等待这个时间。代码遵循这些，我们将做之前做的常规事情，我们将定义这个锁定变量以及线程。
- en: will try to acquire both locks。 So this one and this one， second one。 And it
    fit with a given timeout， if they were able to block to lock everything。 the value
    will be locked。 In other case， if they， were not able to lock everything。 they
    will release the lock that was acquired and everything is going。
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 将尝试同时获得两个锁。所以这个和这个，第二个。如果它们能够在给定的超时时间内锁定一切，值将被锁定。否则，如果它们无法锁定一切，它们将释放已获得的锁，一切都将继续。
- en: to start again because locked is going to be kept as false。 So again， it will
    try acquired the lock。 Let's say the first one was acquired correctly。 So this
    is here， this is true。 The second one was。 it's going to wait， it's going to block
    for 0。001 seconds。 And then it returns false。 It said。 it said， I didn't， I wasn't
    able to acquire this lock in this amount of time。 So then if。
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 再次开始，因为锁将保持为假。因此，它将再次尝试获得锁。假设第一个锁被正确获得。这是这里，这是真的。第二个锁是。它将等待，将阻塞`0.001`秒。然后它返回假。它说，我没有能够在这段时间内获得这个锁。那么如果。
- en: we're all the locks acquire， no true and false。 One of them was not acquire。
    So locked。 So this is not， the code it gets in this branch。 And is rest one acquire？
    Yes， it's acquire。 So it really is it。 Is rest two acquire？ No。 So there is no
    need of releasing it。 And then it goes back again， to the beginning。 Lock this
    false and it keeps moving the process。
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都是锁的获得者，没有真正的真假。它们中的一个并没有被获得。所以锁住了。因此这不是，代码在这个分支中进入。剩下的一个获得了吗？是的，它获得了。所以这确实是。剩下的两个获得了吗？没有。所以不需要释放它。然后它又回到起点。锁是假的，过程继续进行。
- en: So we're going to try acquiring， the lock kind of forever。 We could potentially
    give it a number maximum of iterations。 But in this case。 we're going to wait
    forever until we can acquire the lock。 And I'm going to run this code。 It's going，
    to take some time。 But as you can see， we have reached the iteration limit。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们会尝试永远获取锁。我们可以设定一个最大迭代次数，但在这种情况下，我们会一直等待，直到能够获取锁。我将运行这段代码，这将花费一些时间。但正如你所见，我们已经达到了迭代限制。
- en: So that means that， we never deadlocked。 And everything is working correctly。
    So again。 the process is we need to acquire， the locks with a given timeout。 We
    should never block forever。 Like， why the lock would have given， timeout。 And
    then if everything happened。 we do whatever we need。 We have now both locks。 In
    other， case。
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这意味着我们从未死锁，一切正常运行。因此，流程是我们需要在给定的超时时间内获取锁。我们不应该永远阻塞。锁会有给定的超时，如果一切顺利，我们就会执行所需的操作。现在我们获得了两个锁。否则。
- en: we're going to move forward and try to do the same thing again and again and
    again until we。 actually lock the resources。 So what's the summary of these。 let's
    say first three lessons altogether， is that this is a very funny image from a
    Mozilla developer。 What we've just learned is that it's very， hard to write correct
    concurrent code using synchronization techniques。
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续尝试一遍又一遍地做同样的事情，直到我们真正锁定资源。那么这前三个课程的总结是什么呢？可以说这是来自Mozilla开发者的非常有趣的图像。我们刚刚学到的是，使用同步技术编写正确的并发代码非常困难。
- en: It's very hard。 There's， always a bug in there。 There's always a deadlocked
    can arise。 There's always an unfortunate race， condition can arise。 It's very。
    very hard to write synchronized correctly synchronized code， either deadlocks，
    starvation。 race conditions， any of these things can arise。 And it's very hard。
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常困难。总是存在一些错误，总会出现死锁，意外的竞争条件总是可能发生。编写正确的同步代码非常困难，死锁、饥饿、竞争条件，这些问题都可能发生，非常困难。
- en: to debug the code and understand when you're doing something correctly or when
    you're not。 Okay。 so that's kind of the summary of this whole lesson。 You are
    watching this tutorial because you。 want to use multi threaded code， probably
    concurrent code。 I just want to warn you that it's not going， to be simple to
    keep that correct。
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 调试代码并理解何时做正确的事情或何时不做，这就是整个课程的总结。你观看这个教程是因为你想使用多线程代码，可能是并发代码。我只是想警告你，保持代码的正确性并不会简单。
- en: You have to do a thousand tests。 You have to make sure。 that to have a ton of
    ice on top of that code， reviewing it correctly。 Because if you hit a deadlock，
    in production， that's the worst thing can happen。 Your whole system will be blocked
    forever until you， go and manually stop it。
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须做一千个测试，确保对那段代码进行大量的审查，因为如果在生产环境中遇到死锁，那是最糟糕的情况。整个系统将永远被阻塞，直到你手动停止它。
- en: So something we don't want to do。 Moving forward， we're going to see a more。
    real life approach to work with a multi threaded code that is going to solve multiple
    of the issues。 we're going to be faced in these first three lessons。 We have pointed
    out two major issues when working。
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想做的事情。接下来，我们将看到一种更实际的方法来处理多线程代码，这将解决我们在前三个课程中面临的多个问题。我们指出了两个主要问题。
- en: with concurrent code with working with multiple threads when writing multi threaded
    programs。 The first one was that if we had too many tasks to perform， right， like
    in our example， we wanted。 check for 900 prices in our cryptocurrency price server。
    These were too many tasks to assign each。 one to a separate thread。 We couldn't
    create 900 threads。 That was the first issue we pointed out。
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用并发代码和多个线程编写多线程程序时，第一个问题是如果我们有太多任务需要执行，就像我们的例子中，我们想要检查900个价格在我们的加密货币价格服务器。这些任务太多，无法将每个任务分配给一个单独的线程。我们无法创建900个线程。这是我们指出的第一个问题。
- en: The second one， it's of course the most complicated one to deal with。 which
    is shared data and synchronization。 We said that writing synchronized code is
    very hard。 It's error prone。 It's hard to debug。 There， is always an issue there。
    Deadlocks can happen。 Corrupted data can happen。 There are multiple， things going
    on when writing synchronized code。
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题，当然是最复杂的一个，涉及共享数据和同步。我们说编写同步代码非常困难，容易出错，调试也很难。总会有问题出现，可能会发生死锁，数据可能会损坏。在编写同步代码时，有很多事情在进行。
- en: What we're going to see now is a partial solution， to many of these problems。
    both handling a large number of tasks。 And also， we will see a technique。 that
    will allow us not to synchronize code if possible。 And this is the producing consumer
    model。 in multi threaded code。 Producing consumer is a very generic denomination
    for multiple models。
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要看到的是一个部分解决方案，解决许多这些问题，既处理大量任务，也将看到一种技术，如果可能的话，可以让我们不需要同步代码。这就是在多线程代码中的生产者消费者模型。生产者消费者是多个模型的非常通用的称谓。
- en: In this case， apply to multi threaded codes means that we're going to have two
    main groups of threads。 One group of threads， or usually just one thread， will
    be the ones producing work to do。 creating tasks。 Putting them in a work queue
    and then consumers' threads， other threads。 will pull from this queue， in order
    to see what tasks are pending to perform。
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，应用于多线程代码意味着我们将有两个主要线程组。一个线程组，通常只有一个线程，将是生产工作的人，创建任务。把它们放在工作队列中，然后消费者线程，其他线程，将从这个队列中拉取，以查看待执行的任务。
- en: So we have some producers， some， threads that are creating the tasks that need
    to be done and workers that are pulling those tasks。 and actually performing the
    work。 The important part here is that all this is synchronized in this。 queue，
    which is in Python， it's thread safe。 That means that we don't need to synchronize
    it。 because there will be no memory corruption， there will be no raised conditions
    when。
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们有一些生产者，一些创建需要完成的任务的线程，以及拉取这些任务并实际执行工作的工作者。这里重要的是，所有这些在这个队列中都是同步的，在Python中，它是线程安全的。这意味着我们不需要同步，因为不会发生内存损坏，不会出现竞争条件。
- en: putting objects or getting objects from this big queue。 So what we're going
    to do， and this is why。 we're solving these two issues is first， we can create
    a given number of consumer threats。 We have 900 prices to check。 So our queue
    will have 900 tasks。 And then let's say we have 10。 threads or 30 threads， whatever，
    let's say we have 10 threads。
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个大队列中放置对象或获取对象。所以我们要做的是，这就是我们解决这两个问题的原因，首先，我们可以创建一定数量的消费者线程。我们有900个价格需要检查。所以我们的队列将有900个任务。假设我们有10个线程或30个线程，随便说，假设我们有10个线程。
- en: then there will be 90 prices to check， per thread。 There will be always constantly
    10 threads running， and they will pull prices， do the work。 And once they are
    finished， they're going to put another price and do the work。 and that's going
    to keep repeating until there is no more work to do。 That is usually the process。
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后每个线程将检查90个价格。将始终有10个线程在运行，他们将拉取价格，执行工作。一旦他们完成，他们会放入另一个价格并继续工作，这个过程将不断重复，直到没有更多的工作要做。这通常是这个过程。
- en: So we've shared the issue with too many tasks。 And again， as this collection，
    the queue is thread。 safe， we have also solved the issue of synchronization。 We
    will not need to manually synchronize our code。 So the queue that we're talking
    about is actually from the queue module， it's a thread safe queue。
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们分享了太多任务的问题。同样，由于这个队列是线程安全的，我们也解决了同步的问题。我们将不需要手动同步我们的代码。所以我们谈论的队列实际上来自队列模块，它是一个线程安全的队列。
- en: And it's a passive very simple API， we're going to instantiate a queue， we can
    check if it's empty。 we can put objects with a put method， and we can check if
    it's empty again， it's not empty， of。 course， the size of the queue， and we can
    get objects out of the queue。 A few important things。 I don't know how familiar
    you are with with data structures。 In this case， the queue is first in。
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个被动的、非常简单的API，我们将实例化一个队列，我们可以检查它是否为空。我们可以使用**put**方法放入对象，然后再次检查它是否为空，当然，队列的大小，我们可以从队列中取出对象。一些重要的事情。我不知道你对数据结构有多熟悉。在这种情况下，队列是先进先出（FIFO）的。
- en: first out， a B C is the way we put the objects， a B C is the way we got out
    the objects。 You can。 create a last in first out of Q2 if you want， usually call
    us TAC， it depends。 I don't want to get。 too deep into the data structures， the
    idea is that you're putting on one side， you're getting。 from the other side，
    and again， in this case， the order is respected。 An important thing is that as。
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，**A B C**是我们放置对象的方式，**A B C**是我们取出对象的方式。你可以创建一个后进先出（LIFO）的**Q2**，如果你愿意，通常称为**TAC**，这取决于你。我不想深入探讨数据结构，关键在于你从一侧放入，从另一侧取出，在这种情况下，顺序是被尊重的。一个重要的事情是。
- en: this is a thread safe queue， you might， there are a few things that are not
    synchronized to put in。 a way， they're not problematic， but for example， checking
    if a queue is empty or the size of the queue。 might be a stale result from time
    to time， because there might be another object pulling from the。 queue， but that
    doesn't matter， usually it's not a problem at all。 But again， put。
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个线程安全的队列，你可能会，有一些东西没有同步放置。在某种程度上，它们并不成问题，但例如，检查队列是否为空或队列的大小，有时可能是过时的结果，因为可能会有另一个对象从队列中提取，但这并不重要，通常这根本不是问题。但再说一次，放置。
- en: it's going to put， objects in the queue， tasks in our case， it's going to be
    a task queue for us。 and get is going to get， the object from the queue。 The queue
    is now empty。 whenever you get an object， the object is removed， it's not that
    you're reading from the queue。 you're actually getting the object out of the queue
    in， order to process it， and that's good。
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 它将把对象放入队列，任务在我们的情况下，它将是一个任务队列，而获取将从队列中获取对象。队列现在是空的。每当你获取一个对象，该对象将被移除，并不是说你在读取队列。你实际上是将对象从队列中取出，以便进行处理，这很好。
- en: because that means that no two threads will see the same task。 Once one thread
    gets the object。 the other threads will never repeat the same task。 The important
    thing about the queue is that it's prepared to work in a threaded environment。
    in this case， the queue is empty， it's like brand new。 If I try to get from the
    queue。
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这意味着没有两个线程会看到相同的任务。一旦一个线程获取了对象，其他线程将永远不会重复同样的任务。队列的重要之处在于它准备在多线程环境中工作。在这种情况下，队列是空的，就像全新的一样。如果我尝试从队列中获取。
- en: the queue will block， because it's waiting， right， the queue is。 this is a blocking
    operation in which， we are practically saying， hey。 I am ready to process a new
    task， give me a task to process， and as a queue is empty。 we will keep blocking
    until a producer thread， on the other end， puts， an object。
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 队列将阻塞，因为它在等待，对吧，队列是。这是一个阻塞操作，我们几乎是在说，嘿。我准备处理一个新任务，给我一个要处理的任务，而当队列为空时。我们将继续阻塞，直到生产者线程在另一端放入一个对象。
- en: and immediately after they put the object， this method will unblock， and it
    will。 and we will receive the task to perform， so that's why the get method is
    made to be blocking， you。 have to be aware of that， because you could potentially
    block forever。 To prevent that。 if necessary， you can pass either blockfalls，
    or you can say， timeout， right， a given time。
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦他们放置对象，这种方法就会解除阻塞，我们将接收到执行的任务，因此获取方法是设计为阻塞的，你需要意识到这一点，因为你可能会永远被阻塞。为防止这种情况，如果必要，你可以传递`blockfalls`，或者你可以设置超时，给定一个时间。
- en: and this is very similar， to the lock， wire interface， right。 in which the wire
    API of the method that we said， that we could。 prevent blocking altogether or
    pass the timeout。 The important part here is that if you don't get。 an object
    out， the method will raise an empty exception， a queue that empty exceptions。
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这与锁的线接口非常相似，对吧。在我们提到的能够完全防止阻塞或传递超时的方法的线API中，这里重要的是如果你没有取出对象，该方法将引发一个空异常，一个空异常的队列。
- en: so we have to， catch that。 A queue can also have a max size， right。 so we can
    say how many resources we're going to， create。 And in this case。 if you want to
    put another object， you have to wait for someone to consume。 the one that was
    created first， okay， so you can always be sure that the maximum size of the queue。
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们必须捕获这一点。队列也可以有最大大小，对吧。我们可以说我们将创建多少资源。在这种情况下，如果你想放置另一个对象，你必须等待有人消费第一个创建的对象，好的，所以你可以始终确保队列的最大大小。
- en: will always be one。 There will be no more than one element in that given queue，
    and of course。 these methods will also raise an exception， in this case， the full
    exception， queue。full exception。 The usual process then， and this is kind of a
    product， a protocol， an algorithm， is for the worker。 threads， they will try getting
    an object out of the queue。 If the queue is empty， right， they will。
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 始终只有一个元素。给定队列中的元素不会超过一个，当然，这些方法也会引发异常，在这种情况下，是满异常，`queue.full exception`。通常的过程是，工作线程将尝试从队列中获取对象。如果队列是空的，对吧，他们将。
- en: pretty much just break out of the code， we should put here something like return
    statement。 If the work， if a task was successfully pulled from the queue。 that
    means that there is still work to do， so we get， here the worker does， performs
    the task。 and finally notifies the queue， saying that that given task， is now
    done。
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上只是跳出代码，我们应该在这里放一些类似于返回语句的东西。如果成功地从队列中提取了一个任务，那就意味着还有工作要做，所以在这里，工作者执行任务，最后通知队列，说明该任务现在完成。
- en: And this is an important property of the queue object， because these will let
    you also。 process failures。 Let's say that you get the object， and you can also
    put it back again if it。 hasn't been finished， for example， if there is an error，
    etc。 So this works as a sort of counter。 how many tasks have been put， how many
    have been processed， and then you can just get all of them。
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这是队列对象的一个重要特性，因为这将允许你处理失败。假设你得到了对象，如果它没有完成，比如说，如果出现错误等，你也可以将其放回去。因此，这可以作为一种计数器，记录有多少任务被放入，多少任务被处理，然后你可以获取所有这些任务。
- en: to a zero state， and that means that the queue， they work to do is empty。 So
    here。 important part is， again， we will ask to get a task， we will not log， or
    we could include a timeout。 but if this， method raises an exception， that means
    again。 that all the work is done because the queue has been empty。 This is valid
    only for 19% of the cases。
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 到零状态，这意味着队列中没有工作要做。所以这里重要的部分是，我们会要求获取一个任务，我们不会记录，或者我们可以包括一个超时。但是如果这个方法抛出异常，那就再次意味着所有工作完成，因为队列已经空了。这只对19%的情况有效。
- en: Sometimes you have producers creating tasks in the queue and。 consumers pulling
    tasks at the same time。 With the model of waiting for the queue to get empty。
    that means that all the work has been placed in the queue， and now you're waiting
    to finish。 once the queue is empty， you can assume that there is no work work
    to do。 But if producers are。
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，生产者在队列中创建任务，消费者同时提取任务。使用等待队列变空的模型，这意味着所有工作都已放入队列，现在你在等待完成。一旦队列为空，你可以假设没有工作要做。但是如果生产者在。
- en: injecting elements in the queue constantly， both of them are producing and consuming，
    producing。 and consuming， that might not be the case。 An empty queue might not
    mean that there is no。 work work to do， but maybe it means that producing producers
    are not producing tasks， fast enough。 So the consumers have to block， and then
    you can either say， here， blocking equal through。
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 不断向队列中注入元素，它们同时在生产和消费，生产和消费，这可能不是情况。空队列并不意味着没有工作要做，而是可能意味着生产者没有足够快地生产任务。因此消费者必须阻塞，然后你可以说，这里，阻塞等于。
- en: which is the default， that means wait forever， or put a timeout。 If there。 are
    no more tasks created in， I don't know， 10 seconds， that means we can give up，
    and we can just。 finish， because there is no more work to do。 So let's see， with
    all these theory， let's see a real。 example， we're gonna be pulling those， nose，
    I have the server stopped， we're gonna start。
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这意味着无限期等待，或者设置一个超时。如果在，我不知道的10秒内没有更多任务被创建，那就意味着我们可以放弃，并且可以结束，因为没有更多的工作要做。那么让我们看看，结合所有这些理论，看看一个真实的例子，我们将开始提取这些，我把服务器停了，我们要启动。
- en: We will not make it slip， so it's fast enough。 You see it's working。 And again，
    the objective。 is to get these 900 requests as we said in our first lesson， but
    we're gonna do it in this。 consumer producer consumer mode。 So these are all our
    exchanges， and we're gonna do it for all。 these dates， and I've just randomly
    selected 30 days， 31 days， days， sorry， in March。
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会让它滑动，所以速度足够快。你看它在工作。而且再次，目标是获得这900个请求，正如我们在第一课中所说的，但我们将以这种消费者生产者模式来做到这一点。这些是我们所有的交换，我们将为所有这些日期这样做，我随机选择了30天，抱歉，是31天，三月份。
- en: And we're gonna do it for all the assembles， BDC， Ether， and LTC。 And in total，
    we're gonna have， 1。023 different requests。 Remember， we'll have 31 days， not
    30。 The method， the function we're。 working with， check price is very simple。
    It receives exchange， symbol， date， and a base URL。 Let's get a build， the request，
    and return the response。 That's everything that it's doing。 So。
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为所有的交易所，BDC，Ether和LTC进行这个操作。总共，我们将有1,023个不同的请求。记住，我们将有31天，而不是30天。我们正在处理的方法，检查价格非常简单。它接收交易所、符号、日期和基本URL。让我们构建请求并返回响应。这就是它所做的一切。
- en: let's say we randomly select exchange， symbol， and date。 So in this case， we're
    gonna get light。 coin from bitstamp on this date。 And let's check the price， and
    let's see what it gets。 There we go。 This is the output of this function。 Some，
    we don't have prices for all the exchanges in all the。 currencies in all the dates。
    So these might potentially be none， just want you to be aware of that。
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们随机选择交换、符号和日期。那么在这种情况下，我们将从Bitstamp获取莱特币的价格。让我们检查一下价格，看看结果。来吧。这是这个函数的输出。我们并没有所有交易所、所有货币和所有日期的价格。因此，这些可能会是空的，只想让你意识到这一点。
- en: So what we're gonna do now， very important， is we're gonna initialize a queue。
    We're gonna put all。 the tasks that we need our threats to complete。 And again，
    in this case， are in these particular。 examples， where in this field or this category
    in which we know upfront all the work we need。 so we can initialize that queue，
    we can put all the work in there just once， and there will be no。
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们现在要做的非常重要的事情是初始化一个队列。我们将把所有任务放入我们需要线程完成的任务中。在这种情况下，在这些特定的例子中，我们知道所有需要做的工作，因此我们可以初始化这个队列，我们可以把所有的工作一次性放进去，这样就不会有。
- en: producer threats， just aside from the main thread。 It's not that producers are
    constantly putting tasks。 we can initialize the queue saying we want you to complete
    all these work， put everything in there。 and the consumer threats will take care
    of that。 So at that particular moment， we can say moment。
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者线程，除了主线程。不是说生产者一直在不断放任务。我们可以初始化队列，告诉它完成所有这些工作，把一切放进去。消费者线程会处理这一切。因此在那个特定时刻，我们可以说。
- en: zero of time， I'm gonna introduce all these， and I put all the objects in the
    task。 The tasks have these form， it's just a plain old dictionary， and we say
    we want you to get。 the price from Prolonix， light coin on this particular date。
    What it's， it's just a dictionary。 that represents a pending task， right？ Task
    that put for all of them。 We have 1。
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 零时，我将介绍所有这些，并将所有对象放入任务中。任务的形式就是一个普通的字典，我们说我们想要获取Prolonix上这个特定日期的莱特币价格。这就是一个表示待处理任务的字典，对吧？对于所有任务，我们有1。
- en: 023 elements in our queue。 That what we're gonna do is we're gonna define a
    very simple class price result。 and what we're， gonna have is a dictionary with
    exchange， date， and symbol， right。 so we can keep track of all our， prices。 An
    important note here is that I know。 because I have read about it， I don't， don't，
    the property search。
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们队列中的023个元素。我们要做的是定义一个非常简单的类`price result`。我们将拥有一个包含交换、日期和符号的字典，对吧？这样我们就可以跟踪所有价格。这里一个重要的说明是我知道，因为我读过这个，我不，不需要属性搜索。
- en: that putting an object in a dictionary in a multi-threaded environment is。 thread
    safe because of the current CPython implementation。 but that doesn't mean that
    dictionary is a， thread safe collection。 I am choosing it just because of simplicity。
    In theory， to make things， thread safe。
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程环境中，将对象放入字典是线程安全的，因为当前的CPython实现。但这并不意味着字典是一个线程安全的集合。我选择它只是因为简单。在理论上，要使事情线程安全。
- en: we should use a thread safe collection， which could be also a resulting queue，
    sorry， in a。 following example， we're gonna actually have two queues， one with
    the tasks to perform。 and one with， the results or the tasks that are already
    done。 We're gonna use two queues because again， they are， thread safe。 In this
    case。
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用线程安全的集合，这也可以是一个结果队列，抱歉，在接下来的例子中，我们实际上会有两个队列，一个是要执行的任务，另一个是已经完成的任务的结果。我们将使用两个队列，因为它们都是线程安全的。在这种情况下。
- en: I'm just using a simple dictionary for the sake of the explanation。 And this
    is the code for our worker。 What it's gonna do， it's gonna try getting a task
    to perform。 and in this case， we're gonna do a block false， okay， this is important。
    because we know that all the， work has been pre-produced upfront。 So all the workers。
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是为了说明而使用一个简单的字典。这是我们工作者的代码。它要做的事情是尝试获取一个要执行的任务。在这种情况下，我们将进行阻塞等待，好的，这很重要。因为我们知道所有工作都是事先生成的。因此所有的工作者。
- en: they can be sure that if they get no， element from the queue， if it's empty。
    then there is nothing else to do， they can just exit， they can， just return。 But
    if there is a task to perform， the thread will make the request check， check the。
    price for that given exchange symbol and date， and it will put the price in that
    given dictionary。
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 他们可以确信，如果从队列中没有获取任何元素，队列为空。那么就没有其他事情可做，他们可以直接退出，直接返回。但是如果有任务需要执行，线程将进行请求检查，检查给定交易符号和日期的价格，并将价格放入相应的字典中。
- en: Something else that I know is that there will be no two threads writing the
    same information。 because I have not repeated exchanges， symbols or dates。 Again，
    that's why I can use a dictionary。 Once I put the price， I will not， I'm gonna
    notify the queue， the task queue。 that the given task has， been done， and I will
    move forward a while through。
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件我知道的事是，不会有两个线程写入相同的信息。因为我没有重复的交易、符号或日期。这就是我可以使用字典的原因。一旦我放入价格，我会通知任务队列，给定任务已经完成，然后我将继续前进。
- en: I will keep repeating until the queue is empty。 So we initialize also the results
    class。 Now。 how many threads are gonna start？ Are we gonna start？
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我会不断重复，直到队列为空。所以我们还初始化了结果类。现在，多少个线程会启动？我们要启动多少个？
- en: All these threads that are working here in the background， they're pulling from
    the queue。 et cetera。 How many can we start？ Well， there are different recommendations。
    It's something that。 needs a ton of tuning in order to understand what's the the
    optimum number of threads in a system。 in the concurrent dot futures package that
    we're gonna see， seven in the seven notebook。
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些在后台工作的线程，它们从队列中提取等。我们能启动多少个？好吧，有不同的建议。这是需要大量调整的，以理解系统中最佳的线程数量。在我们将要看到的并发dot
    futures包中，七在七个笔记本中。
- en: In this package， the recommended or actually the default number of。 threads
    for a pool that we're gonna talk you about later is either 32 or OS。CPU count，
    plus four。 sorry。 So it's the minimum of these two things。 I don't know what's
    the。 I don't know if this is actually times four， we should check it out。 They
    talk about， oh no。
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个包中，我们稍后要讨论的线程池推荐或实际上默认的线程数量是32或操作系统的CPU数量加四。抱歉。所以这是这两个数值中的最小值。我不知道这是否实际上是乘以四，我们应该检查一下。他们说，哦不。
- en: it's plus four。 Okay， so it's either CPU count plus four。 So whatever number，
    it's best for you。 there is this good recommendation here is just about what we
    prefer。 In this case。 I'm just gonna set 32， so all the tasks are finishing faster。
    It also depends on how much。 memory your computer has。 It depends on the nature
    of the operations。
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 是加四。好吧，所以它是CPU数量加四。所以无论哪个数字，最适合你。这是一个很好的建议，关于我们所偏好的。在这种情况下。我只会设置为32，这样所有任务就能更快完成。这还取决于你的计算机有多少内存。还取决于操作的性质。
- en: If they are CPU bound or IO bound， something we're gonna talk about all send
    them up。 multiple processing one in the gear one。 But for now 32 is a good number。
    So I'm gonna create all the threads。 I have just created 32， threads。 Again， the。
    what the worker receives is the queue， so it can get a new work to do a new task。
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们是CPU密集型或IO密集型，我们会讨论一下，然后启动多个处理程序。但目前32是一个不错的数字。所以我要创建所有线程。我刚创建了32个线程。再次强调，工作者接收到的是队列，以便获取新的工作或新任务。
- en: to perform and the results。 So it can publish if you want the results when they
    are ready。 I'm gonna start all the threads and now I'm gonna block on the queue。
    Okay， I'm gonna set and wait。 until the queue is empty， basically。 I'm gonna wait
    until all the tasks have been clear from the。 queue。 And that's why we need to
    publish that with that task done notification。
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 执行和结果。所以如果你想，它可以在结果准备好时发布。我将启动所有线程，现在我将阻塞在队列上。好的，我将设置并等待，直到队列基本为空。我将等待所有任务从队列中清除。这就是我们需要通过任务完成通知发布的原因。
- en: The worker is saying， to the queue， hey， I have just finished doing this thing。
    And once the queue gets back to zero， we know that all the work has been done。
    The task is zero and all the threads have exit， right？ QSMT， my work here is on，
    exiting QSMT。 my work here is on exiting。 And all the different threads， we started，
    the 32。
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者对队列说，嘿，我刚完成这个事情。一旦队列的数量回到零，我们就知道所有工作都已完成。任务数量为零，所有线程都已退出，对吧？QSMT，我在这里的工作是，退出QSMT。我的工作是退出。所有不同的线程，我们启动了32个。
- en: they have all finished。 So that's it。 We're gonna check all the prices we have。
    There's just a few random prices you can check there。 There you go。 There are
    some again that are。 non， there are more， more decimals， just there you go。 So
    for example， for MXBT on these days。 either we don't have a price。 Again， we have
    failed all the prices that we needed with our producer。
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 他们都完成了。所以就是这样。我们将检查我们所有的价格。那里只有几个随机价格你可以检查。没错。还有一些是非，更多的十进制，只管去吧。因此，例如，MXBT在这些日子里，或者我们没有价格。再次地，我们与我们的生产者一起未能获得所有我们需要的价格。
- en: consumer model。 So again， the important summary of this part is this is a completely
    different。 mental model on in the way we will design a multi threaded system。
    It's still a multi threaded system， but we didn't need any manual synchronization。
    That's great。 because the queue is thread safe。 And also， we're putting a large
    number of tasks in this queue and we're creating this pool of。
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者模型。因此，这部分的重要总结是，这是一种完全不同的心理模型，关于我们将如何设计多线程系统。这仍然是一个多线程系统，但我们不需要任何手动同步。这很好，因为队列是线程安全的。而且，我们在这个队列中放入大量任务，并创建了这个池。
- en: consumer threats are working and we're making sure we're not overloading the
    system。 This is a number， you can always tune the max worker one， you can tune，
    I don't know where it is。 you can tune the， number of workers that you're gonna
    create。 And you can always keep a report。 right？ Given these， number of workers，
    this was the load on the system CPU memory all that。
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者威胁正在发挥作用，我们确保系统不会过载。这是一个数字，你可以随时调整最大工作线程，你可以调整，我不知道它在哪里。你可以调整你将创建的工作线程数量。你可以始终保留报告，对吧？考虑到这些工作线程的数量，这就是系统CPU内存等的负载。
- en: And this was how much time it， took， etc。 You can keep tuning and perfecting
    the number of workers。 Moving forward， we're gonna see， the girl just a very interesting
    thing and see Python。 And you have probably heard about it already。 I am sorry。
    but you will not like what we're gonna see in this lesson。 It's not pretty at
    all。 It's。
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是花了多少时间等等。你可以继续调整和完善工作线程的数量。接下来，我们将看到一些非常有趣的内容，看看Python。你可能已经听说过它。抱歉，但你可能不会喜欢我们在这节课中看到的内容。这一点都不好看。
- en: actually one of the major issues with Python， which is the girl。 Let's get started。
    I'm gonna try to， to make a good introduction here。 So just follow me。 follow
    the tail of when we're gonna hit the， girl， what is the girl， what's the problem
    with it。 etc。 So again， this is just a story for now， follow my lead。
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是Python的一个主要问题，就是那个女孩。让我们开始吧。我会尝试做一个好的介绍。所以跟着我。跟随我们将要面对的那个女孩，什么是那个女孩，问题是什么，等等。所以再次强调，这只是一个故事，先跟着我的引导。
- en: We're gonna try computing prime numbers or actually checking if a number is
    prime。 and we will try to see a multithared approach for that。 So the first thing
    we're gonna do is define。 the function is prime。 Given a number， it's gonna tell
    you if it's prime or not。 Pretty simple so far。 I have a list of numbers here。
    Just the file is you this file。
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试计算素数，实际上检查一个数字是否为素数。我们将尝试为此查看一个多线程的方法。所以我们要做的第一件事是定义函数is prime。给定一个数字，它会告诉你这个数字是否为素数。目前为止相当简单。我这里有一组数字。文件就是这个文件。
- en: you can check it out。 List of， let's say， large numbers， I don't know if they're
    large。 but it's gonna take some time to， compute if one of these numbers is prime
    or not around 0。6 seconds。 Let's say there is some， issues here with timing， even
    a mineral book， etc。 So let's say it takes 0。5 seconds， half a second， to compute
    if a number is prime or not。
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看一下。让我们说一说大数字的列表，我不知道它们是否大。但计算这些数字是否是素数需要一些时间，大约0.6秒。我们说这里有一些计时问题，即使是微小的书等等。所以假设计算一个数字是否是素数需要0.5秒，半秒钟。
- en: If we have 10 of these numbers， we could expect the whole， check， right。 to
    check if all the 10 numbers are prime， it should take around five seconds。 So
    make this make a sequential approach， right， as a not multithreaded sequential
    approach。 in which we check if all the numbers are prime or not， and we are gonna
    expect that it actually。
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有这10个数字，我们可以期望整个检查，对吧。检查这10个数字是否都是素数，应该大约需要五秒钟。因此，采用顺序的方法，对吧，不是多线程的顺序方法。在这种方法中，我们检查所有数字是否是素数，我们希望实际上是这样的。
- en: took four seconds， it's even faster， four seconds to run this thing sequentially。
    one number after the， other。 We immediately see that this is a task that we could
    parallelize。 There are 10 different， there are 10 different thread numbers。 Sorry，
    so let's assume。 let's say we have four different， numbers， we have 10 actually。
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 处理四秒，实际上顺序运行这些数字，依次处理一个数字后另一个数字会更快。我们立刻看到这是一个可以并行化的任务。有10个不同的线程。抱歉，假设我们有四个不同的数字，实际上我们有10个。
- en: And my computer has actually 16 cores， this is literally what I have， right
    here in this computer。 but you know， it's pretty common for our computer to have
    eight， 16， 32 cores。 But let's say we have four numbers， I have four cores， what
    basically I can do is， put each CPU。 right， to work on each number， and they all
    work in parallel， right， and the final。
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我的电脑实际上有16个核心，这正是我在这台电脑上所拥有的。但你知道，电脑有8个、16个、32个核心是相当普遍的。假设我们有四个数字，我有四个核心，基本上我可以把每个CPU分配给每个数字，它们都可以并行工作，最终的结果。
- en: result is computed in parallel， and how much time this is gonna take if each
    one of these takes。 half a second， right， half a second， and I have 10 of these
    numbers， it's gonna take half a second。 because they will all run in parallel。
    Actually， let's say one of them takes 0。6 seconds。 then it's gonna take 0。6 seconds，
    these ones will be way finished by the time this one is done。 So。
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是并行计算的，如果每个数字的处理时间为半秒，那么处理10个数字只需半秒。因为它们都会并行运行。实际上，假设其中一个需要0.6秒。那么总时间将是0.6秒，其他的在这个完成时会很快结束。所以。
- en: if I can run all these tasks in parallel， that means that the total time is
    gonna be just the。 time of the slowest task， using multiple threads again， in
    this question approach， of course。 that's， not the case， because we're checking
    one number， and then the next number。 and the next number。 So， the total time
    it is some of all the different individual elapsed times for each one of those。
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我可以并行运行所有这些任务，那么总时间将仅是最慢任务的时间，当然，这里我们使用多个线程的方法。这并不是说我们只检查一个数字，然后下一个数字，再下一个数字。所以，总时间是所有不同个体经过的时间之和。
- en: numbers。 So let's actually write our multi threaded code， and we're gonna see
    right here， this is。 the way we're gonna run it， it's gonna be gonna create a
    function check prime worker。 which is gonna， put the value in a results list only
    if the value is prime。 Remember。 a list might not be considered， threats， threats
    at collection in CPAINT， and we know it is。
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 数字。现在让我们实际编写我们的多线程代码，我们将在这里看到。这就是我们要运行的方式，创建一个名为check prime worker的函数，只有在值是质数时才会将值放入结果列表中。记住，列表可能不会被视为在CPAINT中的威胁，尽管我们知道它是的。
- en: So this is just for education and purposes。 We're gonna create 10 threads， okay。
    one for each number， each number is gonna have its own thread， each number is
    a task， we could say。 So there's gonna be 10 different threads running this task。
    and hopefully they are gonna all running parallel， I have 16 cores。
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这只是为了教育目的。我们将创建10个线程，好的。每个数字一个线程，每个数字将有自己的线程，每个数字是一个任务，可以说。因此，将有10个不同的线程在运行这个任务，希望它们能够并行运行，我有16个核心。
- en: I have a pretty low footprint in， terms of resources in this computer。 I'm not
    using anything aside from this notebook in this browser。 So this should just go
    very fast if things go in parallel。 So let's see the results。 how much time does
    it take？ Oh， the final result is 4。2 seconds for the multi threaded approach。
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这台电脑上我的资源占用非常低。我除了这个笔记本和浏览器外没有使用任何其他东西。所以如果一切都能并行进行，这应该会非常快。那么，让我们看看结果。多线程方法的最终结果是4.2秒。
- en: So it seems like all the threads were running concurrently， but they will not
    running in parallel。 Okay， the problem here is that we have just faced the global
    interpreter lock， Python's global。 interpreter lock。 So let me show you first
    why we have this issue， and then I'm gonna tell you what。 the gill is。 Or actually
    let me tell first， let me explain a little bit better the issue and in。
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 所以看起来所有线程都是并发运行的，但它们并没有并行运行。好的，这里出现的问题是我们遇到了全局解释器锁，Python的全局解释器锁。让我先给你解释一下为什么会有这个问题，然后再告诉你什么是gill。或者实际上让我先稍微解释一下这个问题。
- en: the same time we're gonna understand in a better way what the gill is。 So what
    is the gill or what。 issue are we having？ Let's assume again， we had four three
    numbers to process， three numbers to。 process， there we go。 So three， eight， and
    seven， we need to check if these three numbers are prime。 In the sequential approach
    again， we did first three， then eight， and then we did seven。 The total。
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 同时我们会更好地理解gill是什么。那么gill到底是什么？我们遇到了什么问题？假设我们需要处理四个数字，其中三个是。处理好了。三个、八个和七个，我们需要检查这三个数字是否是素数。在顺序方法中，我们首先处理了三个，然后是八个，然后是七个。总的来说。
- en: time of our program was the sum of individual times to check each one of these。
    That sequential。 we know that。 In a multi threaded approach， right， we have three
    threads starting three， thread one。 we have thread two， and we have three， and
    we're expecting all these threats， to run in parallel。 right， let's just all run
    at the same time， right。 And let's say， let's say。
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的时间是检查每一个数字所需时间的总和。那是顺序的。我们知道。在多线程方法中，我们有三个线程，开始处理三个，第一个线程。我们有第二个线程，还有第三个，我们期待这些线程并行运行。对吧，大家同时运行。假设。
- en: this one right here takes 0。5 second， this one takes 0。6 seconds， and this one
    takes 0。5 seconds。 So this is， actually the total time when we process all the
    threats， we said it was 0。6 seconds。 That was the， expected outcome， right， we
    were hopefully waiting for everything to be processing。 part of。 So each CPU was
    assigned a number， and everything's going to finish very fast。
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个需要0.5秒，另一个需要0.6秒，而这个需要0.5秒。所以，实际上当我们处理所有线程时，总时间是0.6秒。这是我们期待的结果，对吧，我们希望所有的处理都能进行。部分。因此，每个CPU被分配了一个数字，一切都将非常迅速地完成。
- en: But that is not what happened。 The final time was 4。21 seconds。 What actually
    happened was that。 we have this three thread starting。 And given the gill， the
    issue with the gill is that in C Python。 no two threads can run at the same time。
    So what happened here was that one thread started。 started processing， and then
    before it was finished。
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 但事情并不是这样。最终时间是4.21秒。实际上发生的是我们启动了三个线程。考虑到gill，gill的问题在于在C Python中。没有两个线程可以同时运行。所以发生的事情是一个线程开始处理，然后在完成之前。
- en: it was transferred the ownership to another thread， and then this thread， and
    then that thread。 So at any given period of time， if you get a window of， time。
    there's only one thread effectively running。 Even if you have a thousand different
    cores in C。 Python， there's only one thread running at the time。 Okay。
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 其所有权被转移给另一个线程，然后是这个线程，然后是那个线程。因此，在任何给定的时间段内，如果你获得一个时间窗口。实际上只有一个线程在运行。即使在C Python中有一千个不同的核心，那个时候也只有一个线程在运行。好的。
- en: and this is exactly what's happening here。 And that makes things even slower。
    because a thread might be paused in the middle of it。 When we were， doing our
    sequential approach。 giving each number， it's our full attention of the CPU， check
    if this number is prime。 check if this number is prime， and then that one， it
    was faster。
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是这里发生的事情。这让事情变得更慢。因为一个线程可能在中途暂停。当我们在进行顺序处理时。给予每个数字，我们的CPU充分关注，检查这个数字是否是素数。检查这个数字是否是素数，然后是那个，它是更快的。
- en: because each process took care or each piece of code took care of finishing
    before moving to the。 next one。 In this case， you might be partially done。 And
    admittedly。 the CPU is actually transferred， to this other thread。 And all the
    values you have loaded in the CPU are suddenly clear out， all the cache， everything。
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个进程或每段代码在移动到下一个之前都完成了。在这种情况下，你可能只完成了一部分。可以说。CPU实际上被转移到了另一个线程。而你在CPU中加载的所有值突然都被清空了，所有缓存，所有内容。
- en: everything is loaded for this thread。 And then half of the way half of， the
    work is done。 This thread now is removed， and it goes back to you。 So you have
    to load everything。 back in the CPU and start over。 So this is why it's even slower
    to do it in this way。 And the question is， why does Python do this？ I mean， why
    can't we have threats that run in。
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这个线程的所有内容都已加载。然后工作完成了一半。这个线程现在被移除，返回给你。因此，你需要把所有内容重新加载到CPU中并重新开始。这就是为什么以这种方式更慢的原因。问题是，为什么Python会这样？我的意思是，为什么我们不能有线程同时运行。
- en: parallel？ It's kind of dumb。 We're saying we want to do Python threading， to
    speed things up。 to run things in parallel。 But the reality， the reality is that
    in C Python， the major。 Python implementation out there， what you're probably
    using， you can't run two threats at the。 same time。 There is no part of listen。
    And the reason for this is a little bit more advanced。 They。
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 并行？这有点傻。我们说我们想要进行Python线程，以加速进程，实现并行运行。但现实是，在**CPython**，即你可能正在使用的主要Python实现中，你不能同时运行两个线程。这里没有并行。这个原因稍微复杂一些。
- en: have actually linked to these talk right here from Larry Hastings。 That is very
    good。 It explains。 why there is a gill in the first place。 And it explains the
    importance of the gill。 But basically。 the gill is Python's global interpreter
    lock。 It's a lock。 What we have just seen in our previous。 lessons， it's a lock。
    It's helping Python prevent multiple threats to corrupt shared data。 Remember。
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我已经链接到这里的演讲，来自**拉里·哈斯廷斯**。非常好。它解释了为何一开始就需要这个锁。并且解释了这个锁的重要性。但基本上，这个锁是Python的全局解释器锁。它是一个锁。正如我们在之前的课程中所见，这是一个锁。它帮助Python防止多个线程破坏共享数据。请记住。
- en: all your threats are running in the same process， and they are all sharing the
    same Python interpreter。 Multiple threats can't run in the same， at the same time，
    in the same process， because they can。 potentially corrupt data。 That's the reason
    why we have a gill。 The gill is basically。 so we were using as users， as coders，
    we were using locks to share to protect our shared data。
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的线程都在同一个进程中运行，并且它们共享同一个Python解释器。多个线程不能同时在同一个进程中运行，因为它们可能会破坏数据。这就是我们需要这个锁的原因。这个锁的存在，基本上是因为作为用户和编码者，我们需要使用锁来保护我们的共享数据。
- en: our variables， we wanted to protect them。 So we created our own locks。 Well，
    I want you to know。 that Python， the Python interpreter also has important shared
    data。 It's going to be seen by。 multiple threats。 And the Python interpreter also
    wants to protect that data。 So that's why。 the interpreter created its own lock，
    right， not the interpreter coders， C Python core developers。
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我想让你知道，Python解释器也有重要的共享数据。这些数据将被多个线程访问。而Python解释器也希望保护这些数据。所以这就是解释器创建自己锁的原因，对吧，不是解释器的编码者，而是**CPython核心开发者**。
- en: introduce the lock in there。 So we will， two threads will not corrupt that data。
    So I recommend。 you， I recommend you to check out these talk right here。 It's
    very good。 It explains why we have a。 kill。 It actually sets the case for why，
    thankfully， we have a gill。 because that may see Python development， development
    a lot faster back in the day。
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 引入锁定机制。因此，我们将确保两个线程不会破坏数据。所以我建议你，查看这里的演讲。非常好。它解释了我们为何需要**全局解释器锁**。实际上，它说明了为何感谢我们有了这个锁，因为这使得Python的发展在早期可以更快。
- en: which meant more popularity。 But again， aside from my， personal opinion。 I think
    there's a very good talk。 And it's going to explain why we have the gill。 So what's
    going on？ I mean， it's like， I'm telling you about concurrency， you're sitting
    watching。 this tutorial about Python concurrency， how can we make our programs
    faster， and all that。 And。
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着更大的受欢迎程度。但再说一遍，除了我个人的看法。我认为这是一场非常好的演讲。它将解释我们为何需要全局解释器锁。那么，发生了什么？我的意思是，我在告诉你关于并发的事情，而你正在观看关于Python并发的教程，我们如何加速程序，等等。
- en: suddenly， I'm telling you， you cannot run two things at the same time。 Well，
    there is light at。 the end of the tunnel， there is a final， there is a final，
    there is final hope to all these。 And it's， in resort in the resort of IO bound
    tasks。 What we did before。 and let me replay this thing， and change colors here，
    gonna there。 What we did today was。
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 突然，我告诉你，你不能同时运行两个任务。好吧，隧道尽头有光，最终希望总是存在于**IO绑定任务**的处理上。我们之前所做的，让我重放这个过程，换个颜色。在今天，我们的变量，我们想要保护它们。因此，我们创建了自己的锁。
- en: we had two threats， let's keep it to two， threats， for simplicity， T one and
    T two。 And what we said was that no two threats could run at the， same time， right？
    That was the statement。 So this one here， this one here， they're alternating，
    they're， both running concurrently。 like they are both started at the same time。
    But they're not， they're not。
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个线程，为了简单起见，我们称之为T1和T2。我们所说的是，没有两个线程可以同时运行，对吧？这是声明。因此，这个这里，这个这里，它们是交替的，它们都是并发运行的。就像它们都是在同一时间启动的。但实际上并不是。
- en: running literally at the same time in parallel， they are switching， you know，
    execution time。 back and forth。 So this is what we mean by concurrency。 Ideally，
    what we wanted to do is have real。 parallelism， having two things being processed
    at the same time。 Again， that's not what happens。 The code that the， yeah， the
    code that is being run here at some point is interrupted， and it's。
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 线程实际上是同时并行运行的，它们在切换执行时间，来回交替。这就是我们所说的并发。理想情况下，我们希望实现真正的并行处理，同时处理两个任务。但这不是实际情况。在某个时刻运行的代码被中断。
- en: shifted。 I mean， the， the context is shifted to the second thread。 These code
    was interrupted by the， interpreter， it said， Hey， live now， now you can't。 you
    can't run here anymore。 Now share the process。 share some part of the CPU with
    that other thread right there。 The CPU， the operating system。
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的上下文被切换到第二个线程。这段代码被解释器中断，它说，嘿，立即执行，现在你不能再在这里运行了。现在分享这个过程，和那个其他线程共享部分CPU。CPU，操作系统。
- en: actually， the Python interpreter kicks you out of the CPU time and gives the
    window， the context。 to run to another thread。 This happened because this thread，
    I'm going to say something in my。 same silly， why was the thread interrupted？
    The thread was interrupted because it was running。 This is dumb， right？ It's like，
    why did I fall？ I fall because I was walking。 So if I'm not。
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Python解释器把你从CPU时间中踢出去，并把上下文转给另一个线程。这是因为这个线程，我会以同样傻的方式说，为什么线程被中断？线程被中断是因为它正在运行。这很傻，对吧？就像，我为什么摔倒？我摔倒是因为我在走路。所以如果我没有。
- en: walking， I will not fall。 If the thread is not running， it can't be interrupted。
    And follow me。 here。 It's a pretty dumb thing when I'm saying it's going to make
    sense in a， in a second。 What is。 happening here is that as this is a CPU bound
    task， checking if something is prime， the， these task。 the nature of the task
    needs CPU， it needs as much CPU as it can get。 CPU， CPU， CPU。
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 走路时，我不会摔倒。如果线程没有运行，它就不能被中断。跟我来。这里有点傻，我说这会在一秒后有意义。发生的事情是，这个任务是CPU密集型的，检查某个数是否为素数，这些任务的性质需要CPU，尽可能多地使用CPU。CPU，CPU，CPU。
- en: CPU finishes with， the answer if something is prime or not。 So as this task
    is so CPU hungry。 the interpreter at any， point decides to stop it and shifts
    the context to another thread。 But that's again because this， is a CPU bound task。
    It's a CPU hungry task。 There are other tasks。 like for example， IO tasks that
    they are short， more short lived bursts of work。 Like for example。
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: CPU完成了一个数是否为素数的答案。因此，由于这个任务非常消耗CPU，解释器在任何时候决定停止它并将上下文转移到另一个线程。但这又是因为这是一个CPU密集型任务。它是一个CPU密集型任务。还有其他任务，比如IO任务，它们是短暂的工作突发。例如。
- en: if we want to， get a price from this server， right， we want to get a price from
    this server。 And then we want to， do some computation。 This task is going to be
    a little bit more like do some processing。 get the， price from the， you get the
    price from， from the server， wait until it's done。 and then do a little， bit more
    processing。 This part right here for algorithm is spent waiting for a result to
    come。
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从这个服务器获取价格，对吧，我们想从这个服务器获取价格。然后我们想进行一些计算。这个任务将更像是进行一些处理。获取价格，从服务器获取价格，等待直到完成，然后再进行一些额外的处理。这部分算法就是在等待结果的到来。
- en: from the internet。 So when we are waiting， and let's introduce here， I'm going
    to change the。 color again。 So it makes a little bit more sense。 Let's put a bloom。
    There you go。 Actually， this。 bloom here， we're going to have our network。 Network
    right there， use black for the rest。 So what is happening here is in this sort
    of do some processing， and then get results and wait。
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在等待时，让我们在这里引入，我将改变颜色。所以这会更有意义。让我们添加一个光晕。看，这个光晕，我们会把网络放在这里。其他部分用黑色表示。因此，发生的事情是，在处理一些事情时，获取结果并等待。
- en: and then do more processing is that we do a little bit of processing。 Then we
    request some。 information from the network， the network processes and returns。
    And then we can keep up the work。 This period of time here， here， we can't do
    anything but wait。 And do you remember from our。 conceptual lessons， when I show
    you the time that in relative terms， how much time or how much。
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然后进行更多处理，我们进行一点处理。然后请求一些来自网络的信息，网络处理并返回。然后我们可以继续工作。在这段时间内，我们除了等待什么也做不了。你还记得我们概念课上吗？我给你展示过相对时间的概念，等待多久。
- en: slower a network connection was compared to a CPU task， network is very， very
    slow。 Network。 IO waiting for a file to be a read and read networking， anything
    that is IO is very slow。 So the result here is that we're going to complete out
    of these here three steps。 Step one， do some。 processing。 Step two， get prizes
    from the network and wait。 Step three， do more processing。
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CPU 任务相比，网络连接较慢，网络非常非常慢。网络 IO 等待文件读取，任何 IO 都是非常慢的。因此，结果是我们将完成这三个步骤。第一步，进行一些处理。第二步，从网络获取数据并等待。第三步，进行更多处理。
- en: In these， scheme， we're going to do the initial process。 And before we asked。
    we make the actually not before， but as we make the network request， what we're
    going to do is we。 this thread is going to inform， the Python interpreter saying，
    hey。 I'm going to sit here and wait for some time。 So you can switch， the context
    to another thread。
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方案中，我们将进行初始处理。在我们请求之前，实际上不是在之前，而是在我们进行网络请求时，这个线程将通知 Python 解释器，嘿。我将坐在这里等待一段时间。因此，你可以将上下文切换到另一个线程。
- en: I am done。 So the Python interpreter will now run。 It will do this， thing， get
    the request。 So here is going to be that here， we're going to have， going to have
    this， interaction here。 And then here。 And then here， sorry， my drawing is right。
    But basically， we have。 sped everything up， because the threads are cooperatively
    waiting for something。
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我完成了。因此，Python 解释器现在将运行。它会执行这个请求。因此，这里会有互动。在这里，然后在这里，抱歉，我的绘图有点错。但基本上，我们加快了一切，因为线程在协作等待某些事情。
- en: and they can inform the， interpreter that they will not be doing any processing
    soon。 So the interpreter can be a shift， to some other thread。 So this is sort
    of a cooperative multitasking in which the thread informs， says， I am doing。 I
    am waiting for a network response。 I don't need the CPU， move it to some other
    thread。
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以通知解释器，它们不会很快进行任何处理。因此，解释器可以切换到其他线程。这是一种协作式多任务处理，线程会通知，表示，我正在等待网络响应。我不需要
    CPU，可以将其移至其他线程。
- en: and just check back with me to see if I have the result， and I will need the
    CPU then。 So that's why， when we run， when we run these things in parallel， as
    we did before。 the total time to check how， many exchanges， three exchanges is
    practically the same as checking one exchange。 Checking the， price of one exchange
    takes 0。8 seconds， checking three of them is just 0。84。
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 然后只需查看我是否有结果，我就需要 CPU。因此，当我们并行运行这些时，如同之前一样，总时间来检查三个交易几乎与检查一个交易相同。检查一个交易的价格需要
    0.8 秒，检查三个只需 0.84 秒。
- en: probably just a rounding， issue。 So if I write again， every very fast， well。
    it was actually a lot faster。 I don't know why。 But basically， again。 the the
    gill is going to be a problem， and this is kind of the summary of the， whole talk。
    The gill is going to be a problem if and only if you are running CPU bound tasks。
    So。
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能只是一个四舍五入的问题。所以如果我再次快速写，实际上速度会快很多。我不知道为什么。但基本上，gill 将成为一个问题，这也是整个演讲的总结。只有当你运行
    CPU 绑定任务时，gill 才会成为问题。
- en: this is the moment when you have to start inspecting your code， rationalizing
    it， writing it， and。 understanding what type of code you are running。 If you have
    a CPU bound code， thanks to our CPU。 processing computing， then threads are not
    going to be such a good idea。 And do you know what is a。 good idea in that case
    that can be multi processing。 Multi processing is a solution for our gill。
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你必须开始检查代码、合理化它、编写它并理解你正在运行什么类型代码的时刻。如果你有 CPU 绑定代码，感谢我们的 CPU 处理计算，那么线程就不是一个好主意。在这种情况下，多处理是一个好的解决方案。多处理是我们克服
    gill 问题的办法。
- en: problems。 We will be able to overcome the limitation of the gill with multi
    processing。 But as we have， seen in several occasions during this tutorial， there
    is no free lunch。 So we're going to win a， little bit of a from some place with
    a gill。 But we're going to loosen another。 So let's actually， talk about it conceptually
    first。
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够通过多处理克服 gill 的限制。但正如我们在本教程中的几个场合看到的，没有免费的午餐。所以我们将在某些地方从 gill 那里获得一些好处，但我们也会在其他地方失去一些。让我们先从概念上讨论一下。
- en: What we did so far was creating multiple threats。 We were doing， multi threaded
    programming。 Our Python process， our Python process was creating several threats，
    planning several threats。 and they were doing work concurrently。 Right， we said，
    it's impossible for。 the Python to see Python interpreter to run multi threaded
    portal code。 That was what we were doing。
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的就是创建多个线程。我们在做多线程编程。我们的Python进程正在创建多个线程，计划多个线程，并且它们在并发工作。对，我们说，Python解释器无法运行多线程的并行代码。这就是我们所做的。
- en: before。 In this lesson， we're gonna see a way to create multiple processes to
    run at the same time。 All right， so we want to compute three prime numbers， instead
    of creating three threats。 we are going to create three processes。 And each one
    of these processes will take care。 of a different threat。 The gill was something
    was created within the Python process to protect。
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一课中，我们将看到一种创建多个进程同时运行的方法。好吧，我们想计算三个质数，而不是创建三个线程。我们将创建三个进程。每个进程将负责处理不同的线程。全局解释器锁（GIL）是Python进程内部创建的，用来保护。
- en: shared data in the process。 So it was only affecting threats。 The gill will
    not affect multiple processes。 We will be able to run multiple processes in parallel。
    So this is kind of good news。 What's the， bad news？ Well。 that processes are a
    lot more expensive than threats。 Creating a process。
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中共享数据。所以它只影响线程。全局解释器锁（GIL）不会影响多个进程。我们将能够并行运行多个进程。所以这是个好消息。坏消息是什么呢？嗯，进程比线程要昂贵得多。创建一个进程。
- en: means setting up this whole machinery in the operating system， including allocating
    run。 memory allocating， sharing file descriptors， initializing the code stacks，
    keeps all those。 things we saw in the introduction that are very， very expensive
    before we can actually set up。 the process work。 So it has to be justified if
    you want to create multiple processes here。 Again。
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在操作系统中设置整个机制，包括分配运行内存，分配共享文件描述符，初始化代码栈，保持我们在介绍中看到的所有这些东西，在我们实际设置进程工作之前，这些都是非常昂贵的。所以如果你想在这里创建多个进程，这必须是有道理的。再一次。
- en: by creating multiple processes， we'll overcome the gill。 There will be no gill
    limitations。 and we will be actually able to run actual parallel code。 If we have
    multiple cores in our machine。 we will see that code is being run in parallel。
    That's a good thing。 Again， the counterpart is that。 a process is a lot heavier
    than creating a threat。 So let's put it in action。 We're going to create。
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建多个进程，我们将克服全局解释器锁（GIL）。将没有GIL的限制，我们实际上能够运行真正的并行代码。如果我们的机器有多个核心，我们会看到代码在并行运行。这是件好事。再说一遍，对应的问题是，进程比创建线程要重得多。那么让我们开始行动吧。我们将创建。
- en: processes or what one important thing。 The multiprocessing module is the one
    we're going to be using。 There is also a process module。 You shouldn't confuse
    that one。 It's a multiprocessing one。 It's very common to import it as MP。 And
    that's what you're seeing right here。 Don't worry too。 much about it。 This is
    just a detailed implementation in Mac OS。
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 进程或某个重要的事情。我们将使用多进程模块。还有一个进程模块，你不应该把它们混淆。是多进程的那个。它通常被导入为MP。这就是你在这里看到的。不要太担心。这只是Mac
    OS中的详细实现。
- en: We have to default back to the fork， mechanism to keep the code simple。 In other
    case。 we'll have to duplicate file descriptors and， memory and a ton of things。
    Let me show you the process API。 And let me show you how it works。 Basically，
    to create a process。 we're going to follow pretty much the same API as we did
    with a， threat。
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须回归到fork机制，以保持代码简单。在其他情况下，我们将不得不复制文件描述符、内存以及大量的东西。让我给你展示进程API。让我告诉你它是如何工作的。基本上，创建一个进程我们将遵循与线程几乎相同的API。
- en: We're going to create an instance of a process that was， again， instantiated
    from the。 multiprocessing module。 And at any moment， we can't start the process，
    and we can check until the。 process is done。 In this case， the process was right
    there。 It was done。 Once the process has finished， it's important to close it。
    Because remember。
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个进程实例，这个实例再次是从多进程模块实例化的。在任何时候，我们都可以启动进程，并且可以检查直到进程完成。在这个例子中，进程就在那儿。它已经完成。一旦进程结束，关闭它是很重要的。因为记住。
- en: it has a ton of resources associated， so it's important， to close it。 A couple
    of interesting things here。 The first one is that we are creating the process。
    And we are。 let me change the color here。 We're going to go back into our red。
    There we go。 We are creating the process here， and we're passing some piece of
    code。
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 它有大量相关资源，因此重要的是要关闭它。这里有几个有趣的点。第一个是我们正在创建进程。让我改变一下颜色。我们将回到红色。我们在这里创建进程，并传递一些代码。
- en: This piece of code seems to be shared。 If these processes are actually completely，
    separated units。 how is it possible that these first processes， as its target。
    gets a reference to the code defined in here？ If they're independent， isolated。
    Also。 what happens is that these processes are running here， doing some work，
    and it's printing。
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码似乎是共享的。如果这些进程实际上是完全独立的单元，为什么这些第一个进程作为目标能引用这里定义的代码？如果它们是独立和隔离的。另外，这些进程在这里运行，做一些工作，并且正在打印。
- en: but the output is shown here in my main process。 The concept here， which is
    a little bit more。 advanced， but basically by using the fork method that we used
    at the top， what is happening is that。 the operating system is duplicating the
    process。 There is this concept of process parents and。 children。 It's a low level
    characteristic of pthreads and some libraries for threading or low。
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 但输出在我的主进程中显示。这里的概念稍微复杂一些，但基本上通过使用我们在顶部使用的fork方法，操作系统正在复制进程。这里有进程父子关系的概念。这是pthread和一些线程库的低级特性。
- en: level。 But basically， we are creating a copy of the thread， and it inherits
    all the code it was。 defined。 So in this case， it was say hello， and also file
    the scriptors。io， I'm going to put here。 These are all inherited and kind of duplicated
    in the second。io process。 So that's why the second。 process， it's completely independent
    and isolated， but has copies of pretty much everything we have。
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们正在创建线程的副本，它继承了所有定义的代码。因此，在这种情况下，它是说“你好”，还有文件的脚本器。我将放在这里。这些都是继承的，并且在第二个进程中有一定的重复。所以这就是为什么第二个进程完全独立和隔离，但几乎拥有我们所有的副本。
- en: right here。 That's why it can run in the way it runs。 Once it finishes， we kill
    the process。 we free up the resources， and we move forward。 So let's actually
    do the prime example。 The find this function is prime when I read all our numbers。
    and then we're going to using processes， we're going to define this very simple
    function that given a number。
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它能够以这种方式运行的原因。一旦完成，我们就终止进程，释放资源，然后继续。所以我们实际上来做质数示例。这个函数是在读取我们所有的数字时确定是否为质数，然后我们将使用进程定义这个非常简单的函数，给定一个数字。
- en: it's going to print if it's， prime or not。 So we're going to create 10 processes。
    one for each one of the numbers。 This is， again， you can see it has 10 different
    tasks。 And the processes are going to take care， we're going to， create one process
    per task。 we're going to start them all at the same time， we're going to keep
    the， time track of the time。
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打印数字是否为质数。因此，我们将创建10个进程，每个数字一个。这又是，你可以看到它有10个不同的任务。进程将处理这些任务，我们会为每个任务创建一个进程，我们将同时启动它们，并跟踪时间。
- en: we're going to start them， we're going to wait until they are all finished。
    and we're going to see how much time it took。 Let me do that very quickly。 Everything
    finished in。 0。76 seconds。 So these feels parallel。 Remember that checking for
    one prime number， or our number。 if it's prime or not， was about five seconds，
    running 10 of them was 0。76 seconds， which is pretty。
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启动它们，等待它们全部完成，并查看所花费的时间。让我快速做一下。所有任务在0.76秒内完成。因此，这感觉是并行的。记住，检查一个质数或我们的数字是否为质数大约需要五秒，运行10个的时间是0.76秒，这相当不错。
- en: good。 All right， so now these actually feels parallel。 So I'm going to close
    all the processes。 and free up all the resources that we had。 Now， what you're
    seeing right here is that I'm printing。 the result， because there is no shared
    data。 In our previous example。 I was creating a dictionary or a， list that was
    shared data。
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。因此，现在这些实际上感觉是并行的。我将关闭所有进程，并释放我们拥有的所有资源。现在，你在这里看到的是我正在打印结果，因为没有共享数据。在我们之前的示例中，我创建了一个字典或列表，这是共享数据。
- en: And I was passing that results collection to the worker， the worker could。 compute
    the outcome and write in that sharp piece of data。 Right？ So if I go back here。
    the sharp piece， of data was here， and all threads were putting the results in
    there。 With processes， we can't do that， sadly。 We can't， because there is no
    shared memory。 I mean。
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我把结果集合传给工人，工人可以计算结果并写入那块数据。对吧？所以如果我回到这里，数据块在这里，所有线程都将结果放入那里。可悲的是，在进程中我们不能这样做。我们不能，因为没有共享内存。我的意思是。
- en: there is the variables on the state， is not shared。 A process is a completely
    new independent unit。 Thankfully， there are a few， ways to do that。 One of them
    is with queues。 So as we use the queue method， the queue module， sorry。 we also
    have a the multi processing module has a few queues that we can use that are very
    similar。
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态上有变量，是不共享的。一个进程是一个全新的独立单元。幸运的是，有几种方法可以做到这一点。其中之一是使用队列。因此，当我们使用队列方法时，抱歉，队列模块。我们还可以使用多处理模块中的几个队列，它们非常相似。
- en: and it's part in the queues we have already used。 And the good news about this
    is that even though。 our two processes are completely independent， this queue
    section will be kind of shared so both can read。 and write from here。 They can't，
    again， I can't change a variable here or I can't change or read a。 variable here。
    This is the independent place of each process。 But we can create this， this shared。
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们已经使用过的队列的一部分。好消息是，尽管我们的两个进程是完全独立的，这部分队列会有些共享，因此两者都可以在这里读取和写入。它们无法再次，我不能在这里更改变量，也不能在这里更改或读取变量。这是每个进程的独立地方。但我们可以创建这个共享。
- en: queue that can be read from a read into these two， these two process。 So the
    way we're going to do。 that is we're going to create two queues。 So in our previous
    example， we created just one queue。 and then we were we were using a dictionary
    to keep track of the results。 But something we can't。 do here， so we're going
    to create two queues， one for work to do and work for work done。
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这个队列可以被这两个进程读取。因此，我们将要做到的方式是创建两个队列。在我们之前的例子中，我们只创建了一个队列。然后我们使用字典来跟踪结果。但我们在这里无法做到，所以我们将创建两个队列，一个用于待办事项，另一个用于已完成工作。
- en: And we're going to prime the queue， the work to do queue by putting all the
    different tasks we want。 to perform in this case， all the numbers that we want
    to check if they're prime or not。 We're。 going to find how many workers we're
    going to have。 So max equals five， just randomly I decided the。 number。 And this
    is the code that we're going to run。 The the queue， it's going to do， sorry， the。
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过放置我们想要执行的不同任务来准备队列，即所有我们想检查是否为质数的数字。我们将找出我们将有多少工人。所以最大值等于五，我随机决定了这个数字。这是我们将要运行的代码。队列，它将执行，抱歉，。
- en: pros are going to do a task you dot get no wait。 This is a synonym for get block
    equals false。 And。 it's also present in the other queue class。 I didn't use it
    before because it wasn't that explicit。 Once we get the number， if we get a number，
    we're going to check if the number is prime。 and then we're going to put the result
    in the results queue， result queue dot put。
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 专家将执行任务，你不会等待。这是一个“获取阻塞等于假”的同义词。而且它在其他队列类中也存在。我之前没有使用它，因为不够明确。一旦我们得到数字，如果我们得到一个数字，我们将检查这个数字是否为质数，然后将结果放入结果队列，结果队列的
    put。
- en: this number and this result。 These can potentially raise an exception， which
    is q dot empty。 which means that these here， these q is empty and there are no
    more results。 In that case。 the process will just just finished。 Everything is
    in this while true， as usual。 So creating the。 process pull， right， creating all
    the processes， I'm going to put them all to work and we're going。
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字和这个结果。这些可能会引发异常，即队列为空，这意味着这里的队列是空的，没有更多结果。在这种情况下，进程将刚刚结束。一切都在这个 while true
    中，像往常一样。因此，创建进程池，创建所有进程，我将让它们全部工作，我们将。
- en: to wait until they're over。 There you go。 They all finished。 And in work done。
    we have all the results， for all the data。 So you see how how these q right， right
    here。 acts as this buffer that we can read， from here and we can write here， we
    can put things here。 they can be read here from this process， and we can inter
    exchange information between these two processes in a safe manner。
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 等待直到它们结束。看吧，它们都完成了。在工作完成中，我们得到了所有数据的结果。所以你看到这里的这个队列是如何作为一个缓冲区的，我们可以在这里读取和写入，我们可以在这里放东西。它们可以从这个进程读取，我们可以在这两个进程之间以安全的方式交换信息。
- en: There is also the concept of a pipe， which is more of like process one， it's
    going to be something。 like P one， and then we're going to have like a tube of
    pipe， right， the name， right， and we're。 going to have another process。 And they
    will be sending messages between them。 So sending message。 and sending message
    here and there。 The standard pipe is bi directional， but you can create one。
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个管道的概念，它更像是进程一，它会是某种东西，像 P 一，然后我们会有像一个管道，对吧，名称，对吧，我们将会有另一个进程。它们会在彼此之间发送消息。所以发送消息，发送消息在这里和那里。标准管道是双向的，但你可以创建一个。
- en: that can just have one direction。 It's perfectly possible。 And the way it's
    going to work is a pipe。 will have two methods， which is receive and send。 Okay。
    we're going to create a pipe which gives you， two connections， connection on the
    left side。 connection on the right side， if you want， left side， and right side。
    In this case。
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以仅有一个方向。是完全可能的。它的工作方式是一个管道。将有两个方法，分别是接收和发送。好的。我们将创建一个管道，它给你两个连接，左侧的连接，右侧的连接，如果你愿意，可以是左侧和右侧。在这种情况下。
- en: I've named them a main， because my main process and worker。 And。 what we're
    going to do is define this function that it's going to receive a number to check
    if。 it's prime or not， and a pipe connection。 And once it checks for that， it
    sends a message， right。 send a message message here saying， Hey， this number，
    and this is a result， it's prime or not。
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我把它们命名为主，因为我的主进程和工作者。我们要做的是定义这个函数，它将接收一个数字以检查它是否是质数，以及一个管道连接。一旦检查完，它就会发送一条消息，对吧。在这里发送一条消息，说，嘿，这个数字，这个结果，它是质数还是不是。
- en: I create all the processes， and I start all the processes。 And then I can start
    receiving all the。 values from this given message。 Actually， they were already
    all published， right， they were。 all published， I got them immediately。 But basically，
    I do connection dot receive for a message。 And I， know that I'm waiting for 10
    different messages。 Pipes are to be honest， not。
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了所有的进程，并且启动了所有的进程。然后我可以开始接收所有来自这个特定消息的值。实际上，它们已经都发布了，对吧，它们都发布了，我立即得到了它们。但基本上，我使用
    connection.dot.receive 来接收消息。我知道我在等待 10 条不同的消息。老实说，管道并不是。
- en: I'm not usually， I don't find myself using them so often to be honest， if they
    are an interesting。 tool to know and know it that it's there。 But I found that
    they are usually more error prone。 I prefer to use cues。 And finally， the multi
    processing module has the pull， the pull， sorry。 the pull multi processing pool
    that basically will let you create multiple processes and send。
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常不使用它们，说实话，我觉得自己并不常用。如果它们是一个有趣的工具，知道它的存在也不错。但我发现它们通常更容易出错。我更喜欢使用提示。最后， multiprocessing
    模块有拉取，多处理池，抱歉，拉取多处理池基本上会让你创建多个进程并发送。
- en: them work to do with a very high level interface without having to deal with
    the low level。 nuances of shared data。 In this case， we're going to create a pool
    of four workers， four， processes。 we know that there are four workers created
    here， and I get a reference in pool。 And。 then I can do an apply sync， okay， just
    run this thing for me。 And I'm going to wait for the result。
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的工作是以非常高级的接口来处理，而无需处理共享数据的低级细节。在这种情况下，我们将创建一个有四个工作者的池，四个进程。我们知道这里创建了四个工作者，我在池中获得了一个引用。然后我可以进行
    apply sync，好的，帮我运行这个。我将等待结果。
- en: So here it's going to be the result that get to get the result。 Let me just
    do that two times。 and we get these two， if they are done or not， I am， I am kind
    of making these synchronous。 But。 if you could make， we can do something like
    R one。 And let's do here。 Actually， let's get this。 R two。 And we can do here，
    four prime is going to be R one， R two， that's you， and one and two， two。
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里将是获取结果的结果。让我再做两次。我们来看看这两个是否完成了，我正在使它们同步。但如果你能做的话，我们可以做类似 R 一的事情。让我们在这里做。实际上，让我们来获取这个。R
    二。我们可以在这里做，四个质数将是 R 一，R 二，那就是你，一和二，二。
- en: one， and one， two。 And now it's a lot faster because I'm not doing it。 Synchronous
    again。 we should have in the original one， basically， I am creating， let's put
    it。 these way to see if it's more clear。 Whatever it's more clear。 I'm creating
    the two numbers。 and then I'm immediately firing them。 It's like， this is not
    blocking。 It's just， you know。
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 一，一，二。现在速度快多了，因为我不再同步执行了。我们在原来的基础上，基本上，我创建了，让我们这么放置，看看是否更清晰。无论怎样更清晰。我正在创建这两个数字，然后我立即启动它们。这就像，这并没有阻塞。这只是，你知道的。
- en: forwarding everything to the pool saying， hey， I need you to run this thing。
    Just get started with。 it。 At any point， I can actually put something like time。slip
    here to print， waiting， or slipping。 and now print getting results。 Slipping，
    getting results， and we immediately get the resources。 were the results， sorry，
    not resource， the results were provided by the pool。 So again， it's like。
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 将一切转发到池中，告诉它，“嘿，我需要你运行这个东西。” 只需开始执行即可。在任何时候，我实际上可以在这里放置像 time.sleep 这样的代码来打印等待或暂停。现在打印获取结果。暂停，获取结果，我们立即得到结果。抱歉，不是资源，结果是由池提供的。所以再次强调，这就像。
- en: you fire and forget， you get a reference to a result。 And once you want to check
    the result。 you just do our one， our one that gets。 So this is amazing， because
    we're not dealing with queues。 with pipes， with anything。 There is nothing low
    level have to deal with。 which is fire all the tasks， and they are， as they are
    completed， we're going to get our results。
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 你启动后就可以忘记，得到一个结果的引用。一旦你想检查结果，只需使用我们的 one，获取结果。这是惊人的，因为我们不需要处理队列、管道或任何东西。没有什么低级的东西需要处理，我们只需启动所有任务，随着它们的完成，我们将获得结果。
- en: There is another important method in the pool， which is the map method， which
    is going to basically。 map multiple collection， right， with a given callable function。
    And this looks a lot like the regular， map method in the standard library， or
    a list comprehension。 So we do that， but then I get very， quickly， we can process
    all the values we had before。
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 池中还有一个重要方法，即 map 方法，它基本上是将多个集合映射到给定的可调用函数。这个看起来很像标准库中的常规 map 方法或列表推导式。因此我们这样做，然后我可以很快处理之前所有的值。
- en: So what's the summary？ Usually， we're going to be， using multi threading。 It's
    a lot， it's a lot。 I don't know， faster， but lightweight to use multiple， threats。
    you can't just fire up 1000 processes， because you're going to completely kill
    your computer。 Threats are lightweight， so we're going to prefer them。 Usually，
    in our work。
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 所以总结一下？通常，我们会使用多线程。这是很重要的。我不知道，更快，但使用多个线程是轻量级的。你不能随意启动 1000 个进程，因为那样会彻底杀死你的电脑。线程是轻量级的，所以我们通常更喜欢它们。
- en: I don't know about you， aside from scientific computing， data science， and all
    that。 usual tasks are， in my experience， they're usually IO bound， usually。 most
    of the time I find myself creating work fixing problems， in real life that depend
    a lot on IO。 writing files， writing files， writing from network， writing to， a
    network， etc。 So in that case。
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你如何看，除了科学计算、数据科学和所有这些，通常的任务在我的经验中，它们通常是 I/O 绑定的。大多数时候，我发现自己在解决依赖于 I/O 的实际问题，写文件、从网络写入、向网络写入等等。因此在这种情况下。
- en: when threats make a lot of sense， IO tasks， remember， they are well， suited
    for threats。 But if your task is CPU bound， it needs a ton of computing power，
    then multi threading。 will not help you on the contrary， it will make things slower
    for you。 So that's why you can resort。 back to multi processing。 But remember，
    creating processes is more expensive。 So you have to always。
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 线程在处理 I/O 任务时非常有意义，记住，它们非常适合线程。但如果你的任务是 CPU 绑定，且需要大量计算能力，那么多线程不会对你有帮助，反而会使事情变得更慢。所以这就是为什么你可以回归多处理。但请记住，创建进程是更昂贵的。因此你必须始终注意。
- en: keep that in mind and be conscious of the profiling process of understanding
    what's the optimal。 number of processes you can create without crushing your entire
    system。 So in this is so far all the， conceptual things we had to see， we talked
    about threats。 we talked about the producer-consuming， model， we talked about
    the race conditions， synchronization。
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这一点，并注意分析过程，以理解你可以创建的最佳进程数量，而不会使整个系统崩溃。到目前为止，这就是我们必须了解的所有概念，我们讨论了线程，讨论了生产者-消费者模型，讨论了竞争条件和同步。
- en: we talked about multi processing， and why it's important， the parallelism with
    the Python Gill。 And now I'm going to show you two， libraries that are high level。
    and they are going to let us create a multi threaded or multi processing， code
    in a very clean way。 All right， and that's going to be the first one concurrent
    of futures。
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈到了多处理，以及它的重要性，还有与 Python GIL 的并行性。现在我将向你展示两个高级库，它们将让我们以非常清晰的方式创建多线程或多处理代码。好的，第一个是
    concurrent.futures。
- en: and then the library that I have created， which is part of。 To finish this tutorial，
    we're going to。 see two high level libraries are going to help us or packages
    that are going to help us create。 more abstract， multi threaded or concurrent
    code， we could say。 And the idea here， high level。 abstract data is not to get
    into the internals of creating threats， creating processes。
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我创建的库，它是这个教程的一部分。为了完成这个教程，我们将看到两个高级库，或者可以说是将帮助我们创建更抽象的多线程或并发代码的包。这里的想法是，高级抽象数据不深入到创建线程和进程的内部。
- en: synchronizing， them， etc。 Have it worked as high level as possible。 That's，
    I think。 the objective of， these libraries。 And the advantages are clear， right？
    We if we don't。 if we don't have to write， synchronization code， there is zero
    chance we actually create a bug in synchronization or a。 deadlock。 If we don't
    have to create threats and processes manually， there is zero chance we forget。
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 同步它们，等等。尽可能高效地工作。这是我认为这些库的目标。优势很明显，对吧？如果我们不需要编写同步代码，就没有机会在同步中创建错误或死锁。如果我们不需要手动创建线程和进程，就没有机会忘记。
- en: to close a process， for example， and clove our computer with unused resources。
    So as high level。 as possible， the first one is concurrent of futures。 And this
    one is a Python built in this part of。 the Sunday library。 So there is nothing
    you need to install just use it。 And it has these very neat。 interface， which
    is the executor， which will be either thread based or pool based， you can create。
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，关闭一个进程，导致我们的计算机被未使用的资源占用。因此，尽可能高层次，第一种是`concurrent.futures`。这也是Python内置的，属于标准库的一部分。所以你不需要安装任何东西，只需使用它。它有一个非常简洁的接口，就是执行器，可以是基于线程的或基于池的，你可以创建。
- en: either a thread base executor or a pool base executor， and sorry process based
    executor。 And。 basically， they both have the same API。 There are subclasses。 So
    any executor， whatever it is。 you can submit tasks。 And this is similar to the
    apply a saying that we saw in the multi processing。 pool， apply a sync or submit
    in this case， it's gonna sub drawn individual tasks， or you also have。
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 要么是基于线程的执行器，要么是基于池的执行器，抱歉，还有基于进程的执行器。基本上，它们都有相同的API。有子类。因此，任何执行器，无论是什么，你都可以提交任务。这与我们在多进程池中看到的`apply`非常相似。在这种情况下，它将提交单个任务，或者你也可以有。
- en: high level methods as the map one。 So let's actually say it in practice， right。
    we have this check price， function that， as usual， it's gonna check for a price
    return result。 we're gonna， instantiate a thread pool executor and run it as a
    context manager。 In this case。 I have 10， worker workers completely overkill doesn't
    matter。
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 高级方法，比如映射。那我们实际上来说说这个，没错。我们有这个检查价格的函数，像往常一样，它会检查价格并返回结果。我们将实例化一个线程池执行器，并将其作为上下文管理器运行。在这种情况下，我有10个工作线程，完全是多余，没关系。
- en: And we're gonna submit a task to perform in this， case， check price for these
    values， these options。 And the result is gonna be a future。 Okay， so this。 is
    the major change in the concurrent that futures library， it introduced the concept
    of a future。 In， this case， the future is an object， we can actually check the
    interface right here。
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提交一个任务来执行，在这种情况下，检查这些值的价格。这些选项的结果将是一个future。好的，因此这是`concurrent.futures`库中的主要变化，它引入了future的概念。在这种情况下，future是一个对象，我们实际上可以在这里检查接口。
- en: it's an object， that represents some given computation that might be happening
    at this very same moment。 And it has， all these different methods， I try to cancel
    it， check if it's running or not。 check if it's done or， not。 And more importantly，
    try to get the result out of it。 So in this case。 once we have the future， handle，
    we can do future dot result。
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个对象，代表一些可能在此时正在发生的计算。它有各种不同的方法，我可以尝试取消它，检查它是否正在运行，检查它是否完成。更重要的是，尝试从中获取结果。因此在这种情况下，一旦我们拥有了future句柄，我们可以调用`future.result`。
- en: and we can get the result of the computation。 In this case， this is the price。
    The same thing happens here。 If by the time you ask for the result， the task is，
    not done。 you're gonna block right for until it's actually done。 If your timeout
    parameter was done。 if your timeout is of course gonna blow up。 There is also
    a very useful。
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得到计算的结果。在这种情况下，这就是价格。在这里也发生了同样的事情。如果在你请求结果的时候，任务还没有完成，你会一直阻塞，直到它实际上完成。如果你的超时参数设置得太低，当然会导致超时。还有一个非常有用的。
- en: not I don't know very useful， it's an interesting method， might be useful to
    you。 which is an add done callback， so it's gonna， basically be invoked whenever
    you finish a result。 What else？ Moving forward， this is again the， interface of
    the result。 check if the result the future is done or not， etc。 There is also
    a map， method。
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道这是否很有用，但这是一种有趣的方法，可能对你有用。它是一个完成回调，因此基本上会在你完成结果时被调用。还有什么呢？继续前进，这再次是结果的接口。检查未来的结果是否完成，等等。还有一个映射方法。
- en: And the map method is interesting because it has a similar API as the， actually
    the same API。 as the built-in standard library map method， it receives a callable
    and a list of things to do。 So in this case， I am passing these parameters exchange
    BDC and the and the date for all these。 exchanges。 And we have all the results
    available right there， right？
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 映射方法很有趣，因为它的 API 与内置标准库的映射方法相似，实际上是相同的 API。它接收一个可调用对象和一个要执行的事项列表。在这种情况下，我正在传递这些参数：交换
    BDC 和所有这些。交换的日期。我们所有的结果都在那里，可以用，对吧？
- en: This is again what we're passing， for each one of them。 The。 this advantage
    of map is that you have zero flexibility in terms of， the parameters you have。
    you can pass up there， let's go map。 You can always only pass a list of。 intervals
    that will be arguments past the function so that we can always only pass that。
    There's no。
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这再次是我们传递的内容，对于每一个。这个映射的优势在于，你在参数上没有任何灵活性。你可以传递上去，让我们进行映射。你总是只能传递一个列表的区间，作为函数的参数，这样我们总是只能传递那个。没有其他。
- en: support for main arguments， there is no support for variable length arguments，
    etc。 It's just very。 strict。 So we can combine the submit method， this is a very
    common pattern， and a function level。 a module level， sorry function， which is
    as completed to do exactly this code。 And let me walk。 with you through this code。
    We're going to submit， we have a list of exchanges， so we're going to。
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 主参数的支持，没有对可变长度参数的支持，等等。这非常。严格。因此，我们可以结合提交方法，这是一种非常常见的模式，还有一个模块级别的函数，抱歉，是已完成的，以完全执行这段代码。让我带你走一遍这段代码。我们将提交，我们有一个交换列表，所以我们将要。
- en: create a dict comprehension。 And for each exchange， we're going to submit a
    job， right， or task to。 perform， that is check price， this exchange， this symbol，
    this date， and the value。 it's going to be， the exchange that we actually used。
    So we're going to have a mapping。 a dictionary that is， futures to exchanges。
    So we can then use the ask completed function of these futures。
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个字典推导式。对于每个交换，我们将提交一个工作，或者任务去。执行，检查价格，这个交换，这个符号，这个日期，和这个值。它将是我们实际使用的交换。因此，我们将有一个映射。一个字典，即期货到交换的映射。这样我们就可以使用这些期货的完成函数。
- en: we're going， to get for each future assets completed， it doesn't matter the
    order。 the first one that finishes is， result is results here， it's a。 it's a
    blocking synchronous function， which it's gonna pretty much。 return futures as
    they are completed。 And you can get the exchange given the futures dictionary
    that。
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要为每个完成的未来资产获取结果，顺序并不重要。第一个完成的结果就是结果，这里是一个。它是一个阻塞的同步函数，基本上会。返回已完成的期货。你可以根据给定的期货字典来获取交换。
- en: we used。 So this is involved with the immutable nature of the future， that can
    be used as a key。 and it can be used to reference it。 And we can pretty much do
    this parameter， this pattern， sorry。 we submit， and we use it as a key of a dictionary。
    The ask completed function again is returning。 values as they are finished。 So
    probably if I run this several times， I'm going to get different。
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的。这涉及未来的不可变特性，可以用作键。并且可以用来引用它。我们基本上可以做这个参数，这个模式，对不起。我们提交，并将其作为字典的键。完成函数再次返回。已完成的值。所以如果我多次运行这个，我将得到不同的结果。
- en: orders。 So cracking first bit， fin X， bit stump， bit， fin X。 bit some crock
    and it's going to change， the order。 because just going to return them as they
    are completed。 Again， the， the one that is。 done first going to be returned here，
    and it's just sequential ordering in there。 I'm using a。
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 订单。因此，首先破裂的部分，fin X，bit stump，bit，fin X。bit some crock，它将改变顺序。因为只是会按完成顺序返回它们。再次，首先完成的将会在这里返回，这只是顺序排列。我正在使用一个。
- en: producer consumer pattern is pretty much the same thing。 So let's move forward
    with all what we know， already， we're going to prime the queue。 we have all the
    tasks in the queue。 And here the worker is。 going to receive as usual a task queue
    and a result queue， two different queues， it's going to try。
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者消费者模式基本上是一样的。所以让我们继续推进我们已经知道的内容，我们将初始化队列。我们在队列中有所有的任务。这就是工作者，它将像往常一样接收任务队列和结果队列，这两个不同的队列，它将尝试。
- en: getting something from the queue if it's， if there is anything else， the Q7
    is going to return。 in order it is going to check the price and put the result
    in the queue。 The way we do it is just we， submit a bunch of these jobs for these
    futures。 and then we just sit and wait until the queue is， the word to do Q is
    empty。 Basically。
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 从队列中获取一些东西，如果还有其他东西，Q7 将返回。它将按顺序检查价格并将结果放入队列。我们做的方法是提交一批这些未来的工作，然后我们就坐着等待，直到队列中的工作完成
    Q 是空的。基本上。
- en: all the tasks are done。 This will finish eventually。 There you go。 And we can
    see that the work done queue has all the results。 We can pass them all into a
    results。 dictionary and use it。 So a couple of important takeaways here。 The first
    one is that we can。 completely change the behavior of these code by just changing
    the name here and saying。
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 所有任务都完成了。这最终会结束。看吧。我们可以看到工作完成的队列中有所有结果。我们可以将它们全部传入一个结果字典并使用它。因此，这里有几个重要的要点。第一个是我们可以通过仅仅更改这里的名称来完全改变这些代码的行为。
- en: process pool executor here， process pool executor。 If you change just this thing
    here， you go from。 multi threading to multi processing in a completely abstract
    way。 Of course， that in this case。 we're， using， we are using multi threading
    queues， you should change to MP queues。 But again。 changing the code for multi
    threaded to multi processing is as simple as changing this thing。
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 进程池执行器这里，进程池执行器。如果你只改变这里的这个东西，你将从多线程转向多进程，完全抽象的方式。当然，在这种情况下，我们使用的是多线程队列，你应该改为
    MP 队列。但再说一次，从多线程代码转换到多进程是如此简单，只需更改这一点。
- en: And the second important thing is， as you're saying。 we're always using this
    thing as a context manager， the with syntax， because basically。 the all the resources
    used by those threats or those processes。 will be freed up once the work is done。
    Okay， so those two are very neat features of this current。
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重要的事情是，正如你所说，我们总是将这个东西作为上下文管理器使用，使用 with 语法，因为基本上那些线程或进程使用的所有资源将在工作完成后释放。因此，这两个都是当前的非常好的特性。
- en: package。 What I can say here is， if you have to， and this is a very important
    summary of the whole。 tutorial， if you can start， if you're gonna do something
    that needs either multi threading or。 multi processing， I will recommend you first
    to try using the concurrent dot futures library。 It's built in， it's bulletproof，
    it's been around for a long time。 It's on its very high level。
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 包。我想说的是，如果你必须这样做，这是整个教程的一个非常重要的总结。如果你能够开始，如果你要做一些需要多线程或多进程的事情，我建议你首先尝试使用 concurrent.futures
    库。它是内置的，坚如磐石，已经存在很长时间了。它在非常高的层次上。
- en: Okay， you don't need to manually synchronize anything。 So try to get it done
    with concurrent dot futures， first。 If that doesn't work。 then you can move to
    low level threading or multi processing。 But first， I think the first。 the main，
    the main reason he has to be， I will try to do this thing with， multi processing
    first。
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你不需要手动同步任何东西。所以先尝试用 concurrent.futures 完成。如果那不行，那么你可以转向低级线程或多进程。但首先，我认为最主要的原因应该是，我会尝试先用多进程来做这件事。
- en: So let's move to the second second library， which is a library that I have，
    created。 So it's a parallel， it's available on GitHub， you can install it very
    quickly with just。 beep install Python portal。 And what I tried doing in this
    library was improving the map methods and。 there are a few others that I have
    not showcased in here， but the seeing map， a few methods with。
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们转到第二个库，这是我创建的一个库。所以它是并行的，可以在 GitHub 上找到，你可以通过简单的 beep install python-portal
    很快安装它。我在这个库中尝试改进映射方法，还有一些我在这里没有展示的其他方法，但看到映射，一些方法与。
- en: more flexibility。 In this case， the function parallel dot map， I didn't define
    the function。 The parallel dot map is receives a function and receives a list
    of。 intervals and potentially extras to pass。 And what it does， it runs everything
    in a multi threaded。 environment by default， except if you change here the executor
    to be multi processing instead of。
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 更多灵活性。在这种情况下，函数并行点映射，我没有定义该函数。并行点映射接收一个函数和一个间隔列表，以及可能传递的额外参数。它所做的，默认情况下是在一个多线程环境中运行所有内容，除非你在这里将执行器更改为多进程。
- en: multi threaded。 So you can change very quickly the executor you are using with
    a simple keyword。 argument。 I've also put a ton of emphasis on good error handling。
    So basically， you can pass name。 parameters or optional arguments for this。 I'm
    gonna， on purpose， I'm gonna break this execution。 I'm gonna change the base URL
    and this will not work， just gonna break。 So every， every other。
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程。所以你可以通过一个简单的关键字快速更改所使用的执行器。参数。我也非常重视良好的错误处理。所以基本上，你可以为此传递名称、参数或可选参数。我要故意破坏这个执行。我要更改基础
    URL，这将不起作用，只会崩溃。所以每，其他。
- en: parameter here is gonna receive base URL equals this。 This one right here will
    define， will resume。 base equals base URL equals eight port 8000。 And this is
    gonna break。 If I run dot。 I'm gonna see it just breaks。 But we have included
    a parameter which is silent， silent， sorry。 So you can， we can keep errors silenced，
    get the result of the execution。
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的参数将接收基础 URL 等于这个。这里将定义，基础等于基础 URL 等于八端口 8000。这将崩溃。如果我运行点。我会看到它只是崩溃。但是我们包含了一个参数，即静默，静默，抱歉。因此，我们可以保持错误静默，获得执行的结果。
- en: And we will see here that bits dump， the variable bits dump here， is a fail
    task。 So we have this。 fail task abstraction， which will let us understand why
    the code failed。 what were the parameters and， why it failed。 This is the idea
    of the fail task。 So if you're interested in high level， parallel computing， just
    check out the library。 Again。
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里会看到位转储，变量位转储在这里，是一个失败任务。所以我们有这个。失败任务抽象，能让我们理解代码失败的原因，是什么参数，以及为什么它失败。这就是失败任务的理念。所以如果你对高级并行计算感兴趣，可以查看这个库。再一次。
- en: my recommendation， we can use this as a whole， summary is try to use concurrent
    dot futures first。 And this is it。 We've reached the end of that， URL。 Please
    keep an eye on the updates for exercises and projects that people be posting。
    It's gonna be。 important to practice what we've seen。 And as a quick summary，
    we can do kind of a dirty checklist。
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是，我们可以整体使用，摘要是首先尝试使用并发点未来。这就是。我们已经到了那个 URL 的尽头。请注意人们发布的练习和项目的更新。练习我们所看到的内容将很重要。作为快速总结，我们可以做一个肮脏的检查表。
- en: on all we've learned and how we can place it or how we can organize it in our
    mind。 I want you to have， the main purpose of this to understand when to use each
    tool and how to use each tool and what。 it means to use a given tool。 The easiest
    thing is to say， let's just use multi threading always。 But we know that's not
    the answer。 If our task is CPU bound， that's not gonna work。 And we know how。
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们学到的所有内容，以及我们如何将其组织在我们脑海中。我希望你明白，主要目的是理解何时使用每个工具，以及如何使用每个工具，以及使用特定工具意味着什么。最简单的事情是说，让我们总是使用多线程。但我们知道这不是答案。如果我们的任务是
    CPU 绑定的，那是行不通的。我们知道如何。
- en: many and even if we decide threats， we're gonna say。 let's use the threading
    module and create threats， by ourselves。 And then we start with all the synchronization
    issues we saw that can raise conditions， deadlocks。 etc。 So again， the most important
    thing is to understand the concepts。 And hopefully for。
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 很多人，即使我们决定线程，我们也会说。让我们使用线程模块并自己创建线程。然后我们开始解决所有我们看到的同步问题，这些问题可能会引发条件竞争、死锁等等。因此，再一次，最重要的是理解概念。希望能。
- en: you to understand when to use the right tool for the job。 First。 do you need
    to write multi threaded， and multiprocessing code at all？
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 你理解何时使用合适的工具。首先。你是否需要编写多线程和多进程代码？
- en: Maybe you don't have a multi threading problem。 You have to use a job。 cube
    as we saw at the beginning， or you have to use something like a big data architecture
    like。 a task or a spark。 So first of all， do you need multi threading？ Do you
    need multiprocessing？
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你没有多线程问题。你必须使用作业。立方体，正如我们在开始时看到的，或者你必须使用一些类似大数据架构的东西，比如任务或火花。因此，首先，你需要多线程吗？你需要多进程吗？
- en: Then if you want to move forward， then realizing if it's a CPU bound task， multiprocessing，
    or if。 usually the case， an I/O bound task， in that case， you're gonna have to
    use multi threading。 Once you have the finite all define all that， you need to
    run concurrent to write concurrent code。 You need to use， for example， multi threaded，
    let's say， then starting backward or downwards， right？
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 然后如果你想继续前进，就要意识到，如果是 CPU 密集型任务，就要使用多进程，或者如果通常是 I/O 密集型任务，那么你就得使用多线程。一旦你有了所有有限的定义，就需要并发运行以编写并发代码。例如，使用多线程，假设，然后从后往前或向下开始，对吧？
- en: The levels of abstractions of the libraries you have。 Can you use a very high
    level library。 that completely abstracts you away from the fact you're creating
    multiple threads， abstracting you。 away from synchronization， deadlocks and all
    that？ If that's available， that's great。 Actually。 it's available。 It's concurrent。futures
    actually would say， I recommend you to use concurrent。
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 你拥有的库的抽象层次。你能否使用一个非常高层次的库，完全将你与创建多个线程的事实隔离，让你远离同步、死锁等问题？如果有的话，那就太好了。实际上，这样的库是存在的。它就是`concurrent.futures`，我推荐你使用并发。
- en: futures， as much as possible， because it's built in， it's in the standard library，
    it's bulletproof。 it's just a lot of eyes are set on that library， and it's proven
    to work fantastically。 So if you。 can start there， high level concurrent。futures，
    then you start saying， my problem is getting more。 complicated。 Can I switch to
    a different library like parallel？ Can I use something that it's。
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能多地使用`futures`，因为它是内置的，在标准库中，非常可靠。许多人关注这个库，它证明了其出色的工作能力。因此，如果你能从这里开始，使用高层次的`concurrent.futures`，那么你可以开始说，我的问题变得更复杂了。我可以切换到像`parallel`这样的不同库吗？我能使用其他的东西吗？
- en: high level， but it's a little bit more powerful。 And if I can't， then start
    going down to the。 threading package， but always being conscious of the issues，
    the doors you're open and the。 issues you might face。 So again， the most important
    thing about multi threading。 multi processing and， concurrent programming is understanding
    when you need to create concurrent software and what problems。
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 高层次，但它更强大一些。如果我不能，那就开始使用线程包，但要始终意识到可能遇到的问题，以及你可能打开的门。所以，再一次，关于多线程、多进程和并发编程最重要的事情是理解何时需要创建并发软件以及会出现什么问题。
- en: that will evolve。 So thank you very much。 It's been a wonderful experience，
    and let's get in touch。 in Twitter， any other medium， it's actually mainly Twitter。
    Hopefully， we'll see you in the next。 Python。
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢你。这是一次美妙的体验，让我们保持联系，在 Twitter 或其他任何媒体上，主要是 Twitter。希望在下一个 Python 会议上见到你。
- en: '![](img/d47b771f29319a5dab186fef57705ab6_29.png)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d47b771f29319a5dab186fef57705ab6_29.png)'
- en: All right。
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。
