- en: P32：Talk Deepak Kumar Gupta - Saved by In-Memory NoSQL - 程序员百科书 - BV1rW4y1v7YG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hello everyone。
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bba88217c914fc5eafd190f5aecd9b1_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Welcome to the SpyCon 2020 talk titled as saved by in-memory NoSQL， a hitchhiker
    guide。 to black box debugging of Python production code。 Sorry about long title
    but I believe by the end of this talk you will understand all of。 it。 So before
    we go ahead something about me my name is Deepak K。 Gupta， I am a tech consultant。
    and software crafter。 I am working in this industry for more than 20 years and
    these are some social media。
  prefs: []
  type: TYPE_NORMAL
- en: handles where you can reach out to me。 So let's go ahead and start。 Let's first
    talk about black box。 Now whenever you hear the term black box what comes to your
    mind？
  prefs: []
  type: TYPE_NORMAL
- en: The picture of an airplane。 Because black boxes are generally associated with
    airplane and black box debugging is actually。 inspired by black boxes that are
    there in an airplane。 So the airplane black boxes are extremely durable hardware。
    It is made to survive extremely harsh conditions。 It has all the information about
    the running system in real time and those informations。
  prefs: []
  type: TYPE_NORMAL
- en: are encoded in nature which means that if someone gets the black box it is not
    possible。 for that person to take the black box and decode all the information。
    And that's the reason we have specialized labs across the world to decode these
    information。 And the reason for existence of black box is this。
  prefs: []
  type: TYPE_NORMAL
- en: In software this can happen quite often that you know something goes wrong in
    the production。 system and we are trying to find the root cause of it。 We are
    not able to find it。 We patch the production system with additional logs within
    the area which we feel that is。 the root cause of the problem and we expect the
    problem to re-occur again。
  prefs: []
  type: TYPE_NORMAL
- en: So that we can get more information and we just believe that these logs will
    be able to。 help us in finding the root cause。 That option is not there in an
    airplane。 So in black box debugging we wanted to come up with something similar
    where we rarely need。 to patch the existing production system to find the root
    cause of a problem。
  prefs: []
  type: TYPE_NORMAL
- en: And here is how the black box architecture looks like it's extremely simple。
    There is a separate entity called black box which is totally separate and it doesn't。
    impact the performance of any of the existing components。 It just get the data。
    get the real time data about component performance。
  prefs: []
  type: TYPE_NORMAL
- en: Like there are thousands of components in an airplane。 They put their real time
    data into the black box。 Their functionality is not dependent upon the black box。
    So let's talk about how come python and black box comes into picture。 So we were
    building a system with complex set of state machines with hundreds of states。
  prefs: []
  type: TYPE_NORMAL
- en: events and transitions。 So if you are building a system like this you know that
    there is no happy path。 Happy path means these are not set of states that will
    happen most of the time。 It depends totally upon the end user behavior and environmental
    circumstances and the permutation。 and combination of these state events and transitions
    are kind of limitless。
  prefs: []
  type: TYPE_NORMAL
- en: You know it's very difficult to understand when something happened in this state
    or because。 of this event what leads to triggering of this state and how many
    things happen and。 what leads to this particular state。 That's the reason we wanted
    to have a black box like feature so that each and every state。 activity events
    and transitions are actually recorded。
  prefs: []
  type: TYPE_NORMAL
- en: And with the recorded log we wanted to generate a visual sequence and activity
    diagram for。 the complete system so that it can help us in understanding what
    happened within the system。 And of course the tool would be sophisticated so that
    if we tell them to generate visual。 diagram from this to this time frame or top
    level or detail level it will be able to do， that。
  prefs: []
  type: TYPE_NORMAL
- en: And these logs will be released as part of production builds。 Now it's a general
    practice that when we add logs we have different types of log like。 info log debug
    log critical logs and it's also a general practice that when we are giving。 the
    system to production we just enable critical logs of course because of the performance。
  prefs: []
  type: TYPE_NORMAL
- en: regions and we do not enable info and debug logs。 Now let's talk about the code
    which we were writing the state machine。 It's a very miniature version of my state
    machine and I just wanted to give you a taste。 of the system how it looks like
    so we had state and event as an abstract base classes。 and we had a state machine。
    This is not the original code this is just the miniature version of a state machine
    just。
  prefs: []
  type: TYPE_NORMAL
- en: to give you an idea how this was actually working so state machine starts with
    state。 it transition to next state there were multiple state machine inner state
    machines and all。 those complexities were built into the system。 So to understand
    the working of the system let's talk about a very simple real time example。 So
    we are in a happy state right now happy state is also in state and we received
    an。
  prefs: []
  type: TYPE_NORMAL
- en: event called lost money got for it but we received this event and we moved to
    sad state。 We again received an event called gain money and we moved back to happy
    state。 So this is the very simple description of how state machine work but when
    we generated。 the log we didn't want it to write in log that you know I'm in happy
    state I lost money。
  prefs: []
  type: TYPE_NORMAL
- en: I'm moving to sad state I'm in sad state I gain money I'm moving to happy state
    no。 What we wanted to do is something similar to what black boxes does is that
    we wanted。 to have a encoded information encoded logs and for that we created
    a mapping table something。 very similar to this like you know happy state will
    be represented by one side by two gain。
  prefs: []
  type: TYPE_NORMAL
- en: and lost money will be represented by Roman one and two and once the log file
    will be generated。 here is how the log file will look like it will be a jump world
    sequence of some characters。 numbers and nobody will be able to make any sense
    of it because they cannot decode it。 And that was extremely beneficial for us
    because we are generating logs in a production system。
  prefs: []
  type: TYPE_NORMAL
- en: and even if someone accidentally or deliberately get access to these logs it
    is not possible for。 them to decode it。 The other benefit is that you know it
    reduces the logs。 size instead of writing plain text if you write jump world encoded
    short information it will reduce。 the log size。 So this is how logs will be generated
    but to do a black box debugging just generating。
  prefs: []
  type: TYPE_NORMAL
- en: logs are not enough we need a complete infrastructure at our end we need data
    structure storage format。 mapping table decoding logic visualizes control basically
    we have to build a complete system at。 our end where we can feed in logs and we
    get the sequence and activity diagrams out of it okay。 So we needed to build a
    complete system it was complex but it was kind of one time job。
  prefs: []
  type: TYPE_NORMAL
- en: but we needed to build something to be able to see these logs otherwise it's
    very difficult to。 manually decode it and try to get sense of it。 So that was
    the complete idea of black box debugging。 I know you might be thinking it's a
    smart idea and you also know that it will work if we get all。 the information
    it will be easy for us to reconstruct based on the information which we already
    have。
  prefs: []
  type: TYPE_NORMAL
- en: but as the saying goes ideas are good execution is everything。 When we thought
    about black box debugging， the biggest question that came to our mind is about
    performance you might have also guessed。 that performance would be a huge issue
    and we needed disk writes to happen to be able to。 persist the log whether it
    is a file write or database write we needed to write it onto the。
  prefs: []
  type: TYPE_NORMAL
- en: disk and it's a huge performance issue especially when we want to write such
    a huge amount of logs。 Now we also looked into some of the existing logging strategies
    used by various systems and people。 some of them are called ring buffer circular
    buffer where logs are actually kept in memory before。 writing it onto the disk
    so which means that if you have a circular buffer for let's say one。
  prefs: []
  type: TYPE_NORMAL
- en: M besides you will wait for one Mb to fail before writing it into the disk but
    for us this was a。 problem we cannot do that because to be able to behave like
    black boxes we needed real time logs。 especially for state transition and events
    so if an event is being triggered we need to write that log。 because if something
    goes wrong at that time we will lose that information which means that。
  prefs: []
  type: TYPE_NORMAL
- en: we need some of the things to be written in real time of course there were few
    things which can。 hold on for a while but state transition and receiving an event
    is something we needed to be。 present in real time。 So here is how the architecture
    of our black box debugging looks like we had a。 totally different dedicated server
    reachable via TCP for the logging and we had our production。
  prefs: []
  type: TYPE_NORMAL
- en: code running in a different place so the different place could be our own servers
    or some of the。 servers in the cloud they are in a totally different space and
    this dedicated log server is in a。 different space。 So far so good but we were
    still skeptical whether this could work so what we。 did is that you know we gave
    it a first try with file write I mean receiving the TCP。
  prefs: []
  type: TYPE_NORMAL
- en: socket buffer and writing it into a file and as you might have guessed it took
    lots of time。 and it was expected also。 Second was SQL database right and of course
    it was better than file。 writes because it totally depends upon how you create
    this schema whether you can use async and。 other options。 Now one thing for us
    reading was not an issue so creation of join， story。
  prefs: []
  type: TYPE_NORMAL
- en: data was not an issue for us because we didn't want it to read in real time。
    For us writing the。 logs was the biggest thing it was better but still not up
    to the mark as far as performance is concerned。 So we gave it a third try with
    a no SQL database right it was generally better but not always so。 again it depends
    upon the type of data you want to use and depends upon how you put the data how。
  prefs: []
  type: TYPE_NORMAL
- en: you rearrange the data so basically data engineering matters over here。 Now
    I am not taking the name of， SQL and no SQL databases because we are not judging
    the database we are not benchmarking them。 What we had is a different kind of
    problem which we were trying to solve it has nothing to do with。 the capability
    or usability of our database。 So this is how it looked like but still the performance。
  prefs: []
  type: TYPE_NORMAL
- en: was an issue。 Now the performance impact was still beyond acceptable limit so
    we were in。 words of discarding this idea before that we thought of trying no
    SQL in memory database writes。 So in memory databases we are not the first choice
    because it is limited by the memory。 of the system which is much much lesser as
    compared to disk space of the system。
  prefs: []
  type: TYPE_NORMAL
- en: So it was not possible， for us to store all the data in the memory so we came
    up with a trick。 What we did is that you， know we allowed no SQL in memory database
    to listen to the TCP connection and receive all the logs。 and store it and what
    we did is that we run a batch system behind the scenes which we will trigger。
    after some time or when the memory usage goes beyond a acceptable limit it will
    run it will put the。
  prefs: []
  type: TYPE_NORMAL
- en: data into a persistent disk so in that way this was working。 So finally this
    gave us some of the。 acceptable performance limit。 Now one caveat if you just
    replace your you know disk database with。 in-memory database and expect a huge
    performance gain this is not going to happen you need to。 engineer how you want
    to store data in memory database also because data structures if they。
  prefs: []
  type: TYPE_NORMAL
- en: start taking more time it will negate the benefits of in-memory database so
    we didn't got perfect。 results in first go we had to do some kind of data engineering。
    Now this was in acceptable limits。 but we thought that you know can we improve
    the performance bit more we came up with an idea and。 it actually indeed improved
    the performance。 So the optimization is that our production code is。
  prefs: []
  type: TYPE_NORMAL
- en: running into different servers maybe in cloud maybe in our own premise。 What
    we did is that we。 created as instance of in-memory DB within that server itself。
    So logs will be written in this。 in-memory DB within that server where the production
    code is running and there will be a bad job which。 will take the data from this
    in-memory and transfer it into a physical database。
  prefs: []
  type: TYPE_NORMAL
- en: So this bad job will， be running in each and every server。 Now I would like
    to share one observation and that's a very， important information。 So within a
    server the communication will be fast but if we replaced in。 memory DB with another
    disk DB the performance difference is sometimes negligible and it。
  prefs: []
  type: TYPE_NORMAL
- en: exactly depends upon that kind of data we are writing amount of data we are
    writing especially。 if you are using some SSDs the performance difference is non-countable
    for a small amount of data but。 we had to end up using in-memory DB because you
    know in a disk DB you need to write it on the disk。 as well as read from the disk
    so that your bad job can transfer it onto a physical DB。 In in-memory。
  prefs: []
  type: TYPE_NORMAL
- en: DB you have to read from the memory itself which is again bit faster so overall
    it turned out to be。 faster。 So that's on what we did and I hope that I was able
    to explain you in this particular talk。 Now before I close some caution about
    black box debugging it's generally a very complex undertaking。 so you are just
    creating a short-lived a small project maybe it's not a best idea to use this。
  prefs: []
  type: TYPE_NORMAL
- en: particular thing it is good for long-term or critical system。 Again even if
    you are writing in-memory， it will take some time even if nanosecond millisecond
    but it will take some time and if you can afford。 that it's a good idea to write
    all those logs it will help you not only in understanding the problems。 in the
    production system but will also help you in understanding the behavior of the
    system。
  prefs: []
  type: TYPE_NORMAL
- en: which you can look and think about optimizing it。 Third and final thing this
    is not limited to。 just Python you can use this particular idea of black box debugging
    in almost any programming。 language and all the database provides driver to write
    in it from any other programming language。 including in memory database。 So that's
    all I had for this particular talk thanks a lot for listening。
  prefs: []
  type: TYPE_NORMAL
- en: thank you picon 2020 for providing this opportunity thanks a lot good day take
    care， [ Silence ]。
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bba88217c914fc5eafd190f5aecd9b1_3.png)'
  prefs: []
  type: TYPE_IMG
