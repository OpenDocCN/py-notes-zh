- en: P78：Tutorial Geir Arne Hjelle - Introduction to Decorators Power Up Your Python
    Code - 程序员百科书 - BV1rW4y1v7YG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P78：教程Geir Arne Hjelle - 装饰器简介，增强你的Python代码 - 程序员百科书 - BV1rW4y1v7YG
- en: Hi everyone， I'm Gaed Arnalap and first of all I'm really sorry that we couldn't
    all。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大家好，我是Gaed Arnalap，首先我真的很抱歉我们没能大家聚在一起。
- en: '![](img/13dc3ed458136a286215705708b44e8c_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_1.png)'
- en: '![](img/13dc3ed458136a286215705708b44e8c_2.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_2.png)'
- en: meet in Pittsburgh。 I've really been looking forward to coming to PyCon to meet
    you all but I guess we couldn't。 really get that one together。 I do want to thank
    the organizers for still giving me the chance to offer you this tutorial。 on Decorators
    and I'm really looking forward to sharing all the cool stuff about Decorators。
    with you。 So what I'll do in this tutorial， it will be about Decorators and I'll
    kind of talk。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在匹兹堡见面。我真的很期待来到PyCon与大家见面，但我想我们没能真正安排好这次见面。我确实想感谢组织者仍然给我机会提供这个关于装饰器的教程，我非常期待与大家分享有关装饰器的所有酷炫内容。所以在这个教程中，我将讨论装饰器，并且我会有点讲解。
- en: through everything from kind of the background to get you started and hopefully
    take you all。 the way until creating some really advanced Decorators。 What I assume
    from starting out is that you're somewhat comfortable with Python but no knowledge。
    of Decorators from before is necessary。 During this tutorial I will be working
    in the terminal and I hope that you will all work。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过所有内容，从背景开始，帮助你入门，并希望带你们一路走到创建一些真正高级的装饰器。我假设在开始时，你们对Python有一定的熟悉，但之前不需要了解装饰器。在这个教程中，我会在终端中工作，希望大家也能一起工作。
- en: together with me。 After we kind of got the basics up and running most of the
    tutorial will kind of be exercise-driven。 where I'll have some kind of tasks for
    you and we need to then figure out how can we。 create Decorators to solve those
    tasks。 After you have given it a shot I will also work through one possible solution
    together。 with you。 So what are Decorators？ That doesn't really tell as much。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 和我一起。在我们基本知识建立起来之后，大部分教程将以练习为驱动，我会给你们一些任务，然后我们需要弄清楚如何创建装饰器来解决这些任务。在你们尝试之后，我还会和你们一起工作出一个可能的解决方案。那么，什么是装饰器？这并没有告诉我们太多。
- en: The concept is much more interesting。 Decorators are there in the language to
    add consistent behavior to many functions that。 want typically。 These things can
    be stuff like label a function that you want to have time during code execution。
    or maybe profiled and even just compiled if that's necessary。 It could be things
    like labeling your endpoints and a web server that these endpoints need。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念更有趣。装饰器在语言中是为了给许多函数添加一致的行为，这些函数通常想要做的事情。这些事情可以是标记一个你想在代码执行期间计时的函数，或者可能是分析，甚至在必要时编译。它还可以是标记你的Web服务器端点，这些端点需要。
- en: to be behind the authentication so the users need to be logged in to see these。
    Or it could be things like， and this is an example from the click package where
    they use。 Decorators to convert regular function arguments into command line arguments
    and options。 Of course we won't have time to implement all of these kind of behaviors
    ourselves but。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 需要通过身份验证，所以用户需要登录才能查看这些内容。或者它可能是一些事情，比如，这是来自点击包的一个示例，它们使用装饰器将常规函数参数转换为命令行参数和选项。当然，我们没有时间自己实现所有这些行为，但。
- en: the plan for the tutorial is that you'll learn all the concepts that are necessary
    to。 work with these things。 What you'll see is that the Decorators are fairly
    small and easy concept once you get。 the hang of it but there are several elements
    that are kind of flying around there。 So it takes some time to kind of just land
    all the necessary things and put them together。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程的计划是你将学习与这些内容相关的所有必要概念。你会看到，一旦你掌握了，装饰器是相对小而简单的概念，但有几个元素在其中飞来飞去。因此，需要一些时间才能将所有必要的内容整合在一起。
- en: So with that let's get started and see what this course will include。 So let's
    go into a little bit more detail about what this tutorial will include。 So first
    of all let me just say that I work as a data scientist in Norway with a company。
    called the MastenXbridge and then on my spare time I write some articles for real
    Python。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧，看看这个课程将包括什么。让我们更详细地了解这个教程将包含什么。首先让我说，我在挪威一家名为MastenXbridge的公司担任数据科学家，然后在我的闲暇时间，我为Real
    Python写一些文章。
- en: and I did write an article with real Python that was published I guess almost
    two years。 ago now about Decorators。 I'll offer you some links for that one later
    as well and you can kind of see more detail。 about some of the things that we're
    covering here in that article as well if you'd like。 to have things written down。
    Okay so what we'll do today is that we'll first start with an introduction to
    Decorators。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实写过一篇与Real Python合作的文章，大约两年前发表的关于装饰器的文章。我稍后会提供一些链接，你可以查看文章中更详细的内容，如果你想要把事情写下来。好的，今天我们要做的就是首先开始介绍装饰器。
- en: and during this introduction we'll kind of get all the pieces that are kind
    of necessary。 to see how the craters work。 Once we kind of got that one up and
    running we'll start to do exercises and first we'll。 have three exercises we're
    all kind of making somewhat basic decorators and just see how。 we can make them
    run for us， kind of learn the basic templates how the decorators look。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次介绍中，我们会收集所有必要的元素，以了解创建者是如何工作的。一旦我们启动并运行了这个，我们将开始进行练习，首先我们会进行三个练习，我们都将制作一些基本的装饰器，并看看我们如何使它们为我们运行，学习装饰器的基本模板。
- en: and things like this。 And then afterwards we'll do more advanced decorators
    where we'll have decorators that。 can take arguments， decorators that can kind
    of work to keep state and all those kind of， things。 And then at the end I'll
    kind of talk a little bit about some additional resources and how。 to kind of
    continue working with decorators。 The first section， Introduction to Decorators。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以及类似的内容。之后我们将进行更高级的装饰器，其中将包含可以接受参数的装饰器，能够保持状态的装饰器等。这结束时，我会稍微谈谈一些额外的资源，以及如何继续使用装饰器。第一部分，装饰器简介。
- en: I want to cover first a couple of building， blocks。 So first is this concept
    of functions being first-class objects。 This is kind of fancy way of just saying
    that you can assign a name to your functions。 You can have many names assigned
    to one function and you can pass them around。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我想首先讨论几个构建块。所以首先是函数作为一类对象的概念。这是一种华丽的说法，实际上是说你可以给你的函数分配一个名称。你可以为一个函数分配多个名称，并且可以随意传递它们。
- en: You can take a function， pass it as an argument into another function。 You can
    have functions returned out of the function and things like this。 So functions
    work exactly like any other object in Python and that's respect。 And we also want
    to talk a little bit about inner functions。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把一个函数作为参数传递给另一个函数。你可以从函数中返回函数，类似这样的操作。因此，函数在Python中的工作方式与任何其他对象完全一样。我们还想稍微谈谈内部函数。
- en: These are just functions that are defined inside of other functions。 And again
    it might be something that you're completely used to but it's also something。
    that if you haven't seen it before it may look strange at first but it kind of
    has a。 natural behavior。 And we'll see both why we want to know about these things
    and how it works in this section。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是定义在其他函数内部的函数。再次强调，这可能是你完全习惯的东西，但如果你之前没有见过，起初可能会显得奇怪，但它具有自然的行为。我们将看到为什么我们想要了解这些内容，以及它在这一部分是如何运作的。
- en: And the third little thing that we want to have a look at is how we can manipulate
    functions。 in different ways。 So for instance playing with their attributes and
    those kind of things。 Putting all of this together will then come to the point
    where we can actually decorate。 our functions。 So we can create decorators and
    that will kind of be more or less the end of this introduction。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想看看第三个小点是如何以不同的方式操纵函数。例如，玩弄它们的属性和类似的东西。将这些内容结合在一起，我们将能实际装饰我们的函数。因此，我们可以创建装饰器，这将大致上是这个介绍的结束。
- en: except that we'll also learn how to make these decorators play nice with us。
    So how can they play together with essentially any function that you can think
    of to decorate。 and things like this。 So that's kind of just an overview of this
    first section。 So now let's get started。 So I will be using IPython as my terminal。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 只不过我们还会学习如何让这些装饰器与我们和谐相处。所以它们如何能够与任何你能想到的装饰函数协同工作。这样就算是这个第一部分的概述。那么现在让我们开始吧。我将使用IPython作为我的终端。
- en: This is a very nice terminal that also kind of， but if you're familiar with
    Jupiter you'll。 kind of recognize it from running there and it gives me a few
    things like command recall。 and command completion and those kind of things。 So
    now to get started the first topic that we want to talk about is just that functions。
    are first class objects。 And as I briefly mentioned during the introduction this
    means that you can use functions wherever。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常不错的终端，如果你熟悉Jupiter，你会从那里运行时认出它，并给我一些东西，比如命令回调和命令补全之类的东西。因此，现在开始我们想讨论的第一个主题就是函数是第一类对象。正如我在介绍中简要提到的，这意味着你可以在任何地方使用函数。
- en: you use other expressions like variables and those kind of things。 And one thing
    that we'll be using a lot is that we can take functions and pass them into。 other
    functions。 So just to kind of get us started and see what this means。 Let's start
    with a very simple say hello function that will essentially be your good。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用其他表达方式，比如变量之类的东西。我们将要经常使用的一件事是我们可以将函数传递给其他函数。因此，为了让我们开始，看看这意味着什么。让我们从一个非常简单的问候函数开始，这将基本上是你的好。
- en: old hello world。 But instead of adding or calling print explicitly I'll here
    add something I just call logger。 which will be a function that will somehow log
    the hello statement。 And then I'll take this logger that is now a function and
    I'll call it and then I'll call。 it with something like hello。 So once we have
    this defined we could now essentially run our regular hello world by。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 老的你好世界。但是，我将不会显式地添加或调用打印，而是这里添加一些我只是调用记录器的东西，这将是某种记录问候语的函数。然后我将把这个现在是函数的记录器调用它，然后调用它，例如hello。所以一旦我们定义了这个，我们现在可以基本上运行我们常规的你好世界。
- en: saying say hello to the world and use print as our logger function。 And you
    can see here that it now prints out a little world。 So just to kind of recap what
    happened here is that I'm here saying that I want logger。 to be the print function。
    And then that is kind of picked up here and now it's calling this function and
    it tells。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 说对世界说你好，并使用打印作为我们的记录器函数。你可以看到这里它现在打印出一个小世界。因此，回顾一下这里发生了什么，我在这里说我想让记录器成为打印函数。然后，这被这里接收，现在它调用这个函数并告诉。
- en: me where it runs print alone。 And just to point out that here we're kind of
    as usually using kind of the duck typing。 up Python。 So if I would give things
    the wrong type here。 so say say hello one comma two we will get， error because
    we are using the logger here as something that can be called typically a。 function
    and you can't execute it too。 Okay but what other things can I do？
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我在哪里运行单独的打印。值得指出的是，这里我们通常使用的是鸭子类型。上Python。因此，如果我在这里给东西错误的类型，比如说说你好1，2，我们将得到错误，因为我们在这里将记录器用作可以调用的东西，通常是函数，而你不能执行它。好吧，但我还能做些什么呢？
- en: So now for instance if I import the logging module I could also say hello to
    our logs。 and now I can say that okay now I want to use a different function。
    So now instead of using print maybe I want to use logger wanting。 And you can
    now see that it's and some stuff here and that's the way that the logging module。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在举个例子，如果我导入日志模块，我也可以对我们的日志说你好。现在我可以说，好吧，我想使用一个不同的函数。因此，现在不使用打印，也许我想使用记录器想要。你现在可以看到，这里有一些东西，这就是日志模块的方式。
- en: works by printing stuff out。 If I use this with a different logger info you'll
    see that nothing is printed out and this。 is again part of the whole logging module
    which is set by default to only outputs things。 that are at the warning level
    or higher as it's called。 So we can kind of see that these functions are doing
    something in the background right？
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打印东西来工作。如果我用不同的记录器信息使用它，你会看到什么都没有打印出来，这再次是整个日志模块的一部分，该模块默认仅输出警告级别或更高的内容。因此，我们可以看到这些函数在后台做了一些事情，对吧？
- en: We could even do things on files。 So for instance say that we have a。 first
    let's just look at a file， let's say hello。text。 and you can see that I don't
    have that file on my computer at the moment。 So let's create it。 So I say that
    I want to say hello。text for writing and call this one file for the moment。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在文件上做一些事情。因此，例如，假设我们有一个，首先让我们看一个文件，假设hello.text。你可以看到我现在电脑上没有那个文件。因此，让我们创建它。所以我说我想写hello.text，并暂时称这个文件为文件。
- en: and now I can call my say hello function and let's say hello to files and this
    time I。 want to use the logger which is file。write。 So that's a method on the
    file object that can write something to that file。 So if we now run this nothing
    on the screen， now look inside we actually see that we have。 created a file on
    the disk。 And then the final example I want to do with this is just that if we
    define now a different。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以调用我的 say hello 函数，让我们对文件说声你好，这次我想使用记录器，它是 file.write。这个方法可以将某些内容写入文件。所以如果我们现在运行这个，屏幕上没有任何输出，现在看看里面，我们实际上看到我们在磁盘上创建了一个文件。然后，我想用这个做的最后一个例子是，如果我们现在定义一个不同的。
- en: function for instance a reversed print function， I'll have this one taking some
    text and I'll。 have it just use your regular print function but then reverse the
    text。 So I'll take the reverse of the text and let me also then throw in a capitalized
    on top， of it。 So this is now just our regular version of course。 I can hide there。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 比如反转打印函数，我会让这个函数接受一些文本，我会让它使用常规的 print 函数，但然后反转文本。所以我将获取文本的反转，然后让我再加上大写字母。因此，这现在只是我们常规的版本，当然，我可以隐藏它。
- en: This one and you'll see that it's reversed the text。 We can also send this one
    to the say hello function。 So for instance let's say hello to let's see if we
    can do this one correctly something。 like no zip and then call our logger reverse
    print。 And you can now see that it prints out the hello message but it's used
    the logger reversed， print。 So all of these examples you might start to see some
    of the power that is within this， concept。 So what we have here is that we only
    have this one function right say hello。 That was just this very simple definition。
    And then we can kind of give it a lot of different behaviors based on the function
    that we're。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到它反转了文本。我们也可以将这个发送到 say hello 函数。例如，让我们对某些内容说声你好，看看我们能否正确执行，没有 zip，然后调用我们的记录器反转打印。现在你可以看到它打印出了问候消息，但使用了记录器反转的打印。因此，在这些例子中，你可能开始看到这个概念中的一些强大之处。我们这里只有这个函数
    say hello。这只是一个非常简单的定义。然后，我们可以根据我们传递的函数赋予它许多不同的行为。
- en: passing in。 And this might be depending on the background I guess。 either completely
    natural or truly， groundbreaking。 And either way whether you're used to this or
    not it is a very powerful concept。 And it's one of these things that kind of comes
    from the world of functional programming。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 传入的内容。这可能取决于背景，我想，可能完全自然或真正的突破性。无论你是否习惯于此，这都是一个非常强大的概念。它是源于函数式编程世界的一种概念。
- en: of which Python has adopted a few principles without really taking it all the
    way。 But it gives us the possibility to write code that can be really reusable
    and kind of applied。 in many different contexts。 And the decorators is kind of
    a very important part of that。 One thing I also want to just point out here is
    that， well let's look at print for instance， here。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python 采纳了一些原则，但并没有完全实现。但它给我们提供了编写可以真正重用的代码的可能性，并且可以在许多不同的上下文中应用。而装饰器是其中非常重要的一部分。我还想指出的一件事是，让我们看看
    print 函数。
- en: Is that when we pass in the function we pass it just with the name。 We don't
    send any parentheses。 Right， we don't do this。 And the difference between these
    two things is that in this first case we are actually。 looking at the print function
    object。 So we're just taking the print object itself and passing it in。 Well in
    the other case if we actually call it what we end up passing in is the return。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们传入函数时，只是用名称传递。我们不发送任何括号。对，我们不这样做。这两者之间的区别在于，在第一个情况下，我们实际上是在查看 print 函数对象。因此，我们只是获取
    print 对象本身并将其传递。而在另一个情况下，如果我们实际调用它，最终传递的就是返回值。
- en: value from print。 In print case that is just none。 So that explains why we get
    this error saying that the none type object is not callable。 Because what we actually
    ended up doing in this output 16 there is really just the same。 as if we had directly
    said logarithms。 So one important thing to just keep in mind when we're passing
    these functions around。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 print 的值。在 print 的情况下，它只是 none。这解释了为什么我们收到这个错误，说明 none 类型对象不可调用。因为我们在输出 16
    中实际上所做的，和我们直接说 logarithms 是完全一样的。所以在传递这些函数时，有一件重要的事情要记住。
- en: is that you want to always pass them around without calling them so without
    using the， parentheses。 Okay so that's kind of how functions as first class objects
    what that really means。 We can pass functions around。 Then we have something called
    inner functions or this is just a concept that you are allowed。 to define functions
    within other functions。 So let's just create a very simple example。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望始终在不调用它们的情况下传递它们，也就是不使用括号。好的，这就是函数作为一类对象的真正含义。我们可以传递函数。然后我们有一种叫做内部函数的概念，允许你在其他函数内定义函数。所以让我们创建一个非常简单的示例。
- en: So I'll just have a regular function that I'll call an outer function and have
    it print， up high。 And then inside of here I'll define a new function that I'll
    call inner。 And then from the inner one I'll say let's say hello from the inner
    function。 And there's a definition of inner but then inside of outer so first
    it will print then。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我将定义一个常规函数，称为外部函数，并让它打印 hi。然后在这里我将定义一个新函数，称为 inner。从内部函数中，我会说我们向内部函数问好。这是 inner
    的定义，但在外部函数内部，所以首先它会打印，然后。
- en: it will define inner and then finally I'll have it call the inner function。
    Something like this。 And now if we run outer you'll see that it both says hi from
    the outer function。 That's just the print we have here。 And then it says hello
    from the inner function which happens when we call the inner function。 right there。
    One thing I'll point out is that inner is not defined outside of outer itself。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它会定义 inner，最后我会让它调用内部函数。像这样。现在如果我们运行 outer，你会看到它既说了来自外部函数的 hi。这就是我们这里的打印。然后它说来自内部函数的
    hello，这发生在我们调用内部函数的时候。有一点我想指出的是，inner 在外部函数本身之外是未定义的。
- en: So it's just defined within the local scope of the outer function。 And again
    this is something that you are probably familiar with already but you may not
    have。 thought of it that way。 So if we look a little bit at this definition of
    outer and let me now also just define a。 new variable here。 So I'll just say variable
    equals one。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它仅在外部函数的局部作用域内定义。而且这可能是你已经熟悉的内容，但你可能没有以这种方式思考过。所以如果我们稍微看看这个外部的定义，现在让我在这里定义一个新变量。我会说变量等于一。
- en: It's slightly interesting and called the variable pi-con and I'll develop it
    2020。 Now if we run this you know that variables defined inside of functions are
    not available。 outside of those functions right。 So if we do other it still runs
    as it used to but pi-con only defined inside of the outer。 function itself。 So
    with the inner functions they behave exactly the same。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 它稍微有趣，被称为变量 pi-con，我将其开发为 2020。现在如果我们运行这个，你知道在函数内部定义的变量在这些函数外部是不可用的，对吧？所以如果我们执行其他操作，它仍然按以前的方式运行，但
    pi-con 仅在外部函数本身内定义。因此，对于内部函数，它们的行为完全相同。
- en: So they are defined there and they're all only kind of bound to the local scope
    within。 those functions。 So what you are kind of used to from using variables
    right is that if there is some variable or。 value that is interesting for the
    outside world what you need to do is to return it。 So if we return pi-con and
    then we call outer then we can get a hold of the value of pi-con， here。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它们在这里被定义，并且仅绑定到那些函数内的局部作用域。因此，你使用变量时所习惯的是，如果有某个对外界有趣的变量或值，你需要做的就是返回它。所以如果我们返回
    pi-con，然后调用 outer，我们就能在这里获取到 pi-con 的值。
- en: And we can do the same with the functions。 Instead of returning pi-con I can
    return inner and now if I call outer you'll see here。 that it returns a function
    with the interesting name of outer。local。inner。 And this inner function let's
    give a name to it。 I'll call it inside just to keep it different from the name
    inner that you've seen。 This is now a regular function that we can call。 After
    it has kind of been returned I have access to it outside。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以对函数做同样的事情。与其返回 pi-con，我可以返回 inner，现在如果我调用 outer，你会看到它返回一个有趣名称的函数：outer.local.inner。这个
    inner 函数我们给它一个名字。我会称它为 inside，以便与你见过的 inner 区分开来。这现在是一个我们可以调用的常规函数。在它被返回后，我可以在外部访问它。
- en: Again this is just being able to do the same with functions that you're already
    able to。 do with things like what you're used to doing with other objects。 So
    like integers in this case。 And then one more thing though I want to point out
    with the inner functions is that they can。 use information from their enclosing
    scope。 So this is again something that you might be familiar with from regular
    functions that。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这只是让你能在函数中做到与其他对象（例如整数）相同的事情。但我还想指出的一件事是，内部函数可以使用它们封闭作用域中的信息。这是你可能从常规函数中熟悉的。
- en: if you have something defined outside of the function you can refer to it inside
    the function。 So that's kind of you're reaching out of your scope is okay。 But
    just to show how that works also for the inner function here now we can say that
    the。 Python is like this and this in the string。 Now when I run outer you'll see
    that it says here Python is 2020 where it has gone to the。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在函数外定义了一些内容，你可以在函数内部引用它。所以这就意味着你可以超越作用域，这没问题。但为了展示这个在内部函数中的工作原理，我们可以说，Python在字符串中是这样的。现在当我运行外部函数时，你会看到它显示“Python是2020”。
- en: enclosing scope to get the value of Python。 So that's a little bit just introduction
    to inner functions。 And now let's try to see how we can use this to kind of play
    with functions。 So now we want to manipulate our functions a little bit。 And one
    thing that I'll just kind of start doing here is I'll just define a very simple。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 封闭作用域中获取Python的值。这是对内部函数的简单介绍。现在让我们看看如何利用这个功能来玩弄函数。现在我们想稍微操控我们的函数。一件我将开始做的事情是定义一个非常简单的函数。
- en: function that I'll call hello and it will take a function as its only argument
    here。 And then I'll just here I'll print out the name of the function。 So I say
    hello and then you can use the double underscore name double underscore so the
    under。 name attribute to get the name of the function。 And yeah let's just start
    there。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我会定义一个叫做hello的函数，它将只接受一个函数作为参数。然后我会在这里打印出函数的名称。我说hello，然后你可以使用双下划线name双下划线这个属性来获取函数的名称。现在我们先从这里开始。
- en: So now we have something that takes a function we define the outer function
    earlier。 So let's try to say hello to it and you can see here that if I have I
    pass in my other。 function object it can now say allow outer。 One thing just to
    show you we also have the inside function。 So here I gave it the name inside but
    it was defined as inner。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个接受函数的东西，我们之前定义了外部函数。让我们尝试跟它打个招呼，你可以看到，如果我传入我的其他函数对象，它现在可以说“allow outer”。值得一提的是，我们还有内部函数。所以这里我把它命名为inside，但它被定义为inner。
- en: So what will be the name if we now say hello inside。 In this case it's picking
    up the original name hello inner it's saying here。 This is something for now just
    to note what happens there and this is something that will。 come back with a little
    bit later。 Okay。 Now let's make our hello function slightly more advanced。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果我们现在说hello inside，名称会是什么呢？在这种情况下，它会选择原始名称hello inner。现在这只是提醒你注意发生了什么，稍后我们会回到这个问题。好的，现在让我们把hello函数稍微复杂一点。
- en: I'll just also return。 So now I'm returning the exact same function I'm not
    doing any manipulation on it right。 I get a function I return it。 So now if we
    say hello outer you can see it still print out hello outer but then it also。 returns
    the function outer。 So the return value from this is a function object right。
    That means that we can just call it。 So I can add double parentheses to it and
    call it。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我也会返回。所以现在我返回的是完全相同的函数，我没有对它进行任何操作。我得到一个函数并返回它。所以现在如果我们说hello outer，你会看到它仍然打印“hello
    outer”，但它也返回了外部函数。因此，这里的返回值是一个函数对象，这意味着我们可以直接调用它。我可以给它加上双括号来调用。
- en: And now you can see that okay we got the hello outer from the hello function
    and then we have。 this output that you've seen before from the that is printed
    inside of outer。 So this is starting to be a little bit of inception here and
    then finally we got the。 return value that was this inner function that we returned
    from outer。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到，我们从hello函数中得到了“hello outer”，然后有你之前看到的输出，这在外部函数中打印。所以这开始有点像《盗梦空间》，最后我们得到了从外部函数返回的内部函数的返回值。
- en: That means that instead of calling it directly I could also assign it to a new
    name。 So I can say that new outer is hello outer and first of all you can see
    here since we're。 just sending this one through。 If I look at new outer it still
    is just the outer function and you can even check here。 that new outer is regular
    outer and that's true。 Okay so that's kind of getting a little bit of playing
    with these functions。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我可以将其分配给一个新名称，而不是直接调用它。所以我可以说新的 outer 是 hello outer，首先你可以在这里看到，因为我们只是传递这一项。如果我查看新的
    outer，它仍然只是外部函数，你甚至可以在这里检查，新的 outer 是常规的 outer，这是真的。好的，所以这有点在玩这些函数。
- en: Now let's move closer to what we actually do when we are decorating functions。
    So what you really do when you decorate a function is that you create a wrapper
    around。 the original function and then in that wrapper you add some functionality。
    So for now I'm going to play with a function that I'll call wrapper and this will
    be our。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更接近我们在装饰函数时实际上会做的事情。所以当你装饰一个函数时，你真正做的是在原始函数周围创建一个包装器，然后在这个包装器中添加一些功能。所以现在我将玩一个我称之为包装器的函数，这将是我们的。
- en: first real decorator in a sense。 And what we'll do here is that we'll start
    out just by doing something before we call。 our function。 So just for now I'll
    just print out that I'll use I'll just print out the sentence before。 Then we'll
    call our function and finally we'll also print out or we'll do something after。
    we have called the function and for now I'll just again print out。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，真正的第一个装饰器。我们在这里要做的是在调用我们的函数之前做一些事情。所以现在我只会打印出这个句子，然后我们将调用我们的函数，最后我们也会打印出或者说在调用函数后做一些事情，现在我再次打印出。
- en: Okay I said this is our first decorator。 It's not really a decorator yet and
    I'll kind of show you just briefly how this one works。 So if I now call this around
    outer you can see here that we have we're doing something。 before we call it then
    these three lines are familiar that's from calling outer function。 and then we
    do something after outer。 But in this case this wrapping happened exactly when
    we ran this line right and if I now just。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我说这是我们的第一个装饰器。它实际上还不算是真正的装饰器，我会简单地向你展示它是如何工作的。所以如果我现在调用这个 around outer，你可以在这里看到我们在调用之前做了一些事情，然后这三行是从调用外部函数来的，然后我们在外部之后做一些事情。但是在这种情况下，这种包装恰好发生在我们运行这行代码时，对吧？如果我现在只是。
- en: run harder again you can see that this is still seems to be a regular function
    and if。 you run it it doesn't have any nothing is happened to it in that sense。
    So this is kind of just wrapping the outer function just at runtime and we need
    to kind。 of call wrapper outer every time we use it。 That's not really what we're
    after we're looking for something that's a little bit more。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行得更努力，你可以看到这似乎仍然是一个常规函数，如果你运行它，它并没有发生任何变化。所以这有点是在运行时包装外部函数，我们每次使用它时都需要调用
    wrapper outer。那并不是我们真正想要的，我们在寻找一些更进一步的东西。
- en: permanent。 So this is where our knowledge now inner functions come into play
    so I'll just create。 an inner function here and just to kind of try to keep track
    of things I'll just name。 it with the same name as the other function but with
    an underscore in front。 And this inner function will now do what we did in wrapper
    earlier namely it will do something。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 永久性。所以这就是我们现在内嵌函数知识发挥作用的地方，我将在这里创建一个内嵌函数，只是为了更好地跟踪事情，我将用与其他函数相同的名称，但在前面加一个下划线命名它。这个内嵌函数将执行我们之前在包装器中做的事情，也就是说，它将执行某些操作。
- en: before calling the function then it will call the function and then it will
    do something。 after calling the function。 And now the kind of little magic that
    we'll do is that here now we'll return this new inner。 function so that's something
    similar to what we already did with the other function right。 And what can this
    do for us now？ So if I now say wrapper of outer remember that when we did this
    last time it ran outer。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数之前，它将调用该函数，然后在调用函数后做一些事情。现在我们要做的小魔法是，我们将在这里返回这个新的内嵌函数，这与我们之前对其他函数所做的有些相似。那么这对我们现在有什么帮助呢？如果我现在说
    wrapper of outer，请记住，当我们上次这样做时，它运行了 outer。
- en: In this case it now just returns this inner wrapper function that we created。
    And what happens here is that we wrap this now at this stage only once and I'll
    now say。 that we take a new outer and we'll make it wrapped outer。 And what I
    can do now is that I'll do a new outer and call it and now you can see that。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，它现在只返回我们创建的内部包装函数。此时发生的事情是，我们在这个阶段只包装了一次，现在我会说，我们取一个新的外部函数，并将其命名为包装外部函数。现在我可以做的是调用新的外部函数，你现在可以看到。  '
- en: we have stuff happening before we run our function we have the stuff that was
    happening。 in the outer function itself and we have stuff happening after the
    outer function。 And this can now happen I can now call this several times but
    the wrapping of outer happened。 only once so it only happened here on line 54。
    The only time we actually did the wrapping itself and what we have been doing
    since then。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '外部函数不再是原本定义的外部函数，现在每次我调用时。我们在运行函数之前发生了一些事情，在外部函数本身发生了一些事情，外部函数之后也发生了一些事情。现在这可以多次调用，但外部函数的包装仅发生了一次，所以只在第54行这里进行了包装。这是我们实际上进行了包装的唯一一次，而我们自那时以来所做的。  '
- en: is calling this actually new function underscore wrapper that then is doing
    something calling。 the function doing something more。 Okay so now we're ready
    for one more very small stuff and that's that we will actually。 just redefine
    the name outer so that it points to this new wrapped function。 So I did say earlier
    new outer equals wrapper outer。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '其实是在调用这个新的函数下划线包装器，它在做一些事情，调用函数，然后再做一些事情。好的，所以现在我们准备好做一个非常小的事情，那就是我们实际上会重新定义外部函数的名称，使其指向这个新的包装函数。所以我之前说的新外部等于包装外部。  '
- en: The only change you'll do now is that instead of sending this to new name I'll
    just redefine。 outer itself like this and this is now something that we call the
    outer has been decorated by。 the decorator wrapper。 So wrapper is now a decorator
    and outer has been decorated and what we can see here is。 that outer is no longer
    the outer function as it was defined and now every time I call。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '你现在唯一要做的改变是，不再将这个发送给新名称，而是像这样重新定义外部函数本身，这现在就是我们所称的，外部函数已经被装饰器包装了。所以，包装器现在是一个装饰器，外部函数已经被装饰，我们可以看到的是。  '
- en: outer you can see that we have changed its behavior。 So that's essentially how
    a decorators work and what you might be used to if you've seen。 anything about
    the creators before you probably not seen this syntax because what we Python。
    introduced a long time ago I believe it was Python 2。3， Python 2。4 is something
    called。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '在外部，你可以看到我们已经改变了它的行为。所以，这本质上就是装饰器的工作方式，如果你之前见过关于创建者的内容，你可能没有见过这种语法，因为我们在 Python
    中引入了它，我相信是在 Python 2.3 和 2.4 之间。  '
- en: a decorator syntax and if we now just recall our other function I'll keep this
    version。 I think and yeah let's first just run it one time and now you can see
    we have our regular。 function back but if I not changed this definition and just
    on the line right before the definition。 the outer line I'll write an add symbol
    and then the name wrapper and this is the usual。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器语法，如果我们现在重新调用其他函数，我想我会保留这个版本，是的，首先先运行一次，现在你可以看到我们恢复了常规函数，但如果我没有改变这个定义，只是在定义的前一行，外部行之前写一个加号，然后是包装器的名称，这就是通常的。
- en: form the usual syntax that we use to decorate functions and if you run this
    and now I run。 outer you can see that it has been decorated with this wrapper
    where it's doing something。 before calling the function it's calling the function
    and then it's doing something afterwards。 So this is the syntax that you'll usually
    see for decorators but kind of the main takeaway。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '这是我们用来装饰函数的常规语法，如果你运行这个，现在我运行外部函数，你会看到它被这个包装装饰了，在调用函数之前它会做一些事情，然后调用函数，再做一些事情。所以，这就是你通常会看到的装饰器语法，但主要的要点是。  '
- en: that I want to make sure that you get here is that that syntax is purely syntactic
    sugar。 for this syntax where you're doing outer equals the wrapper of outer。 So
    just to kind of enforce that point a little bit just you take away that I hope
    you have。 so far is that what we'll call decorators that's just any function that
    accepts a function。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '我想确保你在这里明白的是，这种语法纯粹是语法糖，表示将外部函数等于包装外部函数。所以，为了进一步强调这一点，我希望你能理解到目前为止，我们所称之为装饰器的就是任何接受函数的函数。  '
- en: and returns a function。 So just to remind you if we define our wrapper function
    here as something that defines a。 function or sorry it takes a function as an
    argument and then it returns some function。 back this function could really be
    any function but it's for all useful purposes it should be。 somewhat related to
    the the function that you get it。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 并且返回一个函数。所以提醒一下，如果我们在这里定义我们的包装函数作为定义一个函数，或者抱歉，它接受一个函数作为参数，然后返回一些函数。这种函数实际上可以是任何函数，但出于所有实用目的，它应该与您获得的函数有一定关联。
- en: And the other takeaway is that this add wrapper syntax or add decorator is just
    syntactic。 sugar for defining the function by itself and then running function
    equals wrapper out function。 This is something that will be very useful to just
    keep in mind when you're trying to。 figure out how do a decorator work when we
    get to the more advanced decorators will have。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要点是，这个添加包装器语法或添加装饰器仅仅是定义函数本身的语法糖，然后运行`function = wrapper(out_function)`。当您试图弄清楚装饰器如何工作时，这一点将非常有用，当我们到达更高级的装饰器时，将会有。
- en: the creators that can take arguments for instance we'll be able to stack several
    decorators on。 top of each other and then to figure out how those things work
    it's always useful to kind。 of come back to what is really happening in the background
    so then having this in mind。 is really useful。 Okay then before we leave this
    topic so here we have our wrapper function I just want to。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 创建者可以接受参数，例如我们能够在彼此之上堆叠几个装饰器，然后要弄清楚这些东西是如何工作的，总是有必要回顾一下后台实际上发生了什么，因此考虑到这一点是非常有用的。好的，在我们离开这个话题之前，这里是我们的包装函数，我想。
- en: point out that there's a few issues with our wrapper function and one is as
    follows if we。 now go back to one hour say hello functions I'll just create a
    very simple hello world exercise。 again say just hello name this and let's okay
    let's run it。 So say hello world works right and now if I decorate this with my
    wrapper like this and。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 指出我们包装函数存在几个问题，其中一个是如果我们现在回到一个小时的“你好”函数，我会创建一个非常简单的“你好世界”练习，再次说“你好名字”，然后我们来运行它。所以“你好世界”工作正常，对吧？现在如果我像这样用我的包装器装饰它。
- en: then we'll say hello world one more time we get a typo it says here that underscore
    wrapper。 takes zero positional arguments but one was given so there's something
    wrong happening。 with the argument here so the fact that say hello here takes
    an argument is causing us。 some problems。 Okay we'll soon look into how to fix
    that but there's more problems so let's say that。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们再说一次“你好世界”，我们得到一个错误，它在这里说下划线包装器接受零个位置参数，但给定了一个，因此这里的参数发生了错误，所以下面这个说“你好”的参数造成了一些问题。好的，我们很快会看看如何修复它，但还有更多的问题，所以我们假设。
- en: we also have another function for this one I'll do a quick dice roll I think
    so let me。 import random and then I'll define a small dice roll function that
    should just return。 a random number and until you're between one and six so if
    we do a dice roll there's three。 there's four so on and now what happens if we
    use our wrapper decorator on this one。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有另一个功能，我会快速进行一次掷骰子，所以让我先导入`random`，然后我会定义一个小的掷骰子函数，它应该只返回一个随机数，并且是介于一到六之间的数字。如果我们掷骰子，这里有三，四，等等。那么如果我们在这个上面使用我们的包装器装饰器会发生什么呢？
- en: In this case once I run dice roll you can see here that while it seems to run
    we got。 the before dice roll we got the after dice roll but somehow we actually
    didn't get the。 result of the dice roll so we can see here that the actual result
    that we saw appeared。 three and four and so on is eaten up by a decorator so there's
    also something regarding。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一旦我运行掷骰子，你可以看到虽然它似乎在运行，我们得到了掷骰子之前和之后的结果，但我们实际上没有得到掷骰子的结果，因此我们看到的实际结果三和四等等被装饰器吞掉了，因此还有一些问题。
- en: return values that doesn't quite work with our wrapper we'll also fix that one
    fairly。 quick and then I'll just want to point out one more thing and yeah let's
    again function。 and that's I've been talking about this double underscore name
    attribute that kind of shows。 us the name of the functions so it's not dice it's
    dice roll but the dice roll here seems。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值和我们的包装器不太兼容，我们也会快速修复这个问题，然后我想指出一点，再次强调一下这个函数。还有就是我一直在谈论的这个双下划线名称属性，它能显示函数的名称，所以这里不是骰子，而是掷骰子，但这里的掷骰子似乎。
- en: to think that it's called wrapper so there's also something happened with the
    name here。 you can probably see why this is happening because when we did the
    decoration we replaced。 the dice roll function with this wrapper function so of
    course it has a different name for most。 cases this isn't really important but
    it may have some subtle problems to it so we definitely。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 认为它叫做包装器，所以名称这里也发生了一些事情。 你可能可以看到为什么会发生这种情况，因为当我们进行了装饰时，我们替换了。 骰子滚动函数与这个包装器函数，所以它当然有一个不同的名称。
    在大多数情况下，这并不重要，但它可能会有一些微妙的问题，所以我们绝对。
- en: want to fix it and it also makes debugging much harder when you can't really
    trust what。 your functions are telling you okay so let's see how we can solve
    these problems the first。 one was that if we said hello world this thing completely
    crashed and so let's see what happens。 here and so if you're looking now into
    what is happening remember that say hello has been。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我想修复它，当你无法真正信任你的。 函数所告诉你的事情时，调试也变得更加困难。 好吧，让我们看看如何解决这些问题，第一个。 是当我们说hello world时，这个东西完全崩溃了，所以让我们看看发生了什么。
    在这里，如果你现在看看发生了什么，记住say hello已经被。
- en: decorated with wrapper so that means that it has really been replaced by this
    wrapper。 function so I'm now calling I'm really calling a wrapper here when I
    say hello world but you。 can see that the wrapper doesn't take any arguments and
    that's of course we could now。 do something like and just add the name argument
    here and then if we do redefine our say hello。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 用包装器装饰，这意味着它确实被这个包装器。 函数替换了，所以当我说hello world时，我实际上在调用一个包装器，但你。 可以看到这个包装器不接受任何参数，这当然我们现在可以。
    做一些事情，简单地添加名称参数，然后如果我们重新定义say hello。
- en: let's see and then run hello world it works and the problem now is that if we
    have any。 function that doesn't take exactly one argument here that function won't
    work so for instance。 if I now apply this to the die-stroll function die-stroll
    won't work and so this is not really。 a good solution let's see a better solution
    did I fix this we can use what's called the。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看，然后运行hello world，它有效，现在的问题是，如果我们有任何。 不准确接受一个参数的函数，这个函数就无法工作，例如。 如果我现在将其应用于die-stroll函数，die-stroll就无法工作，所以这并不是一个。
    很好的解决方案，让我们看看更好的解决方案，我修复了这个，我们可以使用所谓的。
- en: star arcs and star star keyword arguments the quarks and what this medium does
    is that。 it just collects or all the positional arguments that you give to a function
    so the ones where。 you don't use a keyword and all the keyword arguments that
    you give to a function and。 just collects them into a list in a dictionary or
    two-plan dictionary and then we don't need。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 星号弧和星星关键字参数，夸克，以及这个介质所做的就是。 它收集你传递给函数的所有位置参数，也就是那些你。 不使用关键字的参数，以及你传递给函数的所有关键字参数。
    它将这些参数收集到一个列表或字典中，然后我们不需要。
- en: to care about how many what they're called or anything and then we can just
    pass those。 further on to our wrapped function weighted function so by doing this
    now I'm saying that。 I'll just take whatever arguments you give to me and I'll
    pass them on to the to the。 function I'm wrapping so let's try to run this wrapper
    around say hello and we can now。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 不关心它们被称为什么或任何事情，然后我们可以将它们传递。 给我们的包装函数加权函数，因此通过这样做，现在我在说。 我将接受你给我的任何参数，并将它们传递给我所包装的。
    函数，所以让我们试着在say hello周围运行这个包装器，我们现在可以。
- en: see that we can run say hello world and now it does what it should do it does
    something。 before say hello it runs the hello world and it does something after
    say hello and if I。 would now for instance call say hello without any arguments
    you can now see that it's actually。 doing something before it's calling say hello
    and now it's say hello itself that's complaining。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们可以运行say hello world，现在它做了它应该做的事情，它确实在做某些事情。在say hello之前，它运行hello world并做某些事情，在say
    hello之后如果我。 现在例如调用say hello而不带任何参数，你可以看到它实际上。 在调用say hello之前正在做某些事情，而现在是say hello本身在抱怨。
- en: about the missing positional argument so now we the wrapper itself is just taking
    whatever。 it's getting and passing it on。 Okay then we had some issue with our
    dice roll so let's see if we remember what was the problem。 here it's just that
    when we have our dice roll it had some return value but that return。 value is
    somehow eaten up by our decorator so let's see what happens then so you can。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 关于缺失的位置参数，所以现在我们，包装器本身只是接受它所获得的内容并传递下去。 好吧，然后我们对骰子滚动有一些问题，所以让我们看看我们是否记得问题是什么。
    在这里，就是当我们有骰子滚动时，它有一些返回值，但那个返回。 值在某种程度上被我们的装饰器吃掉了，所以让我们看看发生了什么。 你可以。
- en: now see that once we call our function which will be the dice roll in this case
    we don't。 collect the return value at all it's just lost when you get to this
    line so the first。 thing we need to do is to definitely make sure that we save
    that return value to some。 value and now to make this behave consistently and
    then return that value so you can see now。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看到一旦我们调用我们的函数，这里是骰子滚动，我们根本没有收集到返回值，它在到达这一行时就丢失了。因此，我们需要做的第一件事是确保我们将返回值保存到某个值中，现在为了让它行为一致并返回该值，所以你现在可以看到。
- en: that I'm just saving the return value here so that I can do some more stuff
    after I've。 called the function and then once I'm done doing that stuff I passed
    the return value。 on so you can see this is kind of the same principle just in
    reverse so with the arcs。 and quarks we need to just take whatever we get and
    pass it on to the function and for。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我可以做的一件事就是改变它。这里我正在保存返回值，这样在调用函数后我可以做更多的事情，然后一旦我完成了这些事情，我就将返回值传递下去。所以你可以看到，这种原则实际上是反向的。因此，利用参数和关键字，我们需要将得到的任何东西传递给函数。
- en: the return value we take whatever we get is return from here and then return
    it further。 out so let's see if this is enough now to fix our dice rolls and let's
    see where we have。 it there we go so now if I call dice roll you can see that
    it does something before the。 dice roll it does something after the dice roll
    and it returns out value some value of。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的返回值是从这里获取的任何值，然后再进一步返回。让我们看看这是否足以修复我们的骰子滚动，并查看我们在哪里有它。好吧，所以现在如果我调用骰子滚动，你会看到在骰子滚动之前它会执行一些操作，在骰子滚动之后也会执行一些操作，并返回一些值。
- en: the dice roll so that worked then the final issue that we looked at was that
    we have changed。 the email dice roll and can we do with this well start kind of
    the via a naive approach。 so here I have my inner function wrapper that I'm defining
    and then the issue is that it。 has the wrong name right so one thing I could do
    is just to say okay let's just change it。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 骰子滚动，所以这有效。然后我们查看的最后一个问题是，我们已经改变了电子邮件骰子滚动，那么我们可以用这个做什么呢？我们将以一种幼稚的方法开始。所以这里我定义了我的内部函数封装器，问题是它的名称错误。
- en: so now I want to wrap your name to just equal okay so if we do this and then
    redefine our。 dice roll first of all let's just check dice roll still works and
    now the name of dice roll。 dice roll so we successfully have changed the name
    of dice roll and now this works but it's。 not an ideal solution for instance now
    if I can I just say print out the function object。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我想将你的名字封装为等于“好的”，所以如果我们这样做，然后重新定义我们的骰子滚动，首先我们检查一下骰子滚动是否仍然有效，现在骰子滚动的名称。我们成功地改变了骰子滚动的名称，现在这可以工作，但这并不是一个理想的解决方案。例如，现在如果我能打印出函数对象。
- en: you'll see that it now in the in kind of the wrapper for the function object
    it still has。 all these weird references to the underscore wrapper and the wrapper
    and things like this。 so we changed name but we haven't changed other things that
    might be useful to to change as。 well and it turns out that this is kind of important
    enough thing to look into so that。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，在函数对象的封装中，它仍然有所有这些奇怪的对下划线封装和封装的引用。因此，我们改变了名称，但我们没有改变其他可能有用的东西。结果发现这实际上是一个值得关注的重要事情。
- en: it exists a function in the in the standard library inside of the fun tools
    package and。 called a wrapper and if you look at the help for this you'll see
    that the doctoring says。 that this is used to update a wrapper function to look
    like the wrapped function so that's。 essentially exactly what we want to do right
    and then it has some details here for it you。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库的fun tools包中存在一个函数，叫做封装器。如果你查看这个的帮助文档，你会看到文档中提到这是用来更新一个封装函数，使其看起来像被封装的函数，所以这正是我们想要做的事情，然后这里有一些细节。
- en: can see what which things it actually changes so here we have the name that
    we talked about。 but it for instance also copies over the duck string and things
    like this and now there。 we could use the fun tools update wrapper but there is
    actually an even a simpler thing。 called wraps and this is a decorator factory
    so it's actually a decorator to apply update。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它实际上改变了哪些内容，这里我们有我们之前讨论过的名称，但它还会复制文档字符串等东西。现在我们可以使用fun tools更新封装器，但实际上还有一个更简单的东西，叫做“封装”，这是一个装饰器工厂，所以它实际上是一个应用更新的装饰器。
- en: wrapper to a wrapper function so this makes it even easier to use okay so how
    do you actually。 use it well let's go back to our wrapper function and now I don't
    want to do this manually instead。 what I'll do is that I'll apply the fun tools
    wraps and right over here and there's this is。 something we haven't seen with
    decorators before but it takes an argument namely which。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将包装器转换为包装函数，这样使用起来更简单。那么，实际上你如何使用它呢？让我们回到我们的包装函数，现在我不想手动执行这个，而是要应用functools的wraps，正好在这里，这是一件我们以前没有在装饰器中见过的事情，它接受一个参数。
- en: function it should copy information from so it should take our original function
    and。 the wrapper function and we'll talk more about how to actually create decorators
    with taking。 arguments later but with this wrapper and now we can have a look
    at our dice roll and。 first of all see that let our name is dice roll so that
    was what we were kind of looking。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应该从中复制信息，所以它应该接收我们的原始函数和包装函数，我们稍后会详细讨论如何实际创建带有参数的装饰器，但现在我们可以查看我们的骰子投掷，首先看到我们的名字是骰子投掷，这就是我们想要的。
- en: for with our fix earlier but if I now look at the dice roll just a wrapper for
    it and。 the function object it has a nice name and we can also yeah mention the
    duck string we're。 playing a little bit hard fast by capturing here but let's
    add a string function and now。 we can see that I can do help as far forward using
    here see that we have six sided dice。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们之前的修复，如果我现在查看骰子投掷，只是一个包装器，函数对象有一个不错的名字，我们也可以提到鸭子字符串，我们在这里有点快速捕捉，但让我们添加一个字符串函数，现在我们可以看到我可以在这里使用帮助。
- en: in the duck string so with all of these things now we have what I'll call actually
    a very。 nice template for how you'll typically create your decorators so what
    you'll do is that。 you'll have some kind of wrapper function so this will be the
    actual decorator it's a。 function that takes a function as input and it returns
    some function as output usually。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些都保持着，但可能有些装饰器你想要在鸭子字符串中添加内容。因此，结合这些因素，我们有一个我称之为非常好的模板，通常你如何创建装饰器。你会有某种包装函数，这将是实际的装饰器，它是一个接受函数作为输入并返回某个函数作为输出的函数。
- en: you'll define this function that it turned it up with as an inner function because
    that。 gives you the possibility to both play with with the funk here and and change
    kind of。 some of its behavior either by doing something before and after or one
    could even do some。 weird things with arguments and those kind of things but often
    you'll end up having something。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你会定义这个函数，将其作为内部函数，因为这给了你可能性去操作函数，并且改变一些行为，可以在之前或之后做一些事情，或者甚至可以对参数做一些奇怪的事情，但通常你会得到一些东西。
- en: before calling the function and then you'll actually call the function recall
    here that。 we pass in the RX and quirks and take we remember the return value
    and then you might be doing。 something after calling function and finally usually
    you'll then return the return value。 from the function so that that's kept but
    there might be decorators where you want to。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数之前，你实际上会调用函数，这里回忆一下，我们传入了RX和quirks，并记住返回值，然后你可能会在调用函数之后做一些事情，最后通常会返回函数的返回值。
- en: change the the return value and things like this as well but this is kind of
    the most。 typical template that we use so this kind of concludes our first part
    and we're now getting。 ready to work work our way into these exercises and one
    thing that I'll just recommend is that。 once you start working on the exercises
    start with this kind of wrapper template here and。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以更改返回值等，但这大概是我们使用的最典型的模板，所以这基本上结束了我们的第一部分，现在我们准备开始这些练习，我要推荐的一件事是，一旦你开始练习，就从这种包装模板开始。
- en: then take it from there。 Okay so let's move on over and look at our first exercises。
    So。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后从那里开始。好的，那我们继续看我们的第一个练习。
- en: '![](img/13dc3ed458136a286215705708b44e8c_4.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_4.png)'
- en: let's start with the exercises so first of all just a little bit of logistics
    so the。 exercises comes with a file where you can or several files that kind of
    help you get started。 You can all download these from this repository and what
    you'll find inside of this repository。 will be some task files that contain some
    code I'll show you those soon and then also the。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始练习，首先一些后勤安排。练习包含一个文件或几个帮助你入门的文件。你可以从这个仓库下载所有这些，你会在这个仓库中找到一些任务文件，其中包含一些代码，我会很快向你展示这些文件。
- en: template that we saw for the for the decorator so let's start here。 So if you
    look inside。 a pike in decorators。py you'll see that it contains this template
    just a few small comments。 added and this you can use as a starting point for
    your own decorators。 For most many cases。 at least it will be a good starting
    point and then as we'll kind of get into more advanced。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在装饰器中看到的模板，所以我们从这里开始。如果你查看pike中的decorators.py文件，你会看到它包含这个模板，只是添加了一些小注释。你可以将其作为自己装饰器的起点。在很多情况下，至少这将是一个好的起点，然后随着我们深入更高级的内容。
- en: things you'll kind of figure out how to add stuff to it。 But then let's move
    over to the。 first task so this is a timer task and what will happen here is that
    you can kind of this。 function or this file you can run and it will probably then
    tell you that you don't have。 timer implemented in pike on decorators。 So your
    task is to implement the timer decorator。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你会逐渐弄明白如何向其中添加内容。但接下来让我们转到第一个任务，这是一个计时器任务，在这里你可以运行这个函数或文件，它可能会告诉你在pike中没有实现计时器装饰器。所以你的任务就是实现计时器装饰器。
- en: so that it will behave properly。 So let me just show you an example of how we
    want this， to run。 So what I'm doing here is that I'm just starting a pike Python
    but now I'm giving， it the task。py file that we have here and then a -i flag。
    So what this means is that。 iPython runs test a pike as a usual script file but
    then once it's finished running it。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这样它才能正常运行。所以让我给你举个例子，展示我们想要的运行方式。我这里所做的就是启动一个pike Python，但现在我给它任务文件task.py，并加上一个-i标志。这意味着iPython会像普通脚本文件那样运行test
    a pike，但在完成运行后。
- en: stops in interactive mode。 So inside of here I now have waste time defined and
    strictly。 enough I also have the timer decorator already implemented just to show
    you the behavior that。 we're expecting and what you can first of all see here
    is that when you run the function。 waste time it pops up a line saying a lapse
    time in this case zero seconds。 At this line。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 停在交互模式下。所以在这里我现在定义了浪费时间，并且我也已经实现了计时器装饰器，只是为了向你展示我们期望的行为。你首先可以看到，当你运行函数浪费时间时，它会弹出一行，显示经过的时间，这种情况下是零秒。在这一行。
- en: you can see it's not anywhere in source code instead that comes from the timer
    decorator。 So that's the part you need to implement and what this decorator does
    is just measuring。 how long time does it take for this function to run。 So what
    is this function for the task。 it can it's not really that important but let's
    just have a quick look at it。 So it's just。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，它并不在源代码中，而是来自于计时器装饰器。所以你需要实现的部分就是这个装饰器。这个装饰器的作用是测量这个函数运行所需的时间。那么这个任务的函数是什么呢？其实不是特别重要，但我们快速看一下。它就是。
- en: something that's kind of set up to waste a little bit of time。 It takes in a
    number argument。 and based on that number it sets up a for loop and so for it
    runs through the range of that。 for that number and inside of that for loop is
    essentially another loop where it runs up。 to the range of the running index there
    and then it somehow calculates some kind of sum。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个设置来浪费一点时间的东西。它接受一个数字参数，并根据该数字设置一个for循环，所以它在那个数字的范围内运行。该for循环内部本质上是另一个循环，它运行到当前索引的范围，然后以某种方式计算某种总和。
- en: out of this。 In the case where number is 10 you can see that the result comes
    out that's， 120。 Let's try to waste time with a slightly bigger number。 So here
    now you can see it at。 least spent 300 of a second。 Since this kind of scales
    more or less like n squared with。 a double loop let's try 10 times more than we
    should be at about 2， 3 seconds。 Yeah it's。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果数字是10，你可以看到结果是120。让我们尝试用稍微大一点的数字浪费时间。所以在这里你可以看到，至少花了300分之一秒。由于这种情况的复杂度大致是n平方的双重循环，让我们试一下大约10倍，应该在2到3秒左右。是的，它。
- en: like less than 2 seconds。 So your task then is to implement the time of the
    decorator so。 that you can also run i Python task。py and see similar results to
    this。 Of course your。 running times will probably be slightly different but the
    behavior should kind of be the same。 And just a small hint I guess to get you
    started is that to actually view the measuring of time。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说少于 2 秒。所以你的任务就是实现这个装饰器的时间测量。这样你也可以运行 `task.py` 并看到类似的结果。当然，你的运行时间可能会稍有不同，但行为应该是类似的。小提示是，要查看时间的测量。
- en: you'll want to import the time module it's part of the standard library and
    it first comes。 at a function called perf。com or perf。com。 You can see here that
    this is what they call。 a counter for benchmarking。 What it returns is a seemingly
    random number。 But the importance。 of this number is that during a session it
    is always increasing and the number here is essentially。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要导入时间模块，它是标准库的一部分，首先以名为 perf.com 的函数出现。你可以看到这是他们所称的基准测试计数器。它返回的看似是一个随机数。但这个数字的重要性在于，在一次会话中它是不断增加的，这里的数字本质上是。
- en: if we can use it to measure time。 So for instance if I took here the time minus
    the previous result。 and that was 8。8 seconds for that example。 So this is what
    you want to kind of base your time around。 And yeah what you should do now is
    just pause the video and see if you can more or less recreate。 this behavior。
    Then once you start up the video again we'll walk through a solution together。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以用它来测量时间。例如，如果我在这里做时间减去之前的结果。对于那个例子是 8.8 秒。所以这是你想要围绕的时间。现在你应该暂停视频，看看你能否大致重现这种行为。然后一旦你重新开始视频，我们会一起讨论一个解决方案。
- en: Good luck。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 祝你好运。
- en: '![](img/13dc3ed458136a286215705708b44e8c_6.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_6.png)'
- en: '[silence]。'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[静默]。'
- en: '![](img/13dc3ed458136a286215705708b44e8c_8.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_8.png)'
- en: Let's have a look then at how we can solve this timer decorated thing。 So first
    of all just to。 do some testing I think I'll copy in when a couple of these examples
    into the script here so we can just。 run it more easily。 I don't have to run it
    manually。 So if we， solve three of them。 And so if we do this time with 10，000
    like this and then just。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们来看看如何解决这个计时装饰器的问题。首先，进行一些测试，我想我会把几个例子复制到脚本中，这样我们可以更轻松地运行它。我不需要手动运行它。所以如果我们解决三个问题。如果我们像这样用
    10,000 计时，然后就。
- en: and I'll show you so now I have a move in my solution。 So if I now run Python
    test。 that's why I get the import error。 I can't import the name timer because
    it doesn't exist。 And so now I have my， wrapper template example here and I'll
    just change this one， to timer quickly。 Let's see like this。 And we have a template
    for decorators。 And now just to run my。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我来给你演示一下，现在我在我的解决方案中有一个移动。所以如果我现在运行 Python 测试。就是为什么我会得到导入错误。我无法导入名称 timer，因为它不存在。因此，现在我在这里有我的包装器模板示例，我会把这个快速改为
    timer。像这样。我们有了一个装饰器的模板。现在就来运行我的。
- en: example we can see here that it at least runs through the thing but it doesn't
    really do anything。 yet。 So that's the next thing we need to fix。 I said that
    we could use， time standard library。 So we can import that。 Now what should we
    be doing with this one？
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以看到它至少执行了，但还没有真正做任何事情。所以这是我们需要修复的下一件事。我说过我们可以使用标准库中的时间。所以我们可以导入它。那我们应该用这个做什么呢？
- en: Well we saw that the perf counter was something that was kind of measuring relative
    time。 So if we sort of implement the clock here so I'll say that I'm the。 perf
    counter and I'll call that the tick。 And we call our function and then we calculate
    the。 clock afterwards。 And now we have two measurements of the perf counter。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到性能计数器在测量相对时间。所以如果我们在这里实现一个时钟，我会说我就是性能计数器，然后称之为 tick。然后我们调用我们的函数，之后再计算时钟。现在我们有了性能计数器的两个测量值。
- en: And then let's see what should we print out something like elapsed time。 And
    then we will find a stick。 And let's let ourselves do this mouse and say seconds
    there。 Now I'm just using the template exactly as it was written right。 And I'll
    do here is that before。 we start the function I'll take a note of what is the
    time right now。 I'll kind of record the tick。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后看看我们应该打印出类似经过的时间。然后我们会找到一个 stick。让我们自己做这个鼠标并说这里是秒。现在我正完全按照模板写的。而我在这里要做的是，在我们开始函数之前，我会记下现在的时间。我会记录这个
    tick。
- en: And then I call the function and then afterwards I want to record what's the
    time after we call。 the function and then print out what's the difference of those
    times。 The rest is just。 the template using the template。 I'll probably update
    this one as well。 Something like recording。 running， or let's just say timing。
    Let's see what this one works。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我调用这个函数，之后我想记录我们调用函数后的时间，然后打印出这些时间的差异。其余的就是使用模板。我可能也会更新这个，类似于记录运行，或者就叫做计时。让我们看看这个工作情况如何。
- en: So if you run this again we can now see that it prints out。 elapsed time and
    it seems to be calculating this thing correctly。 So this shows an example of how
    to， kind of get started。 Hopefully this gives you some idea about how you can
    do something， before calling a function。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你再次运行这个，我们现在可以看到它输出了经过的时间，而且似乎在正确地计算这个东西。所以这展示了一个如何开始的例子。希望这能给你一些关于如何在调用函数之前做一些事情的想法。
- en: How you can do things after calling a function。 And。 just to remind you if we
    look at our task here we can also see that our template has taken care of。 sure
    the number that we pass in and the total that is passed out are both handled correctly。
    Right so the clearly number has something to say here and we get the return values
    here。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在调用函数后做事情。只是提醒你，如果我们看一下我们的任务，这里我们也可以看到我们的模板已经处理好了我们传入的数字和传出的总数都正确处理了。对，所以明显数字在这里有话要说，我们在这里得到了返回值。
- en: So this gives us at least one solution for the first exercise。 Okay then it's
    time for the second one。 Let's move on。 For the second exercise we're gonna do
    something called the trace decorator and this one is also。 something that should
    fit to the pattern of the template that you've seen already fairly well。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这至少给了我们第一个练习的一个解决方案。好吧，接下来是第二个练习。我们来继续。对于第二个练习，我们要做一个叫做 trace 装饰器的东西，这个也应该很符合你已经看到的模板的模式。
- en: So let me first just do a demo to show you a little bit how this would work。
    So again I just run my。 IPython terminal and over this second task file and now
    I have the functions defined here。 So you。 can for instance if we just look at
    the first one it's again essentially a hello world type of。 function but we decorate
    it here with the decorated trace。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我首先做一个演示，向你展示这将如何工作。所以我再次运行我的 IPython 终端，并且在这个第二个任务文件上，现在我有定义好的函数。所以你可以例如，如果我们只看第一个，它基本上又是一个
    hello world 类型的函数，但我们在这里用 decorated trace 装饰了它。
- en: So if I run this you can see that it returns， hello world and that's kind of
    what the function does but then the trace decorator adds this output。 So what
    it does is that it's just kind of say more or less a debug output that you can
    get to kind。 of follow how the flow of your program is。 So in this case it says
    that okay it's calling the。 greet function with world and then this greet function
    returned hello world and now if we for。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我运行这个，你可以看到它返回了“hello world”，这就是这个函数的作用，但随后 trace 装饰器添加了这个输出。所以它做的就是基本上提供更多的调试输出，让你可以跟踪程序的流动。所以在这种情况下，它说好吧，它调用了
    greet 函数，传入了 world，然后这个 greet 函数返回了 hello world，现在如果我们继续。
- en: instance do something like a bit name equals world you can see here that it
    picks up that we're。 using a keyword argument or if I'm also changing the reading
    so maybe it will end to be a Python。 and say def world and you can kind of see
    these things kind of happening here and then to kind。 of just make the example
    a little bit more interesting。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如做一些像 name = "world" 的事情，你可以看到这里它识别出我们正在使用一个关键字参数，或者如果我也在改变问候语，可能它会变成一个 Python，然后说
    def world，你可以看到这些事情在这里发生，然后为了让例子变得更有趣一些。
- en: We also have a couple more functions so here I， added a random greet function
    with this one does is that it just picks out the greeting at random。 from this
    list that we have up here and then it calls a greet with that。 So as an example
    and now。 since this is random let's actually set the random C so it's reproducible
    and now if I call random。 greet let's see random greet yeah I'll just call it
    with the default arguments here then you can see。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有几个其他函数，所以在这里我添加了一个随机问候函数，它的作用是从我们上面的列表中随机挑选一个问候语，然后用这个问候语调用 greet 函数。作为一个例子，现在由于这是随机的，我们实际上设置随机种子以便可重复，现在如果我调用随机问候，让我们看看随机问候，嗯，我就用默认参数调用它，你可以看到。
- en: that you see random greet is called and then this one calls our greet function
    with the name Emily and。 the greeting Nee and then this kind of returns all the
    way back to us and then to make this。 even more I guess convoluted probably and
    there's also a greet many function that just calls random。 greet several times
    so if I do a greet many let's say we do that three times。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到随机的 greet 被调用，然后这个调用了我们的 greet 函数，名称是 Emily，问候是 Nee，然后这种返回一路回到我们这里，然后为了让这一切。变得更加复杂，可能还有一个
    greet many 函数，它只是调用 random。greet 几次，所以如果我做 greet many，比如说我们做三次。
- en: and you can now see that we first call greet many and then there are。 one random
    greet loop here's a second one and a third one and then inside each。 of these
    we call the greet function and then finally greet many returns with this list。
    So again it may not seem like an amazing kind of function but this can be useful
    to just follow。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到我们首先调用了 greet many，然后有一个随机的 greet 循环，这里是第二个和第三个，然后在每一个里面。我们调用 greet 函数，最后
    greet many 返回这个列表。因此，这看起来可能不是一种惊人的函数，但跟随它是很有用的。
- en: the structure of your program and mainly this is now just for testing so what
    we want to do here。 is to write so your task is to write this trace decorator
    and mainly the big difference from。 what you've done already is that we are here
    using the values of arcs and quarks the argument list and。 the keyword argument
    list also inside of the function itself or inside of the decorator I guess the。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的结构，这主要是为了测试，所以我们想在这里做的就是写。因此你的任务是写这个 trace 装饰器，主要的区别在于。你已经做过的事情是，我们在这里使用
    arcs 和 quarks 的值，即参数列表和。关键字参数列表，这也在函数内部或装饰器内部。
- en: creative function so that should hopefully work out well。 There's a little bit
    of。 to kind of get this kind of formatting it's a little bit of play with。 yeah
    F strings and joints and things like this if you can just print them out that's
    also perfectly。 fine and then just remember when you want to get the name here
    you can get that from essentially the。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 创意功能，希望这能很好地工作。这里有一点。需要玩一下这种格式，稍微调整一下。是的，F 字符串和连接这些东西，如果你能把它们打印出来，那也完全可以。好的，然后只要记得，当你想获取名称时，你可以从本质上获取它。
- en: name attribute right so greet underscore for instance and one little thing you
    might remember here or。 can't try out as well is that the name of the function
    is something that you can。 figure out already inside your decorator before the
    wrapper function if you want to do that。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 名称属性对了，所以 greet_，例如，有一点你可能记得或者。也可以尝试的是，函数的名称是你可以在装饰器内的包装函数之前就弄明白的，如果你想这样做的话。
- en: '![](img/13dc3ed458136a286215705708b44e8c_10.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_10.png)'
- en: okay so let's look at how we can solve the second task so the first thing we
    need to do is to add。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么让我们看看如何解决第二个任务，首先我们需要做的是添加。
- en: '![](img/13dc3ed458136a286215705708b44e8c_12.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_12.png)'
- en: a trace decorator to our Python decorators list and for this one yeah let's
    spell it out here。 you could also just copy the timer decorators since we will
    be doing something quite similar。 but I'll kind of do it step rest up here so
    show the trace of function calls I guess we can call this one。 and one thing that
    we can just do right now is just define the name of the function because this。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将 trace 装饰器添加到我们的 Python 装饰器列表中，对于这个，是的，我们在这里拼写一下。你也可以直接复制计时器装饰器，因为我们将做一些非常相似的事情。但我会在这里一步一步地做，所以展示函数调用的
    trace，我想我们可以称之为这个。我们现在可以做的一件事是定义函数的名称，因为这个。
- en: we're going to use a couple of times so I'm just defining this in a variable
    that I leave in the。 decorator itself because it will not change from function
    call to function call so this will kind of。 be a what's called a closure but it
    it will then be in the closing scope we define it once when we。 find a when we
    kind of decorate the function and then we can use it afterwards inside of our
    wrapper。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用几次，所以我只是将其定义在一个变量中，保留在装饰器内部，因为它不会在函数调用之间改变，所以这将是一个。所谓的闭包，但它会在闭包作用域内，我们定义一次，当我们装饰函数时，然后可以在我们的包装器内部使用它。
- en: function and then we have the wrapper function and this one remember we need
    to take in all the。 arguments and key where arguments and then we want to add
    the fun tools wraps on top of this。 so that's the one that adds in kind of the
    correct naming of our wrapped function。 and this will then be the yeah I'll call
    it the trace function that replaces the original function。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使输出更美观，这并不会改变函数的功能，然后我们有包装函数，记住我们需要接收所有的参数和关键字参数，然后我们想在此基础上添加`functools.wraps`。所以这就是添加我们包装函数的正确命名的。
- en: and then remember okay how was the template we do something。 before we call
    the function then we call the function， hold arguments and keyword arguments。
    and and make do something， and we're calling the function and finally we return
    value and then the final thing we need。 for now is that the trace decorator here
    it needs to return a function and so we need a second return。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后记住，好的，模板是怎样的，我们在调用函数之前做一些事情，然后我们调用函数，保持参数和关键字参数。做一些事情，我们在调用函数，最后返回值，最后我们现在需要的是追踪装饰器在这里需要返回一个函数，因此我们需要第二个返回。
- en: bottom here where we return the different so what I've done so far is not really。
    implementing much of the functionality of trace that we're looking for the only
    thing is the name。 thing there but more written out the template just to have
    that one here for me and now just to test。 that this kind of runs I'll now run
    i thin and the task too and one thing I did was just that I added。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部返回不同的东西，因此到目前为止，我所做的并没有真正实现我们所寻找的追踪的功能，唯一的事情就是名称的事，但更多的是为了写出模板，以便我能在这里有一个，现在只是为了测试一下，这种运行的情况，我将运行它并完成任务。
- en: a few test cases so the ones that we did manually earlier I added them to the
    bottom of the file just。 to make it easier for us to test I used the same random
    seed here so we can kind of be consistent。 so if i'm running this you can now
    see that as expected I guess it's not printing out any。 other tracing information
    and the three lines that are here are just me separating the test cases。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些测试用例，所以我们之前手动完成的那些我已将它们添加到文件底部，以便我们更容易测试，我在这里使用了相同的随机种子，以便保持一致。所以如果我运行这个，你可以看到，如预期那样，它没有打印出任何其他追踪信息，这里有的三行只是我在分隔测试用例。
- en: with some lines okay so that means that at least we have defined the decorated
    trace in the in the。 correct place so now it's time to actually do the implementation
    and I was okay now we're going to。 use the arcs and quarks here a little bit and
    so one thing we could then do would be something like。 pulling and then now I
    can use my name variable but I pick up there。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是，嗯，我称之为追踪函数，替换原始函数，带上一些行。因此这意味着至少我们已经在正确的位置定义了装饰追踪，现在是时候真正进行实现了，好的，现在我们将稍微使用弧和夸克，因此我们可以做的事情类似于拉取，然后我现在可以使用我在那里的名称变量。
- en: and if we know the arcs and quarks， something like this and then we want to
    say here。 and name returned， so now I'm printing out what was the arguments and
    keyword arguments we got before calling the。 function and then I'm printing a
    three turn value afterwards so if we now run this。 now see okay here we started
    and that we actually get the trace here so now you can see that it's。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道弧和夸克，类似这样，然后我们想在这里说。返回的名称，因此现在我正在打印调用函数之前得到的参数和关键字参数，然后在之后打印三次返回值，所以如果我们现在运行这个。
- en: calling greet greet returned hello world it's calling greet again which returned
    def world in this。 case random greet which calls greet inside greet returns random
    greet returns and so on and so。 here we have essentially solved the exercise one
    thing I'll just spend this short half minute on。 is just we can make the output
    nicer it doesn't really change the functionality of the。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`greet`，`greet`返回“hello world”，它又调用`greet`，这次返回的是“def world”，在这种情况下是随机的`greet`，它在`greet`内调用`greet`，返回随机的`greet`，依此类推。因此我们实际上解决了这个练习，我将花短短的半分钟在这一点上。
- en: of the decorator though so it's not really that important say to this exercise
    but。 gonna just to show you so one thing we can do is that we can make。 a representation
    of the keyword arguments and first I'm just gonna take all the。 representations
    for each of the arguments for a in cards and this doesn't really。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管装饰器不太重要，但我想展示一个可以做的事情，那就是我们可以对关键字参数进行表示，首先我将获取每个参数在`cards`中的所有表示，这并不真正重要。
- en: inch much the the only thing this part would do is that it will kind of print
    out。 quotes around strings typically in our case here and then for the keyword
    arguments I want to。 represent them like a string where it's showing the key equals
    the value for k and v in quarks。 items let's see like this and then finally I
    can say that my signature so the signature of the。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: function I can get now by just joining together all of these things with a comma。
    and now if I print out here the signature， we can see how that looks so now you
    can see we get something that looks more like。 the actual function called here
    and there's one little thing left that we might want to fix。 so that's you can
    see here there's missing quotes around the strings and that's because here we're。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: just using the string representation and not the wrapper representation like
    we did there。 so I could here just do a wrapper of v as well let's quickly see
    that that then adds in your。 quotes there and there's also a shortcut to doing
    wrapper v in in F strings so if you just do a bang。 and then R that means use
    the wrapper representation instead of string representation so we can do that。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: as well and I'll just do the same here for the value here since we're dealing
    with strings that。 mostly just puts quotes around the actual string values to
    make them easier to see。 let's do this one up so here for instance you can see
    that the return value also has string。 okay so that gives us a nice trace decorator
    again it just follows the same pattern that we're using。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: doing something before we call the function and we're doing we're calling the
    function。 and then we're doing something after calling the function so the main
    kind of takeaways。 here we're that okay we can also use these arcs and quarks
    and we can use the function itself。 if what we're taking out only depends on the
    function not on the arguments then you can even do。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: stuff up here in the so in the decorator function and the kind of convenience
    or the nice thing about。 doing it here is that this only happens once when you
    actually decorate the function。 while whatever you do down here needs to happen
    every time the decorator is called so if it's。 something that takes a little bit
    of time it's great to be able to do it once if that's possible。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: okay then one more thing I want to show you before we move on is that it's also
    possible to stack。 decorators so for instance if I now have the timer decorator
    defined right and so we could。 use that together with the trace decorator so as
    an example let me just put it。 well time run trace right here， and then to yeah
    to see the updates we can now run our function again。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: and you'll now see that every time a random greet is called we also get one
    of these elapsed time。 outputs， and so what happens here is that we have put the
    timer around the trace random greet function。 and this is kind of when one of
    the first times when it really starts messing a little bit with。 okay what's actually
    happening here and so it might be useful then to just spell out。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在会看到每次调用随机问候时，我们也会得到这些经过时间的输出。因此，发生的事情是我们在跟踪随机问候函数周围放置了定时器。这是第一次真正有些混淆的情况，好的，实际上发生了什么，所以写下来可能会有用。
- en: what's actually happening so this is now， essentially what it does is that it's
    calling it's defining random greet to be timer of trace。 of our definition original
    definition of random greet。 so this statement is essentially the same as what
    we're doing here and so so it。 remember random greet is a function then trace
    returns a function and then timer takes in a function。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上发生的事情是，它正在调用并将随机问候定义为定时器跟踪。我们原始定义的随机问候。所以这个语句本质上和我们在这里做的是一样的。记住随机问候是一个函数，然后跟踪返回一个函数，定时器则接收一个函数。
- en: and returns it again so what timer we'll do is just take how much time does
    it or measure how much。 time does it take for this trace a random greet function
    to run so so it all kind of。 builds together nicely one short little note that
    will do， is let's see if we can make。 it's our source this okay here we go， so
    if we run this you can see here that the elapsed timeprints after。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 并再次返回，所以定时器将做的是测量这个随机问候函数运行需要多少时间。因此，这一切都很好地结合在一起。我们做的一个简短小笔记是，让我们看看能否制作它的源代码，好的，我们开始吧。如果我们运行这个，你可以看到这里的经过时间在之后打印出来。
- en: the tracing is done and that makes sense because we put timer on the outside
    of trace。 it's also possible to move it below so just flip the order here。 and
    what this means is that we're actually timing just random greet and then we're
    tracing。 kind of the timer call and you won't see much difference but if you know
    it now。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪完成了，这很合理，因为我们在跟踪外部放置了定时器。也可以将其移至下面，所以只需在此翻转顺序。这意味着我们实际上是在随机问候时计时，然后再进行跟踪。这有点像定时器的调用，你可能看不到太大区别，但如果你现在知道了。
- en: elapsed time is at least printed out before random greet returns because。 the
    elapsed timeprint is now part of the function call if you remember down here。
    so when we call function here that's actually calling the timed function。 so in
    this case this part is already printing out the elapsed time before we get to
    the print。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 经过去的时间至少在随机问候返回之前打印出来，因为经过的时间现在是函数调用的一部分。如果你记得在下面。当我们在这里调用函数时，实际上是在调用定时函数。因此，在这种情况下，这部分已经在打印经过的时间，而我们还没到打印。
- en: statement down there yes so this is mainly just showing you that we can。 indeed
    stack timers now stack decorators together。 okay then for the third exercise we'll
    do something a bit different。 so for this third exercise we're going to do something
    slightly different。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的语句是的，这主要是向你展示我们确实可以将定时器堆叠，现在将装饰器堆叠在一起。好的，那么第三个练习我们将做一些稍微不同的事情。因此，在这个第三个练习中，我们将做一些略有不同的事情。
- en: so now we're looking at a decorator that we're again going to implement that
    we're called。 register and this one will actually not change any functions instead
    it will just。 register essentially the existence of a function and we now have
    this code here before I kind of。 walk you through what this code does let me just
    run it and show you the effect of it。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在看一个装饰器，我们将要实现一个叫做注册的装饰器。这不会改变任何函数，而是仅仅注册函数的存在。我们现在有了这段代码，在我逐步讲解这段代码的作用之前，让我先运行它，给你展示效果。
- en: so again I'll run it with iPitan so that it first runs through the code and
    then it stops。 afterwards so we can do some investigation as well so now you can
    see it actually there is。 actually some a little bit of script here that it stops
    running so first it's actually an input here。 asking me to input a text so let's
    say something like decorators are。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我再次使用iPitan运行它，让它首先通过代码，然后停止。之后我们可以进行一些调查。现在你可以看到，实际上有一些小脚本在这里停止运行，所以首先这是一个输入，询问我输入文本，所以让我们说一些像“装饰器是”。
- en: now it says here that there are some parsers one called two or fourths one called
    reversed and。 one called rubber language and it asks me to choose a parser and
    if you look over here on the。 on the code you can see that the parsers come from
    something called registered that's also part of。 the decorator that you're going
    to make and but you can kind of recognize here the names here are。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这里说有一些解析器，一个叫做two or fourths，一个叫做反转，还有一个叫做橡胶语言，它要求我选择一个解析器，如果你看代码，你可以看到解析器来自于某个叫做registered的地方，这也是你要制作的装饰器的一部分，但你可以识别出这些名称。
- en: from these functions so there's a registered true or false function there's
    a registered。 reversed function and there's a registered rubber language function
    and we're going to look at what。 these do as well but let's choose reversed that's
    an example and you can now see somehow prints out。 nephirasarutarotz or something
    like this and if you look closely at this you can kind of see。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些函数中，有一个注册的真或假函数，还有一个注册的反转函数，以及一个注册的橡胶语言函数，我们将要深入了解它们的功能，但先选择反转作为例子，你现在可以看到它打印出nephirasarutarotz或类似的东西，如果你仔细观察，你会发现。
- en: that this is decorators are fun in reverse so this thing has reversed our text
    so you can kind of see。 here okay what what does the script to it asks us to input
    a text then there's a there's a wild。 true loop here the only thing it does is
    to make sure that the answer that we're giving here is one。 of the registered
    parsers if it's not it just asks one more time once that's done it comes down
    here。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是装饰器在反转中的乐趣，所以这个东西已经反转了我们的文本，你可以看到，脚本要求我们输入一个文本，然后有一个while真循环，它唯一的作用是确保我们在这里给出的答案是注册解析器之一，如果不是，它只会再问一次，完成后会来到这里。
- en: and it says okay parser funk it goes into this registered dictionary and picks
    out the parser。 from the dictionary and then it calls this parser funk with the
    text so let's have a closer look at。 what this registered is and you can hear
    see that this is a dictionary and it has entries where you。 have the name of a
    function and pointing to the function object itself and this is kind of。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 它说，parser funk进入这个注册字典并从字典中挑选出解析器，然后调用这个parser funk与文本，所以让我们更仔细地看看这个注册字典，你可以看到这是一个字典，其中有条目，功能名称指向函数对象本身。
- en: happened for all three of these and this is something that can be used in Python
    for instance to emulate。 switch switch statements and things like this or it can
    be used like here to give the user some。 some kind of dynamic choice between different
    available things for instance you could imagine that。 this was part of a bigger
    plugin or hooking system where you can define hooks and just register。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这在所有三个中都是这样，这可以在Python中用于模拟开关语句等，或者像这里一样，为用户提供在不同可用选项之间的一种动态选择，例如你可以想象这是一个更大插件或钩子系统的一部分，你可以定义钩子并注册。
- en: them like this even at even at runtime you could add registered new hooks so
    it kind of gives you。 some extra flexibility in your code but one thing to note
    here is that yeah it's just these claims。 to be the functions that we have defined
    right here and in this case we have actually not been。 using fun tools reps so
    it actually is just the pure function and so for the register。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在运行时，你也可以添加注册的新钩子，这为你的代码提供了一些额外的灵活性，但这里需要注意的是，这些声称是我们在这里定义的函数，实际上我们并没有使用fun
    tools reps，所以它实际上只是一个纯函数，因此对于你要制作的注册装饰器，它实际上并不需要包装函数本身，只需返回相同的函数。
- en: decorated that you're going to make it will actually not need to to wrap the
    function itself it just。 returns the same function so the only thing you need
    to do there is to the the registered。 decorator takes in the function and then
    it just registers that function into the registered。 dictionary that you have
    here and then it can return that function back again and before。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你需要做的唯一事情是，注册的装饰器接受函数，然后将该函数注册到你这里的注册字典中，然后它可以将该函数返回回来，在此之前。
- en: having you run off and implement this and i'll just show you quickly what these。
    things do as well and so the true or false function so let me actually call it
    here so have a true or。 false this so you can see this is now a function so we
    can call it and it does things like it。 translates between few different say more
    human readable strings that has some true or false。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让你去实现这个，我会快速展示这些功能的作用，所以真或假函数。让我实际上在这里调用一下，所以你可以看到这现在是一个函数，所以我们可以调用它，它做一些事情，比如在几个不同的说更人性化的可读字符串之间翻译，这些字符串有真或假。
- en: connotation so for instance yes is true and no is false for example so that's
    one way to just parse。 some text if we happen to write something here that's not。
    one of those words for instance if i actually write decorators here it just returns
    none。 either there is no return statement so it just falls off the of the function
    and returns none。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，含义是是为真，否为假。所以这是一种解析文本的方法。如果我们在这里写的内容不是其中之一，例如，如果我在这里写装饰器，它就返回无。要么没有返回语句，所以它就会掉出函数并返回无。
- en: the next one is reversed so that was the one we saw already it's just reversing
    the string and。 then using capitalized to put a capital letter in front。 and then
    the final little parser just for fun here is something called the rubber language。
    parser and let's move there we go and and this is based on actually。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个是反向的，所以这是我们已经看到的内容，它只是反转字符串，然后使用大写字母放在前面。最后一个小解析器只是为了好玩，这是一种称为橡胶语言的解析器。让我们移过去，这实际上是基于的。
- en: children's book series by the Swedish author of the lingran where they， mean
    these similar。 and just as an example if we do decorators for instance there。
    we can see that it translates decorators into， and and it's a fairly simple thing
    what it does here is that for each letter in the text string that。 you give it
    if that letter is part of the consonants so if it's a consonant then it's written
    out as the。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 瑞典作者林格兰的儿童书籍系列，它们意味着相似的东西。作为一个例子，如果我们为实例添加装饰器，我们可以看到它将装饰器翻译为，做的事情相当简单。它会为你给定的文本字符串中的每个字母，如果这个字母是辅音，那么就将其写出。
- en: letter repeated and then within o between them so you can for instance see there
    we have the first。 the other decorators there's the C and the decorators and so
    on and otherwise so if it's a well or any。 other symbol it's just returned as
    is so that this was kind of then yeah used as a toy language for。 kids in suite
    so these are just different functions to play with for different kind of。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 字母重复，然后在它们之间有o，所以你可以例如看到这里我们有第一个。其他装饰器有C和装饰器等等，否则，如果是井号或任何其他符号，它就原样返回。所以这被用作儿童的玩具语言。这些只是不同的函数，可以用于不同类型的玩耍。
- en: so it's text parsing and so not really important again for the for the implementation
    of the task。 but the task that you have is to figure out how can you create this
    decorator so good luck。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是文本解析，这对于任务的实现并不重要。但你需要做的任务是找出如何创建这个装饰器，祝你好运。
- en: '![](img/13dc3ed458136a286215705708b44e8c_14.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_14.png)'
- en: '![](img/13dc3ed458136a286215705708b44e8c_15.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_15.png)'
- en: okay so let's see how we can actually implement this register decorator and
    now i have。 the decorators that we already created and let's just yeah let's。
    just give this one and now just to show you i moved the implementation of register
    so now again I。 get the error saying that we don't have register defined so let's
    see what did we need here we wanted。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们看看如何实际实现这个注册装饰器，现在我有了已经创建的装饰器。让我们给这个一个机会，现在我将注册的实现移走，所以现在我再次收到错误，说明我们没有定义注册，所以让我们看看我们需要什么。
- en: if you look here we want to have the decorator register and we want to have
    the dictionary registered。 so let's just start with the first one we'll just define
    this as a module level dictionary。 and it can just be empty we don't need this
    to the moment that will instead be dynamically filled。 in by the grader and we
    wanted to have a decorator called register and since it's a decorator it takes。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看这里，我们想要有装饰器注册，我们想要有字典注册。我们先从第一个开始，我们就将其定义为模块级字典。它可以是空的，我们不需要它，现在会由评分者动态填充。我们想要一个名为注册的装饰器，由于它是装饰器，它需要。
- en: in a function let's add in a quick buck string to it and some point at least
    this one will just。 return the same function right that was one of the things
    one of the hints essentially we talked about。 how this one should not wrap the
    function at all it should just return the same function。 so you can see how that's
    different from how for instance the timer decorator works which takes。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个函数中，我们添加一个快速的字符串，并且至少在某个时刻，这个函数将返回同一个函数。这个是我们讨论的其中一个提示之一。这个装饰器不应该包装函数，它只需返回同一个函数。因此你可以看到，这与计时器装饰器的工作方式不同，后者会接受。
- en: in a function and wraps it in a different function that is then returned so
    we can start with something。 like this and now we can see that if we run this
    at least it starts running so the imports work。 and if now the decorators are
    fun you can now see that okay my parsers here is empty so there。 there is no parser
    to choose from maybe it works to just type reversed and choose one of them。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个函数中，将其包装在一个不同的函数中，然后返回。所以我们可以从像这样的开始，现在我们可以看到，如果我们运行这个，至少它开始运行，所以导入正常工作。如果现在装饰器正常工作，你可以看到我的解析器这里是空的，所以没有解析器可供选择，也许尝试输入reversed并选择其中一个。
- en: so we just need to stop that so there's still a little bit lacking here in our
    registration。 but it's not too much so what we said we want to do is that for
    every function we want to have。 one item into our dictionary so that means that
    I want to do something like you registered and。 I need the name of the function
    and this we've seen a few times we can pick out using the name。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们需要停止这个，注册的部分还有一点缺失。但并不多，所以我们说我们想做的是，对于每个函数，我们想在我们的字典中有一个条目。这意味着我想做一些像你注册的事情，我需要函数的名字，这一点我们见过几次，可以使用名称提取。
- en: attribute and what do I want this to point to I just wanted to do the function
    itself so I can just do。 something like this and let's see if this works better
    than so if we run again okay let's input。 the decorators are fun and now you can
    see that we actually got our list of parsers here。 true or false reversed and
    rubber language so let's try to choose the rubber language this time then。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 属性，我想让它指向什么？我只是想让它指向函数本身，所以我可以做一些像这样的事情。让我们看看这是否比之前更好，所以如果我们再运行一次，好的，输入。装饰器是有趣的，现在你可以看到我们实际上得到了解析器列表。真或假，reversed和rubber
    language，所以这次我们尝试选择rubber language。
- en: language and indeed it seems to work now we have， (speaking in foreign language)，
    and so this。 fairly simple decorator here and you can see it's a decorator because
    it accepts a function。 it returns a function in this case the same function and
    the only thing we've done is that。 we've created a list at runtime our dictionary
    at runtime over which functions that are。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 语言，确实现在看起来能正常工作，我们有了（讲外语），所以这是一个相对简单的装饰器，你可以看到它是一个装饰器，因为它接受一个函数。它返回一个函数，在这个案例中是同一个函数，我们唯一做的就是。我们在运行时创建了一个字典，记录了哪些函数。
- en: registered by this decorator and just to show you finally here if we do。 look
    at this interactively so let's just go through our false for this example。 yes
    is true show you also that it's now the registered dictionary that we hear started
    just。 as empty has been filled out by them with the different functions and this
    happens at the time。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个装饰器注册的内容，最后在这里展示一下，如果我们以交互的方式来看。是的，是真的，告诉你现在注册的字典是我们开始时的空字典，现在已经被不同的函数填充了，这在时间上发生。
- en: the function is defined so for instance we could just to show you we could read
    add another function。 this case so just add the old trusted world example we've
    been doing a few times。 something like this and now if I look in the understood。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 函数被定义了，例如我们可以给你展示，我们可以再添加一个函数。在这种情况下，添加我们已经做过几次的老信任的世界示例。类似于这样的事情，现在如果我查看已理解的内容。
- en: '![](img/13dc3ed458136a286215705708b44e8c_17.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_17.png)'
- en: or you can see that this has indeed been added here and we could now。 use that
    to parse text in a similar manner so that's at least one solution for task three。
    and just to kind of do a quick summary of what you have seen so far as we've seen
    a couple of。 decorators kind of following the this regular pattern where you define
    a decorator as a function。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这确实已经被添加在这里，我们现在可以使用它以类似的方式解析文本，所以这至少是任务三的一个解决方案。简要总结一下到目前为止你所看到的，我们看到了一些装饰器，遵循这种常规模式，其中你将装饰器定义为一个函数。
- en: that accepts a function as an argument it then defines an inner function that
    is used to wrap。 around that function and where you do something for this particular
    case the timer function。 we just start the timer but you do something before calling
    the function then you call the function。 and then you do something after calling
    the function and then finally inside of this。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个函数作为参数，然后定义一个内部函数，用于包装该函数，在这个特定情况下你要做一些事情，比如计时器函数。我们只需启动计时器，但在调用函数之前你要做一些事情，然后调用该函数。接着在调用函数之后再做一些事情，最后在这里结束。
- en: wrapper function you return the return value and then from the decorator itself
    you return that。 wrapper function and so we saw one example with the timer for
    doing this we saw another fairly。 similar example with the trace but how we could
    split out so we could do some of the。 things that are related to the function
    itself we can kind of do outside of the wrapper function。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在包装函数中，你返回返回值，然后从装饰器本身返回该包装函数。因此我们看到了一个使用计时器的例子，我们还看到了另一个相似的例子，即追踪，但我们可以将某些与函数本身相关的事情放在包装函数之外进行。
- en: while if you need to do any actions on the arguments you should do it inside
    of the wrapper。 function but otherwise this kind of has the same structure and
    then finally we saw this simpler。 register decorator that doesn't really change
    the function at all but just in this case registers。 the existence of the function
    so that's half half the task we're going to do in this course。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要对参数进行任何操作，应该在包装函数内部进行，但否则这个结构大体相同。最后我们看到了一个更简单的注册装饰器，它实际上并没有改变函数，只是注册了函数的存在，因此这是我们在本课程中要完成的一半任务。
- en: so this is a great time to just take a break your stretch your legs a little
    bit but then。 once you're back which will on the video will be just in a few seconds
    we will continue with a few。 more slightly advanced concepts so in this second
    part we'll talk a little bit about a few more。 advanced concepts for decorators
    the first one would be looking at decorators that can keep some sort。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是一个很好的时机休息一下，活动一下腿，但一旦你回来，视频将在几秒钟内继续，我们将继续讨论一些稍微高级的概念。因此，在这一部分中，我们将谈论一些关于装饰器的更高级的概念，第一个是查看能够保持某种状态的装饰器。
- en: of state so you can add some state to your functions essentially and somewhat
    related to keeping state。 is how would you go about and decorate classes so classes
    is one kind of language construct。 that's really good for keeping state so in
    this section we'll actually look a little bit on both。 using classes as decorators
    so so far we've kind of been saying that a decorator is a function。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 状态，所以你可以为你的函数添加一些状态，基本上与保持状态相关的是如何装饰类。类是一种非常适合保持状态的语言构造。在这一部分，我们将实际看一下将类用作装饰器的情况。到目前为止，我们一直在说装饰器是一个函数。
- en: it turns out it doesn't need to be a function it could for instance be a。 eopia
    class and there's actually in python 3。9 we'll briefly touch on this as well。
    there's some new developments to decorators where a decorator doesn't even need
    to be a function or。 class it's it might be some kind of expression so we'll briefly
    touch on that as well。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 结果发现，它不一定是一个函数，例如它可以是一个类。在Python 3.9中，我们也会简要提到这一点。关于装饰器的一些新发展是，装饰器甚至不需要是一个函数或类，它可能是一种表达式，所以我们也将简要提到这一点。
- en: and then so far we've been using just kind of decorators just something like
    timer but sometimes。 you want to have arguments to your decorators as well so
    we'll look at how we can add arguments。 to our the careers and then it turns out
    that there's also some use cases where you may want to use。 arguments or maybe
    not so we'll have some how can you actually get away with using optional arguments。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在使用像计时器这样的装饰器，但有时你也希望为你的装饰器添加参数。因此，我们将研究如何向我们的装饰器添加参数，结果表明，还有一些用例你可能希望使用参数，也可能不需要。因此我们将探讨如何实际上使用可选参数。
- en: in our decorators so this will be the the next coming tasks that we're kind
    of looking to。 so yeah we'll start working on task 4 in a second。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的装饰器中，这将是我们即将进行的下一项任务。因此，是的，我们将很快开始任务4。
- en: '![](img/13dc3ed458136a286215705708b44e8c_19.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_19.png)'
- en: so in this fourth task what we're going to do is look at decorators that can
    keep state。 and how they can kind of remember information over time and as a。
    kind of the example of this that we want you to implement is this decorator here
    called count calls。 and what it will just do is just count how many times a function
    has been called。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第四个任务中，我们要做的是查看可以保持状态的装饰器，以及它们如何能够随着时间的推移记住信息。我们希望你实现的一个例子是这个装饰器，称为 count
    calls。它的作用就是统计函数被调用了多少次。
- en: so so again this may not be the most useful thing but it could help you out
    in in sort of like debugging。 or profiling your your code and as an example of
    how it can work and I have here what this kind of。 the classical bad implementation
    of a Fibonacci calculator so just for brief background for those。 who are not
    familiar with Fibonacci numbers this is just a series of numbers that go something
    like。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这可能不是最有用的事情，但它可以帮助你进行调试或分析你的代码。作为它如何工作的一个示例，我这里有一个经典的 Fibonacci 计算器的不佳实现。因此，简单介绍一下，对于那些不熟悉
    Fibonacci 数字的人来说，这只是一个数字序列，大致是这样的。
- en: 1 2 3 5 8 13 and so on and what you can kind of notice here is if you look at
    one Fibonacci number。 it is always the sum of the two previous ones so 5 here
    is the sum of 2 plus 3 8 is the sum of 3。 plus 5 and so on and so one way to write
    this out just using say more like a math notation is。 saying something like fib
    n the nth Fibonacci number is just sum of fib n minus 1 so the previous Fibonacci。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2 3 5 8 13 依此类推，你可以注意到，如果你查看一个 Fibonacci 数字，它总是前两个数字的总和。所以这里的 5 是 2 加 3 的总和，8
    是 3 加 5 的总和，依此类推。以更像数学符号的方式写出来就是，fib n，第 n 个 Fibonacci 数字只是 fib n 减 1 的总和，因此前一个
    Fibonacci。
- en: number and fib n minus 2 the number before that again and implementing this
    in code kind of using。 exactly this notation that we have here we can implement
    this essentially as what's called a recursive。 function so you have here to calculate
    Fibonacci I would give a number we just sum up Fibonacci of。 the previous number
    number minus 1 and Fibonacci of number minus 2 and then one thing we need to。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 数字和 fib n 减 2，就是前一个数字。使用我们在这里的这种符号来实现它，我们实际上可以将其实现为一个递归函数。因此你在这里计算 Fibonacci，我给出一个数字，我们只是将
    Fibonacci 的前一个数字（数字减 1）和 Fibonacci 的（数字减 2）相加。然后我们需要做的一件事是。
- en: remember in a recursive function is that we need some kind of stop condition
    so in this case the。 numbers will always be smaller so for instance if we start
    with 3 here we will be looking at Fibonacci。 of 2 plus Fibonacci on 1 and so here
    we just stop whenever the number is less than 2 then。 we should return 1 so you
    kind of want this the first Fibonacci number。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在递归函数中需要记住的一点是，我们需要某种停止条件，因此在这种情况下，数字将始终更小。例如，如果我们从 3 开始，我们将查看 Fibonacci 的 2
    加上 Fibonacci 的 1，所以在这里只要数字小于 2，我们就停止，然后我们应该返回 1，所以你大致想要这个第一个 Fibonacci 数字。
- en: and yeah let's just run this and see then what happens so again I'll just use
    my ipython。 to run task 4 and I'll stop it in a directory mode and so we have
    here now。 and this is called the creator so one thing it does is that it adds
    an attribute to the function。 and so you can see here I'm able to say Fibonacci
    dotted number calls and so this is just a counter。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，让我们运行一下，看看会发生什么，因此我将使用我的 ipython 来运行任务 4，并在目录模式中停止它，所以现在我们有这个。这被称为创建者，所以它所做的一件事是为函数添加一个属性。因此你可以看到，我能够说
    Fibonacci 点数调用，这只是一个计数器。
- en: that counts how many times have this function been called and then we can do
    something like Fibonacci。 of say 1 and then I can ask again how many times has
    this been called and you can now see that okay。 if first of all we got the first
    Fibonacci number is indeed 1 and Fibonacci has been called one time now。 if I
    now call Fibonacci one more time you can now see that it remembers but it had
    called it once。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器统计这个函数被调用了多少次，然后我们可以做类似 Fibonacci 的调用，例如说 1，然后我可以再次询问这个函数被调用了多少次。现在你可以看到，如果首先我们得到的第一个
    Fibonacci 数字确实是 1，而 Fibonacci 被调用了一次。如果我现在再调用一次 Fibonacci，你现在可以看到它记住了，已经调用过一次。
- en: before and now we call it one more time so now we are called it twice and now
    I mentioned that this。 is a bad implementation of Fibonacci and just to demonstrate
    that let's for instance calculate the。 seventh Fibonacci number and that's kind
    of what you can see here as well and now how many calls。 would we need to calculate
    this and so if you now ask for the number of calls you can see that this。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们再调用一次，所以我们调用了两次，我提到这是一种糟糕的Fibonacci实现，仅仅为了证明这一点，让我们计算第七个Fibonacci数字，这就是你可以看到的，现在计算这个需要多少次调用，因此如果你询问调用次数，你会看到这个。
- en: so grown up for some reason this code spent 41 calls to Fibonacci to calculate
    this number。 and the reason for this is just that there is no say memory inside
    of here so that when we for。 instance did Fibonacci of 7 that calls Fibonacci
    of 6 plus Fibonacci of 5 but then the call to Fibonacci。 of 6 here also needs
    to call Fibonacci of 5 but it it calculates it all over again instead of using。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 不知何故，这段代码花费41次调用Fibonacci来计算这个数字，原因在于这里没有记忆。因此，当我们例如计算Fibonacci的7时，它会调用Fibonacci的6加Fibonacci的5，但这里对Fibonacci的6的调用也需要调用Fibonacci的5，它却重新计算，而不是使用之前的结果。
- en: the value that it has here so in this way this code ends up just doing a lot
    of。 work that it already has done so a good implementation of Fibonacci would
    use something like either a。 lookup table some caching or just a simple for loop
    where you kind of fill out an array as you move。 through or something like this
    but this implementation it's really nice to just illustrate something that。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的值以这种方式，代码最终只是做了很多已经完成的工作。因此，Fibonacci的良好实现会使用类似查找表、缓存或简单的循环，在移动时填充数组，或者类似的方法，但这个实现真的很适合说明一些内容。
- en: ends up spending a lot of number of calls so for this one kind of L2N3 so I'm
    here just to show that。 this is really bad so this 30 second Fibonacci number
    that should just take 30 something additions。 right but you can see here it actually
    takes some time to calculate and if I now look at the number。 of calls we can
    see that it spent over 7 million function calls to calculate this number and。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最终花费了很多调用次数，所以对于这个L2N3，我在这里只是想展示，这真的很糟糕，因此这个第30个Fibonacci数字应该只需要30次加法，但你可以看到这里实际上需要一些时间来计算，如果我现在查看调用次数，我们可以看到它花费了超过700万次函数调用来计算这个数字。
- en: okay so that's the Fibonacci code and now what the task is here as I said is
    to implement this。 count calls decorator and this is in some sense it's it's fairly
    straightforward building on what。 we've done before the new thing is that we have
    this Tottenham calls thing that we're using here。 for state and just to show you
    a little bit of how those work we can I'll just show you here something。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就是Fibonacci代码，而我的任务是实现这个计数调用装饰器，从某种意义上说，这非常简单，建立在我们之前所做的基础上。新东西是我们在这里使用的这个Tottenham调用，它用于状态，稍微展示一下它们是如何工作的。
- en: like an example of the hello world thing that we've seen but very implement
    a little bit of state。 so I'll give my third greet name equals world and of course
    we need to。 the clue in there and but now I want to assume that I have a list
    of seen names that I have added as a。 as a little greet so I'll say something
    like this and the greet。scene will be a list directly a set。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们看到的“你好，世界”的示例，但很少实现一些状态。所以我会给我的第三个问候，名字是世界，当然我们需要在那里加一些线索，但现在我想假设我有一个已经添加的已见名字列表作为一个小问候，所以我会说类似这样的内容，而问候的场景将是一个直接的集合。
- en: of the different names that I've already seen and then if I've already seen
    this name we can just。 print a different message so just something like seeing
    you before name and then if we haven't seen。 this before we'll just go back to
    our usual hello name。 And now for this to work probably we should。 also now just
    note that we have a seen name so I'll add this to our set and then something like
    this。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经看到的不同名字，如果我已经见过这个名字，我们可以打印不同的消息，所以类似“之前见过你”这样的内容，如果我们没有见过这个，我们就回到通常的“你好，名字”。为了使这个正常工作，我们也应该注意我们有一个已见名字，所以我会把它添加到我们的集合中，然后类似这样的内容。
- en: so now I mentioned that gray greets。scene I want this to be a set and the way
    to do this is actually。 just to define it so I can say greet。scene should be an
    empty set like this and now if I look at。 greet。scene it is an empty set I'll
    see if this actually works so if we now just run greet it says。 hello world as
    we expected to if I then call greet again it says seen you before world so now。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到的 gray greets 场景，我希望这成为一个集合，定义它的方法其实很简单。我可以说 greet.scene 应该是一个空集合，现在如果我查看
    greet.scene，它就是一个空集合。我来看看这是否真的有效，现在我们只需运行 greet，它会说 hello world，正如我们所期待的。如果我再调用
    greet，它会说 seen you before world。
- en: can actually use this greet。scene attribute that it's using here so we're keeping
    some state and。 to do this we could have used some kind of global variable but
    by putting it as an attribute on。 the function we kind of namespace it to where
    it belongs so this is something that's really。 interesting for this for this function
    so we've named space it to that by putting it as an attribute。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上可以使用这个 greet.scene 属性来保持某种状态。为此我们可以使用某种全局变量，但通过将其作为属性放在函数上，我们就将其命名空间化，归于它应该属于的地方。这对这个函数来说真的很有趣，我们通过将其作为属性放置来命名空间化。
- en: and for instance now if you instead greet icon we'll see the hello p icon and。
    p icon has entered the greet。scene set that we had so this was just an example
    to show you how you can。 add a num calls and an attribute to a function so what
    the task is as mentioned is implement。 the count calls to grader and so that it
    has a num calls attribute that counts the number of。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你现在打招呼图标，我们会看到 hello p 图标，而 p 图标已经进入了 greet 场景。这只是一个示例，向你展示如何为函数添加 num
    calls 属性并调用它。
- en: calls the function has been invoked good luck。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数已被调用，祝你好运。
- en: '![](img/13dc3ed458136a286215705708b44e8c_21.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_21.png)'
- en: okay so let's see how we can solve this so now again i've been flipped out my
    piking the creators。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们看看如何解决这个问题。我再次将我的 piking 创作者翻转了。
- en: '![](img/13dc3ed458136a286215705708b44e8c_23.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_23.png)'
- en: and i've added some tests here so now just see how it's advanced if we now run
    python path。 c04 we can see that i haven't implemented count calls yet。 so let's
    start by doing that so we have our decorators here i have the old ones we have。
    registered timer and trace and now we want to implement a count calls takes in
    a function and。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里添加了一些测试，现在看看它的进展。如果我们现在运行 python path c04，我们可以看到我还没有实现 count calls。那么我们开始实现它吧。我们有我们的装饰器，我有旧的，已经注册的计时器和跟踪器，现在我们想实现一个
    count calls，它接收一个函数。
- en: this one should do is essentially count the number of calls to function。 and
    for now i just let's see what do we know about this yeah let's implement the basics
    that。 we're used to so we'll add wraps like this i'll wrap so for this one we
    actually need。 some kind of wrapper function because we need to do something when
    the function is called。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的作用是计算函数调用的次数。现在我想看看我们对此了解了多少，是的，让我们实现我们习惯的基本内容，所以我们会像这样添加 wraps。我们实际上需要某种包装函数，因为我们需要在函数被调用时执行某些操作。
- en: so i'll just call this underscore count calls we have the arguments and keyword
    arguments that。 will pass on and then we're going to do something here well that
    is and then let's see what else。 yeah we want to return calls so this is kind
    of just a skeleton and then we'll implement this。 and a little bit but let's just
    check that this works well we don't have the num calls attribute。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我将其称为 _count_calls，我们有参数和关键字参数将会传递，然后我们会在这里做一些事情，接下来我们看看还有什么。对，我们想返回 calls，所以这只是一个框架，我们稍后会实现这个。但让我们先检查一下这是否有效，我们现在没有
    num calls 属性。
- en: right okay so let's start by just adding that one in so when we are just defining
    the function。 we want count calls to be initialized to be zero so in this case
    i'll just say okay what i want。 count calls to have and it calls zero so something
    like this so again you can just。 even a function you can just define an attribute
    on that function simply by assigning to it。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们先添加那个。当我们定义函数时，我们希望 count calls 初始化为零，所以在这种情况下，我会说我想让 count calls 为零，像这样。所以你可以简单地为这个函数定义一个属性。
- en: so if we do this now let's see if that one runs yes so now we have code running
    right。 and if we look here at the tests we had we're printing up num calls and
    then i tried to calculate。 seventh Fibonacci number for that when i got none so
    of course the code isn't doing what it should。 yet but at least it's it's running
    through okay so let's see what do we actually need to do inside。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我们现在这样做，让我们看看这个是否能运行，是的，所以现在我们有代码在运行。查看我们测试时，我们打印出调用次数，然后我尝试计算。那时我得到了无，因此当然代码没有按预期工作。还，但至少它通过了，所以让我们看看我们实际上需要在里面做什么。
- en: of our decorator well essentially every time we call the function we just want
    to increase or。 increment num calls so that can be done by input also and so say。
    equals equals this and then i want to add one to it so count calls and plus equals
    one。 and that should help us at least get some numbers in here so well let's try。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的装饰器中，基本上每次我们调用这个函数时，我们只想增加或。增加调用次数，所以这可以通过输入来完成，所以说。等于等于这个，然后我想给它加一，所以计数调用加等于一。这应该至少帮助我们在这里获得一些数字，所以好吧，让我们试试。
- en: okay yeah now we can see that something happens but we're still getting the。
    none from here and that's because well we're taking the function in here but we're
    not calling。 it right so now we need to actually call the function and since this
    time we're actually not。 need to do anything we're doing anything after we call
    the function so i'll just return。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，是的，现在我们可以看到发生了什么，但我们仍然得到这里的。无，因为好吧，我们在这里获取函数，但我们没有调用。对吧，所以现在我们需要实际调用这个函数，由于这次我们实际上不需要。做任何事情，我们在调用函数后不做任何事情，所以我将返回。
- en: function both way and bugs and like this so let's see if this one runs。 and
    now you can see okay we got zero calls let's see what these numbers mean。 zero
    calls before we do anything then the seventh Fibonacci number is 21。 an article
    claiming that we spent 41 calls to do it then the 32nd Fibonacci number is something。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 函数两方面和错误，就像这样，所以让我们看看这个是否能运行。现在你可以看到，好的，我们有零次调用，让我们看看这些数字意味着什么。在我们做任何事情之前，零次调用，然后第七个斐波那契数是21。一篇文章声称我们花了41次调用来做到这一点，然后第32个斐波那契数是某个东西。
- en: like three and a half million and in total we've now spent seven million function
    calls。 so that seems to work correctly so just a quick recap what we're doing
    here is that we have this。 wrapper function and mainly what it does is just call
    the function itself but we need to wrap here。 because every time we call the function
    we want to increment this camera so that's what we're doing。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 大约三百五十万，总共我们现在花费了七百万次函数调用。所以这似乎正确运行，所以快速回顾一下，我们在这里做的事情是我们有这个。包装函数，主要功能就是调用函数本身，但我们需要在这里包装。因为每次我们调用函数时，我们想增加这个计数器，这就是我们在做的事情。
- en: there so this is one way that you can keep state in your decorators。 and it
    works fairly nicely although you might be thinking well if i'm going to keep state。
    typically i want to use a class if you're if you're used to classes。 and using
    classes gives you much more flexibility and they're kind of built more for。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种你可以在装饰器中保持状态的方法。效果相当不错，尽管你可能会想，好吧，如果我要保持状态。通常我想使用一个类，如果你习惯于类。使用类会给你更多的灵活性，并且它们的构建更适合。
- en: we're doing this so let's see if we can actually implement the count calls decorator
    as a function。 oh sorry as a class so earlier i kind of said that a decorator
    is a function but it turns out that。 anything that you can kind of use to fulfill
    the pattern right so if you remember if we just。 add our color like this so we
    said here that doing something like count calls， of some function。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做，所以让我们看看是否可以实际实现计数调用装饰器作为一个函数。哦，对不起，作为一个类，所以早些时候我有点说装饰器是一个函数，但事实证明。你可以用来满足这个模式的任何东西，所以如果你记得，如果我们这样添加我们的颜色，所以我们在这里说，做一些像计数调用的事情，某个函数。
- en: setting that thing up is essentially the same as just defining your function。
    and then afterwards assigning things so the main thing like this so the stop thing
    is the same as。 defining the function independently and then decorating it manually
    afterwards。 so this syntax is just translated to this one and usually what you
    want to have here is a function。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 设置这个东西基本上和定义你的函数是一样的。然后在之后分配东西，所以主要的事情就像这样，停止的事情和。独立定义函数是一样的，然后手动装饰它。因此，这个语法只是翻译成这个，通常你想在这里有一个函数。
- en: but anything that kind of you can use that syntax for will more or less work。
    currently that's not completely true it will be more true in python 39 as we'll
    note a little bit。 later but it will work for anything that's callable so if you
    have a class and that class is callable。 you could do the same thing so what does
    it mean for a class to be callable。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 但任何可以使用这种语法的东西都或多或少可以工作。目前这并不完全正确，但在Python 3.9中会更准确一点，稍后我们会提到，但它对任何可调用的东西都有效。所以如果你有一个类并且这个类是可调用的，你可以做同样的事情。那么，一个类可调用意味着什么呢？
- en: well let's just look at a basic class here so i'm going to make an adder class。
    and this adder will just when instantiate it it will will essentially be a factory
    of sorts。 so when you instantiate it will take some number let's just score that
    number。 and then what we want to do is that we want this adder class well let's
    look at an example。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们看看一个基本的类，我将创建一个加法器类。这个加法器在实例化时，实际上会充当一种工厂。因此，当你实例化它时，它会接受一个数字，我们就将这个数字记录下来。然后我们想要做的是，让这个加法器类来看看一个例子。
- en: i want to be able to say something like adder three should be now essentially
    a callable that。 can add three to a number so if i do this i now want to be able
    to say something like add three to five。 and then want this thing to say eight
    here you can see i got the type error saying that the。 adder object is not callable
    so that's the concept we were talking about and the idea is that we want。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我想能够说类似于加法器三现在本质上是一个可调用的，可以将三加到一个数字上。所以如果我这样做，我现在希望能够说将三加到五上。然后希望这个东西输出八。你可以看到我得到了类型错误，说明加法器对象不可调用。这就是我们所讨论的概念，目的是我们想要。
- en: to make adder callable and then any cluster is callable we should be able to
    use also as a decorator。 this kind of a goal we're looking for here so how do
    you make a class callable。 it's actually by implementing one of the special methods
    called call or double underscore call。 double underscore under call and i'm going
    to say here now that when i call it i want to have some。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使加法器可调用，并且任何集群都是可调用的，我们应该能够作为装饰器使用。这是我们在寻找的目标，那么如何让一个类可调用呢？实际上是通过实现一个特殊的方法，称为`__call__`。
- en: other number and then the result of calling this adder instance will be that
    i return。 other number plus i or number plus so now by adding in the call method
    here we have made the。 adder object callable so now we can do and add three again
    create this adder object。 and if i now do add three of five let's see that's number
    three you can see that this turns out to be。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 其他数字，然后调用这个加法器实例的结果将是我返回其他数字加上我或数字加上。所以现在通过在这里添加调用方法，我们使加法器对象可调用。现在我们可以再次添加三，创建这个加法器对象。如果我现在对五加三，看看，这个数字三，你可以看到这变成了。
- en: eight surprisingly and if i add three to twelve i get fifteen and so on。 so
    defining this call method here has made our adder object callable so let's see
    if we can。 then do the same thing but plus that i want to call count calls。 and
    what this count calls to be is something i can use as a decorator so what does
    that mean well。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，如果我给十二加三，我会得到十五，依此类推。因此，在这里定义这个调用方法使我们的加法器对象变得可调用。那么让我们看看能否做同样的事情，但我还想计算调用次数。这个调用次数是我可以作为装饰器使用的。那么这意味着什么呢？
- en: we just saw that then we need to be able to define a call method so we're going
    to have。 call method here and as the the call method will now kind of replace
    our wrapped function up here。 so i'm just going to define something like this
    and then we'll figure out what we need to put。 into there then we're also saying
    that we want to have let's see for this to work as a decorator。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到，我们需要能够定义一个调用方法，所以我们将有一个调用方法，并且这个调用方法将替换我们上面的包装函数。所以我将定义一些内容，然后我们将弄清楚我们需要放入其中的内容。同时，我们也在说我们希望让这个作为装饰器来工作。
- en: i need to be able to essentially now say i want to say something like count
    calls。 out some function， and then i'm well it's not defined yet but that's fine。
    this should then translate into something like， the f equals count calls of f
    so that means that when i do this what i'm doing then is instantiating。 the class
    and so to get this to work we need to have the instantiation of the class to pick
    up the。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要能够本质上说我想说一些类似于计算调用次数的内容，输出某个函数，然后我……虽然还没有定义，但没关系。这应该翻译成类似于`f = count_calls(f)`，所以这意味着当我这样做时，我是在实例化这个类。因此，为了使这个工作，我们需要实例化这个类来获取。
- en: f the function that we're working with so that means that we need to have an
    init method。 here that takes in one parameter and that parameter will be a function。
    and seems like it's a good idea to store that function for later。 so something
    like this is kind of the basic structure of our count calls。
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在处理的函数，这意味着我们需要在这里有一个初始化方法，它接受一个参数，而这个参数将是一个函数。看起来将这个函数存储以备后用是个好主意。因此，像这样的结构就是我们
    count calls 的基本结构。
- en: later that should work the same as the as the， now it's defined using a class
    instead so let's see there's of course still some details missing。 here so we'll
    add in those shortly but i'm first just going to go here in the task。 and flip
    this over and use count calls so let's see now if i can restart my terminal。 on
    my ipython and this looks good now we can see that okay we're kind of back in
    the situation。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后这应该与现在定义的类一样工作，因此当然这里还有一些细节缺失。我们将很快添加这些，但我首先只是想在任务中转过来，使用 count calls。所以现在让我们看看能否重启我的终端。在我的
    IPython 上，这看起来不错，现在我们可以看到好的，我们又回到了这个情况。
- en: we were earlier when we were running this task let me just run it with a regular
    python here。 and see that we have no attribute name calls so let's start working
    on this one then so first of。 all we again want to have the attribute name calls
    and so since this is a class we just define。 calls now in a sense more naturally
    instead of adding it to a function like we do here。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前运行这个任务时，让我在这里用常规的 Python 再运行一次。我们看到没有属性名称调用，因此我们开始着手这个任务。首先，我们想要的属性名称调用，既然这是一个类，我们就更自然地定义调用，而不是像我们在这里那样将其添加到函数中。
- en: we just add it as a regular instance attributes in our init method。 so this
    should at least help us a little bit and now we can see that yeah we're back to
    the situation。 way so earlier where we have zero name calls and we get the non-returns
    when calling the function。 so this now in a sense the logistics of this works
    but we don't have。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将其作为常规实例属性添加到我们的初始化方法中。因此，这至少应该对我们有所帮助，现在我们可以看到，是的，我们回到了之前的情况。这样一来，我们的名称调用为零，并且在调用函数时我们得到了非返回值。因此，从某种意义上说，这个逻辑是可行的，但我们没有。
- en: the function kind of running properly yet i want to add one more test just to
    my。 quick little set here as well and let's just remember that we used the functor
    tools reps。 earlier and now to get for instance a good name and so on so just
    want to check that we are able。 to do the same thing also with the function yeah
    and we can see that there is something wrong。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 函数似乎还没有正常运行，我想再添加一个测试到我的小集合中。让我们记住之前使用过的函数工具 reps，现在为了得到一个好的名称等等，所以我想检查我们是否也能对这个函数做同样的事情，是的，我们可以看到有些地方出错了。
- en: there as well okay let's see then how should we continue working with this。
    well for to get rid of this one we want to do something with the functor tools
    and now it's not。 completely clear to me where should i put the reps right probably
    here we had it on the。 function that was kind of cold so maybe i should put it
    there or i should put it here。
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们应该如何继续进行呢？为了摆脱这个问题，我们想要做一些关于函数工具的事情，而现在我不太清楚我应该把 reps 放在哪里。也许我们在之前的函数中有它，所以也许我应该把它放在那里，或者我应该把它放在这里。
- en: but then i need to refer to the function which is only fine there and so on
    so it's it's hard to。 use the functor tools reps like we do it here and what we
    can do instead is to just use functor tools。 remember that the functor tools reps
    is it's really just using something called update wrapper in the。 background so
    we'll use that one instead and see that the functor tools update wrapper it takes。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 但我需要引用该函数，而这在此是可以的等等，因此使用函数工具的 reps 会很困难，就像我们在这里做的那样，而我们可以做的就是直接使用函数工具。请记住，函数工具的
    reps 实际上只是使用名为 update wrapper 的东西在后台运行，所以我们将使用这个，并查看函数工具的 update wrapper 它接受。
- en: both the wrapper and a wrapped and where it updates a wrapper function to look
    like the wrapped function。 and now what i want to wrap to make look like or what's
    the wrapper that's just the count class。 thing so i'll just write self there and
    then what i want to wrap is the functor oh what's this in place。 let's see how
    this runs and now we can see that it has gotten its name Fibonacci so we got that。
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器和被包装函数，以及它如何更新包装函数，使其看起来像被包装的函数。现在我想要包装的内容使其看起来，或者说包装的内容就是 count 类的内容。所以我会在这里写
    self，然后我想要包装的是函数，哦，这在这里是什么。让我们看看这个运行情况，现在我们可以看到它已经得到了名称 Fibonacci，所以我们得到了这个。
- en: one in place and we have the syracles but now we just need to work a little
    bit on call itself。 and let's see what did we need to do with call well each time
    we call we want to increase the。 number calls so i'll add one and then yeah let's
    just test it again make sure it works yes now we。 can see that we got the ones
    and views and then we want to uh call the function so in this case i。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们有syrcales，但现在我们只需要稍微处理一下调用本身。让我们看看我们需要对调用做什么，每次调用时我们想要增加调用的次数，所以我会加一，然后是的，我们再测试一下，确保它工作。是的，现在我们可以看到我们得到了计数和视图，然后我们想要调用函数，所以在这个情况下我。
- en: want to return itself so now we call the function that we have in this sort
    of here or and we're just。 gonna pass through the variables that we got in call
    so hargs and hargs so let's see then。 so now if we run now it's starting to look
    better so now we we got something that actually。 has decorated uh our Fibonacci
    function in a proper manner so let's look at these ones together。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我想返回自身，所以现在我们调用我们在这里的函数，或者我们只需传递我们在调用中得到的变量，所以是hargs和hargs。让我们看看，那么现在如果我们运行，它开始看起来更好了，所以现在我们得到了某种方式，实际上以适当的方式装饰了我们的斐波那契函数。让我们一起看看这些。
- en: and so what we see here is that the count call function decorator and the count
    calls。 class decorator they both work in the same way here and if we look at the
    code you can also see。 that it's it's very much the same so essentially all the
    code that we had here in count calls the。 wrapper function we now put into call
    so that's kind of what happens every time we call the。
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在这里看到的是，计数调用函数装饰器和计数调用类装饰器在这里都以相同的方式工作。如果我们看看代码，你也会看到它们实际上非常相似。所以基本上我们在计数调用中所有的代码，现在都放入了调用中。这就是每次我们调用时发生的事情。
- en: decorator function and then we had some of this other initialization function
    or methodology here。 and that stuff we put in the init of the class， okay then
    what one more thing related to decorators and classes and so let's now。 have a
    look at our let's see yes so let's let's go back to the trace decorator that we
    had here。 and I'll just import it like this and now say that I want to use this
    not to decorate a function。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器函数，然后我们在这里有一些其他的初始化函数或方法。我们将这些内容放在类的初始化中，好吧，还有与装饰器和类相关的另外一件事，所以现在让我们来看看。是的，让我们回到我们在这里的跟踪装饰器。我就这样导入它，现在说我想用它来装饰一个类，而不是装饰一个函数。
- en: but to decorate a class so we're kind of doing the opposite now so what you've
    seen。 with the count calls was how to use a class to decorate a function now we're
    going to see can we。 use a function to decorate a class so let's do something
    like just reusing the old trace。 and we have some kind of class it doesn't really
    matter too much for this example so just gonna make。
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们现在有点反过来了，你看到的关于计数调用的是如何使用一个类来装饰一个函数，现在我们要看看能否使用一个函数来装饰一个类。所以我们来做一些类似于重复使用旧的跟踪的东西。我们有某种类，对于这个例子来说，它其实并不是很重要，所以我就直接创建一个。
- en: a quickly trivial class that was really weird but I decorated it with trace
    and now I'm able to say。 thing equals thing like this and you can here see that
    the trace kicks in together so when I。 decorated the class here it means that
    when I essentially call the class which means kind of。 instantiates the class
    the trace thing starts working and I can then see that okay it's calling。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 快速创建了一个非常简单的类，它真的很奇怪，但我用跟踪装饰了它，现在我能够说。thing等于thing像这样，你可以在这里看到跟踪开始起作用。所以当我在这里装饰类时，这意味着当我基本上调用类（这意味着有点像实例化类）时，跟踪就开始工作，我可以看到它正在调用。
- en: thing and then it this thing returned an object which is now our thing now this
    seems to just work。 out of the box but one thing has kind of changed here it seems
    like this is a thing right but now。 if I want to pick I can say is instance little
    thing of the class thing and we'll get some weird。 error here saying that this
    instance argument too must be a type or a two pull of types so it seems。
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后这个东西返回了一个对象，这现在就是我们的东西。现在这似乎可以直接使用，但有一件事似乎发生了变化。看起来这是一个东西，对吧，但现在如果我想检查，我可以说这个小东西是否是类的实例，我们会得到一些奇怪的错误，说这个实例参数也必须是一个类型或类型的元组，所以看起来。
- en: like the thing here it's not the type anymore so let's have a look at see what
    it is oh thing has。 turned into a function and if we think about this a little
    bit we might be able to realize what。 has happened because how did we define thing
    well we use trace here around thing so that means that。 thing there it comes in
    takes the name fun inside of here even though it's a class but then it's kind。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 像这里的内容，它不再是类型了，那么我们来看看它是什么，哦，这个东西已经变成了一个函数。如果我们稍微思考一下，我们可能会意识到发生了什么，因为我们是如何定义这个东西的，我们在这个东西周围使用了
    trace，这意味着。
- en: of we create this inner function and then we return that inner function so that
    effectively replaces。 thing right there with this inner function so that means
    that this class。 even though the decorator might do its work the class has changed
    somewhat。 in many applications that doesn't really matter too much but there are
    definitely applications。
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建这个内部函数，然后返回这个内部函数，这样有效地替换了那里的内容，这意味着这个类。尽管装饰器可能完成了它的工作，但这个类在某种程度上已经改变。在许多应用中，这并不太重要，但确实有一些应用。
- en: where you want to keep you want to both be able to decorate your class and keep
    its type intact。 and so let's see how we can do that and first let me just point
    out also that one thing we could do。 would be to move the trace decorator down
    to the init method and just decorate the init method。 instead that wouldn't change
    the class here and we would kind of get the same effect of just showing。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在你希望既能装饰你的类又能保持其类型完整的情况下，让我们看看我们可以怎么做，首先让我指出一件事，我们可以做的就是将 trace 装饰器移到初始化方法中，仅仅装饰初始化方法。这样不会改变类，并且我们会得到展示的相同效果。
- en: the trace of the init but that's more of an artifact of this being a very simple
    example that。 there are definitely cases where you may want to decorate classes
    properly so let's look at the。 principle and essentially what we need to take
    care of here is that we need to create a decorator。 that just returns the same
    class so let's have a look at that so I'm just going to make a new。
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化的 trace，但这更多是由于这是一个非常简单的例子，确实存在一些情况，你可能想要正确地装饰类，所以让我们看看这个原则，基本上我们需要注意的是，我们需要创建一个装饰器，简单地返回相同的类，让我们看看这个，所以我只是想创建一个新的。
- en: decorator I'm calling it hello it will be a simplified version of trace and
    essentially what。 we want to do here is that we want to take in the class as our
    thing essentially and then we want to。 do something see what better later and
    then at the end of this doing something I still just want。 to return the class
    and just to point out that this now essentially does well it really does nothing。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我称这个装饰器为 hello，它将是 trace 的一个简化版本，基本上我们想要做的是将类作为我们的目标，然后我们想要做一些事情，看看以后更好，然后在做完这些事情后，我仍然只是想返回类，并指出这现在基本上确实什么也没做。
- en: just do the example quickly so the thing is thing and now let's see that。 thing
    is an actual instance of thing so this is kind of where we're what we want to
    happen。 but we want this to actually be something useful so that we for instance
    got this trace saying that。 this thing was instantiated okay so how can we do
    it let's have a look at our function here。
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速做个例子，所以这个东西就是东西，现在让我们看看这个东西是这个东西的实际实例。这是我们想要发生的地方，但我们希望这实际上是一些有用的东西，例如，我们得到了这个
    trace 说这个东西被实例化了，好的，我们该怎么做呢，让我们看看我们的函数。
- en: so the the important kind of principle that we need to adhere to here is that
    we return。 CLS at the end here so what can we actually play with then well what
    I want to do in this case I just。 want to print out a message whenever the class
    is instantiated so that in practice means that I。 just want to wrap the the init
    function of this particular class so there are it this will depend。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们需要坚持的一个重要原则是，在这里我们最终返回 CLS。那么我们实际上可以玩什么呢？我想做的就是每当类被实例化时打印出一条消息，这在实践中意味着我只想包装这个特定类的初始化函数，所以这将依赖于。
- en: very much on the decorator you're creating exactly what you want to do here
    it may be something that。 is similar to what we did here with count calls that
    you want to add some attributes it might be。 that you want to change around some
    return values it may be that you want to automatically define some。 special methods
    and things like this in this case we're just kind of wrapped init method。
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 很多关于装饰器的内容，你正好在这里创建你想要的东西，这可能类似于我们在这里做的计数调用，你想添加一些属性，可能是你想改变一些返回值，可能是你想自动定义一些特殊方法，类似这样的东西，在这种情况下，我们只是包装了
    init 方法。
- en: so one way to do that would be to then create hello init wrapper。 and kind of
    as usual this wrapper function will just take in lots loads of arguments and。
    group and and let's see what did I want to do first I just want to say that an
    instance。 of the in now we have a class， that name here was created。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 所以做这件事的一种方法是创建 hello init 包装器，像往常一样，这个包装函数将接受大量参数并进行分组。那么我首先想说的是，实例现在我们有一个类，这里的名称被创建。
- en: and let's see let's spend a little bit more space on this I know and so that's
    my print and then I。 essentially want to now turn my CLS init all the args and
    quarts。 so now I'm kind of just wrapping the init but how do I now actually。 make
    sure that this init thing is wrapped properly well what I usually do write this
    just to return。
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在这上面花点更多的空间，我知道这是我的打印，然后我基本上想要将我的 CLS init 转换为所有参数和关键字参数。所以现在我只是包装 init，但我现在如何确保这个
    init 正确包装呢？我通常会这样写，以便返回。
- en: now we need to return class so what I instead is saying something like class
    init。 is hello init let's see it should not be a call but that one it's an equal
    sign there。 so what we're doing here is that I'm just replacing class init with
    my new wrapper function。 and now one more thing we need to be a little bit careful
    with here is that I'm replacing it but。
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要返回类，所以我所说的类似 class init 是 hello init。让我们看看这不应该是一个调用，而是等号。所以我们在这里做的事情就是用我的新包装函数替换
    class init。还有一件事，我们需要小心的是，我替换它，但是。
- en: then I'm calling it again and this will actually create an infinite loop。 where
    I'm just calling well myself so it turns into something recursive without an。
    in condition so we need to actually store also a reference to the old or original
    init。 so let's just say something like original init that is the class init and
    then here what we're。
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我再次调用它，这实际上会创建一个无限循环，我只是在调用自己，所以它变成了递归，没有结束条件，所以我们需要存储对旧的或原始 init 的引用。我们就说原始
    init 是类的 init，然后这里我们要做的。
- en: actually calling is the original init method okay so let's see if this thing
    actually can work。 so now I just created this trivial think class we're decorating
    it with hello which is this thing。 and if I now say that thing it's a thing you
    can see that hello does its work and。 tells us that the instance of thing was
    created so that comes from up here。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上调用的是原始 init 方法，好吧，所以让我们看看这个东西是否真的能工作。现在我刚创建了这个简单的类，我们用 hello 装饰它，这个东西。如果我现在说这个东西，你可以看到
    hello 进行了它的工作，并告诉我们实例的东西被创建了，这来自上面。
- en: so it seems like the hello thing works and have we now managed to actually preserve
    the type as well。 so let's see is instance thing oh thing we have and so so this
    is just one example of。 how you could potentially work if you need to decorate
    classes probably the most。 say famous decorator that's used for decorating classes
    is the new data class decorator that was。
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 所以似乎 hello 的功能是有效的，我们现在是否成功地保留了类型？所以让我们看看这个实例的东西哦，东西我们有，这只是一个例子。你如何可能工作，如果你需要装饰类，可能最著名的装饰器就是新的数据类装饰器。
- en: introduced in python 3 7 okay so this has been a bit of a teacher in a sense
    from from the task。 that we had at hand but remember what we did here we implemented
    a count calls decorator。 so that we could keep state and we implemented both using
    function properties or attributes and。 as a class and then we also took a small
    leader into looking into how we can decorate classes。
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.7 中引入的，好的，所以这在某种意义上是一个教学内容，来自我们手头的任务。但请记住我们在这里做了什么，我们实现了一个计数调用装饰器，以便我们可以保持状态，我们实现了函数属性或属性，以及类，然后我们也小小探讨了一下如何装饰类。
- en: then we're now ready for our fifth task so let's see what that turns out to
    be。 okay so now we are ready for our fifth task and actually before we start with
    the task itself。 i'm just going to do a short demonstration and the topic that
    we're going to talk about now is how。 can we create decorators that can take arguments
    and what we're going to use this for is that we'll。
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为我们的第五个任务准备好了，所以让我们看看结果是什么。好的，现在我们准备好第五个任务，实际上在我们开始任务本身之前，我要做一个简短的演示，现在我们要讨论的主题是如何创建可以接受参数的装饰器，我们将用这个来做什么。
- en: create decorator called use units where we can specify that a given function。
    returns values with the given unit so， doing this we can then actually in a safe
    way calculate with numbers in different units and kind。 of have them work out
    nicely what i'm going to do now first before we actually look at the details of。
    the task i'm just going to show you a few examples of how to calculate with these
    units。
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个叫做使用单位的装饰器，我们可以指定一个给定函数返回具有给定单位的值。通过这样做，我们可以安全地计算不同单位的数字，并能够很好地处理它们。现在，我要做的第一件事是在我们实际查看任务细节之前，给你展示一些如何用这些单位进行计算的例子。
- en: and this will both give you some ideas about kind of the unit part of this but
    it will also。 build towards how can we create a decorators with arguments so let's
    just start with this。 fairly straightforward decorator where i'm just going to
    say that they'll have a function or。 a decorator called meters per second it will
    take in a function as usual and what i'm going to do here。
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给你一些关于这个单位部分的想法，同时也为我们如何创建带参数的装饰器铺路。所以让我们从这个相对简单的装饰器开始，我将说它们会有一个函数或一个叫做米每秒的装饰器，它将像往常一样接受一个函数，然后我将在这里做。
- en: is now i just add an attribute to the function which is just a string saying
    meters per second。 this and then i'll return the function so you can see that
    this in structure it reminds us a little。 bit called this register decorator that
    we did earlier where we had where rejects took in a function。 and put essentially
    a reference to that function into a dictionary and then we return the function。
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在只是给函数添加一个属性，这只是一个字符串，表示米每秒。然后我将返回这个函数，所以你可以看到在结构上，它让我们想起之前做的注册装饰器，那个装饰器接受一个函数，并基本上将对那个函数的引用放入字典中，然后我们返回这个函数。
- en: itself so now again we're returning the same function but we're just adding
    an attribute on the。 function instead of registering it somewhere else and now
    this will not really be super helpful。 but let's have a look at how it works so
    if i have the decorator meters per second。 and now i'm just going to define a
    fairly straightforward function again that's called。
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们再次返回相同的函数，但我们只是给这个函数添加一个属性，而不是在别处注册它。现在这并不是特别有用，但让我们看看它是如何工作的，所以如果我有米每秒的装饰器，现在我将定义一个相对简单的函数，叫做。
- en: every bit and it just takes in a duration and yeah let's do the distance first
    to make it even。 easier for us a distance and a duration this， there we go and
    then it returns the average speed so if we are given a distance and removing that。
    distance over a given duration then the average speed is the distance divided
    by that duration。 and now the idea behind the meters per second decorator is just
    mainly just a reminder to ourselves。
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个部分，它只是接受一个持续时间，是的，让我们先处理距离，这样对我们来说会更简单。一个距离和一个持续时间，这就可以了，然后它返回平均速度。因此，如果我们给定一个距离，并在给定的持续时间内去除这个距离，那么平均速度就是距离除以那个持续时间。现在，米每秒装饰器背后的想法主要是一个提醒。
- en: that this average speed will be calculated as meters per second of course this
    will actually。 depend on the units of your incoming variables typically you want
    them to have a distance in。 meters and the duration in seconds so this it's not
    really very helpful this is mainly it's a small。 say one thing you can do here
    is just say average speed of unit and you can kind of。
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个平均速度将以米每秒计算，当然这实际上将取决于你输入变量的单位。通常你希望它们的距离以米为单位，持续时间以秒为单位，所以这并不是非常有用。这主要是小的说法，你可以在这里说平均速度的单位，基本上是这样的。
- en: be okay this should be in meters per second and just to see a quick calculation
    let's have a look at。 how fast was in bulk running when he set the 100 meter record
    at that time he ran 100 meters。 and 98 seconds so this was during the world championships
    in 2009 and i can see here that。 his average speed or those 100 meters was 10。4
    meters per second as we can then see right here。
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是每秒米，快速计算一下，让我们看看博尔特在创下100米纪录时的速度有多快。他在98秒内跑完100米，所以这是在2009年世界锦标赛期间，我可以看到他那100米的平均速度是每秒10.4米，就像我们现在看到的。
- en: okay so that's just some mainly using a decorator for bookkeeping maybe not
    that helpful。 but let's see how we can actually build this out a little bit to
    work with units themselves。 and to do this i'm going to use a very cool library
    that's called the pint and。 your first year is just a pip install pint so the
    library itself。
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这主要是使用装饰器来做记账，也许不是很有帮助。但让我们看看如何实际构建这一点来处理单位本身。为此，我将使用一个非常酷的库，叫做pint，你的第一步就是通过pip安装pint，因此库本身。
- en: and i already have this library installed so you can see it's already satisfied
    but if you。 doesn't don't have it you should install it for yourselves。 and let's
    just have a quick look at how pint works so you import it import pint and then
    pint。 has something called the unit registry and unit registry as you can see
    here is just something that。
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经安装了这个库，所以你可以看到它已经满足要求，但如果你没有的话，应该为自己安装它。让我们快速看看pint是如何工作的，你导入它`import pint`，然后pint有一个叫做单位注册表的东西，你可以在这里看到它只是一些。
- en: stores definitions and relationships between units so this will be sort of like
    a global。 thing that you need to access to get to get the units so when you start
    using pint you want。 initialize it by just making an instance of the unit registry。
    and then what you can do with the unit registry is that you can then just add
    strings or call it。
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 存储单位之间的定义和关系，这将像是一个全球性的东西，你需要访问才能获取单位。因此，当你开始使用pint时，你想通过仅仅创建一个单位注册表的实例来初始化它。然后你可以对单位注册表做的是，你可以添加字符串或调用它。
- en: with a string like this meters per second and you can see here that it then
    gives us a unit。 like this and these units are able to calculate so we could for
    instance now say okay two meters。 per second then we have two meters per second
    but then I can also multiply this with something like。 say three seconds if I
    do this now I'm talking okay if I move at a speed of two meters per second。
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像这样的字符串，每秒米，你可以在这里看到它给了我们一个单位。像这样，这些单位能够计算，所以我们现在可以说，好的，每秒两米，那么我们有每秒两米，但我也可以把这个乘以像三秒的东西。如果我这样做，现在我说，好的，如果我以每秒两米的速度移动。
- en: for three seconds how far can I move that and we can see here then let's okay
    that's six meters。 so it's able to essentially just multiply two times three and
    it's able to multiply meters per。 second times seconds and figure out that that's
    meters but we can also do other units so let's try。 for instance to say oh by
    the way we weren't measuring the speed in meters per second we were。
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 三秒我能移动多远，我们可以在这里看到，好的，六米。因此，它能够本质上只是将两乘以三，并能够将每秒米乘以秒，得出这是米，但我们也可以做其他单位，所以让我们尝试。例如，顺便提一下，我们并不是在用每秒米来测量速度，我们在。
- en: measuring it in miles per hour for instance and then if we move for two miles
    per hour for three。 seconds how far do we move and now pint has also calculated
    well this might not be that。 satisfactory but it's calculated okay in this case
    we calculated or removed six miles seconds per hour。 that may not be that helpful
    how much is a miles second per hour that's not the distance I know。
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以每小时英里为单位进行测量，然后如果我们移动两英里每小时，持续三秒，我们移动了多远，现在pint也计算了，这可能不是很令人满意，但它计算了，在这种情况下，我们计算得出每小时移动了六英里。这可能不是很有帮助，每小时六英里是多少？这不是我知道的距离。
- en: but actually we can have pint simplified as far as using something we call two
    base units。 and this we can get out the result it will kind of simplify everything
    down to。 the base units and we can see that okay we move 2。7 meters more or less
    or we could also just specify。
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，我们可以将pint简化为使用我们称之为基本单位的东西。这样我们可以得出结果，它会将所有内容简化到基本单位，我们可以看到，好的，我们大约移动了2.7米，或者我们也可以指定。
- en: here what do we actually want to see this and so maybe we want to。 okay so that's
    just the basics of pint so let's now combine our decorator with pint and see how。
    that works so let's go back to our meters per second decorator and what we need
    to do here now。 is that I want to have this one return not the not just a function
    itself but I wanted to。
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们实际上想看到这个，所以也许我们想要。好的，这只是pint的基础，现在让我们将装饰器与pint结合起来，看看它是如何工作的。让我们回到我们的米每秒装饰器，现在我们需要做的是，我希望这个返回的不仅仅是函数本身，而是我想要。
- en: actually multiply in the unit into the return value of the function so the first
    thing we need。 to do right was to have the unit registry so I want to find unit
    registry and I want to instantiate it。 and now we could do what we did earlier
    just have a global variable that kind of points to the。 unit registry but to kind
    of keep our namespace and clean I'll add this one。
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上将单位乘入函数的返回值中。所以我们首先需要做的是拥有单位注册表，我想找到单位注册表并实例化它。现在我们可以做我们之前做的，只是拥有一个全局变量来指向单位注册表，但为了保持我们的命名空间干净，我会添加这个。
- en: kind of global unit registry just on the decorator here itself。 and then yeah
    we can just keep the unit here and let's now。 instead of saying unit there I'll
    just say that the unit this time is， I'm yours。 and I'm sorry I will just keep
    it like this and then I'm gonna now we want to have the。
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一种全局单位注册表，就在装饰器本身上。然后，是的，我们可以在这里保持单位，现在而不是说单位在那儿，我会说这次单位是，我的。抱歉，我会保持这样，然后我现在想要有。
- en: so then I'll do my inverse per second underscore and this one takes in arcs
    and quarks as usual。 and this and now I return the function called with the arcs
    and quarks and I multiply this。 meters per second year eggs of the unit registry
    of the unit。 and let's see then now we do not return the function itself but we're
    returning the rapid function。
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我会做我的逆每秒下划线，这个与通常的弧和夸克一起接受。现在我返回用弧和夸克调用的函数，并且我将这个米每秒的单位乘以单位注册表的单位。让我们看看，现在我们不返回函数本身，而是返回快速函数。
- en: so now you can see this looks more like they are critical decorators where we
    have a rapid function。 that we return back here okay and now let's just apply
    this one on the first function that we had。 earlier and let's see what happens
    so now earlier we calculated the average speed。 and now we're going to do a little
    bit more interesting stuff on this I'm just going to save this as。
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到这看起来更像是我们有一个快速函数的关键装饰器，我们在这里返回。好的，现在让我们将这个应用到我们之前的第一个函数上，看看会发生什么。所以早些时候我们计算了平均速度，现在我们将做一些更有趣的事情，我将把这个保存为。
- en: variable bolts like this and first of all we can now just look at this violation
    bolt and we can。 see that it's still 10。4 and now we have the unit right here
    right so we can start playing with it。 so first of all just to show we could say
    well what would happen if bolt ran twice as fast well in。 that case he would run
    for second for instance but maybe more interesting to get the hold of how。
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的可变螺栓，首先我们可以看看这个违规螺栓，看到它仍然是10.4，现在我们有单位在这里，所以我们可以开始玩这个。首先，假设我们说如果螺栓的速度是原来的两倍会发生什么，那么在这种情况下，它将持续运行一秒钟，但更有趣的是了解如何。
- en: fast did he actually run we can see here that we can convert this to kilometers
    per hour。 oh 3738 kilometers per hour that's recently fast or we could also do。
    a minute hour something like this and that will give us a number and it's also
    possible to。 pick out so if you now need to store this back as just a regular
    float number if you do。
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 他实际上跑得快吗？我们可以在这里看到我们可以将其转换为公里每小时。哦，3738公里每小时，最近很快，或者我们也可以做。每分钟小时，类似这样的事情，这将给我们一个数字，并且也可以。提取出来，如果你现在需要将其存储为一个普通的浮动数字，如果你这样做。
- en: it and that will kind of give you a little， okay so now we have defined ourselves
    a decorator that can add in the unit meters per second。 and now let's say that
    we have another function and that is not returning speed it's returning a。 distance
    in that case we can't really decorate it with meters per second we need a new
    decorator。 that has a distance unit and so then we just create meters decorator
    and we kind of go through。
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这样会给你一点，好的，所以现在我们定义了一个可以添加米每秒单位的装饰器。现在假设我们有另一个函数，它不返回速度，而是返回一个距离，在这种情况下，我们不能真正用米每秒来装饰它，我们需要一个新的装饰器，具有距离单位，所以我们创建米装饰器，并且我们逐步进行。
- en: the same motions and we can see that that's not really working out too well
    for us so what we really。 want to do here is to create ourselves a decorator but
    it we want to be able to use it。 let's see so if you look at this one I want to
    be able to write something like use unit and then send。 in the unit as a as an
    argument to the decorator that this way I can use the same decorator but。
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 但同样的动作，我们可以看到这并没有为我们提供太好的效果，所以我们真正想要做的是创建一个装饰器，但我们希望能够使用它。让我们看看，所以如果你看看这个，我希望能够写一些类似use
    unit的东西，然后将单位作为参数传递给装饰器，这样我就可以使用相同的装饰器。
- en: for many different types of units and essentially creating that decorator is
    our task number five。 so how can we create a decorator that will be able to be
    used in this way and give us something。 reasonable and let's see here this works
    so let's just。 see this unit has not been defined but I haven't done the exercise
    but to have a look at our。
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多不同类型的单位，创建这个装饰器是我们的第五个任务。那么，我们如何能创建一个能够以这种方式使用并给我们一些合理结果的装饰器呢？让我们看看这是否可行，所以让我们来看看。这单位尚未定义，但我还没有做练习，只是看看我们的。
- en: our file I can see here now that we have we're importing something called use
    unit。 and in this case the task here will be actually， comparing the speed of
    a runner and of a plane so just to show you how this can end up working。 let's
    run this task file and now I can， as before I can find a bolt but now he's a runner
    that can run 100 meters in 9。58 seconds， and then plane I'll pretend now that
    there's a plane that flies from the bird。
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的文件中，我现在可以看到我们导入了一些叫做use unit的东西。在这种情况下，这个任务实际上是比较跑步者和飞机的速度。所以为了向你展示这如何能运作，让我们运行这个任务文件。现在我可以像之前一样找到博尔特，但现在他是一个能在9.58秒内跑完100米的跑者，而飞机我假装是一架从鸟那里起飞的飞机。
- en: there are no direct routes but if there were that plane would be flying something
    like 6，261。 kilometers more or less in 9 hours so you can see here now I define
    two different things that can。 move and now if you have a look over here in the
    task we see that the class runner takes in the。 distance and duration and can
    calculate average speed in meters per second while the plane。
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有直接的航线，但如果有的话，那架飞机大约在9小时内飞行6261公里，所以你可以看到，我现在定义了两个不同的东西，它们可以移动。现在如果你看看任务，我们看到类Runner输入了距离和时间，并可以计算每秒米的平均速度，而飞机。
- en: also takes in distance and duration but calculates its average speed in kilometers
    per hour。 so that means that now if I ask both for what's your average speed，
    I can see that that is 10。4 meters per second as we have seen before and I can
    ask my plane。 what's your average speed and it will be something like 696 almost
    700 kilometers per hour。
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 同时还需要输入距离和时间，但计算其平均速度为每小时公里数。这意味着如果我问博尔特你的平均速度是多少，我可以看到这是10.4米每秒，正如我们之前所看到的，我可以问我的飞机，你的平均速度是多少，它会是大约696，几乎700公里每小时。
- en: and now something possibly interesting would then would be to see how many times
    faster。 I assume the plane is faster how many times faster is the plane then you
    say in bolt when it's running。 so to do that we can take this and divide by both
    average speed and I'll get a better ratio in this。 case and if you look now at
    the ratio it seems like the plane is something like 66。6 kilometers。
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能有趣的是看看飞机到底快多少倍。我假设飞机更快，那么飞机到底比博尔特快多少倍呢？所以为了做到这一点，我们可以将这个速度除以博尔特的平均速度，我将在这种情况下得到一个更好的比率。如果你现在看看这个比率，似乎飞机的速度是66.6公里。
- en: seconds per hour meters faster than bolt again we get this completely crazy
    unit that doesn't really。 tell as much so let's try to see by looking at the base
    units。 and now we can see we've done something correctly because we end up with
    something that's dimensionless。 and now it's easy to see that the plane is just
    a little bit actually less than 20 times faster than。
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 秒每小时、米比博尔特快，我们又得到了这个完全疯狂的单位，它并没有提供太多信息。所以让我们试着通过查看基本单位来解决这个问题。现在我们可以看到我们做对了一些事情，因为我们得到了一个无量纲的结果。现在很容易看出，飞机的速度实际上比博尔特快一点点，少于20倍。
- en: bolt so I guess that means that bolt it feels like it's fairly faster。 okay
    so this is kind of the calculation that we one end up being able to do at the
    end of this task。 so how do you actually create this use unit decorator。 so let's
    have a look and the idea as we briefly said was that we want to be able to do
    something。
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我想这意味着博尔特感觉上相对更快。好的，这就是我们最终能够在这个任务结束时进行的计算。那么，如何实际创建这个使用单位的装饰器呢？让我们看看，正如我们简要提到的那样，我们希望能够做一些事情。
- en: something like this it's kind of the idea here and if you remember so essentially
    when when trying。 to figure out how a decorator work it's always useful to go
    back to what what does the notation。 mean what does this thing appear mean and
    remember this would be something similar to if we first。 define our average speed
    so I'm not going to write it out but just okay so we have defined it。
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这里的核心思想，如果你记得的话，基本上在试图理解装饰器是如何工作的时，回顾一下符号的含义总是很有帮助。这个符号出现的意义是什么，请记住，这会类似于如果我们先定义我们的平均速度。虽然我不打算写出来，但我们已经定义了。
- en: and then we decorate it by saying something like okay average speed is the same
    as and then we look。 at what is this here because it's the same as doing that
    and apply it to average。 let's move this over a little bit so you can see and
    and then let's see if we now stare at this for a。 while you can see that calling
    use unit with meters per second there that part should return。
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过说类似于“平均速度是相同的”来装饰它，然后我们看看这里是什么，因为这与这样做是相同的，并应用于平均速度。我们把这个稍微移过来一点，这样你就能看到。然后让我们看看，如果我们现在盯着这个看一段时间，你会看到调用
    `use unit` 与“米每秒”结合，这部分应该返回。
- en: a decorator so the use unit will actually not be a decorator itself it will
    be a decorator factory。 it will be something that can create decorators for us
    so it will be a different decorator depending。 on the unit and so what that actually
    means is that you'll end up with something like。 deaf use unit this thing should
    just take in a unit and then inside of here you're going to do。
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个装饰器，`use unit` 实际上并不是一个装饰器本身，而是一个装饰器工厂。它将会是一个可以为我们创建装饰器的东西，因此它会是一个根据单位不同而不同的装饰器。实际上，这意味着你将会得到类似于
    `def use unit` 的东西，这个东西应该只接收一个单位，然后在这里你要做一些事情。
- en: something and then essentially you want to hear define some kind of decorator
    that you will then。 return from use unit so that they call use unit meters per
    second is a decorator so that's what。 we need to return from use unit and then
    that decorator will be a function that can take a function。 here and then wrap
    that function again so what we're doing here is kind of adding one more layer。
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然后基本上，你想在这里定义某种装饰器，你将从 `use unit` 返回这个装饰器。所以它叫 `use unit meters per second`
    是一个装饰器，这就是我们需要从 `use unit` 返回的内容。然后这个装饰器将是一个可以接收一个函数的函数，然后再次包装这个函数。因此我们在这里所做的其实是添加了一个层。
- en: of inner functions to what we already have been doing okay so then that's the
    task can we make it。 run on the run run clean code here and i'm just gonna say
    good luck with that and then i'll be back。
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 内部函数的用途，我们已经在做的事情。好吧，那么这个任务就是我们能否让它在干净的代码上运行。我会说祝你好运，然后我会回来。
- en: '![](img/13dc3ed458136a286215705708b44e8c_25.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_25.png)'
- en: shortly with with one solution for it， okay i hope you enjoyed that task so
    now let's see how can we make the use unit decorator。
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，这里有一个解决方案，我希望你喜欢这个任务。那么现在我们来看看如何使用 `use unit` 装饰器。
- en: '![](img/13dc3ed458136a286215705708b44e8c_27.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_27.png)'
- en: and so that you can take in arguments and as before i've gone in here now and
    just added a。 the test case to to our file here so that we can see where we're
    at just by running running this。 task with python and first of all let's just
    see here that now we cannot even import use unit from。 the decorators so we need
    to start off just by defining it and let's see then so if i now go to。
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你就可以传入参数，和之前一样，我现在已经在这里添加了一个测试用例到我们的文件中，这样我们可以通过运行这个任务来查看我们目前的进展。首先，让我们看看现在我们甚至无法从装饰器中导入
    `use unit`。所以我们需要先定义它，然后我们再来看。
- en: my python decorators i'm just here all the way at the bottom and i'm gonna define。
    use unit decorator and in this case let's see this was now as we mentioned this
    will be a decorator。 not really a decorator itself it will be a decorator factory
    something that will return。 the craters and so does that really mean it means
    that for this one。
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 Python 装饰器就在这里，最底部，我将定义 `use unit` 装饰器。在这种情况下，正如我们提到的，这将是一个装饰器，实际上并不是真正的装饰器，而是一个装饰器工厂，返回装饰器的东西。那么这实际上意味着什么呢？这意味着对于这个。
- en: let's first actually just say here that this decorator will register， or add
    units to return values。 what i'm gonna do here is that i'm gonna define the use
    unit decorator that will be the thing that i。 want to return and since this is
    a decorator it will take in a function and then it will。 return some function
    i'm just gonna return the same function。
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们先说这个装饰器将注册，或将单位添加到返回值。我要做的是定义一个使用单位的装饰器，这将是我。想要返回的东西，由于这是一个装饰器，它会接受一个函数，然后它将。返回一些函数，我只是会返回相同的函数。
- en: and my decorator factory and then needs to return for the crater so if we do
    something like this。 now we have created a i guess trivial decorator factory so
    whatever the value of unit here i just。 return decorator that does nothing it
    just returns the function itself but this kind of just to check。 the logistics
    of what we're doing so for now call our task we can see that it starts running。
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我的装饰器工厂需要为创造者返回值，所以如果我们做这样的事情。现在我们创建了一个我想是微不足道的装饰器工厂，所以无论这里单位的值是什么，我只是。返回一个什么都不做的装饰器，它只会返回函数本身，但这只是为了检查。我们正在做的后勤工作，所以现在调用我们的任务，我们可以看到它开始运行。
- en: it's able now to calculate the average speed of our both it's able to calculate
    the average speed of our。 plane but you can see there's no units here and then
    we get an error when we start to actually use。 the units here by calling to base
    units but this is promising we are kind of getting somewhere。 so now we want to
    actually build up our decorator factory so the first thing i'm gonna do now is
    like。
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在能够计算我们两个的平均速度，它能够计算我们。飞机的平均速度，但你可以看到这里没有单位，然后当我们开始实际使用。这里的单位时会出现错误，但这很有希望，我们在某种程度上正在取得进展。所以现在我们想要实际建立我们的装饰器工厂，所以我现在要做的第一件事是。
- en: we did earlier i need to instantiate this unit registry and i'm just gonna store
    it on my。 function as an attribute so here we're gonna do unit registry and now
    we can see that。 my flake 8 is hopefully pointing out that i haven't defined a
    point so let's just run up here and。 and then we are linter happy and so now we
    have the unit registry so that means that we should be。
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 像之前一样，我需要实例化这个单位注册表，我只是要把它存储在我的。函数作为一个属性，所以在这里我们将做单位注册表，现在我们可以看到。我的`flake8`希望指出我没有定义一个点，所以让我们在这里运行一下。然后我们很高兴我们的代码风格检查工具正常工作，所以现在我们有了单位注册表，这意味着我们应该。
- en: able to start returning some functions here or adding in some units i guess
    so now we should kind。 of focus on this part because on the outside we now have
    a decorator factory but so far we've。 just been thinking about decorators so the
    factory is kind of just something that is partly just messing。 with our heads
    so now we want to write this the way we usually write decorators kind of forget
    about。
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 能够开始在这里返回一些函数或者添加一些单位，我想现在我们应该有点。专注于这部分，因为在外部我们现在有一个装饰器工厂，但到目前为止我们只是在思考装饰器。所以工厂有点像是部分干扰了我们的思维，所以现在我们想要以我们通常写装饰器的方式来写这个，稍微忘掉它。
- en: what's on the outside and so how do we write our decorators well we define an。
    a wrapper function so the wrapper function i'll just call use units with。 for
    as usual and remember that these things usually then take in the harks and quarks
    of the function。 that we can just pass through and at some point here we're gonna
    return the function of harks。
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 外部的内容，那么我们如何编写我们的装饰器呢？我们定义一个。包装函数，我将这个包装函数称为使用单位，像往常一样。并记住，这些东西通常会接受函数的参数和夸克。我们可以直接传递过去，并且在某个时候我们将返回参数的函数。
- en: and quarks and so that's more or less what we're doing there but then the decorator
    itself should。 now return this rapid function so here we want to return use unit
    like this and now we should also。 remember to apply the fun tools wraps of and
    so now we have something that's at least some kind of。 the crater it corrects
    something that we can see now i'm still not doing what i promised i would be。
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 夸克，所以我们大致上就是在做这个，但是装饰器本身应该。现在返回这个快速函数，所以在这里我们想要返回使用单位，像这样，现在我们还应该。记得应用`functools.wraps`，所以现在我们有了一些至少是某种的。创造者，它修正了一些我们现在能看到的东西，我仍然没有做到我承诺的事情。
- en: doing which was actually multiplied by units so let's fix that part as well
    and so that means that。 i need to take the unit unit registry and the unit from
    it。 oh like this and let's see yeah so we can try to run this and see now it seems
    to actually work out。 right we have our 10。4 we now got the label that is a meter
    per second we have this almost 700。
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实际上是乘以单位，所以让我们修复那部分。因此，这意味着我需要获取单位注册表中的单位。哦，就这样。让我们看看，是的，我们可以尝试运行这个，看看现在似乎确实能正常工作。我们有我们的10.4，现在得到了每秒米的标签，几乎700。
- en: kilometers an hour and now we see the ratio it's actually 18。5 in dimensional
    units and one thing i'll， kind of just throw in here at the end it was not really
    part of the task but remember we had this。 reminder that we could put on the function
    and so if i want to do this as well i could now say use unit。 but unit so now
    i'm equals unit so now i'm just adding the reminder on the function that。
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 千米每小时，现在我们看到的比率实际上是18.5，以维度单位表示。最后，我要补充一点，这并不是真正任务的一部分，但请记住，我们可以在函数上添加这个提示。因此，如果我也想这样做，我现在可以说使用单位。但单位，所以现在我的单位等于单位，这样我就在函数上添加了提示。
- en: reader is returning that this what's the unit of this this is really not necessary
    since we're。 actually getting it out with you it's here the other way but let's
    just have a quick look at how that works。 and so this means now that i should
    be able to for instance say let's see we have gold。 it's a runner and his average
    speed function and unit is not there。
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 读者正在返回这个单位，这实际上不是必需的，因为我们正通过这个方法获取它。让我们快速看看它是如何工作的。因此，这意味着我现在应该能够说，比如我们有金牌运动员，他的平均速度函数和单位并不存在。
- en: i we forgot to save them let's see sorry about that let's do this one more time。
    now both average speed unit is meters per second and so just to remind you once
    more time that we can。 come out in this unit the tricky part here is probably
    more of just keeping track of。 at which level do we actually need to do this thing
    so so now we have just to repeat this we have here。
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忘记保存了，抱歉，让我们再来一次。现在，平均速度单位是米每秒。再次提醒一下，我们可以以这个单位输出。这里棘手的部分可能更多的是跟踪我们实际上需要在哪个层次上做这件事情。因此，现在我们只需重复一下，我们在这里。
- en: we have the the wrapper function the one that actually replaces the the average
    speed method。 when we do the decorator right here we have the decorator itself
    that is the thing that actually。 decorates but then to use arguments we also have
    this factory that kind of takes care of。 creating a different decorator for each
    argument that he created okay so now we're ready for our。
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个包装函数，它实际上替代了平均速度方法。当我们在这里做装饰器时，我们有装饰器本身，这就是实际进行装饰的东西，但为了使用参数，我们还需要这个工厂，它负责为每个创建的参数创建不同的装饰器。好吧，现在我们为我们的任务准备好了。
- en: last task in this tutorial and what we're going to do here is to kind of put
    together what we've。 learned so far and you can see here in this task we have
    a decorator called super trace which is。 really just the trace decorator more
    or less but it has some superpowers and what super trace can do。 is that we can
    call it both as a regular decorator like you see here and we can call it as a
    decorator。
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的最后一个任务，我们要做的是将到目前为止学到的内容汇总在一起。在这个任务中，我们有一个名为**super trace**的装饰器，它实际上就是普通的trace装饰器，但拥有一些超能力。**super
    trace**能做的事情是我们可以像这里看到的那样，将它作为一个常规装饰器调用，同时也可以作为一个装饰器使用。
- en: with arguments like you see down there and what that allows us is both to kind
    of give something。 that's super easy to use to the user but also give some flexibility
    so for instance in this case。 the idea is that you can specify a logger to kind
    of change how the tracing is logged so。 as usual i'll start out by just trying
    out this thing。
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数就像你在下面看到的那样，这让我们可以向用户提供非常简单易用的功能，同时也提供一些灵活性。因此，在这种情况下，想法是你可以指定一个记录器，以改变跟踪日志的记录方式。因此，像往常一样，我将先尝试这个功能。
- en: so first of all let's just try to call the greet function so we build a low
    world and here you can。 see the output that you're used to from from the old trace
    right so super trace without any arguments。 works exactly like the old trace but
    what happens if we call random greet。 so random greet you can now see that it
    also works similar to what we're used to but。
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们尝试调用greet函数，因此我们构建了一个“低世界”，你可以看到你所熟悉的旧trace的输出。因此，super trace在没有任何参数的情况下，工作方式与旧trace完全相同。但是，如果我们调用random
    greet呢？现在你可以看到它也类似于我们所熟悉的方式，但。
- en: note here that there's some warning output there and you can kind of see how
    the calling random greet here。 has gotten the warning prefix and that comes from
    the logging。warning method so instead of actually。 being printed to the screen
    here it's being logged by the logging。warning method so super trace。 can both
    work as a decorator as you see there and as what we saw last time was we're decorator。
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里有一些警告输出，你可以看到调用随机问候的地方得到了警告前缀，这来自于日志记录的警告方法，因此实际上并没有打印到屏幕上，而是通过日志记录的警告方法进行了记录，所以超级跟踪可以作为装饰器工作，正如你所看到的，以及我们上次看到的，我们是装饰器。
- en: factories so essentially your task for task number six will be how can you implement
    this。 and again i'm just going to give a few small hints if you want to work completely
    without hints。 just take a break now but one little hint that i'm kind of going
    to give and it's it's kind of hint。 that you have i guess heard a few times now
    and let's let's try to look at what what does the notation。
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂，所以基本上，你第六个任务的任务是你如何实现这一点，我再给几个小提示，如果你想完全没有提示地工作，那就现在休息一下，但我将给出的一个小提示，你可能听过几次，现在让我们试着看看这个表示法。
- en: here really mean right so we have now both something that we can write as super
    trace。 or we can write it with the with the arguments and if we remember what
    that means is that we have some。 we have some function but we want to create and
    that really means that。 either we're doing super trace， of like this or we're
    doing f equals super trace of logar equals let's do logging。
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这里真正的意思是什么，所以我们现在有一些可以作为超级跟踪编写的内容，或者我们可以带有参数进行编写，如果我们记住这意味着我们有一个函数，但我们想创建，这实际上意味着我们要么在做超级跟踪，要么在做f等于超级跟踪的日志记录。
- en: warning， of us and we need this super trace function to be able to handle both
    of these cases。 and the trick there to kind of get you started is that it is in
    general it will be hard to be able。 to support the creators with taking positional
    arguments so let me just drill that way now。 right now so we will not be able
    to do this that will not work as expected so i'm going to say that。
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 警告，我们需要这个超级跟踪函数来处理这两种情况。要开始的诀窍是，通常很难支持使用位置参数的创建者，所以让我现在深入讲讲这一点。现在我们无法做到这一点，这将不会按预期工作，所以我会说。
- en: we want to only use keyword arguments here and the reason is just that we need
    to somehow recognize。 that the argument we're getting is a function that we're
    going to decorate so in the easiest way to。 do that is just to say okay the first
    positional argument if that's a function then we're gonna。 um work with this but
    you can see here that if we would do this without the logger then logging。
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在这里仅使用关键字参数，原因是我们需要以某种方式识别我们获取的参数是一个我们要装饰的函数，因此最简单的方法就是，如果第一个位置参数是一个函数，那么我们将与此进行处理，但你可以看到，如果没有记录器，这样做将会遗漏那个函数。
- en: warning would be a callable it will be a function and it would be very hard
    to differentiate this。 so we're gonna put this limitation on that we're gonna
    use a。 the keyword arguments and that kind of gives you then some starting point
    so that means that first。 of all okay it should be able to take in a function
    as their argument as usual it should also be able。
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 警告将是一个可调用的，它将是一个函数，并且很难区分这一点，所以我们将对此施加限制，我们将使用关键字参数，这样给你一个起点，这意味着首先，它应该能够像往常一样接受一个函数作为参数，它也应该能够。
- en: to leave out that function right so what we're doing here relieving that function
    out so let's see。 what that actually means then um so that means that when you
    define your super trace that's both。 a clear and a decorative factory and the
    signature of this will be something like okay it could take a。 function or it
    could take a logger right but either of these has to be optional so we need to
    specify。
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在这里做的是排除那个函数，让我们看看这实际上意味着什么，所以这意味着当你定义超级跟踪时，它既是一个清晰的又是一个装饰工厂，这个签名大概是这样的：它可以接受一个函数或一个记录器，但这两者必须是可选的，所以我们需要指定。
- en: some default values for them for the sense to just say that if we're not giving
    a function we'll just。 use none to say that and then i'm just also just gonna
    force or use the star here just means that。 everything after this meets the keyword
    arguments it's not really necessary to put it in here but。 it's kind of nice to
    just point it out that everything coming behind here we should regard as keyword。
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些默认值的设置，意思是如果我们不提供一个函数，我们就用`none`来表示，然后我还会强制使用星号，这意味着后面的所有内容都被视为关键字参数。将它放在这里并不是绝对必要的，但指出这一点还是挺好的。
- en: arguments and since we want super trace to work also with just the function
    we need logger here to be。 optional as well so this should then take a also have
    an optional value and the value of this would be。 what do we use for logging in
    the default case so i'm just gonna say that our default print is the。 logger so
    this will be the signature of your decorator slash decorator function and now
    what you need to。
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望super trace能够正常工作，因此logger这里也需要是可选的。这应该也接受一个可选值，这个值就是在默认情况下我们用来记录的内容。所以我将说我们的默认打印是logger。这将是你的装饰器/装饰器函数的签名，现在你需要做的就是。
- en: do is to essentially have this one behave either like a decorator or a decorator
    factory depending on。 the value of funk whether funk is none if funk is none then
    this will be a decorator factory and。 it should create different decorators based
    on the logger here if funk is actually a function then。 we're already at the decorate
    stage so then this should just work as a decorator and return a wrapped。
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是让这个函数根据funk的值表现得像一个装饰器或装饰器工厂。如果funk是none，那么这将是一个装饰器工厂，并且应该基于logger创建不同的装饰器。如果funk实际上是一个函数，那么我们就已经处于装饰阶段，所以这应该作为一个装饰器正常工作，并返回一个封装。
- en: function so that's a hint that hopefully is enough to get you started and then
    i'll just say good luck。 on this last task and then i'll see you in a minute with
    a suggestion for a solution。
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是一个提示，希望能帮助你入门，然后我会祝你在最后的任务中好运，稍后再见面，给你一个解决方案的建议。
- en: '![](img/13dc3ed458136a286215705708b44e8c_29.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_29.png)'
- en: okay i hope you enjoyed that little task so now let's see how we can solve this
    uh super trace。
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我希望你喜欢这个小任务。那么现在我们来看一下如何解决这个super trace。
- en: '![](img/13dc3ed458136a286215705708b44e8c_31.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_31.png)'
- en: the decorator and um what i've gone ahead and done here i'm more or less as
    usual is that i've。 added a few just just cases down here uh some both printing
    out the greet printing along line and。 then the random greet and i'll see if we
    can get the super greeter to work so remember we want this to。 use print um here
    uh super trace sorry and the logging thing for the random great function。
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器方面，我在这里所做的和往常一样，我添加了一些打印输出的用例，包括打印问候语、打印一行内容，然后是随机问候。我将看看是否能让super greeter正常工作。请记住，我们希望这里使用打印，super
    trace，对随机问候函数进行记录。
- en: and um now let's just start out by testing this this thing uh work and see now
    that it's okay i can't。 import super trace because i haven't defined it yet so
    let's start by doing that and um now one。 one thing i'm gonna do here since as
    i mentioned this the super trace is basically just uh the trace。 the crater so
    i'm gonna use my copy paste powers uh to include trace one more time here but
    then。
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始测试这个东西，看看它是否正常。我无法导入super trace，因为我还没有定义它，所以我们先来做这个。就像我提到的，super trace基本上就是trace的创建者。所以我将使用我的复制粘贴功能，再包含一次trace。
- en: we also so have we want to use the super trace decorator or the creator factory
    will have the。 following signature so it will either take a function which will
    be known if the function is not given。 or it will take a logger which has the
    default value of print so the default value is print。 and otherwise will use uh
    whatever is given and then we have the actual trace down here and i'm just。
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想使用super trace装饰器，或者说创建工厂将具有以下签名。它将接受一个函数，如果没有提供函数则会被识别，或者接受一个logger，默认值为print。因此默认值是print，其他情况下将使用提供的任何内容，然后我们在这里有实际的trace，我只是。
- en: gonna indent it so now this trace is just i mean let's define internally in
    um inside of here and。 also just to kind of be consistent with the notation that
    we're usually using i'll call this the super trace。 uh greater so let me give
    track of what's what and then this kind of inner。 the wrap function i'll rename
    this one as well to be underscore super trace。
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要缩进，所以这个跟踪器是我在这里内部定义的，并且为了与我们通常使用的符号保持一致，我会称之为super trace。让我跟踪一下这些是什么，然后将这个内部的包装函数也重命名为_超跟踪。
- en: and let's see that was actually the wrong one， let's see down here we have our
    super trace decorator and here we have our。 super trace and let's see what else
    do we need to change now well we have now。 this logger will be an option so let
    me change the function as we have here。 using whatever is the value of logger
    so by default this will still be print but we may be able to change。
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看，这实际上是错误的，让我们看看这里有我们的super trace装饰器，这里是我们的super trace，我们还需要改变什么呢？好吧，现在这个logger将是一个可选项，所以让我像我们这里这样更改函数，使用logger的值，所以默认情况下这仍然是print，但我们可能能够更改。
- en: it okay so that's essentially just what we need to do to reuse trace and so
    now comes the。 i guess the tricky part of the of the of this task of this exercise
    and that is how what do we。 need to do now to have super trace out here work both
    as a decorator and as a decorator factory。 and i'm just for now i'm just going
    to hide the code for the decorator down there。
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以本质上我们需要做的就是重用跟踪装饰器，现在的难点在于，怎样才能让super trace在这里既作为一个装饰器，又作为一个装饰器工厂。现在我就暂时隐藏下面装饰器的代码。
- en: to be able to focus on the logic here so what i have now is that i have defined
    my。 decorator as kind of usual this is kind of the usual trace decorator and i
    somehow now want to use this。 for my for my arguments so you can remember when
    we just had the regular arguments if this had just。 been something like this what
    we need to do here would just be to return。
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够专注于这里的逻辑，所以我现在的定义是将我的装饰器定义为一种常见的，这是一种常见的跟踪装饰器，而我现在想用它来处理我的参数。你可以记得当我们只有常规参数时，如果这仅仅是这样的情况，我们需要做的就是返回。
- en: super trace decorator like this then we would have。 something that works fine
    as as a decorator that takes arguments the problem with this is that it。 doesn't
    allow us to not give arguments we need to have the parentheses essentially。 since
    this is an optional argument we would be allowed to use， let's see here something
    like， like。
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样定义super trace装饰器，那么它就可以作为一个接受参数的装饰器正常工作，问题在于这不允许我们不传递参数。我们需要有括号，基本上这是一个可选参数，我们允许使用，看看这里，像这样的。
- en: i we're calling things there but so we haven't implemented everything yet but。
    if we are if we would have this kind of definition we would be allowed to use
    super trace。 like this with an empty empty braces there because that would just
    mean that we use the regular。 the regular， okay let's run this you can see that
    this this will actually work。
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里调用了一些东西，但我们还没有实现所有内容。如果我们有这样的定义，我们可以这样使用super trace，带着空的括号，因为这意味着我们使用常规的，好的，让我们运行这个，你会看到这实际上是可行的。
- en: and what what happens here is that since we're not giving any arguments there
    it's just using。 the default value of logger being print and then we could add
    in the。 here kind of say that logger should be logging dot warning like this and
    then。 or hello will work the warning and so this this is what we kind of saw in
    the last exercise where we。
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是，由于我们没有传递任何参数，它只是使用了logger的默认值print，然后我们可以在这里添加，类似于logger应该记录警告，然后或hello将记录警告，因此这就是我们在上一个练习中看到的。
- en: use arguments but what as you might have seen from some other。 output we had
    what we will not be allowed to do is just use it without the arguments here。 this
    will now throw an error at us and and the reason of course is that without the。
    braces there what actually happens is that the funk hello here is passed into。
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数，但正如你可能从其他输出中看到的，我们不允许的就是在这里不传递参数。这样会抛出一个错误，原因当然是没有括号，实际上发生的是funk hello在这里被传递进来。
- en: the super trace factory as the new logger and then it's somehow using this as
    a。 logger and everything gets quite confusing so that's not what we want to happen。
    so let's see we had here funk equals now and then a star。 and now what we have
    seen essentially now is that if funk is none。
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 超级追踪工厂作为新的记录器，然后以某种方式使用它作为记录器，这一切变得相当混乱，这不是我们想要的。因此，我们这里有funk现在是一个星号。我们看到的基本上是如果funk是无。
- en: what does that actually mean well it means that there was no function that was
    passed in。 instead we were given a logger argument or possibly even let's see
    where did we have it。 up here or possibly even this case but in either way there
    was no function that was passed in。 so that is actually the case that we have
    already solved so let's just like this。
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上意味着什么？这意味着没有函数被传入。相反，我们给出了一个记录器参数，或者可能看看我们在哪里有它。在这种情况下，没有函数被传入。这实际上是我们已经解决的情况，所以我们就这样做。
- en: so we could do this and now if we just restart this。 we heard some error message
    from calling greet and just to taking out of this we'll now see that。 this super
    trace， in this this will still work while as we saw from the output above if we
    do it without any parentheses。 I'm calling we're now getting this weird non-type
    object is not callable and that is because hello。
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以这样做，现在如果我们重启这个，我们从调用问候中听到了一些错误消息。将其取出后，我们现在看到这个超级追踪器仍然有效，而如上面输出所示，如果我们不使用任何括号，我调用的东西现在变成了奇怪的无类型对象不可调用，这就是问候。
- en: there is no hello it seems if I actually print out hello you can see that this
    is none。 and that is because we ran into here super trace is none if function
    is none we do this。 but then we just fall off the end here so then if function
    is not none which happens in this case。 then we haven't defined what happens so
    hello was actually just replaced by none in this case。
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我打印出问候，似乎没有任何输出，你可以看到这是无。因为我们进入了这里，如果函数是无，我们就这样做。但是如果函数不是无，在这种情况下，我们并没有定义发生了什么，所以问候实际上在这个情况下被替换成了无。
- en: that's clearly not good enough so instead what do we need to do well now what
    we really would love。 to happen is to just go back to the old trace decorator
    right that's kind of what we。 that's the behavior we're interested in here and
    what was the old trace decorator well that was。 the one that we have copied over
    here the super trace decorator that I call it now and。
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然不够好。那么我们真正想要的是什么呢？就是回到旧的追踪器装饰器，这就是我们感兴趣的行为。那么旧的追踪器装饰器是什么呢？那就是我们在这里复制过来的那个超级追踪器装饰器。
- en: what happened really there so it seems like again I want to take this thing
    but now I want to kind。 of skip a step I want to just apply this directly to my
    function and for this to behave like for。 for this super trace here to behave
    like it's a it's a decorator this one needs to just define。 or return the wrapped
    function and that is actually exactly what super decorator does。
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么呢？我想再次处理这个问题，但现在我想跳过一步，直接将其应用到我的函数上，使得这个超级追踪器像一个装饰器一样工作，这需要定义或返回被包装的函数，这正是超级装饰器所做的。
- en: if I send it funk right so that's funk into the super trace decorator it will。
    okay let's just open up everything here here again um so super trace decorator
    it starts up there。 and it goes down here so if I send in super trace decorator
    and I send funk to it it will return me。 super trace which is this wrapping function
    so this thing right here will actually help us out。
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将funk传入超级追踪器装饰器，它会……好的，让我们打开所有内容。超级追踪器装饰器从上面开始，然后向下走。所以如果我发送超级追踪器装饰器并传递funk，它会返回我超级追踪，这个包装函数将帮助我们。
- en: and and take that necessary step that we're looking at and first let's actually
    run this to see if。 that theory works so we'll just run over here and now you
    can see。 let's just make it be enough and that if I run now the greet thing actually
    works so let's recall。 what happens here and we print out greet world and that
    is just super trace without any arguments。
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先运行一下，看看这个理论是否成立。我们现在运行，看到结果。如果我现在运行，问候函数实际上是有效的，所以让我们回顾一下，这里打印出问候世界，这只是超级追踪器没有任何参数。
- en: so that part works and our random greet where you super trace with the logging
    that also works so now。 the the things the the magical if else thing we we made
    here actually works and just to have。 one more explanation on why this thing works
    and let's。 and recall again I kind of repeat this so this is kind of the mantra
    that I hope you。
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 所以那部分有效，我们的随机问候和超级追踪的日志记录也有效，现在这些神奇的**if-else**结构确实有效，并且有一个额外的解释，说明这个东西为什么有效，让我们再回忆一下，我有点重复，这就是我希望你能记住的咒语。
- en: you realize is kind of the key takeaway here is that to figure out how these
    decorators work。 it's always useful to kind of unwrap temptation and see what
    actually happens here。 so say that we have some function I'll just call it f again
    and that we apply super trace to it。 so if I do like super trace of f this is
    really the same as。
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你意识到这里的关键要点是，弄清楚这些装饰器如何工作总是很有用的，解开一些复杂的概念，看看这里实际发生了什么。假设我们有一个函数，我再称它为`f`，并且我们对其应用超级追踪。因此，如果我像这样使用超级追踪的`f`，这实际上是相同的。
- en: '![](img/13dc3ed458136a286215705708b44e8c_33.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_33.png)'
- en: if we instead just define f and then we say that f equals super trace of f right。
    and what are we now done over here is that okay if we do this then we're passing
    in f there so f。 becomes a funk over here so funk is not none so that means that
    what we're doing is saying that f。 equals underscore super trace creator of fun
    quote of。
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们直接定义`f`，然后说`f`等于超级追踪的`f`，那么我们现在所做的是，如果这样做，那么我们就将`f`传入，所以`f`在这里变成了一个函数。因此，函数不是空的，这意味着我们在说`f`等于下划线超级追踪创建的函数。
- en: so this is what happens in the case where we have。 we're passing in without
    any arguments or without any parentheses。 what happens in the case where we use
    arguments so say that we're doing super trace parentheses。 equals logging that
    warning， and then of this function so now if we spell this out well what we're
    doing now is that we're doing f。
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当我们没有任何参数或没有括号传入时发生的情况。当我们使用参数时，会发生什么情况？假设我们正在做超级追踪的括号等于记录警告，并且此函数的内容。那么如果我们详细描述一下，现在我们在做`f`。
- en: equals super trace of logger equals logging that warning of f。 right this is
    kind of the translation of of this notation now what does that mean if we start
    looking。 into here well in that case there is no funk that's defined right here
    right。 now so that means that funk take its default value which is none so we're
    in this case。
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 等于超级追踪的日志记录器等于记录警告`f`。对吧，这就是这种符号的翻译。那么这意味着什么呢？如果我们开始观察这里，实际上这里没有定义函数。因此，这意味着函数取默认值，即空值。所以在这种情况下。
- en: and in that case super trace is just essentially replaced by super trace decorator。
    so then we will end up with the notation f equals underscore super trace。 decorator
    and that's just all of this has been replaced by super trace decorator。 and then
    we have the parentheses f at the end so taking this function object that we're。
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，超级追踪本质上被超级追踪装饰器替代。因此，我们最终得到的符号是`f`等于下划线超级追踪装饰器，而这一切都被超级追踪装饰器所替代。然后我们在最后有括号`f`，这样就取到了我们正在处理的这个函数对象。
- en: returning here and applying it to f and as you can see now is that in both cases
    super trace。 and super trace with this thing happening we end up at the exact
    same place where f has been decorated。 by super trace decorator so that's exactly
    what we wanted right that's what we were aiming for。 the only difference between
    these two cases is that the value of the logger has changed。
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里返回并应用到`f`，如你所见，在这两种情况下，超级追踪和超级追踪都在发生，我们最终到达了完全相同的地方，`f`被超级追踪装饰器装饰，这正是我们想要的，对吧，这就是我们的目标。这两种情况下唯一的区别是日志记录器的值发生了变化。
- en: so in the second case we are changing the value of logger and that logger is
    used inside of our trace。 wrapper function to say how we are printing out the
    trace so this is definitely a mouthful but。 if you wrap your head around this
    you really should know enough to understand。 essentially any decorator that you
    can find in the python language so hopefully this has been。
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们正在改变日志记录器的值，这个日志记录器在我们的追踪包装函数内部使用，以说明我们是如何打印追踪的。这确实很复杂，但如果你理解这个，你应该足够了解，基本上可以理解Python语言中任何装饰器。因此，希望这对你有所帮助。
- en: something that you have enjoyed and have learned something from now that actually。
    around the exercises that we're going to do so now i'm just gonna end with the
    small。 kind of recap of what we have been learning so first of all in this advanced
    decorators section。 what you we were talking about was first a little bit about
    how to keep state with decorators。
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该享受并从中学习到一些东西，现在实际上围绕着我们要做的练习，所以我就以一个小总结结束我们所学的内容。首先，在这个高级装饰器部分，我们讨论的是如何通过装饰器保持状态的一些内容。
- en: and we saw how we can either use function attributes to remember things from。
    invocation to invocation or classes which are probably better fitted for this。
    then we saw a little bit on how do we decorate classes and especially how can
    we make sure that。 we keep the type information because usually when you're decorating
    something you're。
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用函数属性来记住从一次调用到下一次调用的内容，或者使用类，这通常可能更适合。然后我们看了一点如何装饰类，尤其是如何确保我们保留类型信息，因为通常在装饰某样东西时。
- en: replacing the original function or class with your wrapper function but if you
    need to kind of。 keep the type hierarchy that's not really possible you need to
    do some other tricks instead。 then for our what was the fifth task we saw how
    we could use decorators with arguments。 this was the exercise where we added units
    to our methods or functions and then now in the final。
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 用你的包装函数替换原始函数或类，但如果你需要保持类型层次结构，这实际上是不可能的，你需要做一些其他的技巧。而对于我们之前提到的第五个任务，我们看到了如何使用带参数的装饰器。这是一个练习，我们向方法或函数添加了单位，现在在最后的部分。
- en: task we looked at how we can have optional arguments where we can call the decorator
    both。 without the parentheses and with the parentheses just to kind of。 one more
    time repeat the key takeaways and is that in general a decorator is any function
    that。 accepts a function and returns a function what we have kind of seen here
    is that this is the。
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是看到了如何使用可选参数，我们可以同时以不带括号和带括号的方式调用装饰器，再次重申一下关键要点，通常装饰器是任何接受函数并返回函数的函数。我们在这里看到的是，这就是。
- en: concept is actually more general than this decorators really any callable thing
    that accepts a callable。 and returns a callable I guess and so it could be classes
    for instance。 and then the one thing that I hope that you definitely take from
    this is just that this kind。 of syntax that we're using for decorators is really
    just syntactic sugar for writing this thing out。
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念实际上比这更为普遍，装饰器实际上是任何接受可调用对象并返回可调用对象的东西。我想，这也可以是类实例。然后我希望你一定能从中记住的一件事是，我们用于装饰器的这种语法实际上只是写出这个内容的语法糖。
- en: and once it's more noted I'll just kind of point out to say we had if we go
    back here。
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更详细的内容被记录下来，我会指出，如果我们回到这里。
- en: '![](img/13dc3ed458136a286215705708b44e8c_35.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_35.png)'
- en: so let's see if we first I'll just do from our Python decorators I'll import
    the count calls。 now say that I want to for instance yeah we're not gonna do too
    much about this but say that for。 instance we have a math factorial function for
    instance here we'll get some numbers and。 we could for instance say that you can
    approximate the value of e。
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从我们的 Python 装饰器中导入计数调用。现在假设我想，比如说，我们不会对此做太多，但假设我们有一个数学阶乘函数，这里我们将得到一些数字，我们可以说你可以逼近
    e 的值。
- en: do something like this by taking the sum of the inverse of factorial numbers。
    so just to show you here first， so we can take math factorial of let's see zero
    that's one one still one two is two。 so this doesn't seem too interesting with
    three we get six so the factorial number is actually。 what you get if you just
    multiply all the numbers less than or equal to the number itself so three。
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 做一些像这样通过求和阶乘数的倒数。首先给你展示一下，我们可以计算数学阶乘，零的阶乘是1，一的阶乘还是1，二的阶乘是2。所以这看起来并没有太大意思，三的阶乘是6，因此阶乘数实际上就是将小于或等于该数字的所有数字相乘的结果，所以三的阶乘。
- en: factorial is six because one times two times three is six then four factorial
    will be 24 for instance。 that's four times two times three times four and now
    there is a mathematical formula that says。 that the number e which is approximately
    seven eighteen which also I guess happens to be the last。 version of a python
    d and can be calculated using these factorial numbers so if I take the sum。
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘是六，因为1乘以2乘以3等于六，四的阶乘则是24。例如，四乘以二乘以三乘以四，现在有一个数学公式表明，数字e大约是七点一八，这也恰好是python
    d的最后一个版本，并且可以用这些阶乘数字进行计算，因此如果我取总和。
- en: of one divided by math factorial let's see of n for n in range of let's give
    ourselves a little。 and if we let's see we should probably return， okay like this
    and now we can see that if I calculate this for instance with using five numbers。
    I get close to two point seven one eight right but not extremely close if I use
    more numbers I get。 closer and now say that I was interested in figuring out how
    many calls do we do to math。
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 一除以math factorial，让我们看看n的范围，让我们给自己一点时间。如果我们看看，我们可能应该返回，好的，就这样，现在我们可以看到，如果我用五个数字计算这个，我得到接近2.718，但并不极其接近。如果我使用更多的数字，我得到更接近。现在假设我想弄清楚我们对math的调用次数。
- en: pictorial during this method now I what I like to want to do is then something
    like cat calls。 and then I want to do that at the definition of factorial but
    if I'm in the standard library。 so that doesn't really help me so we do instead
    and in this case what you can do is to actually。 just use your the non-sick tactic
    sugar version of decoration。
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我想做的是像cat calls这样的东西。然后我想在阶乘的定义中做到这一点，但如果我在标准库中，这并没有真的帮助我。所以我们做相反的，而在这种情况下，你可以做的是实际使用你的非常规糖版本的装饰。
- en: '![](img/13dc3ed458136a286215705708b44e8c_37.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_37.png)'
- en: '![](img/13dc3ed458136a286215705708b44e8c_38.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_38.png)'
- en: and see the factorial is count calls of math。f pictorial like this and now if
    we do。 math factorial factorial and then calls we can see that this has not been
    called yet but if we do。 calculate this e of 25 we can see that factorial has
    indeed been called 25。 So this was just a。 quick example showing that it is actually
    possible to decorate even functions that you are not defining。
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 查看阶乘调用次数，像这样math.f pictorial。现在如果我们进行math factorial factorial，然后调用，我们可以看到这尚未被调用，但如果我们计算这个e的25，我们可以看到阶乘确实被调用了25次。所以这只是一个快速的例子，表明实际上可能装饰甚至你没有定义的函数。
- en: '![](img/13dc3ed458136a286215705708b44e8c_40.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_40.png)'
- en: yourself and so this will actually last time that I mentioned how these things
    are different。 and this is kind of what you can actually think that we're doing
    if you need to figure out how。 decoration actually works。 Then just a few notes
    that we saw from the previous section we can use。 function attributes or classes
    to keep state。 Decorators can take arguments and to implement。
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 你自己，这实际上是我提到这些东西不同的最后一次。这就是你可以想象我们在做什么，如果你需要弄清楚装饰器是如何工作的。然后，关于我们从前一部分看到的一些注意事项，我们可以使用函数属性或类来保持状态。装饰器可以接收参数并进行实现。
- en: this you will be using decorator factories which are just functions that create
    decorators and we。 could also have decorators optionally use arguments and in
    that case your decorator factory。 should return either a decorator or a wrapped
    function depending on how it's called。 That was。 kind of the task 6 that we saw。
    Just a quick list of some decorators that you may be familiar with。
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用装饰器工厂，它们只是创建装饰器的函数。我们也可以让装饰器可选地使用参数，在这种情况下，你的装饰器工厂应该根据如何调用返回一个装饰器或一个封装的函数。这就是我们看到的任务6。这里有一些你可能熟悉的装饰器的快速列表。
- en: already。 So there's a few decorators in the standard library where probably
    the most well-knowns。 at least if you use object-oriented programming would be
    property and class method probably。 So what property does is that it can just
    convert a method on a class into a property as something。 that you just get out
    with an attribute access instead of calling it。 The class method creates。
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有一些标准库中的装饰器，其中可能最著名的，至少如果你使用面向对象编程的话，就是属性和类方法。属性的作用是将类中的方法转换为属性，以便通过属性访问获取，而不是调用它。类方法创建。
- en: class methods in your classes and static method can create static methods on
    your classes。 The functor wraps decorator we have used heavily today so hopefully。
    you have a feeling for what that one does。 Then there was in Python 3。7 there
    was something you。 call data classes and that is a new way of constructing classes。
    It kind of simplifies。
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你类中的类方法和静态方法可以在你的类上创建静态方法。我们今天大量使用的functor wraps装饰器，希望你对它的功能有一些了解。然后在Python
    3.7中，有一个称为数据类的东西，这是一种构造类的新方式。它在某种程度上简化了。
- en: a lot of the boilerplate that you often want to use for classes and this is
    a decorator that you。 apply directly to a class and it will work a little bit
    similar to what we did when we decorated。 classes in that it kind of builds a
    class and it adds attributes to it。 And finally there's one in。 the library called
    contextlib which is a library for working with context managers and there's a。
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常想要在类中使用的许多样板代码，这实际上是一个装饰器，你可以直接应用于类，它的工作方式与我们装饰类时有些相似，构建一个类并为其添加属性。最后，库中有一个叫做contextlib的库，它用于处理上下文管理器，还有一个。
- en: decorator that can simplify the creation of new context managers which is actually
    quite cool。 But the decorators are probably more common in different libraries
    and I'm not going to。 even attempt to list all the different ways they can be
    used in kind of third-party packages。 but just a few that you may be familiar
    with depending on the background。 So one is called number。
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器可以简化新上下文管理器的创建，这实际上非常酷。但这些装饰器在不同的库中可能更为常见，我甚至不会尝试列出它们在第三方包中的所有不同用法，仅仅列出你可能熟悉的一些。因此，有一个叫做number的装饰器。
- en: which is a really cool project for speeding up especially computation heavy
    code and it has。 a JIT decorator so that means just in time or where it does just
    in time compilation so。 on the fly compilation essentially of your code which
    can really speed up your code if it's really。 CPU heavy。 Then flask is a web framework
    which uses decorators to just designate。
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常酷的项目，特别是加速计算密集型代码，并且它有一个JIT装饰器，这意味着即时编译，因此在你的代码的飞行编译上，如果代码非常CPU密集，这可以极大地加速你的代码。然后flask是一个Web框架，使用装饰器来指定。
- en: functions as handlers essentially or as an endpoints for your website using
    the app that。 route is one of the decorators it's using and then click is a command
    line interface library。 that you can use to create command line programs essentially
    from your Python scripts and it。 uses decorators to just specify different commands
    inside of your command line program different。
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上作为处理程序或作为你网站的端点的函数，使用的装饰器之一是route，click是一个命令行界面库，你可以用它从Python脚本创建命令行程序，它使用装饰器来指定你命令行程序中不同的命令。
- en: arguments different options and so on。 So all of these ease decorators in a
    very nice fashion。 Then there are some further resources and as I mentioned at
    the beginning of the course。 I have written an article for the website real Python
    which goes into a lot of the same detail。 that we've done here and if you look
    at that article you'll kind of recognize some of the。
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 参数、不同选项等。因此，所有这些装饰器都以非常优雅的方式简化了工作。还有一些进一步的资源，正如我在课程开始时提到的。我为real Python网站写了一篇文章，其中详细介绍了我们在这里所做的许多相同内容，如果你查看那篇文章，你会认识到一些。
- en: examples we've done some examples that are new but it's a good resource to kind
    of look back to。 if there's something you need to remember from this tutorial。
    On real Python there's also a video。 course that kind of covers mostly of the
    basic decorator part so it doesn't go into quite a。 much depth as we've done here。
    Then there's some other cool resources so there is a package on。
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了一些新例子的示例，但这是一个很好的资源，可以回顾一下，如果你需要记住这个教程中的某些内容。在real Python上，还有一个视频课程，主要覆盖基本装饰器部分，因此它没有像我们在这里所做的那样深入。还有一些其他很酷的资源，有一个包。
- en: pipi called decorator and if you're going to work with decorators this one kind
    of takes a lot of。 the work that we have been putting into creating our decorators
    and I'm kind of abstracted away a。 little bit so especially when we come to things
    like making decorators with optional arguments and。 things like this it's easier
    to do using the decorator package so I'll recommend having a look at that one。
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: pipi 中有一个称为 decorator 的包，如果你要使用装饰器，这个包简化了我们在创建装饰器时的许多工作，尤其是在处理带可选参数的装饰器时，使用
    decorator 包会更容易，因此我推荐你看看这个。
- en: The Python Cookbook it's a book that was published by Orile something like seven
    years ago I think now。 and it's a fantastic book with many small recipes that
    kind of tell you how to do stuff and in chapter。 nine of that on the Python Cookbook
    it's called something like meta programming there are many。 different recipes
    using decorators so if you have access to that book I really recommend that you。
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 《Python Cookbook》是一本大约七年前由 O'Reilly 出版的书，书中有许多小食谱，告诉你如何做各种事情，在这本书的第九章中，有一个关于元编程的章节，里面有很多使用装饰器的不同食谱，所以如果你能找到这本书，我强烈推荐你看看。
- en: check it out。 The source code so the kind of the recipes themselves are available
    on the David Beasley's。 homepage so you could also just head over to this guitar
    batteries here and have a look at。 some other ways that they're doing things there
    and then if I guess for the if you really want to。 dive into the details decorators
    were added to the Python language using a Python enhancement proposal。
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看一下源代码，这些食谱本身可在大卫·比斯利的主页上找到，你也可以直接访问这个吉他电池，看看他们其他的实现方式。如果你真的想深入了解，装饰器是通过 Python
    增强提案（PEP）添加到 Python 语言中的。
- en: and pep 318 was the one that was the one that kind of introduced the creators。
    quite a few years ago now but there's actually something happening in decorated
    land so for Python。 three nine which is now very close to being in beta there
    is actually a new addition to。 decorators and so that's introducing in something
    called pep 614 and what the pep 614 does is that it。
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 318 是引入创作者的提案，已经过去好几年了，但实际上在装饰器领域发生了一些新变化，所以对于即将进入 beta 阶段的 Python 3.9，确实有一个新的装饰器提案，称为
    PEP 614，而 PEP 614 的作用是。
- en: actually allows it kind of relaxes a little bit on some of the restrictions
    that are on decorators。 and let's have a look at how that actually works so let's
    see we'll use one and then we'll go over。
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 其实它放宽了一些对装饰器的限制，我们来看一下这实际上是如何工作的，所以我们将先使用一个，然后再继续。
- en: '![](img/13dc3ed458136a286215705708b44e8c_42.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_42.png)'
- en: here to them just a little piece of code that I prepared for for this example。
    and what we used to is that we have this is a decorator all right we have here
    the most trivial。 decorator we can have it's a do nothing decorator that takes
    the function and just returns it straight。 back again so decorating anything with
    do nothing changes nothing does nothing then we have a simplified。
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我为这个示例准备的一小段代码。我们有这个装饰器，这是我们能拥有的最简单的装饰器，它是一个什么也不做的装饰器，接受函数并直接返回它。因此，使用 do
    nothing 装饰任何东西都不会改变任何事情。
- en: trace decorator here i'm just saying that we're calling the function not trying
    to say anything。 about the arguments and return values and so on but it's another
    decorator right we have trace。 funk returning the wrap function here and so how
    we would typically now use this is that we'll just。 say something like add do
    nothing and if we're going to try this you can see here flake is complaining。
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 trace 装饰器只是说我们在调用函数时并不打算讨论任何参数和返回值等等，但这也是一个装饰器，对吧？我们有 trace 函数返回包装函数，所以我们通常会这样使用：我们只需说类似于
    add do nothing 的东西，如果我们尝试这个，你可以看到这里的 flake 报错了。
- en: about this syntax error happening here because here i'm not decorating with
    the function or。 callable i actually put in some expression here and you can see
    here i've added just this if else。 statement or if else expression i guess where
    i'm using the prod variable that we have appear。 that i'm currently set to false
    and then i'm saying okay so if prod then do nothing so if we're in。
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这里发生的语法错误，因为我并没有使用函数或可调用对象进行装饰，而是放入了一些表达式，你可以看到我添加了这个 if else 语句，或者说是 if else
    表达式，我在这里使用的 prod 变量当前被设置为 false，然后我说好的，如果 prod 为真，那么就不做任何事情。
- en: production i don't want to do anything with this one but if we're not running
    in production then i。 want to decorate my little hello world function here with
    the trace decorator and in um， python 3。8 so the current python and this is a
    syntax error we can't really do this but then， what pep 6。14 is saying is that
    there's really no reason not to allow this and。
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，我不想和这个打交道，但如果我们不在生产环境中，我想用trace装饰器装饰我的小hello world函数，在Python 3.8中，这是一个语法错误，我们实际上不能这样做，但PEP
    6.14说，实际上没有理由不允许这样。
- en: this is one example where this might be useful and that you can kind of easily
    turn on and off。 some debugging flags when you're running outside of production
    and so essentially it。 means that you can have any expression here that evaluates
    to a callable will be allowed as a decorator。 so let's see how this actually runs
    so if i now run so first let me actually just show you that this。
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可能有用的例子，你可以轻松地在非生产环境中开启和关闭一些调试标志，所以这基本上意味着你可以在这里使用任何可调用的表达式作为装饰器。让我们看看这实际上是如何运行的，如果我现在运行，让我先给你展示一下这个。
- en: doesn't work at all right it's a syntax error if i just use my regular python
    but if i run this。 with python 3。9 see here that okay and down here i'm printing
    the value prod which is false and then。 i'm calling greet there which the trace
    tells me here that it's calling greet so we can see here。 that in this case it
    decorated using trace and just a quick note here this was an enhanced syntax。
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 完全不起作用，对吧？这是一个语法错误，如果我只是用常规Python，但如果我用Python 3.9运行，看到这里好的，在这里我打印出值prod为false，然后我调用greet，trace告诉我在这里调用greet，因此我们可以看到，在这种情况下，它使用trace装饰。
- en: for fstrings that was introduced in python 3。8 that you can use an equal sign
    like this。 together with a variable and it will print out both the name of the
    variable and the value of the。 variable so that was an enhancement in python 3。8
    okay so this seems to work it was able to figure。 out that it could use trace
    in this case so let's try just to change this one then to run run in。
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在Python 3.8中引入的fstrings，你可以像这样使用等号与变量结合，它会打印出变量的名称和变量的值，这在Python 3.8中是一个增强功能。好的，这似乎有效，它能够识别出在这种情况下可以使用trace，所以我们尝试将其更改为在。
- en: production so now we're setting some flag and we're running in production instead。
    and from this now we can see okay prod equals true which i assumed and it's still
    called greet。 i believe let's actually test that as well so we'll add a print
    statement there。 but it has it's calling greet but it's not tracing anything so
    in this case it's using the do nothing。
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境中现在我们设置了一些标志，并且在生产中运行。由此我们可以看到prod等于true，这我假设并且仍然调用greet。我相信我们也可以测试这一点，所以我们添加一个打印语句在那里，但它调用greet，但没有追踪任何内容，因此在这种情况下，它使用的是不做任何事的模式。
- en: decorator that's only calls the function as usual。 so that's somewhat exciting
    at least and it of course。
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个仅调用函数的装饰器，和往常一样。因此这至少有点令人兴奋，当然。
- en: '![](img/13dc3ed458136a286215705708b44e8c_44.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_44.png)'
- en: gives you many opportunities to probably abuse this so use it twice but it's
    i guess fun to see that。 something is happening also to decorators they've kind
    of been。 fairly solid means they in the language for a long time now。 so with
    that i yeah i'd recommend you to check out these extra resources。
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了你许多滥用的机会，所以可以使用两次，但我想看看确实有些事情在发生，装饰器在语言中已经相当稳定很长时间了，所以我推荐你查看这些额外的资源。
- en: and then i'm just gonna end here by thanking you so much for your attention
    hopefully。 this was useful and if you have any questions do please contact me
    so you could。 reach me either at yeah yeah at twitter you can find some information
    on github。 and you can see some more information about this article and real python
    and so on。
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我想在这里结束，感谢你们的关注，希望这对你有帮助，如果你有任何问题，请随时联系我。你可以在Twitter上找到我，也可以在GitHub上找到一些信息，关于这篇文章和Real
    Python等更多信息。
- en: so yeah thank you so much bye bye。
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢你，再见。
- en: '![](img/13dc3ed458136a286215705708b44e8c_46.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_46.png)'
- en: you， you， (buzzing)， You。
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你， 你， （嗡嗡声），你。
- en: '![](img/13dc3ed458136a286215705708b44e8c_48.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13dc3ed458136a286215705708b44e8c_48.png)'
