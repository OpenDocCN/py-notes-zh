- en: P87：Tutorial Sebastian Witowski - Modern Python Developer's Toolkit - 程序员百科书
    - BV1rW4y1v7YG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P87：教程塞巴斯蒂安·维托夫斯基 - 现代Python开发者工具包 - 程序员百科书 - BV1rW4y1v7YG
- en: Hi， welcome to Modern Python Developers Toolkit Workshop。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 嗨，欢迎参加现代Python开发者工具包研讨会。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_1.png)'
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_2.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_2.png)'
- en: Today， I'm going to teach you how to configure your Python development nicely，
    how to set。 up your code editor， how to manage different Python versions and Python
    dependencies。 And hopefully at the end of this tutorial， you will feel comfortable
    writing Python， projects。 So first of all， if you go to this URL， you can find
    the materials for this tutorial。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我将教你如何优雅地配置你的Python开发环境，如何设置你的代码编辑器，如何管理不同的Python版本和Python依赖项。希望在本教程结束时，你能对编写Python项目感到舒适。所以首先，如果你访问这个网址，你可以找到本教程的材料。
- en: During the workshop， I will be doing a lot of live calling， live sharing of
    some stuff。 but you can find on this website all the things that I will be talking
    about nicely。 describe with all the details。 So who am I？ My name is Sebastian
    and I write Python code for leaving。 I also teach others how to write Python。
    And while talking with other people。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在研讨会上，我会进行很多实时通话和分享一些内容，但你可以在这个网站上找到我将谈论的所有内容，描述得非常详细。那么，我是谁呢？我叫塞巴斯蒂安，我以编写Python代码为生。我还教别人如何写Python。在与其他人交谈时。
- en: I noticed that there is a huge gap between knowing how。 to write Python code
    and actually being able to write Python project。 Even though you know Python。
    when you sit down to write your first Python website or Python， package。 you sometimes
    don't really know where to start。 Like how do you update Python version on your
    computer or how do you install dependencies。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我注意到，知道如何编写Python代码与实际上能够编写Python项目之间存在巨大的差距。即使你知道Python，当你坐下来编写第一个Python网站或Python包时，有时你真的不知道从哪里开始。比如，你如何在计算机上更新Python版本或安装依赖项。
- en: so that they don't mess up with other dependencies that you have installed before。
    So that's why I decided to make this workshop。 If you already know how to write
    Python。 but you're not comfortable writing Python projects。 or you feel that the
    tools on your computer could be tweaked a bit more， this is what we。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以确保它们不会与之前安装的其他依赖项发生冲突。这就是我决定举办这个研讨会的原因。如果你已经知道如何编写Python，但对编写Python项目不太自信，或者觉得电脑上的工具可以进一步调整，这正是我们今天要讨论的内容。
- en: are going to talk about today。 So at the beginning。 I'm going to show you how
    to set up your code editor。 Then we are going to talk about how to manage different
    Python versions and Python dependencies。 Then we're going to have a short exercise。
    Then we'll talk about the project structure and how to use a tool called cookie
    cutter。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时，我将向你展示如何设置你的代码编辑器。然后我们将讨论如何管理不同的Python版本和Python依赖项。接着我们将进行一个简短的练习。然后我们将讨论项目结构以及如何使用一个名为cookie
    cutter的工具。
- en: Next we're going to talk about the code style， how to use a different REPL and
    how to write。 tests and documentation， which tools you might want to use。 Finally。
    we are going to do a mini project。 So we are going to take everything that I showed
    you before and we are going to build。 a small to do application。 At the end， I'm
    going to show you how to take your application and deploy it with Docker。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将讨论代码风格，如何使用不同的REPL以及如何编写测试和文档，以及你可能想要使用的工具。最后，我们将进行一个小项目。我们将把我之前展示的所有内容整合起来，构建一个小型待办事项应用程序。在最后，我会向你展示如何将你的应用程序用Docker部署。
- en: To follow this tutorial， you should have Visual Studio Code Editor installed。
    If you don't have it installed yet， don't worry， I'm going to show you how to
    get it。 You will also need to have Docker。 So if you go to this URL， you can get
    a Docker installation file。 I don't think Docker desktop will work if you're using
    Windows Home Edition， but if you。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本教程，你需要安装Visual Studio Code编辑器。如果你还没有安装，不用担心，我会告诉你如何获取。你还需要Docker。所以如果你访问这个网址，你可以获取Docker安装文件。如果你使用Windows家庭版，我认为Docker桌面可能无法正常工作，但如果你。
- en: search for Docker Windows Home， you will find some tutorials how to install
    it。 And then finally。 you should have Python 3。6 or higher version。 Again， if
    you don't have it， don't worry。 I'm going to show you some tools that will， let
    you easily switch Python versions。 And of course。 you should know the basics of
    Python。 If you don't know what a context manager or decorator is。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索“Docker Windows Home”，你会找到一些安装教程。最后，你应该安装Python 3.6或更高版本。如果你没有，不用担心。我将向你展示一些工具，让你轻松切换Python版本。当然，你应该了解Python的基础知识。如果你不知道什么是上下文管理器或装饰器。
- en: it's perfectly fine。 You just need to know the basics syntax。 And as for the
    operating system。 as you can see， I'm using a Mac OS。 So everything that I showed
    you will work on the latest version of Mac OS。 Also on Linux， since it's quite
    similar， you should be able to follow it。 As for Windows。 I try to install all
    the tools that I talk about。 And sometimes Windows works slightly different。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全没问题。你只需要了解基本的语法。至于操作系统，如你所见，我正在使用Mac OS。所以我向你展示的所有内容在最新版本的Mac OS上都可以工作。在Linux上也可以，因为它非常相似，你应该能够跟随。至于Windows，我尝试安装我所讨论的所有工具。有时Windows的操作方式稍有不同。
- en: So if you're checking this documentation， look for the small Windows icon to
    see some。 hints of what do you have to do different if you're using Windows。 Let's
    talk about code editors。 I'm going to show you how to install and set up VS Code。
    Since code editors are essential tools of every programmer， some people are very
    sensitive。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你在查看此文档，请寻找小Windows图标，看看在使用Windows时需要做什么不同的提示。我们来谈谈代码编辑器。我将向你展示如何安装和设置VS
    Code。因为代码编辑器是每个程序员的基本工具，有些人对此非常敏感。
- en: about it。 If you don't like VS Code and you're not really interested in learning
    how to set it up。 feel， free to skip this section。 But if you're a beginner and
    you don't really know where to start or which editor to choose。 VS Code is a very
    good choice。 I'm using it since over a year and I'm very happy with it。 I've decided
    to use VS Code in this tutorial mostly because of its popularity。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢VS Code，并且对学习如何设置它不感兴趣，随意跳过这一部分。但如果你是初学者，不知道从哪里开始或选择哪个编辑器，VS Code是一个非常好的选择。我已经使用它超过一年，并对此非常满意。我选择在本教程中使用VS
    Code，主要是因为它的受欢迎程度。
- en: So if you check the Stack Overflow Developer Survey， this is a survey that every
    year Stack。 Overflow does and it checks what kind of technology people are using。
    So if you check the results from 2017， you'll see that Visual Studio Code was
    somehow popular。 but it was not the most popular tool。 If we switch to 2018。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看Stack Overflow开发者调查，这是每年Stack Overflow进行的一项调查，检查人们使用的技术类型。如果你查看2017年的结果，你会看到Visual
    Studio Code在某种程度上很受欢迎，但它并不是最受欢迎的工具。如果我们切换到2018年。
- en: you can see that Visual Studio Code is on the first place but also。 the Visual
    Studio or Node++ have almost the same results。 But if you check the results from
    last year， you'll see basically almost every other programmer。 is using Visual
    Studio Code。 There are other code editors like VIM or EMACs that are faster than
    VS Code and offer you。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现Visual Studio Code排在第一位，但Visual Studio或Notepad++的结果几乎相同。如果你查看去年的结果，基本上几乎每个程序员都在使用Visual
    Studio Code。还有其他代码编辑器，如VIM或EMACs，它们比VS Code更快，提供更多功能。
- en: a much higher level of configurability。 So if you spend enough time。 you can
    really make them look and do whatever you want。 But the thing here is you have
    to spend time to configure them。 While if you install VS Code。 it's pretty usable
    since the beginning。 So in my opinion。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 具有更高的可配置性。所以如果你花足够的时间，你可以真的让它们看起来和做你想要的任何事情。但这里的问题是你必须花时间去配置它们。而如果你安装VS Code，它从一开始就相当实用。在我看来。
- en: VS Code strikes a really nice balance between productivity and being， beginner-friendly。
    You just install it and then if you open a Python file， it's gonna tell you like，
    "Hey， look。 there is this Python extension that you might want to use。"， So we
    installed that。 Then you may be open a Markdown file and it's gonna suggest you
    another extension。 As you go。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code在生产力和用户友好性之间取得了很好的平衡。你只需安装它，然后如果你打开一个Python文件，它会告诉你，“嘿，看看。这里有一个你可能想用的Python扩展。”所以我们安装了它。接着你可以打开一个Markdown文件，它会建议你另一个扩展。随着使用。
- en: you will be probably installing more and more tools but you'll be pretty productive。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会安装越来越多的工具，但你会非常高效。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_4.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_4.png)'
- en: since the beginning。 So if you haven't done it yet， let's install Visual Studio
    Code together。 I will be using a fresh installation of macOS Catalina so you can
    follow along。 So if you open a browser and search for VS Code， you can go here
    and you'll see a link。 to the "upload installation for your operating system。"，
    And since this is a clean installation。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始就是这样。如果你还没有做到这一点，让我们一起安装 Visual Studio Code。我将使用一个全新的 macOS Catalina 安装，这样你可以跟着操作。所以如果你打开浏览器搜索
    VS Code，你可以访问这里，你会看到一个链接，指向“为你的操作系统上传安装程序”。因为这是一个干净的安装。
- en: we're gonna see a lot of pop-ups。 Once it's done， open VS Code。 And that's pretty
    much it。 The first thing you want to do in VS Code is to install Python extension。
    VS Code doesn't have extensions for programming languages by default。 So without
    a Python extension。 we won't even have syntax highlighting， not to mention any。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会看到很多弹出窗口。一旦完成，打开 VS Code。这基本上就是了。在 VS Code 中你要做的第一件事是安装 Python 扩展。VS Code
    默认没有编程语言的扩展。所以如果没有 Python 扩展，我们甚至没有语法高亮，更不用说其他功能了。
- en: other functions that a proper IDE would have。 So when you open VS Code。 you're
    gonna have this welcome page。 Here you can click "Python" and it's going to show
    you a small pop-up。 We say "okay"。 It's gonna install Python extension for you。
    If you don't have this welcome window。 you can also go to the extensions and search。
    Well， now it's gone。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正常情况下，打开 VS Code 后，你会看到这个欢迎页面。在这里你可以点击“Python”，它会显示一个小弹出窗口。我们点击“好的”。它会为你安装 Python
    扩展。如果你没有这个欢迎窗口，你也可以去扩展选项卡搜索。好吧，现在已经消失了。
- en: but you would normally go to the extensions tab and search for Python。 And here。
    now it's already installed。 If it was not installed yet， you'll see a green button
    like that。 So now with the Python extension installed， we have access to a set
    of new tools。 We have Intel-ESense， so the code completion and syntax checking
    or code navigation。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但通常你会去扩展选项卡搜索 Python。现在它已经安装好了。如果还没有安装，你会看到一个绿色按钮。现在有了 Python 扩展，我们可以访问一组新工具。我们有
    Intel-ESense，所以代码补全和语法检查或代码导航。
- en: So if you want to go to a definition of a function， now we have it。 We also
    have access to linting and formatting tools。 So if you open a Python file。 VS
    Code will offer you to install， for example， a linter。 that will check your code
    if there are some errors。 We also have some debuggers that we can enable。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想去查看一个函数的定义，现在可以了。我们还可以访问代码检查和格式化工具。所以如果你打开一个 Python 文件，VS Code 会提示你安装，比如说，一个
    linter，它会检查你的代码是否有错误。我们还有一些调试工具可以启用。
- en: for example， for Django or for Flask applications。 And we can also detect Python
    environments and automatically enable virtual environments。 that we'll talk about
    later。 So let's try to open a Python file。 I have an example "Hello World"。 And
    if you open a Python file， you're gonna probably have the suggestion that a linter。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于 Django 或 Flask 应用程序。我们还可以检测 Python 环境并自动启用虚拟环境，稍后我们会讨论这些。所以让我们尝试打开一个 Python
    文件。我有一个示例“Hello World”。如果你打开一个 Python 文件，你可能会收到一个建议，提示 linter 没有安装。
- en: is not installed。 So while Visual Studio Code will suggest "pilint"。 I would
    suggest a slightly different one。 I'm gonna install Flake 8。 So once you click
    it。 you get another pop-up。 And since I'm using a brand new Mac installation。
    it doesn't have pip install。 Normally when you install Python on your computer。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所以虽然 Visual Studio Code 会建议“pylint”，但我会建议一个稍微不同的。我将安装 Flake 8。一旦你点击它，你会收到另一个弹出窗口。因为我使用的是全新的
    Mac 安装，所以没有安装 pip。通常在你的计算机上安装 Python 时。
- en: it's gonna install pip as well。 But I haven't actually installed Python on this
    Mac installation yet。 So I just have the Python that came with MacBook and no
    other dependencies like pip。 If you are in the same situation as me and you don't
    have pip installed， later in this。 tutorial I'm going to show you a tool that
    you can use to easily install new Python versions。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它还会安装 pip。但我实际上还没有在这个 Mac 安装上安装 Python。所以我只有 MacBook 自带的 Python，没有其他依赖项，比如 pip。如果你和我在同样的情况，且没有安装
    pip，稍后在本教程中我会给你展示一个工具，你可以用它轻松安装新的 Python 版本。
- en: But in the meantime， I'm going to go and install Python version from the Python
    website。 just so I can add linter to Visual Studio Code。 Now that I have installed
    another version of Python。 I will have to tell visuals to， your code to actually
    use it。 So to do that。 we can either click Python version here and we'll see a
    list of different， Python versions。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我将去 Python 网站安装 Python 版本。这样我就可以将 linter 添加到 Visual Studio Code。现在我已经安装了另一个版本的
    Python。我必须告诉 VS Code，你的代码实际上要使用它。所以为此，我们可以点击这里的 Python 版本，查看不同的 Python 版本列表。
- en: So the one that I'm currently using is a terribly outdated Python that comes
    with Mac。 And I want to use the Python 3。7 or they have just installed。 So I just
    click that and you can see that the version has changed here。 And again。 we get
    this pop-up。 That linter is not installed。 In case you don't get this pop-up and
    you don't know how to install a linter。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在使用的是一个非常过时的 Python，来自 Mac。而我想使用 Python 3。7 或者他们刚刚安装的版本。所以我只需点击它，你可以看到版本已经在这里更改。再一次，我们收到这个弹出窗口。提示
    linter 尚未安装。如果你没有收到这个弹出窗口，且不知道如何安装 linter。
- en: you could close， this file and reopen it。 But a much better way is to open the
    command palette and select。 set for a command called， linter。 Here we can click
    Python select linter。 Here we choose flake 8 and then we get the pop-up。 So visual
    studio code is going to install flake 8 package on your computer。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以关闭这个文件然后重新打开。但一个更好的方法是打开命令面板，选择一个名为 linter 的命令。在这里我们可以点击 Python 选择 linter。这里我们选择
    flake 8，然后我们会得到弹出窗口。所以 Visual Studio Code 将在你的计算机上安装 flake 8 包。
- en: This is not the perfect solution because it's not separating it from other dependencies。
    on your computer。 So later on， I'm going to show you a better way how to do this。
    But now just for the illustration purpose， let's go with that。 In case you're
    wondering what's this linter tool that we have just installed， it's a tool。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是完美的解决方案，因为它没有将其与电脑上的其他依赖项分开。所以稍后我将向你展示一个更好的方法。但现在仅为说明目的，让我们这样做。如果你在想我们刚刚安装的
    linter 工具是什么，它是一个工具。
- en: that will help you find some bugs in your code。 For example。 if you have imported
    a module or a function and you're not using， linter， is going to complain。 If
    you try to use a variable that is undefined or if you put a breakpoint statement
    outside。 of a loop， linter is going to complain。 So for example。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助你找到代码中的一些错误。例如，如果你导入了一个模块或一个函数但未使用，linter 会发出警告。如果你尝试使用一个未定义的变量，或者将断点语句放在循环外，linter
    也会发出警告。例如。
- en: if in our simple hello world we forget the closing quotation mark， we're， going
    to have an error。 You can hover and see that this is a syntax error。 However。
    since Python is not a statically typed language， linter is not going to detect。
    all the problems of your code。 If you try， for example， to add a string to an
    int。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我们简单的 hello world 中忘记了闭合引号，我们将会出现错误。你可以悬停查看这是一个语法错误。然而，由于 Python 不是一种静态类型语言，linter
    不会检测出你代码中的所有问题。如果你尝试，例如，将字符串添加到一个整数。
- en: linter is not going to detect it， but if you run your program， it's going to
    fail。 One final step that I suggest you to do is to add code command to your terminal。
    So that way。 if you are in a terminal and you type code in the name of a file
    or a folder。 you will automatically open it in the VS code。 So to do that， you
    need to open the command palette。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: linter 将不会检测它，但如果你运行你的程序，它会失败。我建议你做的最后一步是将代码命令添加到你的终端。这样，如果你在终端中输入代码加上文件或文件夹的名称，你将自动在
    VS Code 中打开它。为此，你需要打开命令面板。
- en: search for shell command， install， code command in path and just run it。 It's
    going to ask you for a password and we have information that it will successful。
    We use the shortcut to open the command palette and VS code has a few more shortcuts
    that you。 will be using quite often。 So let's take a look at some of them。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索 shell 命令，安装，路径中的代码命令，然后运行它。它会要求你输入密码，我们有信息显示它将成功。我们使用快捷键打开命令面板，VS Code 还有一些你会经常使用的快捷键。让我们来看看其中的一些。
- en: So you already know the command palette and this basically gives you a list
    of all the。 commands that are available in VS code。 Next we have go to file so
    we can quickly open any file in the project that we are currently。 working on。
    So if I type blueprint， I can go to blueprints。 Next we have go to symbol。 So
    symbols are all the functions， methods， variables， modules in a current file。
    If we press colon。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你已经知道命令面板，这基本上给你一个在 VS Code 中可用的所有命令的列表。接下来我们有“转到文件”，所以我们可以快速打开当前项目中的任何文件。如果我输入
    blueprint，我可以去蓝图。接下来我们有“转到符号”。符号是当前文件中的所有函数、方法、变量和模块。如果我们按冒号。
- en: VS code is going to group them together。 So we're going to have classes at the
    top。 then we're going to have methods and at the， end we're going to have variables
    if we get there。 Yeah。 Another useful shortcut is control space。 So if you're
    typing some code。 you will get this auto completion。 But if for some reason it
    disappears and you want to get it back。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 将把它们分组。因此，我们将把类放在顶部，然后是方法，最后是变量。如果我们到达那里。是的，另一个有用的快捷键是控制空格。所以如果你正在输入代码，你会得到这个自动补全。但是如果因为某种原因它消失了，你想把它找回来。
- en: one way is to actually， delete the code and hope it's going to appear again。
    But much better way is to use a shortcut to trigger auto completion。 So by default
    it should be control space but it seems that it's not working。 So if we open the
    keyboard shortcuts and we search for suggest， we can see that apart。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是实际删除代码，然后希望它会再次出现。但更好的方法是使用快捷键触发自动补全。因此，默认情况下应该是控制空格，但似乎它不起作用。所以如果我们打开键盘快捷键并搜索建议，我们可以看到除外。
- en: from the control space， there is also option escape that can trigger this。 So
    let's try with this one。 So we have our self and then， yep， it's working。 If you
    want to go to a definition of a function， you can press F12 and this is going
    to open。 a new file with the definition。 If you don't have F12 on your keyboard。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从控制空格中，还有选项逃脱也可以触发这个。所以我们来试试这个。所以我们有了自我，然后，是的，它有效。如果你想查看一个函数的定义，可以按 F12，这将打开一个带有定义的新文件。如果你的键盘上没有
    F12。
- en: you can also press command and then just click， the function name。 If you don't
    want to open a new file， you can press option and then F12 and this is going。
    to open a small window with the definition of a function in the current file。
    And finally。 if you are in the definition and you want to see all the places where
    this， function is used。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以按命令键，然后单击函数名。如果你不想打开新文件，可以按选项键，然后 F12，这将打开一个小窗口，显示当前文件中函数的定义。最后，如果你在定义中，想要查看这个函数被使用的所有地方。
- en: you can just press shift and F12 and this is going to show you a list。 of all
    the places where this function is currently being used。 If you want to learn more
    about the shortcuts that VS Code has to offer， you can go to the。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按 shift 和 F12，这将显示一个列表，列出这个函数当前被使用的所有地方。如果你想了解更多关于 VS Code 提供的快捷键的信息，可以去。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_6.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_6.png)'
- en: keyboard shortcuts section of the documentation and then there is a list of
    printable shortcuts。 that you can download。 And of course， VS Code has even more
    shortcuts that are shown on this list。 So if you open VS Code and you go to keyboard
    shortcuts， you will see that almost every action。 in VS Code has a keyboard shortcut
    that you can assign to it。 Finally。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 文档的键盘快捷键部分有一个可打印的快捷键列表，你可以下载它。当然，VS Code 还有更多在此列表中显示的快捷键。因此，如果你打开 VS Code 并进入键盘快捷键，你会发现几乎每个在
    VS Code 中的操作都有一个可以分配给它的键盘快捷键。最后。
- en: if you are migrating to VS Code from a different code editor， then you have
    some。 plugins that will change the keyboard bindings to those from your previous
    code editor。 So that way。 you don't have to retrain your muscle memory from the
    first day and you can。 slowly get used to the new keyboard bindings。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是从其他代码编辑器迁移到 VS Code，那么你会有一些插件，它们会将键盘绑定更改为你之前代码编辑器的绑定。这样，你就不必从第一天起重新训练你的肌肉记忆，你可以慢慢适应新的键盘绑定。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_8.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_8.png)'
- en: Let's talk about using VS Code。 VS Code is pretty easy to use。 You press letter
    A to type A。 You press letter S to type S。 You press letter D。 I'm just， kidding。
    If you have a file and it's a standalone file like a script or a module so it
    doesn't require。 a web server like a flask or Django application， you can run
    it directly in the terminal that。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈如何使用VS Code。VS Code相当简单。你按下字母A输入A。你按下字母S输入S。你按下字母D。我只是开个玩笑。如果你有一个文件，并且它是一个独立文件，比如脚本或模块，所以不需要像Flask或Django应用程序那样的网络服务器，你可以直接在终端中运行它。
- en: comes with VS Code。 All you have to do is to search for run Python file in terminal
    and run this command。 As you can see， we have the output here。 Also， you can just
    press the green arrow and it's also going to run the whole file in。 the terminal。
    If you want to run just a part of your code in the terminal。 you can select it
    and search， for command run selection in Python terminal。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与VS Code一起提供的。你所要做的就是搜索“在终端中运行Python文件”，并运行这个命令。如你所见，我们在这里得到了输出。此外，你也可以直接按绿色箭头，它也会在终端中运行整个文件。如果你想在终端中只运行代码的一部分，你可以选择它并搜索“在Python终端中运行选择”命令。
- en: This will open a Python REPL and run just one line of your code。 You can also
    just select the code and press shift entered for the same effect。 Things get a
    bit more complicated if you want to run a web application。 Of course。 you can
    always run it from a terminal but maybe you don't like to switch between。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个Python REPL并运行你代码中的一行。你也可以选择代码并按Shift+Enter达到相同的效果。如果你想运行一个Web应用程序，事情会变得更复杂。当然，你可以始终从终端运行它，但也许你不喜欢在它们之间切换。
- en: VS Code and the terminal。 So let's say you have a very simple flask web application
    in a file called uppy。 Just make sure you have flask installed using pip and then
    switch to the building terminal。 Remember you can trigger it with the command
    tilde and run Python or actually Python 3， in my case。 minus M flask run。 This
    will start a development server for your flask application。 Okay。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code和终端。所以假设你在一个名为uppy的文件中有一个非常简单的Flask网络应用程序。确保你使用pip安装了Flask，然后切换到构建终端。记得可以用反引号命令触发它，运行Python或者实际上是Python
    3，在我的情况下是`-m flask run`。这将为你的Flask应用程序启动一个开发服务器。好的。
- en: so that was a pretty terrible tip。 You could do the same thing from the terminal。
    And since VS Code has plenty of buttons， surely one of them can be used to start
    a server for， us。 If you open a debug panel， it's this one with the bug and the
    play button， you can click。 the create a launch JSON file。 Next， you have to select
    flask from this list since this is a flask application。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一个相当糟糕的建议。你可以从终端做同样的事情。由于VS Code有很多按钮，肯定有一个可以用来为我们启动服务器。如果你打开调试面板，就是这个有虫子和播放按钮的，点击它可以创建一个launch
    JSON文件。接下来，你必须从这个列表中选择Flask，因为这是一个Flask应用程序。
- en: We press enter and we get a launch JSON。 Let's stop the server and let's actually
    use this launch file to run our flask application。 As you can see now in the run
    panel， we have this small green arrow for a Python flask， application。 If we press
    it， VS Code does a lot of stuff and it complains that it can't find up file。 To
    fix that problem， I had to take my app and move it to the same folder where the
    launch。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按下回车键，就会得到一个launch JSON。让我们停止服务器，并实际上使用这个launch文件来运行我们的Flask应用程序。如你所见，现在在运行面板中，我们有一个用于Python
    Flask应用程序的小绿色箭头。如果我们按下它，VS Code会做很多事情，并且抱怨找不到uppy文件。为了解决这个问题，我不得不把我的应用移动到与launch文件相同的文件夹中。
- en: dot JSON is。 So if we go to the run panel right now and we try to run flask
    again， we can see that。 this time it's starting the development server correctly。
    One nice thing about starting your flask server from VS Code like that is that
    it actually。 starts it in a debugger mode。 So what does it mean？ Well， let's say
    we have some more code。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: JSON文件是什么？所以如果我们现在去运行面板，再次尝试运行Flask，我们可以看到这次它正确地启动了开发服务器。从VS Code启动Flask服务器的一个好处是它实际上以调试模式启动它。那么这意味着什么呢？好吧，假设我们有一些更多的代码。
- en: If you hover over the numbers on the left side of your editor， you will see
    a red dot。 You can click it and you will put a breakpoint on that line。 If you
    start a server right now and you open the website in the browser， then if the
    code。 execution gets to that breakpoint， your interface will display a lot of
    new information。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将鼠标悬停在编辑器左侧的数字上，你会看到一个红点。你可以点击它，将一个断点放在那一行。如果你现在启动服务器并在浏览器中打开网站，那么如果代码执行到那个断点，你的界面将显示很多新信息。
- en: This little border indicates where the code execution has stopped。 So you can
    see we have stopped at this breakpoint。 Here we have only one。 but if we would
    put more than the code execution would stop at， each of them。 On the left side。
    you can see a list of current variables。 We only have local variables。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小边框表示代码执行已停止的位置。所以你可以看到我们在这个断点处停止了。这里只有一个断点，但如果我们放置多个，代码执行将会在每个断点处停止。在左侧，你可以看到当前变量的列表。我们这里只有局部变量。
- en: but if we had some global ones， they will also be displayed， here。 Underneath
    you had a watch section。 You can add some expressions here and VS code will print
    their values。 It's useful if you know in which variable you have a bug and you
    want to see how this。 variable is changing over time。 And underneath you have
    a call stack and a list of active breakpoints。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们有一些全局变量，它们也会在这里显示。下面是监视区。你可以在这里添加一些表达式，VS Code 将会打印它们的值。如果你知道哪个变量有错误，并且想要查看这个变量如何随时间变化，这很有用。下面是调用堆栈和活动断点的列表。
- en: At the top of the main window， you can see the toolbar for the debugging。 It
    has the typical buttons for the debugger， so you can continue the execution。 You
    can step over the next function。 You can step inside or outside of a function。
    You can restart the whole debugging session and you can stop the debugger。 Finally。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在主窗口的顶部，你可以看到调试工具栏。它有典型的调试器按钮，可以让你继续执行。你可以逐步执行下一个函数。你可以进入或退出一个函数。你可以重新启动整个调试会话，也可以停止调试器。最后。
- en: at the bottom you have a debug console。 You can use it to execute any Python
    code。 Let's stop the debugger。 VS code has a nice interface for running your tests。
    By default。 it's not visible， although the Python extension might sometimes ask
    you if。 you want to configure it。 If it doesn't， this is how you enable it。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部你有一个调试控制台。你可以用它来执行任何 Python 代码。让我们停止调试器。VS Code 为运行测试提供了一个很好的界面。默认情况下，它不可见，尽管
    Python 扩展有时会询问你是否想配置它。如果没有，这就是你如何启用它。
- en: Open the command palette and run Python configure test。 It's going to ask you
    which test framework you want to choose and I'm going to choose。 by test and then
    select where do you keep your tests。 In my case， this is the root directory。 As
    you can see， PyTest was not installed yet， so VS code is going to install it。
    At the same time。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 打开命令面板并运行 Python 配置测试。它会询问你想选择哪个测试框架，我将选择 PyTest，然后选择你存放测试的位置。在我的情况下，这是根目录。如你所见，PyTest
    还未安装，所以 VS Code 将会为你安装它。同时。
- en: it's asking me if I want to install it。 No， because it's already there。 Now
    you can see we have this magic potion icon。 If we click it。 we're going to get
    the sidebar for the tests。 At the beginning， there is not much here。 Let's see
    what kind of buttons we have。 We have one to rerun all tests， debug tests， discover
    tests。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它在问我是否想安装它。不，因为它已经存在。现在你可以看到我们有这个魔法药水图标。如果我们点击它，将会打开测试的侧边栏。一开始，这里没有太多内容。让我们看看我们有什么样的按钮。我们有一个按钮来重新运行所有测试，调试测试，发现测试。
- en: show test output， and then， collapse all。 We are interested in this discover
    test。 So if you click it， VS code is going to go through all the files and try
    to find tests。 In case of PyTest， it will look inside every file starting with
    test and then it's going。 to search for every function that starts with tests
    and it's going to assume those are the， tests。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 显示测试输出，然后收起所有。我们对这个发现测试感兴趣。所以如果你点击它，VS Code 将会遍历所有文件并尝试查找测试。在 PyTest 的情况下，它会查找每个以
    test 开头的文件，然后搜索每个以 test 开头的函数，并假设这些就是测试。
- en: Now， as you can see， we have three tests here and we have question marks because
    VS code。 hasn't run those tests yet。 If we try to run them， it's going to take
    some time and as you can see。 two of them are， passing and one is failing。 You
    can hover over the name of the test and you will see that there is a problem with
    our。 subtraction。 So what we can do is we can put a breakpoint here and then we
    can debug this test。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如你所见，我们有三个测试，这里有问号，因为 VS Code 尚未运行这些测试。如果我们尝试运行它们，将会花费一些时间，正如你所看到的，两个通过了，一个失败了。你可以将鼠标悬停在测试名称上，你会看到我们的减法有问题。所以我们可以在这里放置一个断点，然后调试这个测试。
- en: In this case， it's not really helping us that much because we don't have variables
    or anything。 that we could investigate。 But at least we know where the problem
    is。 So we stop the debugging and if we fix our test， we can rerun it and yeah，
    we have all。 the tests passing。 If you want to run a single test。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这并没有给我们太多帮助，因为我们没有变量或其他可以调查的东西。但至少我们知道问题在哪里。因此我们停止调试，如果修复了测试，我们可以重新运行，是的，所有测试都通过了。如果你想运行一个单独的测试。
- en: you can do this from the sidebar or you can press， the run test above the test
    function。 Let's talk about snippets。 Once you have the Python extension installed。
    if you start typing in a Python file， you will， see two tips with some suggestions。
    It's just a way that the autocompletion tells you like， "Hey， I see that you're
    trying to。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从侧边栏进行此操作，或者你可以按测试函数上方的运行测试。让我们谈谈片段。一旦你安装了Python扩展，如果你在Python文件中开始输入，你会看到两个提示和一些建议。这只是自动完成告诉你，“嘿，我看到你试图。
- en: type a function。 I can put a skeleton of this function to make it faster。"。
    If by accident you dismiss this tool tip， you can get it back by pressing the
    control。 space or in my case， option escape and you get it back。 Every snippet
    has some places in the code that you can switch between using the tau key。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个函数。我可以放置这个函数的骨架来加快速度。如果不小心关闭了这个工具提示，可以通过按控制空格键或在我的情况下，选项逃键来恢复。每个片段在代码中都有一些位置，你可以使用tab键在这些位置之间切换。
- en: Once you go through all the positions， you just end up at the end of the code。
    So let's say we want to write a function and I don't know why I get the class。
    Ah， here we go。 And that's it。 You can write your own snippets。 So if you feel
    that there is some piece of code that you keep typing over and over and。 you want
    to save yourself a few keystrokes， you can go to the command palette。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你遍历了所有位置，你将结束在代码的末尾。假设我们想写一个函数，我不知道为什么我得到这个类。啊，来了。这就是全部。你可以写自己的片段。如果你觉得有某段代码需要反复输入，并且想节省几次按键，可以去命令面板。
- en: And select configure user snippets。 Here you will see all the snippets for a
    given programming language。 So if we set for Python， you will see a file where
    you can define snippets that will be。 used in Python files。 Right now there are
    no snippets。 There is only an example how to create a snippet。 For some reason
    in every file。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 选择配置用户片段。在这里，你将看到特定编程语言的所有片段。如果我们为Python设置，你将看到一个文件，在其中可以定义将用于Python文件的片段。现在没有片段，只有一个如何创建片段的示例。出于某种原因，在每个文件中。
- en: the example is the same and it's for JavaScript。 But let me show you how to
    quickly create a snippet。 Let's say we want to create a snippet that will put
    a breakpoint in our code and we are。 not using the latest version of Python。 So
    we can't really just write breakpoint。 So what we want to have is a snippet that
    will be triggered with， let's say， debug statement。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 示例是相同的，适用于JavaScript。但让我告诉你如何快速创建一个片段。假设我们想创建一个片段，将断点放入我们的代码中，而我们又不使用最新版本的Python。因此我们不能仅仅写断点。我们想要的是一个片段，当输入调试语句时会被触发。
- en: and it will turn it into an import PDB and PDB set trace。 So how can you get
    this？ Well。 first let's get rid of this。 Let's uncomment the example。 First we
    define the name of the snippet。 This name will be displayed in this autocomplete
    suggestion。 So let's name our snippet debugger snippet。 Oh， maybe breakpoint。
    Yep， can't type。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它将转换为导入PDB和PDB设置跟踪。那么你如何获取这个呢？好吧。首先，让我们摆脱这个。取消注释示例。首先我们定义片段的名称。这个名称将显示在自动完成建议中。因此我们将我们的片段命名为调试器片段。哦，也许是断点。没错，无法输入。
- en: Next we need to define the prefix that will trigger our snippet。 We want our
    snippet to be triggered when we type debugger。 So we can type debugger but maybe
    we don't always remember that it's a debugger。 Sometimes we just type in PDB and
    we also want the snippet to be triggered on this。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要定义将触发我们片段的前缀。我们希望当我们输入调试器时触发片段。因此我们可以输入调试器，但也许我们并不总是记得它是调试器。有时我们只输入PDB，我们也希望在这种情况下触发片段。
- en: So prefix can accept a list of different values。 So let's add PDB。 Next there
    is body of the snippet。 The stroller sign and the number defines where the cursor
    will jump if you press tab。 In our case， we don't really have a place where we
    want to put a cursor。 So let's just put our PDB statements here。 Put PDB， PDB
    set， trace。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前缀可以接受不同值的列表。让我们添加PDB。接下来是片段的主体。符号和数字定义了如果你按下tab键，光标将跳转到哪里。在我们的例子中，我们并没有确切想要放置光标的位置。因此我们就把PDB语句放在这里。放入PDB，PDB设置，trace。
- en: And finally we have a description。 This is optional but this will be displayed
    also in the autocompletion。 So let's put something here。 Put a PDB breakpoint。
    Okay， let's save it and let's test our snippet。 So if I type debug， you can see
    in the first place we have our debugger snippet。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个描述。这是可选的，但它也会在自动补全中显示。让我们在这里写一些内容。放一个 PDB 断点。好吧，让我们保存它并测试我们的片段。因此，如果我输入
    debug，你会看到在第一位有我们的调试器片段。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_10.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_10.png)'
- en: The snippet that we just use is very basic but you can write pretty advanced
    snippets。 You can。 for example， use special variables。 You can find a whole list
    here like name of the file。 line number， but also current date。 You can do some
    regex transformations or you can even assign key bindings to a snippet。 Final
    feature that I want to show you are the tasks。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用的片段非常基础，但你可以编写相当复杂的片段。例如，你可以使用特殊变量。你可以在这里找到一个完整的列表，比如文件名、行号，还有当前日期。你可以进行一些正则表达式转换，甚至可以将快捷键绑定分配给一个片段。最后一个我想展示的功能是任务。
- en: If you have some common files with tasks for different programming languages
    like make， files。 ground， gulp， aunt， jc rake or ms build files in your project，
    VS code can detect。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些用于不同编程语言的常见文件，例如 make 文件、ground、gulp、aunt、jc rake 或 ms build 文件，VS code
    可以检测到。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_12.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_12.png)'
- en: comments from those files。 So for example here I have packaged JSON with some
    scripts and if I select run task。 I can， say show all tasks and here you can see
    I have the list of my tasks。 Also in the sidebar I can also find them here。 You
    can press this arrow to run this task。 Well this advice doesn't really apply to
    Python because there are no task files for Python。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件中的注释。例如，这里我有一个包含一些脚本的打包 JSON，如果我选择运行任务，我可以说显示所有任务，在这里你可以看到我的任务列表。此外，在侧边栏中我也可以在这里找到它们。你可以按这个箭头来运行这个任务。好吧，这个建议实际上并不适用于
    Python，因为 Python 没有任务文件。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_14.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_14.png)'
- en: If you want to define some tasks， for example you can run tasks with some predefined
    settings。 You can create a tasks。json file and define your Python tasks inside
    of it。 You can find more information in this documentation。 We are almost done
    with this short introduction to VS code but I would also like to show you。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想定义一些任务，例如你可以使用一些预定义的设置来运行任务。你可以创建一个 tasks.json 文件，并在其中定义你的 Python 任务。你可以在这个文档中找到更多信息。我们几乎完成了对
    VS code 的简短介绍，但我还想给你展示。
- en: some of the plugins that I am using。 Some of them are pretty obvious。 some of
    them are not so maybe you will find them useful。 First plugin is for Python programming
    language。 This is probably the only plugin that you will have to install if you
    want to write Python。 code。 If you are programming in another programming language
    you will also find extensions for them。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用的一些插件。有些插件非常明显，有些则不太明显，因此也许你会觉得它们有用。第一个插件是用于 Python 编程语言的。这可能是你写 Python
    代码时唯一需要安装的插件。如果你使用其他编程语言，你也会找到相应的扩展。
- en: for C++， for Rust， for Go。 If you are working with Django or Flask or any other
    framework you probably want to install。 a plugin for that framework。 For example
    if you install plugin for Django it is going to add a bunch of snippets that。
    will make your life easier。 And not only that but it will also provide syntax
    highlighting for framework specific。 files。 For example if you have template files
    in Django。combine， HTML and Django text then it。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 C++，对于 Rust，针对 Go。如果你在使用 Django 或 Flask 或任何其他框架，你可能想要安装一个插件来支持该框架。例如，如果你安装
    Django 的插件，它会添加一堆片段，使你的生活更轻松。不仅如此，它还会为框架特定的文件提供语法高亮。例如，如果你在 Django 中有模板文件，结合了
    HTML 和 Django 文本，那么它。
- en: will give you a proper syntax highlighting for those。 Next we have Intelli code。
    So if you install Python plugin you will get the code completion。 But if you install
    Intelli code you will get a slightly smarter auto completion。 So as you can see
    Intelli code tries to predict what function you actually need and it will。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将为这些文件提供合适的语法高亮。接下来我们有 Intelli code。如果你安装了 Python 插件，你将获得代码补全。但如果你安装 Intelli
    code，你会得到稍微智能一些的自动补全。如你所见，Intelli code 试图预测你实际需要的函数，并且它会。
- en: put this function on the top of the list with a star。 So here is an example
    from the documentation where someone is using TensorFlow and the Intelli。 code
    is pretty successfully predicting what will be the next function that is needed
    in。 this situation。 Next there is Emmet and it is technically not an extension
    because it is already integrated。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 用星号将这个函数放在列表的顶部。这是文档中的一个例子，有人使用 TensorFlow，而 IntelliCode 很成功地预测出在这种情况下需要的下一个函数。下一个是
    Emmet，从技术上讲它不是一个扩展，因为它已经集成在内。
- en: with VS code。 But if you are writing a lot of HTML and CSS I strongly recommend
    you take a look at how。 Emmet works。 If you learn the basics of Emmet you can
    very quickly write a lot of HTML code with a simple。 shortcuts。 Next there is
    AutoDoc string。 It is not very popular plugin but I like it because it makes writing
    documentation for my。 functions much faster。 So if you write a function and then
    below you put three double quotes and you press enter。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VS Code 中。但如果你在写大量的 HTML 和 CSS，我强烈建议你看看 Emmet 的工作原理。如果你掌握 Emmet 的基础知识，可以用简单的快捷键快速编写大量
    HTML 代码。接下来是 AutoDoc string。这不是一个非常流行的插件，但我喜欢它，因为它使我为函数编写文档的速度大大加快。所以如果你写一个函数，然后在下面放三个双引号并按下回车。
- en: it will automatically generate a skeleton of the documentation。 And if you annotate
    the arguments in the function it will also detect the types correctly and。 move
    them to the body of the documentation。 Next extension that I like a lot is the
    bookmarks。 It lets you bookmark a location in your code so you can easily switch
    between the existing。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它会自动生成文档的框架。如果你在函数中注释参数，它还会正确检测类型并将其移到文档主体中。下一个我非常喜欢的扩展是书签。它允许你在代码中标记一个位置，以便你可以轻松地在现有书签之间切换。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_16.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_16.png)'
- en: bookmarks。 I find it very useful when I'm working with either a new project
    so I'm trying to figure。 out what's going on or large files where I need to jump
    between different places in。 the same file to see definitions of different functions。
    So for example if I put a bookmark here and I go somewhere else in the code I
    can use a。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 书签。我觉得在处理新项目时非常有用，这样我可以弄清楚发生了什么，或者在大型文件中需要在同一个文件的不同地方跳转，以查看不同函数的定义。例如，如果我在这里放一个书签，然后去代码中的其他地方，我可以使用一个。
- en: keyboard shortcut to automatically go back to this bookmark。 And it also supports
    bookmarks in a different file。 So if I put bookmark in here and maybe also here
    I can use a command bookmark list from。 all files and I can see the list of my
    bookmarks here。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 快捷键会自动返回到这个书签。而且它还支持在不同文件中的书签。所以如果我在这里放一个书签，可能还在这里放一个书签，我可以使用命令 bookmark list
    来查看所有文件中的书签列表。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_18.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_18.png)'
- en: Next extension is dash。 I don't use it that often but it's very useful if you're
    working somewhere where you don't。 have access to the internet。 Dash extension
    is a wrapper around a tool that lets you save documentation offline。 So you can
    for example save documentation for Python or Django and if you're working somewhere。
    where you don't have access to the internet you can use it instead。 Next extension
    is error lens。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个扩展是 Dash。我不常用，但如果你在没有互联网的地方工作，它非常有用。Dash 扩展是一个工具的包装器，允许你离线保存文档。例如，你可以保存 Python
    或 Django 的文档，如果你在没有互联网的地方工作，可以用它代替。下一个扩展是 error lens。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_20.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_20.png)'
- en: If you have some errors in the Python code you will see a curly line but with
    error lens。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Python 代码中有一些错误，你会看到一个波浪线，但使用 error lens。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_22.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_22.png)'
- en: you will also see small icon in the gutter that indicates that there is an error
    on this。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会在边缘看到一个小图标，表示这里存在错误。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_24.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_24.png)'
- en: line。 So I really like it because I can quickly see where are some errors by
    just scanning the。 gutters。 And you can also configure it。 By default it's going
    to display you an error message next to the place in the code where。 the error
    happened but as I said I like to change it and display an icon in the gutter。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我非常喜欢它，因为我可以通过扫描边缘快速看到哪里有一些错误。而且你也可以进行配置。默认情况下，它会在代码中错误发生的地方显示错误消息，但正如我所说，我喜欢将其更改为在边缘显示图标。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_26.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_26.png)'
- en: Next extension is file utils。 It adds a few new commands related to the files
    like rename。 move or duplicate。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个扩展是文件工具。它添加了一些与文件相关的新命令，比如重命名、移动或复制。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_28.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_28.png)'
- en: So if you try to let's say duplicate a file or move it you don't see an option
    here but。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你试图例如复制一个文件或移动它，你不会在这里看到选项，但是。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_30.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_30.png)'
- en: if you install file utils you will see those options popping up in the sidebar。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你安装文件工具，你会在侧边栏中看到这些选项。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_32.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_32.png)'
- en: Next extension is get lens。 Get lens is a massive extension with a lot of additional
    functionality related to git。 So once you install it you can see line level annotations
    of who changed that line。 You can see file level annotations。 You can also see
    the git status in the status bar and you can toggle the git blame view。 You also
    get a new sidebar with a lot of information related to git。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个扩展是git lens。git lens是一个拥有大量与git相关附加功能的强大扩展。安装后，你可以看到每行的注释，了解是谁修改了这一行。你还可以看到文件级别的注释。在状态栏中也能看到git状态，并可以切换git
    blame视图。你还会得到一个包含许多与git相关信息的新侧边栏。
- en: So for example if your branch is behind or ahead of a given remote you can see
    branches。 contributors， incoming activity， stashes， tags and there is a lot of
    features here。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的分支落后于或超前于某个远程分支，你可以查看分支、贡献者、传入活动、存储、标签，功能非常多。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_34.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_34.png)'
- en: I don't think I'm even using like 10 or 20 percent of it。 Next there is jumpy
    or metago。 Those are two very similar extensions。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得我甚至没有使用10%或20%的功能。接下来是jumpy或metago。这两个扩展非常相似。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_36.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_36.png)'
- en: And what they do is that they help you quickly move around the code。 So let's
    see an example。 If I'm here in my code and I want to get let's say here I can
    either use my mouse or use。 the arrow key a couple of times but if you don't like
    using mouse this is not very convenient。 So what jumpy does is that it defines
    a keyboard shortcut that I can press and then it will。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的作用是帮助你快速在代码中移动。让我们来看一个例子。如果我在代码中，想要跳到某个地方，我可以使用鼠标或按几次方向键，但如果你不喜欢用鼠标，这就不太方便。那么，jumpy的作用就是定义一个我可以按下的键盘快捷键，这样就能。
- en: assign a two-letter shortcut to get to any place in my current screen。 So if
    I want to get to my password I need to press letter I and O and I get there。 If
    I want to move somewhere else I can press JF and I get here。 So once you get used
    to jumpy it's really fast way to move around your code。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 分配一个两字母的快捷键，以便快速到达当前屏幕上的任何位置。所以如果我想去我的密码那里，我需要按字母I和O，这样我就到了。如果我想去其他地方，我可以按JF，这样我就到了。一旦你习惯了jumpy，移动代码就非常快速。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_38.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_38.png)'
- en: Next is paste an indent。 So if you find that VS code is not doing a very good
    job when you paste some code you。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是粘贴并缩进。如果你发现VS Code在粘贴一些代码时效果不好，你可以。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_40.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_40.png)'
- en: can try this extension。 It's very useful for Python。 Let's see an example。 Let's
    say I want to take this piece of code and paste it here。 So as you can see by
    default it's not doing very good job。 And if I actually copy it like that then
    it's even worse。 So I have to go here and indent this。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试这个扩展。它对Python非常有用。让我们看一个例子。假设我想将这段代码复制到这里。如你所见，默认情况下效果并不好。如果我这样复制，那效果就更差了。所以我必须去这里进行缩进。
- en: go here and then that。 So if you don't like to indent lines by hand you can
    use this extension。 What it does it's going to give you a command called paste
    an indent action。 So you have to open your keyboard shortcuts， go to user shortcuts
    and then you have to assign。 this action to some keyboard shortcut。 I'm using
    command shift P and even though VS code is complaining that it can't recognize。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里，然后到那里。所以如果你不喜欢手动缩进行，可以使用这个扩展。它会给你一个名为“粘贴并缩进”的命令。你需要打开键盘快捷键，进入用户快捷键，然后给这个动作分配一个快捷键。我使用的是命令加shift加P，尽管VS
    Code抱怨它无法识别。
- en: this command it's because paste an indent is a very old extension and it hasn't
    been updated。 since like three years。 So even though we get this warning don't
    worry it's going to work。 If we go back here let's delete that。 So let's try again。
    We copy this， we go here and we paste it。 So as you can see it's better it's still
    not perfect because we have to indent this line。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令是因为粘贴并缩进是一个非常老的扩展，三年来没有更新。因此即使我们收到这个警告也不要担心，它会正常工作。如果我们回到这里，先删除它。再试一次。我们复制这个，然后去这里粘贴。所以如你所见，效果更好，但仍然不完美，因为我们需要缩进这一行。
- en: But at least we get this nice behavior that the pasted text gets selected。 So
    by default you're not going to get it， you have to go to the preference settings。
    You have to go to user settings and you need to add this line。 So just make sure
    that after pasting the code this extension will also select it so we can。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但至少我们得到了一个不错的行为，粘贴的文本会被选中。因此默认情况下你是得不到这个的，你需要去偏好设置。你需要进入用户设置，并添加这一行。确保在粘贴代码后，这个扩展也会选中它，以便我们可以。
- en: press tab to indent it or shift tab to unindent it。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 按下tab键来缩进，或按shift tab来减少缩进。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_42.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_42.png)'
- en: So it's a really nice and useful extension。 If you're working on more than one
    project on your computer then you probably already。 know the concept of workspaces
    in VS code。 It's a way of grouping together some files or folders so you can easily
    switch between。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一个非常不错且实用的扩展。如果你在电脑上同时处理多个项目，那么你可能已经知道VS Code中的工作区概念。这是一个将一些文件或文件夹组合在一起的方式，以便你可以轻松地在它们之间切换。
- en: them。 But with workspaces you have to store their configuration somewhere and
    sometimes you。 don't really know in which folder you saved your workspace configuration。
    So what I like about the project manager extension is that it takes this hassle
    away。 Basically it just creates a one file that stores the paths to your different
    folders。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 但是使用工作区时，你必须在某个地方存储它们的配置，有时你并不知道把工作区配置保存在哪个文件夹里。因此我喜欢项目管理器扩展，因为它消除了这个麻烦。基本上，它只创建一个文件，存储你不同文件夹的路径。
- en: and then it gives you a nice sidebar that you can use to switch between the
    projects。 Quick and simple text selection is a small utility that lets you assign
    keyboard shortcuts。 for different type of selections。 So if you want to select
    all the text inside a single quote。 double quote， parenthesis， angle brackets，
    curly brackets， you can do this with a shortcut。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它给你一个不错的侧边栏，你可以用来在项目之间切换。快速简便的文本选择是一个小工具，它让你为不同类型的选择分配快捷键。如果你想选择单引号、双引号、括号、尖括号或大括号内的所有文本，你可以用快捷键做到这一点。
- en: I really like it because VS code doesn't support these different selections
    out of the box。 Settings thing is an extension that you really want to have。 It
    lets you synchronize settings of your VS code between different computers。 So
    how it works is that you connect it to a private GitHub guest and then you export
    your， settings。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢这个，因为VS Code并不原生支持这些不同的选择。设置工具是你真的想要的扩展。它允许你在不同的电脑之间同步VS Code的设置。它的工作方式是将其连接到一个私有的GitHub存储库，然后你导出你的设置。
- en: Then if you lose your computer or you switch to another computer you can just
    download。 the settings back。 I think in one of the upcoming version of VS code
    the settings synchronization will become。 built in。 To do highlight is another
    small tool that highlights that to do or fix me comments in。 my code so I can
    easily spot them。 And finally there is spell right。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后如果你丢失了电脑或者换了另一台电脑，你可以轻松地下载设置。 我认为在即将发布的VS Code版本中，设置同步将会内置。To do highlight是另一个小工具，用于突出显示我代码中的待办事项或修复我评论，这样我可以轻松发现它们。最后还有spell
    right。
- en: It's strange but VS code doesn't have a built in spell checkers so if you want
    to check。 the spelling of your code or more important if you want to check the
    spelling of your。 comments this is the extension that you want to have。 The final
    part of the VS code section is a bug of miscellaneous tips and tricks that。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 很奇怪，VS Code没有内置的拼写检查器，因此如果你想检查代码的拼写，或者更重要的是检查评论的拼写，这就是你需要的扩展。VS Code部分的最后一部分是一些杂项提示和技巧的错误。
- en: I picked up along the way。 So you can take a look and maybe you'll find something
    useful there as well。 If you're using Docker there is a Docker extension that
    you will probably really like。 It lets you start and stop containers， connect
    to a running container with a shell or attach。 VS code to a running container。
    It's very useful。 If you're working with some colleagues and you want to share
    your screen or even better。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我在路上捡到的一些东西。所以你可以看一下，也许会发现一些有用的东西。如果你在使用 Docker，那么有一个 Docker 扩展你可能会非常喜欢。它可以让你启动和停止容器，连接到正在运行的容器并使用
    shell，或者将 VS code 附加到正在运行的容器上。这非常有用。如果你和一些同事一起工作，想要共享屏幕，或者更好的是。
- en: let them modify the code in your VS code。 Check out the live sharing extension
    and then there are some tips and tricks。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让他们修改你在 VS code 中的代码。查看实时共享扩展，还有一些小技巧和窍门。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_44.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_44.png)'
- en: You can use the out key to change the way how you split the windows。 If you
    have the outline sidebar you can select the follow cursor so you always see functions。
    corresponding to what you see in the main screen。 And for troubleshooting if you
    need to restart VS code you don't actually have to close it。 and then go to applications
    and open it again。 There is a command to reload the window that basically restarts
    the VS code for you。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 out 键来改变窗口的分割方式。如果你有大纲侧边栏，你可以选择跟随光标，这样你总能看到与主屏幕上所见内容相对应的函数。对于故障排除，如果需要重启
    VS code，实际上你不需要关闭它，然后去应用程序再打开一次。可以使用一个命令重新加载窗口，这基本上是为你重启 VS code。
- en: If you find that show symbols or go to definition stops working then you can
    try to change the。 auto completion engine。 By default VS code is using IntelliSense
    but if you install Python extension you will also。 get jedi which is another engine
    and sometimes switching engines will fix the show symbols。 or go to definition
    for me。 And finally if you're working with Django or Flask and you want to put
    a break point in。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现显示符号或转到定义停止工作，那么你可以尝试更改自动完成功能。默认情况下，VS code 使用 IntelliSense，但如果你安装了 Python
    扩展，你还会获得 Jedi，这是另一个引擎，有时切换引擎会修复显示符号或转到定义的问题。最后，如果你正在使用 Django 或 Flask，并希望在其中设置断点。
- en: your templates VS code can get confused if the HTML file that you're editing
    is really。 a Django template or not and maybe you won't be able to put a breakpoint
    there。 If you find this problem annoying you can change the setting for breakpoints
    and allow。 breakpoints everywhere so that way you can put breakpoints in any file。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你的模板 VS code 可能会混淆，如果你正在编辑的 HTML 文件确实是一个 Django 模板，可能你就无法在那里设置断点。如果你觉得这个问题烦人，你可以更改断点的设置，允许在任何地方设置断点，这样你就可以在任何文件中设置断点。
- en: Now that we have VS code configure let's talk about how to manage Python and
    Python packages。 on your computer。 In this part we are going to see how to install
    different versions of Python and how to easily。 switch between them but also how
    to isolate dependencies for your project and why do you。 care about isolating
    them。 Sooner or later you'll need to install a different version of Python on
    your computer。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置好 VS code，让我们来谈谈如何在你的计算机上管理 Python 和 Python 包。在这一部分，我们将看到如何安装不同版本的 Python，以及如何轻松切换它们，同时也讨论如何为你的项目隔离依赖项，以及你为什么需要关心隔离它们。迟早你需要在计算机上安装不同版本的
    Python。
- en: Probably sooner than later。 For example if you're using a MacBook then you'll
    have Python to install by default and。 you might be thinking well that's an outdated
    version so why don't I just update to Python， 3。 And this is a terrible idea because
    you have some software on your computer that relies。 on this old version of Python
    so if you change it you'll probably break some stuff on your。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会比你想的早。例如，如果你使用的是 MacBook，那么默认情况下你会安装 Python，而你可能会想，这个版本过时了，为什么不直接更新到 Python
    3 呢。这是个糟糕的主意，因为你的计算机上有一些软件依赖于这个旧版本的 Python，所以如果你更改它，你可能会破坏一些东西。
- en: computer。 And even if by chance you have Python 3 installed globally on your
    computer it's probably not。 the latest version and you shouldn't rely on a system
    wide Python。 This gets even more complicated if you're working on multiple Python
    projects and you。 want to have different Python 3 versions installed at the same
    time。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的计算机上。即使你碰巧在计算机上全局安装了 Python 3，它也可能不是最新版本，你不应该依赖系统范围的 Python。如果你正在处理多个 Python
    项目，并希望同时安装不同版本的 Python，这会变得更加复杂。
- en: For example if you're writing a Python library then you probably need to test
    it in at least。 a few recent versions of Python so let's say Python 3。6， 7， 8
    and maybe 3。9 and you need。 to have an easy way to switch between those versions。
    You can install each of them with separate prefix but that's a bit cumbersome
    and there's。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你正在编写一个Python库，那么你可能需要在至少几个最近的Python版本中测试它，比如Python 3.6、7、8，可能还有3.9，你需要有一种简单的方法在这些版本之间切换。你可以用不同的前缀安装每一个，但那有点麻烦。
- en: actually much easier way to handle this problem。 In this part of the tutorial
    I'm going to show you how to use Pyenv to install multiple。 versions of Python
    and how you can easily switch between them。 The easiest way to install Pyenv is
    to use Pyenv installer script。 It will install not only Pyenv but a few additional
    plugins like Pyenv doctor to verify。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 其实有一个更简单的方法来处理这个问题。在本教程的这一部分，我将向你展示如何使用Pyenv安装多个Python版本，以及如何轻松切换它们。安装Pyenv最简单的方法是使用Pyenv安装器脚本。它不仅会安装Pyenv，还会安装一些额外的插件，比如Pyenv
    doctor来进行验证。
- en: that the installation is fine。 Pyenv virtual environment which is really nice
    because it's a plugin to manage virtual。 environments that we'll be talking about
    next and a few more。 So if we go to Pyenv installer you can see that the recommended
    version is to run this。 core command。 If you don't trust running scripts from
    the internet which in general you shouldn't trust。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 安装是正常的。Pyenv虚拟环境非常好，因为它是一个管理虚拟环境的插件，我们接下来会讨论以及更多内容。如果我们去Pyenv安装器，你会看到推荐的版本是运行这个核心命令。如果你不信任来自互联网的脚本，通常你不应该信任它们。
- en: them， you can also use homebrew or simply clone the repository as explained
    in the installation。 section。 But I'm going to choose the easy way。 I open the
    terminal， paste it here， run it。 At the end of the installation you will see some
    instructions on how to add some code。 to your bash RC file or if you're using
    Z shell or fish it's going to be slightly different。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用Homebrew，或简单地克隆仓库，如安装部分所述。但我打算选择简单的方法。我打开终端，把它粘贴在这里，运行。在安装结束时，你会看到一些关于如何将代码添加到你的bash
    RC文件的说明，或者如果你使用Z shell或fish，稍微会有不同。
- en: But it's important to pay attention to this message。 So let's copy those lines
    and add it to our bash RC file。 And finally we have to restart the terminal。 To
    check that everything worked fine I'm just going to run pyenv command。 And it
    doesn't work because I'm using Z shell not bash so let's modify the Z shell RC
    file。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 但注意这个信息很重要。所以让我们复制这些行并将其添加到我们的bash RC文件。最后，我们必须重启终端。为了检查一切是否正常，我将运行pyenv命令。但这不工作，因为我使用的是Z
    shell而不是bash，所以让我们修改Z shell RC文件。
- en: And one more try。 Great， if you see a list of commands here it means that the
    pyenv was successfully installed。 Once you have installed pyenv make sure to check
    the dependencies section on github。 For my coas it mentions a few packages that
    are optional but recommended。 So if you notice that you have some problems using
    pyenv make sure to install them。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 再试一次。太好了，如果你在这里看到命令列表，这意味着pyenv成功安装。一旦你安装了pyenv，确保检查GitHub上的依赖部分。对于我的Mojave，它提到了一些可选但推荐的软件包。所以如果你发现使用pyenv有问题，请确保安装它们。
- en: You also have a list of dependencies for other operating systems。 And if you
    want to use pyenv on windows check out the pyenv win package。 It doesn't have
    all the features of pyenv but it has the essential ones so you will be。 able to
    install different versions of pyenv and switch between them without a hassle。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你还有其他操作系统的依赖列表。如果你想在Windows上使用pyenv，可以查看pyenv win包。它没有pyenv的所有功能，但有基本功能，所以你可以安装不同版本的pyenv并轻松切换。
- en: So if you are on my coas Mojave then there is this github issue that explains
    that you。 have to add additional SDK headers。 If you run version of both Mojave
    like Catalina then you don't need this step。 Let's try to install a new version
    of Python using pyenv。 To see the list of available versions we need to run pyenv
    install -list。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在我的Mojave上，那么有一个GitHub问题解释你需要添加额外的SDK头文件。如果你同时运行Mojave和Catalina版本，那么你不需要这一步。让我们尝试使用pyenv安装一个新的Python版本。要查看可用版本的列表，我们需要运行`pyenv
    install -list`。
- en: Here we can see all the versions that pyenv can install for us。 At the top you
    have the standard Python versions， then you have anaconda， mini-konda， you even。
    have pipy and some other stuff like stackless。 So let's try to install the most
    up-to-date version of Python so 3。8。2。 When we talked about the dependencies I
    showed you that for my coas some dependencies are。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以看到pyenv可以为我们安装的所有版本。顶部是标准的Python版本，然后是anaconda，mini-konda，甚至还有pipy和一些其他的东西，比如stackless。现在我们尝试安装最新版本的Python，即3.8.2。当我们谈到依赖关系时，我告诉过你，对于我的coas，一些依赖是可选的。
- en: optional and here since we didn't have open SSL pyenv is installing it for us。
    Done。 That took around 10 minutes so I'm really happy that I didn't try to do
    live coding and I。 can just fast forward it。 So now if we do pyenv versions we
    can see that we have the system version of Python and。 the 3。8。2 that we just
    installed。 Let's add another version。 If you don't have open SSL。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，由于我们没有open SSL，pyenv正在为我们安装它。完成了。大约花了10分钟，所以我真的很高兴我没有尝试实时编码，我可以直接快进。那么现在如果我们运行pyenv
    versions，我们可以看到系统的Python版本和我们刚安装的3.8.2。让我们添加另一个版本。如果你没有open SSL。
- en: readline or Z-lib dependencies pyenv will download them for each。 new version
    of Python that you try to install。 So normally I would install those dependencies
    using homebrew。 If we check installed version you can see we have two different
    Python versions installed。 If I try to run any Python command you can see that
    I'm still using the built-in Python， version。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: readline或Z-lib依赖关系，pyenv会为你尝试安装的每个新Python版本下载它们。所以通常我会使用homebrew安装这些依赖。如果我们检查已安装的版本，你会看到我们有两个不同的Python版本已安装。如果我尝试运行任何Python命令，你会看到我仍在使用内置的Python版本。
- en: So if we want to switch which version of Python we are using we need to use
    pyenv global， command。 If you just run pyenv global it's gonna tell you which
    Python you are using。 If you run pyenv global with a version number you will switch
    your Python to this version。 So now if I try to run Python command you can see
    that it has not changed。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们想切换正在使用的Python版本，我们需要使用pyenv global命令。如果你只运行pyenv global，它会告诉你正在使用哪个Python。如果你用版本号运行pyenv
    global，你将切换到这个Python版本。那么现在如果我尝试运行Python命令，你会看到它没有改变。
- en: So if this happens to you you need to run pyenv rehash。 I forgot to mention
    this but you need to run pyenv rehash after you install a new Python。 version
    so pyenv will set up everything for you。 So let's try to run Python command again。
    And voila now we are using the latest version of Python。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种情况发生在你身上，你需要运行pyenv rehash。我忘了提到这一点，但在你安装新Python版本后，你需要运行pyenv rehash，以便pyenv为你设置一切。那么让我们再试一次运行Python命令。瞧，现在我们正在使用最新版本的Python。
- en: If I want to switch to a different version all I have to do is run pyenv global
    and the。 different version。 And that's it every Python version is nicely isolated
    from each other and you don't have。 to worry that you will mess up something if
    you try to install another one。 So now we know how we can change the global Python
    version on our computer but another。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想切换到另一个版本，我所需要做的就是运行pyenv global和不同的版本。就是这样，每个Python版本都是彼此隔离的，你不必担心如果你尝试安装另一个版本会弄乱什么。那么现在我们知道如何更改我们计算机上的全局Python版本了，但还有另一个。
- en: cool feature of pyenv is that you can set a Python version for a specific directory
    and。 all its subdirectories。 It's a useful feature if you're working on a project
    that requires a different Python。 version。 For example you have some legacy code
    that is still using Python 2 and you only want to。 use Python 2 if you are in
    the specific directory。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: pyenv的一个酷功能是你可以为特定目录及其所有子目录设置Python版本。这是一个很有用的功能，尤其是在你正在处理需要不同Python版本的项目时。例如，你有一些仍在使用Python
    2的遗留代码，而你只希望在特定目录中使用Python 2。
- en: So instead of switching the global version back and forth all you have to do
    is to run。 pyenv local and this will create a Python version file。 Pyenv will
    always look for this file in the current directory and if it can find it then。
    it's going to use it to determine which version of Python you want to use。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，除了来回切换全局版本，你所需要做的就是运行pyenv local，这将创建一个Python版本文件。Pyenv总是会在当前目录中查找此文件，如果找到，它将用来确定你想使用哪个Python版本。
- en: So let's see this in action。 As you can see I'm using Python 3。8 globally and
    let's say I have a project that requires， an older version of Python。 So if I
    want to use Python 3。7 only in this folder all I have to do is to run pyenv local。
    and a Python version。 This will create Python version file and inside of it you
    can see which version of Python。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们看看这个实际操作。正如你所看到的，我在全局使用Python 3.8，假设我有一个项目需要旧版本的Python。所以如果我只想在这个文件夹中使用Python
    3.7，我要做的就是运行`pyenv local`，然后指定一个Python版本。这将创建一个Python版本文件，里面可以看到使用的Python版本。
- en: we want to use。 So if we run Python version command you can see that we are
    using Python 3。7 and if we， go outside of this directory you can see that globally
    we are still using Python 3。8。 So this is a really nice feature of pyenv especially
    if you're working on different projects。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要使用的。因此，如果我们运行`Python version`命令，你可以看到我们正在使用Python 3.7，而如果我们离开这个目录，你可以看到全局仍在使用Python
    3.8。这是pyenv的一个非常不错的功能，尤其是当你在不同项目中工作时。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_46.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_46.png)'
- en: that require different Python versions。 And the final feature of pyenv that
    I want to show you is how you can change Python version。 for only a specific terminal
    session。 So for example if you want to test something in let's say Python 2 you
    don't have to change。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目需要不同的Python版本。最后，我想向你展示的pyenv的一个功能是如何仅为特定的终端会话更改Python版本。例如，如果你想在Python
    2中测试某些东西，你不必更改。
- en: the local or global Python version。 All you have to do is to run pyenv shell
    command and provide it with the version number。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本地或全局Python版本。你要做的就是运行`pyenv shell`命令，并提供版本号。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_48.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_48.png)'
- en: So let's say I'm globally using Python 3。8 but for some reason I want to test
    something。 in Python 2。 On my computer I still have Python to install as a system
    Python so I can use that。 This command starts another shell session in our terminal
    so if I run Python version。 you can see that I'm using Python 2。 And we even have
    the warning Python 2。7 is not recommended。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我在全局使用Python 3.8，但出于某种原因我想在Python 2中测试一些东西。在我的电脑上，我仍然有安装作为系统Python的Python，因此我可以使用它。这个命令会在我们的终端中启动另一个shell会话，所以如果我运行`Python
    version`，你可以看到我正在使用Python 2。我们甚至收到警告，Python 2.7不推荐使用。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_50.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_50.png)'
- en: If you're wondering how does Python works and how does it install different
    Python versions。 without messing up anything on your computer all it does is it
    creates a directory of shims。 and puts some binary files like Python， peep， Python
    3。0 and then it inserts this directory。 at the beginning of your path variable。
    So each time you run command like Python or peep your computer instead of using
    the system。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道Python是如何工作的，以及它是如何安装不同的Python版本而不干扰你电脑上的任何东西，实际上它所做的就是创建一个shims目录，并放置一些二进制文件，如Python、pip、Python
    3.0，然后将这个目录插入到你的路径变量的开头。因此每次你运行像`Python`或`pip`这样的命令时，你的电脑就会从这个shim目录中获取二进制文件，而不是使用系统。
- en: wide commands will pick up the binaries from this shim directory。 And those
    binaries are not even real Python commands those are just pine scripts that。 will
    determine what's the current version of Python that you want to use and call binaries。
    from this version of Python。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛命令将从这个shim目录中获取二进制文件。而这些二进制文件甚至不是真正的Python命令，它们只是一些脚本，会确定你想要使用的当前Python版本并调用该版本的二进制文件。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_52.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_52.png)'
- en: And this whole idea of creating a shim directory and adding it at the beginning
    of the path。 variable is not new。 If you're using other programming languages
    then you probably already know ErbN。 NodeN， or GoN that do exactly the same thing
    but for different programming languages。 If you're programming in multiple languages
    check out the ASDFVM。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个shim目录并将其添加到路径变量开头的这个想法并不新颖。如果你使用其他编程语言，你可能已经知道ErbN、NodeN或GoN，它们做的正是相同的事情，但针对不同的编程语言。如果你在多种语言中编程，可以看看ASDFVM。
- en: This is a one tool to manage different versions of different programming languages。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种管理不同编程语言不同版本的工具。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_54.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_54.png)'
- en: So if you use it you don't have to install separately pi nth， node nth， ErbNth。
    With pi nth we solved one problem how we can easily switch between different versions
    of， Python。 But even if you're using the same version of Python all the time you'll
    have another problem。 managing Python dependencies。 So Python has one big problem
    you cannot have multiple versions of the same package installed。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你使用它，就不需要单独安装 `pip`、`node`、`erb`。使用 `pip` 我们解决了一个问题，即如何轻松切换不同版本的 Python。但即使你一直使用相同版本的
    Python，你还会面临另一个问题：管理 Python 依赖关系。Python 有一个大问题，即你不能安装同一包的多个版本。
- en: at the same time on your computer。 Since every package goes to the same directory
    you can't have Django 2 and let's say Django。 3 installed at the same time。 Each
    time you run peep installed Django people check if Django is already installed
    on your。 computer。 If not it's going to install the latest version。 You can also
    specify which version you want to have。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个包都安装在同一个目录下，所以你不能同时安装 Django 2 和 Django 3。每次运行 `pip install Django` 时，`pip`
    会检查 Django 是否已经安装在你的计算机上。如果没有，它将安装最新版本。你也可以指定你想要的版本。
- en: So for example if you want to have Django version 2 you will do peep install
    Django。 equal equal 2 and then peep will first check if you have this version
    of Django on your， computer。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想要 Django 版本 2，你需要运行 `pip install Django==2`，然后 `pip` 会首先检查你的计算机上是否已安装该版本的
    Django。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_56.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_56.png)'
- en: If you don't have it it's okay peep is going to install it。 If you have a different
    version of Django let's say version 3 peep will first uninstall。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有安装，也没关系，`pip` 会为你安装它。如果你有不同版本的 Django，比如版本 3，`pip` 会首先卸载它。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_58.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_58.png)'
- en: it and then install version 2 instead。 Great so now you have version 2 but if
    you switch to another project that is using version。 3 it will stop working。 There
    is no longer Django 3 on your computer。 So you can run peep install Django equal
    equal 3 which will uninstall version 2 of Django。 So now each time you switch
    a project you will be uninstalling some dependencies and installing。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后安装版本 2。很好，现在你有了版本 2，但如果你切换到使用版本 3 的另一个项目，它将停止工作。你的计算机上不再有 Django 3。所以你可以运行
    `pip install Django==3`，这将卸载 Django 的版本 2。每次切换项目时，你都在卸载一些依赖并重新安装。
- en: different versions and the more projects you have the more annoying this thing
    can be。 To solve this problem we can use virtual environments。 A virtual environment
    will prepend a folder with some binaries to your path variable。 So each time you
    run Python command you will automatically use Python and packages from。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 不同版本的问题会让你有多个项目时更加麻烦。为了解决这个问题，我们可以使用虚拟环境。虚拟环境会在你的路径变量中添加一个包含一些二进制文件的文件夹。因此，每次你运行
    Python 命令时，你将自动使用来自该虚拟环境的 Python 和包。
- en: this folder and if you run peep install you will install packages not globally
    but inside。 this virtual environment。 With virtual environments the main idea
    is that you should use separate virtual and for。 each of your Python project。
    So that way you won't mix the penances。 If you are using Python 3。3 or above then
    you don't have to install anything to use virtual， enf。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件夹内，如果你运行 `pip install`，你将安装的包不是全局的，而是在这个虚拟环境内。使用虚拟环境的主要思想是，每个 Python 项目应该使用单独的虚拟环境。这样，你就不会混合依赖。如果你使用
    Python 3.3 或更高版本，你不需要安装任何东西来使用虚拟环境。
- en: There is already a built-in module called venv that we can use to create virtual
    environments。 To create a new virtual environment run Python minus mvenv and then
    specify the name of the。 virtual environment。 This will create a directory named
    in the same way as you named your virtual environment。 and inside this directory
    you can see there is a bunch of folders and files。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有一个名为 `venv` 的内置模块，我们可以用它来创建虚拟环境。要创建一个新的虚拟环境，运行 `python -m venv`，然后指定虚拟环境的名称。这将创建一个目录，其名称与虚拟环境名称相同。在这个目录内，你可以看到有一堆文件和文件夹。
- en: The only one that we are actually interested in is inside the bin folder and
    it's called， activate。 When we run it this will activate this virtual environment。
    You can see that now we have the name of the virtual environment displayed in
    the terminal。 So it's a good way to see if we are currently using a virtual environment
    or not。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正感兴趣的只有一个，它在 bin 文件夹内，名为 `activate`。当我们运行它时，它会激活这个虚拟环境。你可以看到，现在我们在终端显示了虚拟环境的名称。所以这是一个很好的方式来检查我们当前是否在使用虚拟环境。
- en: Right now we are inside an isolated environment。 If we install some packages
    with peep they won't be installed globally they will be installed。 in this folder。
    Let's try it。 Let's say we want to install flask。 And if we do peep phrase to
    see the list of installed packages you can see that we have。 flask and its dependencies
    here。 To stop using this virtual environment we just have to run the activate
    command。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们处于一个隔离的环境中。如果我们用 peep 安装一些包，它们不会全局安装，而是安装在这个文件夹中。让我们试一下。假设我们想安装 flask。如果我们运行
    `peep freeze` 来查看已安装包的列表，你可以看到我们在这里有 flask 及其依赖项。要停止使用这个虚拟环境，我们只需运行激活命令。
- en: Now we are not using any virtual environment so if we try to list the peep packages
    you。 see that there are no global peep packages。 If we try to run flask we will
    get a message that flask is not installed。 Let's say we have another project where
    we are using a different version of flask。 So let's create another virtual environment。
    And now let's install previous version of flask。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们没有使用任何虚拟环境，所以如果我们尝试列出 peep 包，你会发现没有全局 peep 包。如果我们尝试运行 flask，我们会收到一条消息，提示
    flask 未安装。假设我们有另一个项目，使用不同版本的 flask。那么我们就创建另一个虚拟环境。现在让我们安装 flask 的旧版本。
- en: As you can see here we are using a different flask version。 And that's pretty
    much all you need to know about virtual environments。 Each time you start a new
    project create a new environment， use peep to install packages。 inside of it。
    And when you stop working on this project or you want to switch to a different
    one just。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里看到的，我们使用的是不同的 flask 版本。这就是关于虚拟环境你需要知道的所有内容。每次开始新项目时，创建一个新的环境，使用 peep 在其中安装包。当你停止这个项目的工作或想要切换到另一个项目时，只需停用环境。
- en: deactivate the environment。 Apart from the built in vnth module there are some
    other tools that will make using virtual。 environments slightly easier。 For example
    if you install pyenv using this pyenv installer then you also have installed。
    the pyenv virtualenv plugin。 So you can use it to create and manage a virtual
    environment。 The main advantage here is that you don't have to remember in which
    folder you created。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置的 `vnth` 模块，还有一些其他工具可以使使用虚拟环境稍微容易一些。例如，如果你使用这个 `pyenv installer` 安装了 `pyenv`，那么你也安装了
    `pyenv virtualenv` 插件。因此，你可以使用它来创建和管理虚拟环境。主要的优点是你不必记得在哪个文件夹创建了虚拟环境，`pyenv virtualenv`
    会为你处理这一切。
- en: which virtual environment pyenv virtualenv will take care of it for you。 To
    create a new virtual environment run pyenv virtualenv then specify the python
    version。 and the name of the environment。 You can see that no new folder was created。
    This is because pyenv is storing virtual environments in a separate directory。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的虚拟环境，运行 `pyenv virtualenv`，然后指定 python 版本和环境名称。你可以看到没有创建新的文件夹。这是因为 `pyenv`
    将虚拟环境存储在一个单独的目录中。
- en: To see the list of available virtual environments run pyenv virtualenv command。
    To activate one of them run pyenv activate and the name of the environment。 And
    to deactivate it just run pyenv deactivate。 Apart from pyenv virtualenv there
    is also virtualenv wrapper which is quite old but still。 very popular virtual
    environment management tool。 It has a very similar set of functionality but it's
    mostly using different commands。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用虚拟环境的列表，请运行 `pyenv virtualenv` 命令。要激活其中一个环境，请运行 `pyenv activate` 和环境的名称。要停用它，只需运行
    `pyenv deactivate`。除了 `pyenv virtualenv`，还有 `virtualenv wrapper`，这是一个相当老但仍然非常流行的虚拟环境管理工具。它的功能集非常相似，但大多使用不同的命令。
- en: And since virtualenv wrapper doesn't work with the fish shell I found that there
    is a。 tool called virtual fish that you can use instead。 It has the same set of
    functionality as virtual and wrapper but the commands are even shorter。 You may
    have heard about penv and if you're already using it I'm not going to suggest。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `virtualenv wrapper` 不支持 fish shell，我发现有一个工具叫做 `virtual fish` 可以替代。它与 `virtual`
    和 `wrapper` 的功能集相同，但命令更短。你可能听说过 `penv`，如果你已经在使用它，我不会建议使用它。
- en: you to change it but if you're looking to start using virtual environments I
    would not。 recommend using penv。 There are some issues with the maintenance of
    this project and since there are many good。 alternatives I suggest that you take
    a look at some other project。 One of those projects can be poetry which is a whole
    new way to manage Python projects。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更改它，但如果你想开始使用虚拟环境，我不建议使用 `penv`。这个项目的维护存在一些问题，而且有很多好的替代方案，我建议你看看其他项目。其中一个项目是
    `poetry`，这是一种全新的管理 Python 项目的方式。
- en: You can use it to generate a scaffolding for your project to manage dependencies，
    prepare。 it to be published on PPI etc。 So if you're looking for one comprehensive
    way to manage your Python projects you can。 check it out。 And finally if you come
    from data science part of Python community then you are probably。 familiar with
    anaconda。 It makes installing new Python versions and packages much easier。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用它为你的项目生成一个框架，以管理依赖项，准备发布到 PPI 等。如果你在寻找一种全面管理你的 Python 项目的方法，你可以看看这个。最后，如果你来自
    Python 社区的数据科学部分，那么你可能对 anaconda 很熟悉。它使安装新的 Python 版本和包变得更加容易。
- en: It automatically creates virtual environments and installs all dependencies
    inside of it。 When you use conda you don't have to worry about the missing dependencies
    they will usually。 be bundled together with the packages。 The main difference
    between pip and anaconda is that anaconda doesn't install packages。 directly from
    PPI。 It installs binaries which means that someone first has to build this binary
    and publish。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 它会自动创建虚拟环境，并将所有依赖项安装在其中。当你使用 conda 时，你不必担心缺少的依赖项，它们通常会与包一起捆绑。pip 和 anaconda
    之间的主要区别是，anaconda 不直接从 PPI 安装包。它安装的是二进制文件，这意味着必须有人先构建这个二进制文件并发布。
- en: it to anaconda repository。 Most of the time that won't be a problem。 If you
    stick to popular packages most of them are already available but if you want to
    install。 a new package or a package that you just created then well you can't。
    If you're using windows anaconda can make your life much easier so if you're having
    problems。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将其推送到 anaconda 仓库。大多数情况下，这不会成为问题。如果你坚持使用流行的包，大多数已经可用，但如果你想安装一个新包或你刚创建的包，那就不行了。如果你使用
    Windows，anaconda 可以让你的生活轻松很多，所以如果你遇到问题。
- en: using pip it's fine to use anaconda but I still suggest you to learn how to
    manage your dependencies。 with virtual environments and pip。 Even though it's
    more difficult than using conda that's what most Python developers are。 doing
    and it will give you much more flexibility in the long run。 So we solved the problem
    of separating dependencies between different projects。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pip 是可以的，虽然我仍然建议你学习如何管理你的依赖项，使用虚拟环境和 pip。尽管这比使用 conda 更困难，但这正是大多数 Python
    开发者所做的，这在长期内会给你带来更多的灵活性。因此，我们解决了不同项目之间依赖项隔离的问题。
- en: However sometimes there might be a situation where you want to use the same
    tool in all。 of your projects。 For example if you want to use black a code formatter
    or flake8 a linker you don't want。 to go to every virtual environment and install
    it there because it's a lot of work。 But you shouldn't also install it globally
    because the more packages you install globally。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时可能会出现你想在所有项目中使用相同工具的情况。例如，如果你想使用 black，一个代码格式化工具，或者 flake8，一个链接器，你不想去每个虚拟环境中安装它，因为那会非常麻烦。但你也不应该全局安装它，因为全局安装的包越多。
- en: the bigger the chance that some of their dependencies will conflict with each
    other and you will。 again end up in this situation that one package is uninstalling
    others。 To solve this problem you can install pipx。 pipx installs pip packages
    in separate environments but at the same time those packages act as。 if they are
    installed globally so you don't have to activate the virtual environment to， run
    them。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 安装包之间发生冲突的机会就越大，你最终会再次陷入一个包卸载其他包的情况。为了解决这个问题，你可以安装 pipx。pipx 会在独立环境中安装 pip 包，但同时这些包就像是全局安装的一样，因此你不需要激活虚拟环境就能运行它们。
- en: We can install pipx with pip or bro if you're on mac。 After the installation
    make sure that the path variable is updated by running pipx and。 sure path command。
    Now we can list all the packages by doing pipx list and install a new one by doing
    pipx。 install in a package name。 Let's check the list of pipx packages again here
    you can see we have black and it's exposing。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 pip 或者在 Mac 上使用 bro 安装 pipx。安装后，通过运行 pipx 和确保路径命令来确保路径变量已更新。现在我们可以通过执行
    pipx list 列出所有包，并通过执行 pipx install <包名> 安装一个新的包。让我们再次检查 pipx 包的列表，这里你可以看到我们有 black，并且它正在暴露。
- en: two commands black and black D and this is the location where pipx is creating
    its virtual。 environments。 So now if we do pip freeze you can see that black is
    not installed globally but if we。 try to run it it works。 You can also use pipx
    run command to run a command from pip package in a temporary virtual。 environment
    that will be deleted after the command exits。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 两个命令 black 和 black D，这是 pipx 创建虚拟环境的地点。所以现在如果我们执行 pip freeze，你会看到 black 并没有被全局安装，但如果我们尝试运行它，它是可以工作的。你还可以使用
    pipx run 命令在临时虚拟环境中运行 pip 包中的命令，该环境将在命令退出后被删除。
- en: So let's say we want to run flake 8 just once we don't really want to install
    it and。 as you can see even though we run flake 8 it has not been installed。 If
    you follow the first part of the workshop where we were setting up VS code you
    remember。 how we installed flake 8。 By default VS code was installing flake 8
    globally and I told you that it's not a good。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只想运行一次 flake 8，我们不想真正安装它。如你所见，即使我们运行了 flake 8，它也没有被安装。如果你记得在设置 VS code 的工作坊的第一部分，我们是怎么安装
    flake 8 的。默认情况下，VS code 会全局安装 flake 8，我告诉过你这不是一个好的做法。
- en: idea to do this。 So I'm going to show you how to configure VS code to use flake
    8 from pipx。 So first let's install flake 8 using pipx。 Now we need to get the
    path to the flake 8 binary。 So let's go here and as you can see flake 8 is here。
    So let's copy this path。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的想法。所以我将向你展示如何配置 VS code 以使用来自 pipx 的 flake 8。首先，让我们使用 pipx 安装 flake 8。现在我们需要获取
    flake 8 二进制文件的路径。所以让我们去这里，正如你所看到的，flake 8 在这里。所以让我们复制这个路径。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_60.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_60.png)'
- en: Let's go to VS code。 Open the settings that you can find here and search for
    flake 8。 You will see that there is path to flake 8 and by default it's just flake
    8 binary。 What you need to do is to replace this value with the full path to the
    flake 8 from the， pipx。 So now let's save it and we can run it and the path is
    invalid。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去 VS code。打开这里可以找到的设置并搜索 flake 8。你会看到有 flake 8 的路径，默认情况下它只是 flake 8 二进制文件。你需要做的是将此值替换为
    pipx 中 flake 8 的完整路径。所以现在让我们保存它，然后我们可以运行，但路径是无效的。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_62.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_62.png)'
- en: Well let's see what happened。 Ok so I know what's the problem。 This is not really
    a binary it's a folder so yeah we can go inside and then there is。 bin folder
    and there we have the binary。 So we have to use this full path instead。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们看看发生了什么。好的，我知道问题出在哪里。这实际上不是一个二进制文件，而是一个文件夹，所以我们可以进去，然后有一个 bin 文件夹，里面有二进制文件。所以我们必须使用这个完整路径。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_64.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_64.png)'
- en: Save it， we close the settings and yay we have an inter。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 保存它，我们关闭设置，太好了，我们有一个接口。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_66.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_66.png)'
- en: We can see it complaining so everything is fine。 We covered a lot of ground
    here so if some of those tools are new for you I have prepared。 a short exercise
    that you can use to practice using them。 Open exercise one and follow the instructions
    there。 If you already know pipx and you are already using visual environments
    you can skip this。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它在抱怨，所以一切都很好。我们在这里涵盖了很多内容，所以如果这些工具中的某些对你来说是新的，我准备了一个简短的练习，你可以用来练习使用它们。打开练习一并按照那里的说明进行。如果你已经知道
    pipx 并且已经在使用虚拟环境，你可以跳过这部分。
- en: exercise but if one of those tools are new for you I suggest that you follow
    them and。 if you have any questions take notes and you can ask your questions
    during the interactive。 session at PyCon。 I hope the exercise wasn't too difficult
    and you're not to board。 Let's switch gears and talk about something else than
    tools。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个练习，但如果这些工具中的一个对你来说是新的，我建议你跟着做。如果你有任何问题，请记笔记，你可以在 PyCon 的互动环节中提问。我希望这个练习不是太难，也希望你不会感到无聊。让我们转变话题，讨论一些与工具无关的内容。
- en: A very common question that I hear is how to properly structure a python project
    and I。 don't have one correct answer for this。 Python doesn't enforce any structure
    so as long as you know what you're doing you can。 organize your project however
    you like。 From the tools and frameworks that I know only Django will try to put
    some scaffolding。 for you but you can always ignore it and move stuff around。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我听到的一个很常见的问题是如何正确地构建一个 Python 项目，我没有一个正确的答案。Python 不强制任何结构，只要你知道自己在做什么，你可以随意组织你的项目。在我知道的工具和框架中，只有
    Django 会尝试为你搭建一些基础结构，但你可以随时忽略它并移动东西。
- en: When you first think about the structure of your project it might not sound
    complicated。 and usually it won't be。 But if you're not careful you'll probably
    hit one of the two common problems。 First the file that you try to import is not
    on the import path and this usually manifests。 through a module not found error
    or you are going to hit some circular import errors usually。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次考虑项目结构时，可能听起来并不复杂，通常也确实如此。但如果你不小心，你可能会遇到两个常见问题。首先，你试图导入的文件不在导入路径上，这通常表现为模块未找到错误，或者你会遇到一些循环导入错误。
- en: resulting in import error。 If you have never encountered these problems then
    probably me just talking about them is。 going to be boring for you。 So I suggest
    that you read the rest of this chapter on your own and if you ever have some。
    problems with the circular import errors or module not found errors I try to describe。
    the possible solutions and also linked to some explanations on stack overflow。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致导入错误。如果你从未遇到过这些问题，那么我仅仅谈论它们可能会让你感到无聊。因此，我建议你自己阅读本章的其余部分，如果你遇到循环导入错误或模块未找到错误的问题，我会尝试描述可能的解决方案，并链接到一些Stack
    Overflow的解释。
- en: In the meantime I would like to show you how we can structure our projects to
    avoid those。 problems and I would like to show you a tool that can help us with
    that。 Every Python project is different but quite often they share some common
    elements。 Writing a website in Django is no longer an exciting adventure into
    the world of web frameworks。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我想向你展示如何结构化我们的项目，以避免这些问题，并展示一个可以帮助我们的工具。每个Python项目都是不同的，但通常它们共享一些共同的元素。在Django中编写网站不再是进入网络框架世界的激动冒险。
- en: It's more likely a mundane creating the same HTML templates connecting them
    to URLs and。 writing some views that are extracting information from the database。
    And since thousands of developers rolled a Django or Flask application or published
    a。 Python package before you some people came up with an idea to extract common
    parts of。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这更像是一个平凡的任务，创建相同的HTML模板，将它们连接到URLs，并编写一些从数据库中提取信息的视图。由于成千上万的开发者在你之前都使用过Django或Flask应用程序，或发布过Python包，有些人想出了提取通用部分的想法。
- en: those applications and create a reusable scaffolding and that's how the cookie
    cutter。 project was born。 With cookie cutter you can create templates and then
    use those templates to generate scaffolding。 for your projects。 For example if
    you're writing a lot of Django websites you might notice that each of them。 has
    a similar structure。 So you might sit down and extract the similar parts into
    a template。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用程序创造了可重用的脚手架，这就是cookie cutter项目诞生的原因。通过cookie cutter，你可以创建模板，然后使用这些模板为你的项目生成脚手架。例如，如果你编写很多Django网站，你可能会注意到它们每个都有相似的结构。因此，你可以坐下来将相似的部分提取到一个模板中。
- en: put some placeholders， for example a website name， author。 date or the license
    and then when you need to create。 another website you will use this template to
    generate most of the code。 In this workshop we won't be writing a cookie cutter
    template but we'll be using one。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 放置一些占位符，例如网站名称、作者、日期或许可证，然后当你需要创建另一个网站时，可以使用这个模板来生成大部分代码。在这个研讨会上，我们不会编写cookie
    cutter模板，但我们将使用一个。
- en: So how to use it？ If you go to the cookie cutter website you can see that down
    there there is a list of。 different popular cookie cutter templates。 For example
    if you want to create a Python package you can use cookie cutter pie package。
    If you want to write a Flask website there are a few Flask skeletons。 The same
    for Django it's somewhere on this list。 Ah yeah。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何使用它呢？如果你访问cookie cutter网站，你会看到下方有一个不同流行cookie cutter模板的列表。例如，如果你想创建一个Python包，你可以使用cookie
    cutter pie包。如果你想编写一个Flask网站，有一些Flask框架可供选择。Django也是如此，它在这个列表中的某个地方。
- en: There are plenty of different Django templates even something for Pyramit and
    you even have。 templates for different languages。 There are templates for C。 C++
    so let's say we want to write a Python package using the， cookie cutter pie package
    template。 First we need to install the cookie cutter。 Notice that I'm using pipx。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的Django模板，甚至有适用于Pyramit的模板，还有适用于不同语言的模板。有C、C++的模板，所以假设我们想使用cookie cutter
    pie包模板来编写一个Python包。首先，我们需要安装cookie cutter。请注意，我使用的是pipx。
- en: Cookie cutter is a tool that I want to use across different projects so there
    is no point。 in storing it in the same virtual environment as my project。 I want
    it to be available globally on my computer。 Next we run cookie cutter command
    and we paste the URL to the github repository with the template。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie cutter 是我想在不同项目中使用的工具，所以没有必要将其存储在与我的项目相同的虚拟环境中。我希望它在我的计算机上全局可用。接下来我们运行
    cookie cutter 命令，并粘贴模板的 GitHub 仓库 URL。
- en: So in this case I want to use cookie cutter pie package。 Press enter and then
    cookie cutter is going to ask you a couple of questions。 The value in the brackets
    is the default value that is going to be used if you don't provide。 a different
    one。 Some of the questions are important some of them are not。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我想使用 cookie cutter pie 包。按下回车后，cookie cutter 会问你几个问题。括号中的值是默认值，如果你没有提供不同的值，它将被使用。有些问题很重要，有些则不然。
- en: For example here if you provide your full name it's going to be used mostly
    in the documentation。 or in the license files。 But later on you will see some
    questions that are actually quite important。 So let's fill in some information。
    Here I don't want to change the default value so I'm just going to press enter。
    Now we got to the point where the questions are actually important。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你提供全名，它主要会用于文档或许可证文件。但稍后你会看到一些实际上非常重要的问题。现在让我们填写一些信息。这里我不想更改默认值，所以我只是按下回车。现在我们到了问题实际上很重要的阶段。
- en: Here we need to decide if we want to use pipest as our testing framework or
    if we want to。 use something else like maybe the built-in unit test。 I want to
    use pipest so I select yes。 Here we can choose if you want to do pipi deployment
    with travis。 I don't want to use it so I would know。 I have no idea what's pie
    up batch so I'm going to go with the default no。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们需要决定是否要使用 pipest 作为我们的测试框架，或者是否想使用其他的，比如内置的单元测试。我想使用 pipest，所以我选择是。这里我们可以选择是否想通过
    travis 进行 pip 部署。我不想使用它，所以我会选择否。我不知道 pie up batch 是什么，所以我将使用默认的否。
- en: Here we can select a command line interface。 You can either use a popular click
    library the build in arc parse or you can choose to。 not use the command line
    interface。 Depending on your answer here cookie cutter will either add or remove
    some files that would。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以选择命令行接口。你可以使用流行的 click 库、内置的 arc parse，或者选择不使用命令行接口。根据你在这里的回答，cookie
    cutter 将会添加或删除一些文件。
- en: normally be a boilerplate for your CLI。 So let's say I want to use click so
    I select one。 I have no idea what's this author file so I'm going to say no and
    now I can select the， license。 Let's go with the default one。 If we look inside
    the current directory you can see that cookie cutter has created a directory。
    for us。 If we go inside you will see that there are a lot of files。 Let's use
    three command。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会是你的 CLI 的模板。所以假设我想使用 click，我选择一个。我不知道这个作者文件是什么，所以我会选择否，然后我可以选择许可证。我们就使用默认的。如果我们查看当前目录，你会看到
    cookie cutter 为我们创建了一个目录。如果我们进入里面，你会看到有很多文件。让我们使用三条命令。
- en: I can't use three。 The amount of files can be quite overwhelming especially
    if all you want to do is to create。 a very simple Python package but you can ignore
    most of them。 For example contributing will only contain some information for
    the contributors to your， project。 History is a place where you can store change
    log of your project。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法使用三条命令。文件的数量可能会让人感到不知所措，尤其是当你只想创建一个非常简单的 Python 包时，但你可以忽略大多数文件。例如，contributing
    仅包含一些供贡献者了解你项目的信息。History 是一个可以存储你项目变更日志的地方。
- en: Some of the files that you should care about are for example the make file。
    If you have never used make files before and you think they are scary you can
    ignore them。 for now but they can be a really good place to store your scripts。
    For example here you can see we have some commands to clean up compiled files
    to link。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该关注的一些文件，例如 make 文件。如果你从未使用过 make 文件，并且觉得它们很可怕，可以暂时忽略它们，但它们是存储脚本的好地方。例如这里你可以看到我们有一些命令来清理编译文件以进行链接。
- en: our files to run tests to generate the documentation or the code coverage and
    finally to install。 our package。 Then there is docs directory and this is where
    the documentation for your package will live。 This cookie cutter template is using
    sphinx to manage documentation and I will talk more。 about sphinx later in the
    workshop so we can skip this folder for now。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的文件用于运行测试、生成文档或代码覆盖，最后安装我们的包。然后是 docs 目录，这是你的包文档所在的位置。这个 cookie cutter 模板使用
    sphinx 来管理文档，我将在研讨会稍后讨论 sphinx，所以我们现在可以跳过这个文件夹。
- en: The my awesome python package directory is a place where the code of your python
    package， will live。 The name of this folder depends on what name you give to your
    package。 So as you can see cookie cutter is able to generate some files or folders
    in a dynamic。 way depending on what answers you provide。 Next we have requirements
    dev。txt file。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: my awesome python package 目录是你的 python 包代码的存放地。这个文件夹的名称取决于你给包的名称。因此，如你所见，cookie
    cutter 能够根据你提供的答案以动态方式生成一些文件或文件夹。接下来，我们有 requirements dev。txt 文件。
- en: This file contains a list of python packages that you will need for development。
    As you can see we have flake 8 for linting， pite test for running tests so those
    are not。 the packages that the end user of your package will use。 The end user
    packages are listed in setup。py and in some other projects you might find them，
    in file called requirements。txt。 Setup。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件包含你在开发过程中所需的 python 包列表。如你所见，我们有用于 linting 的 flake 8，运行测试的 pite test，因此这些不是你的包最终用户将使用的包。最终用户包在
    setup。py 中列出，在一些其他项目中，你可能会在一个叫 requirements。txt 的文件中找到它们。设置。
- en: py is probably the most complicated file in this whole directory。 It contains
    a bunch of settings that will let you publish your package on pite or install。
    it with pip。 The good news is it's already set up for you so you don't really
    have to touch it and。 as you can see here we have the end user requirements of
    our package and in this case。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: py 可能是这个目录中最复杂的文件。它包含一堆设置，可以让你在 pite 上发布你的包或使用 pip 安装它。好消息是它已经为你设置好，所以你不需要真的去动它，正如你所见，我们有我们包的最终用户需求。
- en: it's just a click package for the command line interface。 There is also setup。cfg
    file that contains settings for various tools that you will be， using during development。
    So as you can see there are settings for flake 8 for pite test。 This file is already
    pre-configured for you so you can also ignore it。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个命令行界面的点击包。还有一个 setup。cfg 文件，其中包含你在开发过程中将使用的各种工具的设置。因此，如你所见，这里有 flake 8
    和 pite 测试的设置。这个文件已经为你预先配置好，所以你也可以忽略它。
- en: If you want to start building a python package now all you have to do is go
    inside the my。 awesome python package， open the my awesome python package。py file
    and add some modules。 and functions here。 If you want to use a CLI you also want
    to modify the cli。py file。 As you can see there is already some code here that
    can help you start。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想现在开始构建一个 python 包，你只需进入 my。awesome python package，打开 my awesome python package。py
    文件并在这里添加一些模块和函数。如果你想使用 CLI，你还需要修改 cli。py 文件。如你所见，这里已经有一些代码可以帮助你入门。
- en: And then when your package is ready you will see that inside the make file there
    is release。 command that will build and publish your package on pite。 One advantage
    of using cookie cutter is that those templates will often provide you with。 some
    additional tools that might help you with the development process。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的包准备好后，你会看到在 make 文件中有一个 release。命令，它将构建并发布你的包到 pite。使用 cookie cutter 的一个优势是这些模板通常会提供一些额外的工具，可能会帮助你进行开发过程。
- en: And the most popular cookie cutter templates are a collaborative effort of many
    python， programmers。 So they will usually contain tools that have been used and
    tested by many other developers。 Not some shiny new toys found yesterday on hacker
    news。 For example the pie package cookie cutter that we just used installed talks。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的 cookie cutter 模板是许多 python 程序员的协作努力。因此，它们通常包含许多其他开发人员使用和测试过的工具，而不是昨天在
    hacker news 上找到的一些闪亮的新玩具。例如，我们刚刚使用的 pie 包 cookie cutter 安装了 talks。
- en: That is a very useful tool to run tests under different python versions。 And
    since you are writing a python package you probably want to test it under at least。
    a few recent python versions。 And it also installs things which is probably the
    most popular tool for writing documentation。 in python。 And again since you're
    writing a python package you probably want to document how to use it。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的工具，可以在不同的Python版本下运行测试。由于你在编写Python包，可能想在至少几个较新的Python版本下进行测试。同时，它还安装一些工具，可能是编写Python文档的最受欢迎工具。而且再次强调，既然你在编写Python包，你可能想记录如何使用它。
- en: Some templates will be more opinionated and they will install more tools。 Some
    of them will be more bare bone。 In the end it's up to you to decide which template
    you want to use and if you actually。 want to use all its features。 If you think
    that the template you found is too complicated just go to the cookie cutter。 website
    and search for another one。 For example if we want to build a flask website just
    search for flask and see what's there。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模板会更加主观，它们会安装更多工具。有些模板则更为简约。最终，选择使用哪个模板以及是否实际使用其所有功能，取决于你自己。如果你觉得找到的模板过于复杂，可以去cookie
    cutter网站搜索其他模板。例如，如果我们想构建一个flask网站，只需搜索flask，看看有哪些可用的资源。
- en: Here you can see we have a flask template with bootstrap。 Let's see how it looks
    like。 Ok so as you can see we'll get a pretty basic bootstrap website with some
    registration and。 login forms and SQL alchemy。 If you feel like you don't actually
    need all this stuff all you have to do is go back and。 search for another flask
    template。 Maybe you want a very bare bone flask application and here you can see
    there is a flask minimal。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里有一个带Bootstrap的flask模板。让我们看看它的样子。好的，如你所见，我们将获得一个相当基础的Bootstrap网站，包含一些注册和登录表单以及SQLAlchemy。如果你觉得其实不需要这些东西，你要做的就是返回去搜索另一个flask模板。也许你想要一个非常简约的flask应用程序，这里你可以看到有一个flask
    minimal。
- en: template that might be more suitable for you。 So as I said it's worth checking
    out at least a few different templates comparing what they。 have to offer and
    if you don't understand how something works either check the documentation。 of
    the template if it's mentioned there or just remove that code。 Apart from deciding
    how to structure your project there are some other important decisions。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 可能更适合你的模板。因此，如我所说，值得查看至少几种不同的模板，比较它们所提供的内容。如果你不明白某个功能如何工作，可以查看模板的文档，或者直接删除那段代码。除了决定如何构建你的项目，还有一些其他重要的决策。
- en: that you have to make and I'm not talking about how to architecture your application。
    whether to use a microservices or build a monolith which database is to use or
    how are。 you going to deploy and scale your application。 Now before we get to
    that there is something else that you need to sort out especially。 if you're working
    with other developers。 You have to decide on a cold style。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须做出的决定，我不是在谈论如何构建你的应用程序，是否使用微服务或构建一个单体，使用哪个数据库或如何部署和扩展你的应用程序。在我们讨论这些之前，还有其他事情需要理清，特别是如果你与其他开发人员合作。你必须决定一种代码风格。
- en: Things like taps or spaces how many characters per line whether you should use
    absolute or。 relative import and honestly I have seen people fighting more about
    the cold style than the。 overall architecture of the project。 And I understand
    it I have my own preferred way of writing code but if you're working。 with others
    sometimes you have to compromise。 So that's why we have PEP8。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 像制表符或空格、每行的字符数、是否使用绝对导入或相对导入，老实说，我见过人们更激烈地争论代码风格，而不是项目的整体架构。我理解这一点，我有自己偏爱的编码方式，但如果你与他人合作，有时需要妥协。这就是我们有PEP8的原因。
- en: It's a style guide for Python that documents how you should write your code
    and then we。 have PEP257 which is a style guide for the documentation。 Those two
    documents give us a very solid foundation on how to write and document our code
    and。 even if it's the first time you hear those two names if you're using the
    auto formatting。
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于Python的风格指南，记录了你应该如何编写代码，然后我们有PEP257，这是一个文档的风格指南。这两份文件为我们提供了关于如何编写和记录代码的坚实基础。即使这是你第一次听到这两个名字，如果你在使用自动格式化。
- en: feature of your code editor then your code is probably already compatible with
    those rules。 But I think documents for example how many spaces you should use
    for the indentation。 how to indent the closing parenthesis or the bracket， what's
    the recommended line length。 or how to sort import statements。 And unless you
    have a very good excuse you should follow those rules。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码编辑器有这些功能，那么你的代码可能已经兼容这些规则。但我认为文档中应该说明你应该使用多少个空格进行缩进，如何缩进闭合括号或方括号，推荐的行长度是多少，或者如何排序导入语句。除非你有非常好的理由，否则你应该遵循这些规则。
- en: The most common exception nowadays is the line length。 Since our screens are
    getting bigger and bigger increasing the limit beyond the 79 characters。 makes
    a lot of sense。 But even with PEP8 there is still some room to argue。 Like how
    do you split functions that have multiple lines， how many spaces you should。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最常见的异常是行长度。由于我们的屏幕越来越大，将限制提高到 79 个字符以上是非常合理的。但即使按照 PEP8，仍然有一些争论的余地。比如你应该如何拆分多行函数，应该使用多少个空格。
- en: use for the hanging parenthesis and stuff like that。 Discussions about those
    small details can waste a lot of time during the code reviews。 and to be honest
    there is no one perfect way how you should write your code。 So instead of focusing
    on those small details it's easier to use an automatic tool that。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 用于悬挂括号等小细节。关于这些小细节的讨论可能在代码审查过程中浪费很多时间。老实说，没有一种完美的方法来编写代码。因此，与其关注这些小细节，不如使用一个自动化工具。
- en: will fix those small problems for you and focus your code reviews on things
    that actually， matter。 So those tools is black。 Black will take your files and
    format them according to the PEP8 and PEP257 rules with。 some additional rules
    on top of that。 Black offers almost no customization。 The only setting that you
    should be able to change is the line length if you don't like。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 将为你修复这些小问题，并将你的代码审查集中在真正重要的事情上。所以这些工具就是 black。Black 将根据 PEP8 和 PEP257 规则以及一些额外规则格式化你的文件。Black
    几乎没有自定义选项。你唯一可以更改的设置是行长度，如果你不喜欢的话。
- en: the default 88 characters。 There are some options like skip string normalization
    that stops black from turning your single quotes。 to double quotes but according
    to the documentation you should not use it。 Black is opinionated。 Some people
    like it that way， some people don't。 I work with people who would merge a pull
    request because they don't like the code formatting。 So black takes those silly
    discussions away and helps you focus on what actually matters。
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下是 88 个字符。有一些选项，比如跳过字符串规范化，这样可以阻止 black 将单引号变为双引号，但根据文档你不应该使用它。Black 是有主见的。有些人喜欢这样，有些人不喜欢。我和那些因为不喜欢代码格式而合并拉取请求的人一起工作。所以
    black 消除了这些无聊的讨论，帮助你专注于真正重要的事情。
- en: So if you ask me I'm going to stick with it and unless you like fighting with
    people。 about cold style you should probably also use black too。 Ok so let's finally
    see black in action。 First we need to install it。 I suggest that you use PEPX
    since you want to use black globally in all your projects。 Yeah seems like I already
    installed it before。 Yeah as you can see we have two commands。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你问我，我会坚持使用它，除非你喜欢与人争论代码风格，否则你也应该使用 black。好了，让我们最后看看 black 的实际效果。首先我们需要安装它。我建议你使用
    PEPX，因为你想在所有项目中全局使用 black。是的，似乎我之前已经安装过它。是的，如你所见，我们有两个命令。
- en: Black and black D。 I think this is to start a demon。 So now if we have a piece
    of code that is ugly and this code is ugly on purpose。 I promise you I don't write
    code like that。 It's ok to hire me。 Now if we run black on this file you will
    see that it was reformatted and we even get。
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 黑色和黑色 D。我认为这是在启动一个恶魔。所以现在如果我们有一段故意丑陋的代码，我向你保证我不会写这样的代码。雇用我没问题。现在如果我们在这个文件上运行
    black，你会看到它被重新格式化了，我们甚至得到了。
- en: some nice emojis。 So let's see how it looks after the reform I think。 As you
    can see the imports are nicely aligned。 All the redundant white spaces are removed。
    The list is now on one line。 The dictionary has proper spacing between the key
    and the value。 So this code looks much nicer。 And if we try to run black again
    you'll see that this time there was nothing to change。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一些不错的表情符号。那么让我们看看经过格式化后的效果。我想。如你所见，导入语句整齐对齐，所有多余的空白都被移除了，列表现在在一行上，字典的键和值之间有适当的间距。所以这段代码看起来好多了。如果我们再次运行
    black，你会看到这次没有任何需要更改的地方。
- en: And that's how you would use black。 You can run it on the folder with your project。
    You can plug it to some continuous integration tool。 You can use tool like pre-commit
    to run it each time you create a new commit and get。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你如何使用`black`。你可以在项目文件夹上运行它。你可以将其插入某个持续集成工具中。你可以使用`pre-commit`这样的工具，在每次创建新提交时运行它。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_68.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_68.png)'
- en: Or you can just run it by hand as I just did。 Another set of tools that can
    help you write better Python code are static code analyzers。 One of the tools
    that I'm using all the time is called flake8。 Flake8 is a linter。 So unlike black
    it won't change your code but it will give you some hints about possible。 problems
    in your code。 And flake8 actually combines three different projects。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以像我刚刚做的那样手动运行它。还有一组工具可以帮助你编写更好的Python代码，它们是静态代码分析工具。我一直在使用的工具之一叫做`flake8`。`flake8`是一个代码检查工具。所以与`black`不同，它不会修改你的代码，但会给你一些关于可能存在的问题的提示。而且`flake8`实际上结合了三个不同的项目。
- en: PiFlex which gives you warnings about unused modules and defined variables and
    stuff like， that。 PiCult style which gives you warnings about pep8 violations
    and maccape which is disabled。 by default。 But if you enable it it will give you
    warnings about the psychlimatic complexity of your functions。 Which basically
    means how complicated your functions are。
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`PiFlex`可以给你关于未使用模块和已定义变量等内容的警告。`PiCult`风格会给你关于`pep8`违规的警告，而`maccape`默认是禁用的。但如果你启用它，它会给你关于函数的心理复杂度的警告。这基本上意味着你的函数有多复杂。'
- en: Flake8 integrates really nicely with VS code。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`flake8`与VS Code的集成非常好。'
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_70.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_70.png)'
- en: So let's take a look。 As you can see this is our ugly。py file with a lot of
    ugly Python code。 And all the reds quickly underlines are errors reported by flake8。
    So here on the first line we are importing a bunch of functions but we are not
    using， it。 Here it's complaining that we don't have two blank lines。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看。如你所见，这就是我们丑陋的`ugly.py`文件，里面有很多丑陋的Python代码。所有快速下划线的红色部分是`flake8`报告的错误。因此，在第一行我们导入了一堆函数，但并没有使用它。这里它在抱怨我们没有两个空行。
- en: Here that we are assigning a local variable my list and we are not using it。
    Same with the dictionary。 Here it's missing some wispaces and stuff like that。
    You can also see all the problems in the problem stop。 As you can see there is
    a lot of things here。 And if for some reason flake8 is not working for you and
    you want to enable it you can open。
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们为本地变量`my list`赋值，但并没有使用它。字典也是如此。这里缺少了一些空格和其他类似的东西。你还可以在问题停止处看到所有问题。如你所见，这里有很多内容。如果因为某种原因`flake8`对你不起作用，而你想启用它，可以打开。
- en: the comment palette。 Type select linker。 And then from the list here select
    flake8。 You can also experiment with other linters and I will talk about them
    in a few minutes。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注释调色板。输入`select linker`。然后从这里的列表中选择`flake8`。你也可以尝试其他的代码检查工具，我会在几分钟后讨论它们。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_72.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_72.png)'
- en: One of the reasons why flake8 is so popular is because it has a massive catalog
    of plugins。 that you can use to customize it。 Some of them will modify the default
    behavior of flake8 and others will give you additional。 options that you can use
    while running flake8。 You can find the list of most popular plugins on the awesome
    flake8 extension website。 It's a github repository with a huge list of different
    extensions。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`flake8`如此受欢迎的原因之一是它有一个庞大的插件目录，你可以用来进行自定义。其中一些会修改`flake8`的默认行为，而其他一些会在运行`flake8`时为你提供额外的选项。你可以在优秀的`flake8`扩展网站上找到最受欢迎插件的列表。那是一个包含各种扩展的GitHub库。'
- en: I have listed here some that I found quite useful and even if you are using
    flake8 I suggest。 that you take a look at this list because when I was preparing
    it I found a lot of useful。 stuff that I wasn't aware of。 Some of those extensions
    will add additional checks for example to make sure that you are。 not overwriting
    the built-in variables and that you don't make some silly mistakes。
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里列出了一些我发现非常有用的工具，即使你在使用`flake8`，我建议你也看看这个列表，因为在准备时我发现了很多我之前不知道的有用工具。其中一些扩展将增加额外的检查，例如确保你没有覆盖内置变量，也不会犯一些愚蠢的错误。
- en: Stuff like flake8 comprehensions will suggest you places where you can use lists，
    set or。 dictionary comprehensions over a for loop。 There is also flake8 dockstrings
    which will enforce pep257 and many more plugins like that。 If you are using a
    lot of flake8 plugins between multiple projects check out the flake hell。 or talks。
    They will both let you install and configure all flake8 plugins by modifying one
    configuration。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 像flake8 comprehensions这样的工具会建议你可以使用列表、集合或字典推导式替代for循环的地方。还有flake8 dockstrings，它会强制执行pep257和许多其他类似的插件。如果你在多个项目之间使用很多flake8插件，可以查看flake
    hell或相关讲座。它们都允许你通过修改一个配置来安装和配置所有flake8插件。
- en: file so you don't have to go to each of your projects and manually do pip install
    flake8。 this extension and that extension。 It's a useful tool。 In case you haven't
    yet installed flake8 this is how you can do this。 I suggest that you use pipx
    so flake8 is available globally but it's still separated。
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 文件这样你就不需要去每个项目手动执行`pip install flake8`。这个扩展和那个扩展。它是一个有用的工具。如果你还没有安装flake8，这就是你可以做的。我建议你使用pipx，这样flake8可以全局可用，但仍然是分开的。
- en: from the other dependencies that you have and if you use pipx and you want to
    install flake8。 plugins to the same virtual environment where the flake8 lives
    you will have to use pipx。 inject function。 And if you want to run flake8 on your
    folder instead of using VS code just run this command。 Flake8 and black are the
    two tools that I'm using everywhere where I can but there are。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从你拥有的其他依赖关系中，如果你使用pipx并想要在flake8所在的同一个虚拟环境中安装flake8插件，你需要使用pipx inject函数。如果你想在你的文件夹上运行flake8，而不是使用VS
    code，只需运行这个命令。Flake8和black是我在任何可以的地方使用的两个工具，但还有其他。
- en: some other static code analyzers。 Another popular linter is a pilot。 It has
    some overlap with flake8 but you can safely use both of them at the same time。
    Just keep in mind that pilot is much more strict than flake8。 It will complain
    if you have too few public methods， too many local variables or classes。
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他静态代码分析工具。另一个流行的linter是pilot。它与flake8有一些重叠，但你可以安全地同时使用它们。只需记住，pilot比flake8要严格得多。如果你有太少的公共方法、太多的局部变量或类，它会抱怨。
- en: with no init method。 It's much easier to write code that will make flake8 happy
    than it is to write pilot。 compatible code。 So try running pilot on your existing
    project and see if you like it。 Next tool is Bandit。 Bandit is designed to find
    common security issues in your Python code。 If you run it out of the box it will
    give you plenty of false positives。
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 没有init方法。编写让flake8满意的代码要比编写与pilot兼容的代码简单得多。所以尝试在现有项目上运行pilot，看看你是否喜欢。下一个工具是Bandit。Bandit旨在查找Python代码中的常见安全问题。如果你直接运行它，它会给你很多误报。
- en: For example it will complain about using assert statements in your pilot files。
    But if you spend some time and configure it it will print some possibly useful
    information。 about insecure usage of some modules， possible SQL injection points，
    silently ignoring exceptions。 and stuff like that。 If you're a beginner Bandit
    can be a good tool that will help review your code。
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，它会抱怨在你的pilot文件中使用assert语句。但如果你花一些时间配置它，它会打印一些可能有用的信息，关于一些模块的不安全使用、可能的SQL注入点、默默忽略异常等等。如果你是初学者，Bandit可以是一个帮助你审查代码的好工具。
- en: PyDoc style is a tool that will make sure that your documentation is written
    according。 to the PEP257 rules。 Just keep in mind that it will complain about
    missing documentation of every function or。 module that you didn't bother to write。
    Then there's vulture that will help you find unused code and we make Python style
    guide。 which is another strict linter that combines flake 8， bunch of flake 8
    extensions and some。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: PyDoc style是一个确保你的文档按照PEP257规则书写的工具。只需记住，它会抱怨你没有编写的每个函数或模块缺少文档。然后有vulture，它会帮助你找到未使用的代码，以及我们创建的Python风格指南，这是另一个严格的linter，结合了flake8、一堆flake8扩展和一些。
- en: custom rules on top of that。 It's very strict so it might be too much for your
    project but maybe you'll actually like。 it。 And finally there is prospector which
    is like flake 8 but instead of pie flake it's using。 pilint。 So it's a combination
    of pilint， pie code style and maccape。 And my final tip here is that you can automate
    most of those plugins by using the pre-commit， tool。
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的自定义规则。它非常严格，所以可能对你的项目来说有些过于苛刻，但也许你会喜欢它。最后还有prospector，它像flake8，但使用的是pylint。因此，它是pylint、pylint代码风格和maccape的组合。我的最终建议是，你可以通过使用pre-commit工具自动化大多数这些插件。
- en: So pre-commit lets you plug linters， formators and static code analyzers as
    git hooks and。 they will be automatically run when you create a commit。 Check
    out this link to see how to set up black and flake 8 as pre-commit hooks。 Another
    tool that you will use very often if you write Python code is the interactive
    Python。
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 pre-commit 让你将 linters、格式化工具和静态代码分析器作为 git hooks 插入，它们会在你创建提交时自动运行。查看这个链接，了解如何将
    black 和 flake 8 设置为 pre-commit hooks。如果你写 Python 代码，另一个你将非常常用的工具是交互式 Python。
- en: shell or the read evil print loop。 It's this type of shell that you get when
    you type Python in your command line interface。 and here you can execute some
    Python code。 It's nice to have the Python REPL so you can test your code interactively
    but the basic。
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: shell 或读取-评估-打印循环。这种类型的 shell 是当你在命令行界面输入 Python 时得到的，在这里你可以执行一些 Python 代码。拥有
    Python REPL 很好，这样你可以交互式地测试代码，但基本的。
- en: Python REPL is well basic and in the long run it's not very convenient to use。
    There are a few different ones。 The most popular one is IPython。 It's the same
    REPL that runs behind the Jupyter notebooks so even if you never used IPython。
    directly you might be familiar with it。 We can install IPython using pip or pipx。
    Again。
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Python REPL 是基本的，从长远来看使用起来并不方便。有几种不同的选择。其中最受欢迎的是 IPython。这是运行在 Jupyter notebooks
    背后的 REPL，所以即使你从未直接使用过 IPython，你可能对它有所熟悉。我们可以通过 pip 或 pipx 安装 IPython。
- en: I recommend pipx since this is a tool that you will share between all your projects。
    The only difference for you now is that if you want to start an interactive session
    you。 just have to type IPython instead of Python。 Some of the best features of
    IPython are the tab completion。 If you press tab in a standard Python shell well
    it's gonna insert tab。
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐 pipx，因为这是一个你将在所有项目之间共享的工具。现在对你来说唯一的区别是，如果你想开始一个交互式会话，你只需输入 IPython 而不是 Python。IPython
    的一些最佳功能是 tab 补全。如果你在标准的 Python shell 中按 tab，它会插入 tab。
- en: If you press tab in IPython it's gonna show you a list of possible auto-completion
    items。 just like your code editor。 We also get syntax highlighting， better error
    messages。 If you start writing a function or a loop IPython will detect that and
    automatically indent。 the next line if you press enter and finally my favorite
    feature of IPython the dynamic。
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 IPython 中按 tab，它会显示一系列可能的自动完成项，就像你的代码编辑器一样。我们还可以获得语法高亮，更好的错误信息。如果你开始编写函数或循环，IPython
    会检测到这一点，并在你按下回车时自动缩进下一行，最后我最喜欢的 IPython 特性是动态。
- en: object introspection。 You can see the documentation of any object in Python
    by just appending a question mark to。 the end of this object。 And it works for
    any type of object。 Options， modules， building modules。 third party libraries，
    a variable that you just defined， anything。 And if the doc string is not enough
    you can append two question marks to see the complete。
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 对象内省。你只需在这个对象的末尾添加一个问号，就可以查看 Python 中任何对象的文档。这适用于任何类型的对象。选项、模块、构建模块、第三方库、你刚定义的变量，任何东西。如果文档字符串不够，你可以添加两个问号来查看完整内容。
- en: source code of this object。 I really like this feature because I no longer have
    to leave the terminal to search for the。 documentation。 IPython also comes with
    a bunch of magic functions。 Those are helper functions that start with one or
    two percentage signs and you can use。 them for example to quickly measure the
    execution time of some code， run a file， browse a history。
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象的源代码。我非常喜欢这个功能，因为我不再需要离开终端去查找文档。IPython 还带有一堆魔法函数。这些是以一个或两个百分号开头的辅助函数，例如你可以用它们快速测量某段代码的执行时间、运行文件、浏览历史记录。
- en: of the previous IPython sessions， rerun some previous commands or open a code
    editor to。 edit some code before executing it。 And you can always write your own
    magic function if you want。 If you think IPython is interesting and you want to
    learn more， check out the IPython documentation。 for a good overview of different
    features。 If you prefer a more visual demonstration。
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的 IPython 会话，重新运行一些之前的命令或打开代码编辑器在执行之前编辑一些代码。如果你愿意，你也可以随时编写自己的魔法函数。如果你觉得 IPython
    有趣并想了解更多，查看 IPython 文档，获取不同功能的好概述。如果你更喜欢更直观的演示。
- en: I gave a presentation about IPython last year。 It's a 45 minute long fast paced
    talk where I go through most of its features。 Watching it on YouTube is probably
    better than seeing in life as you can always stop。 and test the feature if you
    find it interesting。 So I really recommend you that you start using IPython instead
    of the default Python。 REPL。 Even if you don't care about most of its features，
    the tap completion syntax highlighting and。
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我去年做了一次关于IPython的演讲。这是一场时长45分钟、节奏很快的演讲，我介绍了它的大部分功能。在YouTube上观看可能比现场观看更好，因为你可以随时暂停，测试感兴趣的功能。因此，我强烈建议你使用IPython，而不是默认的Python
    REPL。即使你对大部分功能不感兴趣，自动补全和语法高亮也值得一试。
- en: automatic indentation alone will make your life much easier。 And if you don't
    like IPython there are some other Python REPLs out there。 They don't have as many
    features as IPython but they have different features。 So maybe you will prefer
    one of them。 We have BPython with syntax highlighting， auto-completion。
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 光是自动缩进就能让你的生活轻松很多。如果你不喜欢IPython，还有其他Python REPL可供选择。它们的功能不如IPython丰富，但各有特色。所以你可能会更喜欢其中之一。我们有BPython，提供语法高亮和自动补全。
- en: automatic indentation and， features like rewind that lets you remove the last
    command that you executed。 And we also have PTPython with a similar set of features
    and a slightly more advanced。 interface with some menus， some emax key bindings
    and stuff like that。 Once you wrote some code you want to make sure that it works。
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 自动缩进和像rewind这样的功能可以让你撤销最后执行的命令。我们还有PTPython，提供类似的功能以及稍微更先进的界面，带有一些菜单和Emacs键绑定等。一旦你编写了一些代码，你需要确保它能够正常工作。
- en: And I don't mean if it works now because you just wrote it you clicked stuff
    around。 so you are sure that everything is fine。 But we need to make sure that
    it will still work after someone else changes some other。 piece of code。 So let's
    talk about writing tests。 Python comes with a unit test module that you can use
    for writing tests。 It's very basic in terms of features and at the same time it's
    overcomplicated in terms。
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我不是说现在能用就行，因为你刚写过，点击了一些东西，所以你肯定一切正常。但我们需要确保在其他人修改了其他代码后，它仍然能够工作。所以让我们谈谈编写测试。Python自带一个单元测试模块，你可以用它来编写测试。这个模块在功能上非常基础，同时在复杂性上又显得过于繁琐。
- en: of how many different assertions you have to remember。 So I suggest that you
    learn Pytest instead。 Pytest is probably the most popular Python library nowadays。
    It's packed with features but at the same time it stays very beginner friendly。
    You don't have to write classes that inherit from unit test test case。
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 关于你需要记住多少不同断言。因此，我建议你学习Pytest。Pytest现在可能是最受欢迎的Python库。它功能丰富，但同时也对初学者非常友好。你不需要编写继承自单元测试用例的类。
- en: You just write functions that starts with test。 You don't have to memorize assert
    equal。 assert true， assert in。 All you have to do is to use assert something equals
    equals something else。 And that's pretty much it。 If you need something more advanced。
    Pytest has a lot of additional features and a very， vast ecosystem of plugins。
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需编写以test开头的函数。你不需要记住assert equal、assert true或assert in。你只需使用assert某个东西等于另一个东西，这样就可以了。如果你需要更高级的功能，Pytest有很多额外特性和一个庞大的插件生态系统。
- en: To start using Pytest， install it with pip。 The only with pipx。 different projects
    might use different Pytest configurations or different， Pytest plugins。 So you
    don't want to install a global version， you want to install Pytest in each of
    your， projects。 Once you install Pytest， create a tests directory in the root
    folder of your project。
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Pytest，使用pip进行安装。由于不同项目可能使用不同的Pytest配置或插件，所以你不想安装全局版本，而是希望在每个项目中安装Pytest。一旦安装了Pytest，在项目的根文件夹中创建一个tests目录。
- en: Create files starting with test_inside。folder and then write functions that
    starts with test_inside。
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以test_inside开头的文件夹，然后编写以test_inside开头的函数。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_74.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_74.png)'
- en: those files。 If you follow this advice， Pytest will work out of the box for
    you。 Once you write some tests， go back to the terminal and run Pytest command。
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件。如果你遵循这个建议，Pytest将开箱即用。一旦你编写了一些测试，返回终端并运行Pytest命令。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_76.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_76.png)'
- en: Pytest will detect all the tests and run them for you。 As you can see here。
    Pytest detected four tests。 Three of them in a file called TestMuff that I used
    when I was showing you how to run test。 in VS code and one more in the TestMuff
    operations file。 The last one has failed and you can see a trace bug and error
    message。
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest会检测所有测试并为你运行它们。如你所见，Pytest检测到四个测试。其中三个在我向你展示如何在VS Code中运行测试时使用的一个名为TestMuff的文件中，另外一个在TestMuff操作文件中。最后一个测试失败了，你可以看到追踪的错误信息。
- en: So now you can go and fix this test。
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以去修复这个测试了。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_78.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_78.png)'
- en: So that's how you can use Pytest。 There are some other Pytest features or testing
    features in general that you'll probably need。 to use in your test， so let's talk
    about them。 First， fixtures。 Let's use an example。 Let's say you have an e-commerce
    website where you sell some stuff。 You want to make sure that everything works
    fine because you don't want to give your products。
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你如何使用Pytest的。还有一些其他的Pytest特性或者一般的测试特性你可能需要在测试中使用，让我们来谈谈它们。首先是夹具。让我们用一个例子。假设你有一个电子商务网站，出售一些商品。你想确保一切正常，因为你不想免费赠送产品。
- en: for free if there is a bug。 So you write some tests。 You check if a user can
    log in。 you add some products to the cart， you go through the checkout， process。
    And for each test。 you need to create a user。 So instead of writing code that
    creates a new user inside of every test。 you decide to， extract this user creation
    to a separate function and then run this function at the beginning。
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有bug的话。所以你编写一些测试。你检查用户是否可以登录，添加一些产品到购物车，进行结账过程。对于每个测试，你需要创建一个用户。因此，你决定将用户创建提取到一个单独的函数中，然后在开始时运行这个函数。
- en: of each test。 So actually this use case where you need a specific object to
    exist at the beginning。 of a test is such a common scenario that the idea of fixtures
    was born。 A fixture is a function that returns an object。 In our case， the user
    object。 but it can be anything。 It can be an item in your shop。 It can be a database
    connection。
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试的开始。因此，实际上，这个用例需要在测试开始时存在特定对象是一个非常常见的场景，因此夹具的概念应运而生。夹具是一个返回对象的函数。在我们的案例中，是用户对象，但它可以是任何东西。它可以是你商店中的一件商品，也可以是一个数据库连接。
- en: And then you can use this fixture in your test。 So to create a fixture in PyTest。
    all you have to do is to write a function and then， decorate it with PyTest fixture
    command。 If you don't know what a decorator is， don't worry， just put this piece
    of code over a function。
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以在测试中使用这个夹具。要在PyTest中创建一个夹具，你只需编写一个函数，然后用PyTest夹具命令装饰它。如果你不知道什么是装饰器，不用担心，只需将这段代码放在一个函数上方。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_80.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_80.png)'
- en: and it will turn it into a fixture。
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将变成一个夹具。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_82.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_82.png)'
- en: And then to use a fixture in your function， you need to pass this fixture as
    an argument。 to your function。 And as a side note， if you want to have the same
    fixture in multiple files。 just put this， fixture inside a file called conftest。py。
    PyTest will automatically load all the fixtures from this file in all your tests。
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后要在你的函数中使用夹具，你需要将这个夹具作为参数传递给你的函数。作为附注，如果你想在多个文件中使用相同的夹具，只需将这个夹具放在一个名为conftest.py的文件中。PyTest将自动在你所有的测试中加载此文件中的所有夹具。
- en: Next concept is mocking and monkey patching。 So let's say that on your e-commerce
    website。 you want to test that if a user buys something， first you charge his
    credit card and if everything went fine。 you send him his order。 Well you can't
    charge a real credit card each time you run tests。 Okay。 technically you can if
    you're very rich， but let's assume we are not very rich and。
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个概念是模拟和猴子补丁。假设在你的电子商务网站上，你想测试如果用户购买某样东西，首先扣取他的信用卡，如果一切顺利，你就发送他的订单。每次运行测试时，你无法扣取真实的信用卡。好吧，从技术上讲，如果你非常富有是可以的，但我们假设我们不是很富有。
- en: we want to avoid losing money。 So that's why you need a mock。 a fake object
    that you can use in place of a real one。 So instead of sending credit card details
    to Stripe， which is a very popular payment processor。 you replace Stripe with
    a mock object。 This mock object should return a success message if you provide
    it with correct parameters。
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望避免亏损。这就是你需要一个模拟的原因，一个可以代替真实对象的假对象。因此，不是将信用卡信息发送到Stripe，这是一种非常流行的支付处理器，而是用一个模拟对象替代Stripe。这个模拟对象应该在你提供正确参数时返回成功信息。
- en: The whole point of mocking is that it's not your job to test if Stripe works
    fine。 All you need to do is to make sure that you send correct data to Stripe
    and then that you。 accept and process whatever information comes back from Stripe。
    So let's say in our code we have a charge customer function that takes an amount
    of money。
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟的整个意义在于你不需要测试Stripe是否正常工作。 你需要确保将正确的数据发送给Stripe，然后接受和处理从Stripe返回的任何信息。 所以假设在我们的代码中有一个charge
    customer函数，它接受一个金额。
- en: and sends it to the Stripe through Stripe API。 Back from the Stripe we get a
    response and the response has a status。 We check if the status is equal to success
    and then if it is we set the status of the。 current order to processing。 By the
    way， this is a completely dumby code that won't work with Stripe。 It's here just
    for the illustration purpose。 Then in our test payment function we need to pass
    the monkey patch function and then。
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过Stripe API将其发送给Stripe。 从Stripe返回后，我们收到一个响应，并且该响应具有状态。 我们检查状态是否等于成功，如果是，则将当前订单的状态设置为处理中。
    顺便说一下，这是一段完全无用的代码，无法与Stripe配合使用。 这里只是为了说明目的。 然后在我们的测试支付函数中，我们需要传递猴子补丁函数。
- en: we use this monkey patch function to replace the charge attribute of the Stripe
    object with。 something that just returns a dictionary with status equal success。
    Then when the charge customer function is called and it gets to the point when
    it executes， Stripe。charge it won't execute a real function our mock will kick
    in and it will automatically。
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个猴子补丁函数将Stripe对象的charge属性替换为。 返回一个状态等于成功的字典。 然后，当调用charge customer函数并执行Stripe。charge时，它不会执行真实函数，我们的模拟将介入并自动。
- en: return the dictionary with the status equal success。 That way no information
    actually gets to Stripe and we can assert that if Stripe returns success。 the
    current order status is set to processing。 Alright I have a joke for you。 A tester
    walks into a bar。 He orders a beer， he orders zero beers， he orders 1 million
    beers。
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个状态等于成功的字典。 这样就没有信息实际发送给Stripe，我们可以断言，如果Stripe返回成功，当前订单状态被设置为处理中。 好吧，我给你讲个笑话。
    一个测试员走进酒吧。 他点了一杯啤酒，他点了零杯啤酒，他点了一百万杯啤酒。
- en: he orders a lizard， he orders -1 beers。 Then at first customer walks into a
    bar he asks where the bathroom is。 The bar bursts into flames killing everyone。
    So there is an important lesson in this old and moderately funny joke and it's
    not about。 fire extinguisher or fire escapes。 You probably want to test your functions
    with a lot of different inputs and Pytest has a。 feature just for you。 You can
    parameterize your test。
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 他点了一只蜥蜴，他点了-1杯啤酒。 然后第一个顾客走进酒吧，他问洗手间在哪里。 酒吧突然起火，烧死了所有人。 所以在这个古老而略显搞笑的笑话中有一个重要的教训，而不是关于灭火器或逃生通道。
    你可能希望用很多不同的输入测试你的函数，而Pytest有一个功能正好适合你。 你可以对你的测试进行参数化。
- en: So you have to decide which part of your test can change。 In case of our e-commerce
    website that could be the number of orders and the size of a single。 order。 And
    then you write one test that accepts those changing parts as parameters and use
    Pytest。mark， parameterize decorator to pass different values to those parameters。
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你必须决定测试的哪个部分可以改变。 在我们的电子商务网站中，这可以是订单数量和单个订单的大小。 然后你写一个接受这些可变部分作为参数的测试，并使用Pytest.mark，parameterize装饰器将不同的值传递给这些参数。
- en: If you look at this example Pytest will actually turn this test into four different
    tests。 In the first one the number of orders and the order size will be equal
    to 1。 Then in the second test the number of orders will be equal to 100 and the
    order size will。 be equal to 1。 Then device versa and then both of them will be
    equal to 50。
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这个例子，Pytest实际上会将这个测试转化为四个不同的测试。 在第一个测试中，订单数量和订单大小将等于1。 然后在第二个测试中，订单数量将等于100，而订单大小将等于1。
    然后反之亦然，然后它们都将等于50。
- en: Pytest parameterize can save you a lot of repetition when you write tests。 One
    of the things that we usually forget to keep up to date is documentation。 Mostly
    because we don't have a tool that tells us when it's outdated and no longer valid。
    Pytest can solve part of this problem。 If you put some code examples in the documentation
    it can evaluate them and tell you if they no。
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest参数化可以在编写测试时节省你大量的重复。 我们通常忘记保持最新的事情之一是文档。 大多数情况下是因为我们没有工具告诉我们它何时过时且不再有效。
    Pytest可以解决部分这个问题。 如果你在文档中放置一些代码示例，它可以评估它们并告诉你是否不再。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_84.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_84.png)'
- en: longer work。 Let's see an example。 If we run Pytest with DocTest module's parameter
    it will check for parts of your documentation。
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 不再工作。我们来看一个例子。如果我们使用 DocTest 模块的参数运行 Pytest，它将检查你的文档中的部分内容。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_86.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_86.png)'
- en: startings with this symbol。 If there are any Pytest will evaluate this line
    and see if the result is equal to the。 next line of the documentation。 If it's
    not it will report an error。 Speaking of running Pytest with parameters there
    are a lot of cool parameters that you。 can pass to Pytest。 You can for example
    stop running tests after the first failure you can rerun only the failed。
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以这个符号开头。如果有任何内容，Pytest 将评估这一行，并查看结果是否等于文档的下一行。如果不等，它将报告错误。说到使用参数运行 Pytest，有很多很酷的参数可以传递给
    Pytest。例如，你可以在第一次失败后停止运行测试，或者只重新运行失败的测试。
- en: test from the previous run。 You can select a single test or a single file to
    run。 You can start a debugger when there is a failure or you can run tests in
    parallel。 You can mark tests so assign a label to a test and then only run tests
    with a specific， label。 You can split your test into for example unit tests that
    you will run every time and end。
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 来自上一次运行的测试。你可以选择单个测试或单个文件来运行。当发生故障时，你可以启动调试器，或者可以并行运行测试。你可以标记测试，给测试分配标签，然后只运行具有特定标签的测试。你可以将测试拆分，例如单元测试，每次都运行这些测试，最终结束。
- en: to end tests that you will run only on the continuous integration platform because
    they， are slow。 And you can also use one of the predefined marks。 For example
    you can tell Pytest to skip some tests if you know that they are broken and。 you
    don't have time to fix them today but use to want your CI to work。 You can tell
    Pytest that some tests are actually expected to fail。
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 结束测试你只会在持续集成平台上运行，因为它们运行缓慢。你还可以使用预定义的标记之一。例如，如果你知道某些测试是坏的，而你今天没有时间去修复它们，但希望你的
    CI 能正常工作，你可以告诉 Pytest 跳过这些测试。你可以告诉 Pytest 某些测试实际上是预期会失败的。
- en: And you can skip some tests if a specific condition is true。 For example you
    might want to skip some tests if they are not supposed to work on windows。 The
    final piece of our "How to make a good Python project" puzzle is the documentation。
    At some point you probably want to explain how to use your project or how someone
    can。
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个特定条件为真，你可以跳过某些测试。例如，如果某些测试不应该在 Windows 上运行，你可能想跳过这些测试。“如何制作一个好的 Python 项目”的最后一块拼图是文档。在某个时候，你可能想要解释如何使用你的项目或其他人如何使用它。
- en: contribute to it。 So you need to write a documentation。 One of the most popular
    tools for Python is called Sphinx。 It's easy to use and it comes with a lot of
    useful features out of the box。 You can generate documentation in various formats。
    You can easily create hyperlinks between functions and modules。 You can automatically
    generate documentation of your APIs。 And similarly to what Pytest does it can
    also test the code examples in the documentation。 So to use Sphinx， install it
    with pip or pipx。 I'm gonna go with pip because maybe in another project I want
    to use something else。
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为此做出贡献。所以你需要编写文档。最受欢迎的 Python 工具之一叫做 Sphinx。它易于使用，并且自带很多有用的功能。你可以生成多种格式的文档。你可以轻松地在函数和模块之间创建超链接。你可以自动生成
    API 的文档。与 Pytest 类似，它还可以测试文档中的代码示例。因此，要使用 Sphinx，通过 pip 或 pipx 安装它。我将使用 pip，因为在另一个项目中我可能想用其他东西。
- en: Once you have Sphinx installed， run Sphinx-quickstart command and pass the name
    of the folder。 where you want to keep your documentation。 A common name for this
    folder is "talks" so I'm gonna go with that。 Then Sphinx will ask you a few questions
    about your project and generate the documentation。 With Sphinx you will be using
    a restructured text to write documentation。
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了 Sphinx，运行 Sphinx-quickstart 命令并传入你想要保存文档的文件夹名称。这个文件夹的常见名称是“talks”，所以我就用这个名称。然后，Sphinx
    会问你一些关于你项目的问题并生成文档。使用 Sphinx，你将使用重构文本来编写文档。
- en: It's very similar to Markdown but it has some custom syntax on top of it。 If
    you want to learn more here is a link to some instruction how to use restructured
    text。 For some reason you don't like restructured text and you want to use Markdown，
    there is。 an extension called "re-common-mark" that you can install。 However。
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 它与 Markdown 非常相似，但在其基础上有一些自定义语法。如果你想了解更多，这里有一个关于如何使用重构文本的说明链接。如果你出于某种原因不喜欢重构文本，想使用
    Markdown，还有一个名为“re-common-mark”的扩展可以安装。不过。
- en: I will go with "restructure text" here。 If we go to the docs directory you will
    see that we have a "make" file and "make"。 path。 Those are files that we will
    use to generate the documentation。 And then we have "build" and "source" folder
    because we chose a separate source and。 build directories in the first question
    that Sphinx asked us。
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我将选择“重构文本”这里。如果我们进入文档目录，你会看到我们有一个“make”文件和“make”路径。这些是我们将用来生成文档的文件。然后我们有“build”和“source”文件夹，因为我们在
    Sphinx 提问的第一个问题中选择了单独的源和构建目录。
- en: Inside the build folder we will find the generated documentation。 Right now
    we don't have any。 Inside the source folder we will find the configuration file
    and index "rest" this is。
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在 build 文件夹中，我们将找到生成的文档。现在我们还没有任何文档。在 source 文件夹中，我们将找到配置文件和索引“rest”，这就是。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_88.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_88.png)'
- en: the main page of your documentation。 As you can see there is not much going
    on here and VS Code is suggesting that it can。 help us with some extension to
    preview the "rest" files。
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你的文档的主页。正如你所看到的，这里没有太多内容，VS Code 提示我们可以通过一些扩展来预览“rest”文件。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_90.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_90.png)'
- en: Right now I'm going to dismiss it。 So to generate the documentation we have
    to go to the folder that contains our "make"。 file and run "make。html" command。
    This should generate the HTML version of the documentation。 If we now go inside
    the build directory you will see that we have "html" folder and inside。 of it
    we have some pages。 Let's open the index "html" in the browser。
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将暂时忽略它。因此，要生成文档，我们必须转到包含“make”文件的文件夹，并运行“make.html”命令。这应该生成文档的 HTML 版本。如果我们现在进入
    build 目录，你会看到我们有一个“html”文件夹，里面有一些页面。让我们在浏览器中打开索引“html”。
- en: Great so we have a skeleton of our documentation。 There is not much going on
    here so let's see how we can fill it up with some content。 You can add more files
    and folders to the source directory and then you can link them。
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，所以我们有了文档的骨架。这里没有太多内容，所以让我们看看如何填充一些内容。你可以向源目录添加更多文件和文件夹，然后你可以链接它们。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_92.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_92.png)'
- en: under the "talk 3" section to create additional pages of your documentation。
    Just make sure you are actually creating those three files that we are specifying
    here otherwise。 you are going to get some errors when building the documentation。
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在“talk 3”部分下创建你文档的附加页面。确保你实际上创建了我们在这里指定的这三个文件，否则在构建文档时你会遇到一些错误。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_94.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_94.png)'
- en: If you are wondering what to actually put in your documentation I can highly
    recommend。 you this talk and this blog post。 If you use this framework for writing
    documentation you will have four main categories。 Tutorials that will explain
    a complete beginner how they can start using your application。 how to guides，
    so recipes how to solve a specific problem， explanations explaining how your project。
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想要在文档中实际放置什么内容，我强烈推荐你观看这个演讲和这篇博客文章。如果你使用这个框架来编写文档，你将有四个主要类别。教程将向完全的初学者解释他们如何开始使用你的应用程序。如何指南，即解决特定问题的配方，解释你的项目。
- en: actually works and reference which is like a Wikipedia page for your project。
    One feature that I really like in Sphinx is that it can automatically generate
    the documentation。 for your API。 All you need to do is to add a plugin。
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它能够工作并且参考，这就像你项目的维基百科页面。我在 Sphinx 中非常喜欢的一个功能是它可以自动生成 API 文档。你所需要做的就是添加一个插件。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_96.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_96.png)'
- en: So open the conf。py file that contains the configuration for your Sphinx documentation。
    and then inside the extensions list add sphinx。ext。out。doc。 Next we need to create
    a file that will contain this API documentation。 So let's create a new file called
    api。rest。 Inside this file for every module that you want to document you need
    to add the following。
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 所以打开 conf.py 文件，该文件包含你的 Sphinx 文档的配置。然后在扩展列表中添加 sphinx.ext.out.doc。接下来，我们需要创建一个将包含此
    API 文档的文件。所以让我们创建一个名为 api.rest 的新文件。在这个文件中，对于你想要记录的每个模块，你需要添加以下内容。
- en: code。 First the name of the module， let's say I want to document the math operations。
    Okay this part is completely optional but I like to add it to have a nice headers
    for。 each of the modules。 And now the mandatory part。 Normally you should first
    provide the name of the package and then the name of the module。 Since here I
    don't really have a package and I have only one file so it's okay to skip。
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 代码。首先是模块的名称，假设我想记录数学运算。好吧，这部分是完全可选的，但我喜欢添加它以便为每个模块提供漂亮的标题。现在是强制部分。通常你应该首先提供包的名称，然后是模块的名称。因为在这里我没有真正的包，只有一个文件，所以跳过也是可以的。
- en: the name of the package。 But normally you would want to use packages to name
    space your modules so to easily separate。
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 包的名称。但通常你会希望使用包来命名空间你的模块，以便轻松分隔。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_98.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_98.png)'
- en: them。 So let's try to build our documentation。
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 它们。所以让我们尝试构建我们的文档。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_100.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_100.png)'
- en: And we get an error。 The problem here is that the math operations file is above
    in the directory structure comparing。
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了一个错误。这里的问题是数学运算文件在目录结构的上方。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_102.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_102.png)'
- en: to conf。py file。 So all we have to do is to modify the path inside the conf。py
    file。 So let's open it and at the top of the conf file you will see an explanation
    of this problem。 So uncomment those lines and change this into two directories
    above。
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `conf.py` 文件中。所以我们要做的就是修改 `conf.py` 文件中的路径。让我们打开它，在 `conf` 文件的顶部你会看到这个问题的解释。所以取消注释那些行，并将其更改为上方的两个目录。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_104.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_104.png)'
- en: That's because we have conf。py file inside the source directory。 Above we have
    the docs directory and the math operation is one directory above the docs。
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们在源目录中有 `conf.py` 文件。在上方我们有文档目录，数学运算在文档目录的上一级。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_106.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_106.png)'
- en: That's why we have to go up to directories。 Once we save this file let's try
    to run make again。 And this time it's successful。 Let's open this file in the
    browser and here we have it。 If you're wondering how do we get those parameters
    and the return value that's because I modified。
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们必须进入上层目录。一旦我们保存这个文件，就试着再次运行 `make`。这次成功了。让我们在浏览器中打开这个文件，这里就是它。如果你想知道我们如何得到那些参数和返回值，那是因为我进行了修改。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_108.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_108.png)'
- en: the math operation and I added more stuff to the doc string。 If you go to the
    Sphinx documentation you can see how you can specify parameters and。
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 数学运算，我对文档字符串添加了更多内容。如果你查看 Sphinx 文档，你可以看到如何指定参数和。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_110.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_110.png)'
- en: return values of your functions。 One feature that I really like is to have a
    link from the documentation to the source。 code of the functions。 And with Sphinx
    we can enable it with just one plugin。
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你的函数的返回值。我非常喜欢的一个功能是可以从文档链接到函数的源代码。通过 Sphinx，我们只需一个插件就可以实现。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_112.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_112.png)'
- en: So open the conf test and add Sphinx。ext view code to the list of our extensions。
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 所以打开配置测试并将 `Sphinx.ext` 视图代码添加到我们的扩展列表中。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_114.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_114.png)'
- en: Now build that documentation again and if we go to the browser you can see a
    link to the。 source of every function。 It's a really nice feature especially that
    we can get it by modifying just one line。 If you're building a REST API so for
    example you are using Django or Flask only for the。 backend of your application
    and then you have view or react in the front end。
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次构建文档，如果我们去浏览器，你可以看到每个函数的源代码链接。这是一个非常不错的功能，尤其是我们只需修改一行就可以实现。如果你正在构建 REST
    API，例如你使用 Django 或 Flask 作为应用程序的后端，而在前端你使用 Vue 或 React。
- en: Check out the swagger UI and redog。 They will both let you easily generate interactive
    documentation for your applications。 When we talked about Pytest I show you how
    you can test your documentation。 But if you're not using Pytest you can also test
    your documentation from Sphinx directly。
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 Swagger UI 和 Redog。它们都可以让你轻松生成应用程序的交互式文档。当我们谈到 Pytest 时，我向你展示了如何测试你的文档。但是如果你不使用
    Pytest，你也可以直接从 Sphinx 测试你的文档。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_116.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_116.png)'
- en: First you need to enable the doc test extension to make sure that you actually
    have some test。
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要启用文档测试扩展，以确保你确实有一些测试。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_118.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_118.png)'
- en: in your documentation and then finally run make doc test command。
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的文档中，然后最终运行 `make doc test` 命令。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_120.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_120.png)'
- en: As you can see the trace back is not as pretty as in Pytest。 You don't have
    green and red colors but you can see that our test has failed。 I would normally
    stick to Pytest to run all types of tests but maybe you like it that， way。 And
    final thing that I want to show you is read the docs。
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，追踪回溯不像在 Pytest 中那样美观。你没有绿色和红色的颜色，但你可以看到我们的测试失败了。我通常会坚持使用 Pytest 来运行所有类型的测试，但也许你喜欢这种方式。最后我想给你展示的是阅读文档。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_122.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_122.png)'
- en: If you're working on an open source project you can host your documentation
    for free online。 All you have to do is visit the read the docs website and create
    an account here。 Once you have an account you will have access to a dashboard
    where you can connect your。 code repository。 Read the docs will take your Sphinx
    documentation and put it online。
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在参与一个开源项目，你可以在线免费托管你的文档。你所要做的就是访问阅读文档网站并在这里创建一个帐户。一旦你有了帐户，你将可以访问一个仪表盘，在那里你可以连接你的代码仓库。阅读文档会获取你的
    Sphinx 文档并将其放到网上。
- en: Here is an example how it can look like。 So we've learned a lot and now I would
    like you to put all that new knowledge into action。 Let's write a small to do
    application where you can use all the tools and ideas that you。 have learned today。
    Your to do application should implement the following features。 Show a list of
    tasks， add a new task， mark it as done and delete a task。
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例，展示它可能的样子。因此，我们学到了很多，现在我希望你能将所有的新知识付诸实践。让我们写一个小的待办事项应用程序，在这里你可以使用今天学到的所有工具和想法。你的待办事项应用程序应该实现以下功能：显示任务列表，添加新任务，标记为完成，并删除任务。
- en: Apart from just writing the code I would like you to also write some tests，
    document some。 of the functions and generate documentation with Sphinx。 I would
    also like you to install Flake 8 in Black and run your code through those tools。
    As a bonus point you can configure your VS code to use Flake 8 in Black automatically。
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 除了仅仅编写代码外，我还希望你编写一些测试，记录一些函数，并使用 Sphinx 生成文档。我还希望你安装 Flake 8 和 Black，并通过这些工具运行你的代码。作为额外奖励，你可以配置你的
    VS Code，使其自动使用 Flake 8 和 Black。
- en: You can start this project from scratch but I would like you to practice using
    cookie cutter。 templates。 So I have created a template for you that you can use。
    Let me show you how you can start。 And for this exercise I will no longer use
    a clean Mac OS installation。 I will use my normal work environment so you can
    see how I'm working。
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从头开始这个项目，但我希望你练习使用 cookie cutter 模板。因此，我为你创建了一个模板，你可以使用它。让我告诉你如何开始。为了这个练习，我将不再使用干净的
    Mac OS 安装。我将使用我正常的工作环境，这样你就可以看到我是如何工作的。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_124.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_124.png)'
- en: So let's start our project。 Let's make a folder for our application。 Let's check
    if I have cookie cutter installed globally。 And yes it's version 1。7 so it should
    be fine。 So let's create a virtual environment。 I'm using virtual fish so I will
    be using different commands than I show you and something broke。
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们开始我们的项目。为我们的应用程序创建一个文件夹。让我们检查一下我是否全局安装了 cookie cutter。是的，它的版本是 1.7，所以应该没问题。接下来，让我们创建一个虚拟环境。我正在使用
    virtual fish，因此我会使用与我展示的不同的命令，但出现了一些问题。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_126.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_126.png)'
- en: Well that's interesting。
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这很有趣。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_128.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_128.png)'
- en: So it turns out I messed up something when I was switching Python versions and
    virtual。 fish didn't like the 3。8 so I'm back to Python 3。6。2 and now it should
    work。 So that's the correct log that you should see not some scary shell errors。
    Did I mention how happy I am this is not life-coding and I can actually go and
    fix some errors。
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，结果是我在切换 Python 版本时搞砸了，virtual fish 不喜欢 3.8，所以我回到了 Python 3.6.2，现在应该可以正常工作。所以你应该看到的正确日志，而不是一些可怕的
    shell 错误。我提到过我有多开心这不是实时编码，我实际上可以去修复一些错误吗？
- en: and you don't have to stare at me running random commands for half an hour。
    We should do this more often。 So we have a folder we have a virtual environment。
    Let's run the cookie cutter。 Let me copy this。 I got this message because I already
    downloaded it。 Let's re-download it。 Cookie cutter is going to ask you a couple
    of questions。
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要盯着我随机运行命令半个小时。我们应该更频繁地这样做。所以我们有一个文件夹，有一个虚拟环境。让我们运行 cookie cutter。让我复制一下这个。我收到这个消息是因为我已经下载过它。让我们重新下载。Cookie
    cutter 会问你几个问题。
- en: Some of them are less important。 Some of them are more。 That's my name so I'm
    gonna stick to it。 Give name， let's leave it as this。 The description stays the
    same。 Directory name。 Well let's stay with two。 So here is the important part。
    I forgot to mention it so far but I will be using Flask in the simple web application。
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些不那么重要，另一些则更重要。这是我的名字，所以我会坚持使用。给名字，咱们就保留这个。描述保持不变。目录名称。好吧，让我们保持两个。所以这里是重要的部分。我到现在为止忘记提了，但我会在这个简单的
    web 应用中使用 Flask。
- en: If you select option one， so scaffolding， cookie cutter will generate a pretty
    comprehensive。 scaffolding for your application。 It will take care of setting
    up everything。 The Flask app。 the database with the models， pictures for tests
    and your task will be just， to finish the function。 add tests and the documentation。
    If you don't know Flask or if you haven't used it in a long time or if you don't
    know web。
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择第一个选项，那么骨架，cookie cutter 将为你的应用程序生成一个相当全面的骨架。它会负责设置一切，包括 Flask 应用、带有模型的数据库、测试用的图片，而你的任务就是完成函数，添加测试和文档。如果你不知道
    Flask，或者很久没有使用过它，或者你对网络开发不熟悉。
- en: development in general， I suggest that you select this option。 It's gonna be
    easier for you to finish this tutorial but then you can just look around。 and
    see how I decided to implement it。 If you select option two， so empty files。 cookie
    cutter will generate files that are， mostly empty with a bunch of to do comments。
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果你在开发中，我建议你选择这个选项。这将使你更容易完成这个教程，但你可以随便看看我是如何实现的。如果你选择第二个选项，那么空文件，cookie
    cutter 将生成大部分空的文件，里面有很多待办事项的注释。
- en: The main reason why I'm generating those files is to enforce some structure。
    A simple website in Flask can be written in a single file。 But one of the main
    points of this exercise is to learn how to split your project into。 separate pieces。
    So let's go with option two。 And this option will generate the HTML scaffolding
    for you。
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我生成这些文件的主要原因是为了强制执行一些结构。一个简单的 Flask 网站可以写在一个文件中。但这个练习的主要点之一是学习如何将项目拆分成不同的部分。所以我们选择第二个选项。这个选项将为你生成
    HTML 骨架。
- en: I suggest you select the S。 This will generate a simple HTML website with some
    bootstrap styling。 If you choose now， you will have to write the HTML yourself
    and this exercise is not。 really about writing HTML。 But it's up to you。 And finally，
    you can select a license。 This is quite a common question in the cookie cutter
    templates。 I'm gonna go with one。
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你选择 S。这将生成一个带有一些 Bootstrap 样式的简单 HTML 网站。如果你现在选择，你将不得不自己编写 HTML，而这个练习并不真正是关于编写
    HTML 的。但这取决于你。最后，你可以选择一个许可证。这是 cookie cutter 模板中一个相当常见的问题。我将选择一个。
- en: So if we look inside the current folder， you will see that we have a to do folder
    created。 If we move there， you can see that we have a few files。
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我们查看当前文件夹，你会看到我们创建了一个待办事项文件夹。如果我们进入那里，你会看到我们有几个文件。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_130.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_130.png)'
- en: Let's actually open VS Code here。 In the README file。 you will see all the steps
    that you need to do to run this application。 We already have a virtual environment，
    so you can skip the first two steps。 Then inside the requirements。txt， you will
    see some requirements。 We are using Flask。
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里打开 VS Code。在 README 文件中，你会看到运行这个应用程序所需的所有步骤。我们已经有一个虚拟环境，所以你可以跳过前两个步骤。然后在
    requirements.txt 中，你会看到一些要求。我们使用 Flask。
- en: Flask SQL alchemy， Sphinx and Pytest。 So then back to README。 you can see that
    we have to install requirements first。
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Flask SQL Alchemy、Sphinx 和 Pytest。那么回到 README，你会看到我们首先需要安装要求。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_132.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_132.png)'
- en: So let's do that。
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们来做这个。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_134.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_134.png)'
- en: And now we can finally try to run our application。 But first。 enable the development
    mode for auto reloading and more verbal errors。 Keep in mind that you don't want
    to do this in production。 But for development。 that's a recommended option。 And
    if we try to start the server， we gonna get an error because run p。
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于可以尝试运行我们的应用程序了。但首先，启用开发模式以实现自动重载和更多详细错误。请记住，你不想在生产环境中这样做。但对于开发来说，这是推荐的选项。如果我们尝试启动服务器，将会出现错误，因为运行
    p。
- en: i。 is empty。
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: i。是空的。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_136.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_136.png)'
- en: So here is where you start。 You need to put some code here that will set up
    everything and run the web server。 And then checking some other files。 You can
    see that we have Views。 Here you should create some Views and connect them to
    URLs。 Then we have Models。 Here we should have a database model for our task。
    It should contain at least the body。
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你开始的地方。你需要在这里放一些代码，以设置所有内容并运行 web 服务器。然后检查其他一些文件。你可以看到我们有 Views。在这里你应该创建一些视图并将它们连接到
    URL。然后我们有 Models。在这里我们应该有一个任务的数据库模型。它应该至少包含主体。
- en: so the text of the task。 And Done， which is a Boolean value defining if the
    task is done or not。 Then we have an API。 So instead of listing， creating。 deleting
    and finishing tasks inside the View functions。 I would like you to write Views
    file that will call functions from the API。
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 任务的文本。而 Done 是一个布尔值，用于定义任务是否完成。然后我们有一个 API。因此，我希望你编写 Views 文件，调用 API 中的函数，而不是在视图函数中列出、创建、删除和完成任务。
- en: And functions from the API will call functions from the models。 In the templates
    we have the HTML page for our application。 There is a lot of code。 but most of
    it is just bootstrap styling。 You can see that our HTML template is expecting
    a task's list。 And then it will go through each task there and print a task。 This
    task should have two attributes。
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: API 中的函数将调用模型中的函数。在模板中，我们有用于我们应用程序的 HTML 页面。有很多代码，但大多数只是 bootstrap 样式。你可以看到我们的
    HTML 模板正在期待一个任务列表。然后它会遍历每个任务并打印一个任务。这个任务应该有两个属性。
- en: Done to specify if the task is finished or not。 And the body with the text of
    the task。 Finally。 we have some URLs that suggest you what URLs the Views should
    expect。 So we should use done slash task ID to mark task as done and delete to
    mark task as delete。 Also here we have a form to create a new task。 It will send
    a payload with the text to slash tasks URL。
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 用于指定任务是否完成的内容。还有包含任务文本的主体。最后，我们有一些建议你预期的视图的 URL。因此，我们应该使用已完成的斜杠任务 ID 来标记任务为已完成，并使用删除来标记任务为删除。此外，这里有一个表单用于创建新任务。它将发送一个包含文本的有效负载到斜杠任务的
    URL。
- en: Then we have a test folder for our tests that's currently empty。 And we don't
    have a test for documentation， so we'll have to generate it with Sphinx。
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有一个测试文件夹用于我们的测试，但目前是空的。我们没有文档的测试，因此我们必须使用 Sphinx 生成它。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_138.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_138.png)'
- en: Okay， so we can pause the video here and try to do this exercise。 If you're
    starting from scratch。 you can completely ignore my project structure and write
    it however， you want。 And if you decided to start with the scaffolding and you
    got stuck somewhere， don't worry。 In a moment， I will show you how to write this
    project， writing code to match what we。
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们可以在这里暂停视频，尝试做这个练习。如果你是从零开始，你可以完全忽略我的项目结构，随意编写。如果你决定从脚手架开始，并且在某处卡住了，不用担心。稍后我会向你展示如何编写这个项目，编写与我们匹配的代码。
- en: already have in the scaffolding。 So please pause the video， try to write it
    on your own。 If you get stuck and you want to take a look at the final solution，
    you can go to this， GitHub URL。
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚手架中已经有了。所以请暂停视频，尝试自己编写。如果你卡住了并想看看最终解决方案，可以访问这个 GitHub URL。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_140.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_140.png)'
- en: And in a moment， I will show you how I will write this project。 So let's start
    with brand PY。
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将向你展示我将如何编写这个项目。那么我们从品牌 PY 开始吧。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_142.png)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_142.png)'
- en: Here I would import up from my project and simply run it。 So now we actually
    have to create this up somewhere。 If I go inside my to do directory。 I will use
    the inid。py file。 In many projects， you will see inid。py empty。 And this is because
    if there is a folder with the inid。py file， it means that it's a Python。
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我会从我的项目中导入 up 并简单地运行它。所以现在我们实际上需要在某处创建这个 up。如果我进入我的待办事项目录，我将使用 inid.py 文件。在许多项目中，你会看到
    inid.py 是空的。这是因为如果有一个带有 inid.py 文件的文件夹，意味着它是一个 Python 包。
- en: package。 And nowadays you don't really have to create this inid。py file because
    we have implicit。 and explicit namespace packages。 But that's a different story。
    Anyway， a nice thing about inid。py is that I can put some code here and then I
    will be。 able to import this code just like that from to do import some functions
    instead of doing。
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 包。现在你实际上不需要创建这个 inid.py 文件，因为我们有隐式和显式命名空间包。但这是另一回事。无论如何，关于 inid.py 的一个好处是我可以在这里放一些代码，然后我将能够像这样从待办事项中导入一些函数，而不是这样做。
- en: from to do dot name of the file。 So let's go here。 Let's import flask and let's
    set up the application。 You can see that my lint there is complaining that it
    cannot resolve flask。 That's because I'm using the wrong virtual environment。
    So let's change that。 And as you can see。
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 从待办事项的文件名导入。所以让我们去这里。导入 Flask，并设置应用程序。你可以看到我的 lint 报告说无法解析 Flask。这是因为我使用了错误的虚拟环境。所以让我们更改它。正如你所看到的。
- en: VS code can actually detect that we have a to do app virtual environment。 So
    let's use this one。 And now we no longer have this warning because flask is installed
    inside our virtual environment。 So let's try to run our flask application。 This
    time I'll actually do this from the VS code。 So let's create a launch。json file。
    It's going to be flask path to the application。 In my case。
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 实际上可以检测到我们有一个待办事项应用的虚拟环境。所以让我们使用这个。现在我们不再有这个警告，因为 Flask 已经安装在我们的虚拟环境中。所以让我们尝试运行我们的
    Flask 应用程序。这次我将实际从 VS Code 执行。因此，让我们创建一个 launch.json 文件。它将是 Flask 应用程序的路径。在我的情况下。
- en: this is run py。 And let's see。 That's a huge。
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 run.py。让我们看看。这是个巨大的。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_144.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_144.png)'
- en: I know。 Okay， seems to be working if we open it。 Okay， something is happening。
    But we get 404。 That's because we don't actually have any URLs in our application。
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道。好的，似乎可以工作，如果我们打开它。好的，有什么事情在发生。但我们得到了 404。这是因为我们实际上在应用程序中没有任何 URL。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_146.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_146.png)'
- en: So let's go back。 Let's stop our server。 No longer need this file。 I want to
    get some。 Let's actually hide everything because I want to get some real estate
    on the screen。 So let's go inside the views and let's actually implement home
    page。 On the main page of the application， we just want to display a list of tasks。
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们回去吧。停止我们的服务器。这个文件不再需要。我想获取一些空间。让我们实际上隐藏所有内容，因为我想在屏幕上获得一些空间。所以让我们进入视图并实际实现主页。在应用程序的主页面上，我们只想显示任务列表。
- en: So let's create a function called task list。 Now， since I don't have a database
    yet。 I'm just going to initialize a list of tasks as， an empty dictionary。 And
    now I need to render our application。html template。 We get an error that this
    name is not defined。 So let's see if we can solve it with the quick fix function
    from VS code。
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们创建一个名为任务列表的函数。现在，由于我还没有数据库，我将初始化一个空字典作为任务列表。现在我需要渲染我们的 application.html
    模板。我们得到一个错误，提示这个名称未定义。所以让我们看看是否可以通过 VS Code 的快速修复功能解决它。
- en: And yeah， that's correct。 This should go here。 This I can remove。 And now we
    actually need to plug this function to a URL。 And now we actually need to import
    our app。 This won't be working yet because our to do app doesn't know about the
    views。 So let's go to ini。py。 And after we initialize our app， we need to import
    the views。 Well， this looks super bad。
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 对，这没错。这应该放在这里。我可以移除这个。现在我们实际上需要将这个函数连接到一个 URL。现在我们实际上需要导入我们的应用程序。因为我们的待办事项应用不知道视图，所以这还不能工作。我们去
    ini.py。在初始化应用程序后，我们需要导入视图。嗯，这看起来太糟糕了。
- en: But if we move our import here， we're going to get into circular import problems。
    So it has to stay here。 And as you can see， like it will complain about that。
    So we need to put a comment to disable this one error on the current line。 And
    also I need to tell i sort， which is a tool to sort your imports， that it should。
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们把导入移到这里，我们将遇到循环导入问题。所以它必须留在这里。正如你所看到的，它会对此感到抱怨。所以我们需要添加一个注释来禁用当前行的一个错误。我还需要告诉
    iSort，这是一个排序你的导入的工具，它应该。
- en: leave this import where it is。 Otherwise， it's going to take it and move it
    to the top of the file。 And that's not good。 In a bigger flask project， you could
    solve this problem by using an extensions file。 Check out this stack overflow
    answer to see how you would use one。 But in case of this small project where you
    have three files， adding another file just。
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 将此导入保留在原处。否则，它将被移动到文件顶部。这不好。在一个更大的 Flask 项目中，你可以通过使用扩展文件来解决这个问题。查看这个 Stack Overflow
    答案，了解如何使用它。但在这个只有三个文件的小项目中，添加另一个文件只是。
- en: to solve this import problem sounds like a bit too much。
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个导入问题似乎有点过于复杂。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_148.png)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_148.png)'
- en: And it's not always the best solution。 Okay， so let's start our server again。
    And as you can see。 we have our beautiful but empty to do list。 We can put something
    and we get for a form not found because we are still missing some。 URLs。
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不总是最佳解决方案。好的，让我们再次启动服务器。正如你所见，我们有了美丽但空白的待办事项列表。我们可以输入一些内容，但因为我们仍然缺少一些 URL，所以会出现“未找到表单”的错误。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_150.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_150.png)'
- en: So let's fix that now。 We want to be able to add tasks to our to do list。 And
    in order to do that。 we need to actually store them somewhere。 So let's add a
    database to our application。 Let's go to our init pui and let's set up a database。
    I will be using SQLite as our database。 Normally I would suggest you to use a
    better database like Postgres even on your development。
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们现在修复它。我们想能够将任务添加到我们的待办事项列表中。为此，我们需要实际存储它们。因此，让我们在应用程序中添加一个数据库。让我们去我们的初始化文件，设置一个数据库。我将使用
    SQLite 作为我们的数据库。通常我建议你使用一个更好的数据库，如 Postgres，即使是在开发阶段。
- en: machine。 But for the purpose of the simple example， SQLite is perfectly fine。
    So next let's go to our models and actually create some models for the database。
    Here we are importing the db object from our init pui file。 So we have a table
    called task that has three columns。 I did to mark tasks as done or delete them。
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 机器。但对于这个简单的示例，SQLite 完全可以满足需求。接下来，让我们查看我们的模型，并实际为数据库创建一些模型。这里我们从我们的初始化文件中导入
    db 对象。因此，我们有一个名为 task 的表，它有三列。我用它来标记任务是否完成或删除它们。
- en: Body that contains the text of a task。 And done that is a Boolean field that
    specifies if the task is done or not。 Let's go to our views and write a function
    that will let us add new tasks。 So we'll get the body of the task from this part
    in the form。 And then after we create a task。 we want to redirect the user to
    the main page。 Well， this is incorrect。
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 包含任务文本的主体。而 done 是一个布尔字段，指明任务是否完成。让我们去我们的视图，写一个可以让我们添加新任务的函数。因此，我们将从表单的这一部分获取任务的主体。然后在我们创建任务后，我们想将用户重定向到主页。嗯，这不正确。
- en: We want to redirect from flask。 So we also need to get the request from flask。
    Nice thing about flask is that the request is global so we can import it wherever
    we want。 So here we could create a task directly in the database。 But I prefer
    to have a separate file for the public API of our application。 First。
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想从 Flask 重定向。所以我们也需要从 Flask 中获取请求。Flask 的一个好处是请求是全局的，因此我们可以在任何地方导入它。所以在这里，我们可以直接在数据库中创建一个任务。但我更喜欢为我们应用程序的公共
    API 保留一个单独的文件。首先。
- en: it's going to be easier to write the unit test for it。 And if we decide that
    we want to extract our API， for example to use it with REST API。 it's going to
    be much easier to do this。 So let's go to our API。py file and create a function
    to create a task there。 And that should be fine。
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更容易为它编写单元测试。如果我们决定提取我们的 API，例如用它来进行 REST API，这将更容易做到。因此，让我们去我们的 API.py 文件，创建一个函数在那儿创建任务。这应该没问题。
- en: Let's also create a function to list all the tasks。 Okay。 So that should be
    fine。 Now we go here and we actually want to use our newly created function。 And
    don't forget to import it。 And here we can actually call our function。 And that
    should be all。 We also need to add it out here。
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还创建一个函数来列出所有任务。好的，这应该没问题。现在我们到这里，实际上想要使用我们新创建的函数。别忘了导入它。在这里，我们实际上可以调用我们的函数。这就足够了。我们还需要在这里添加它。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_152.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_152.png)'
- en: Now let's run our server。 No， we can't。 We get another cannot import name redirect。
    Okay。 That's because it's not in the templating module。 It's in Flask itself。
    So we should be good now。 One more try。 Okay。 So it's working， but we get this
    weird error。 Well， it's not an error。 It's the deprecation warning。 And it even
    says that you can set a config variable to get rid of this message。
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行我们的服务器。不，我们做不到。我们遇到了另一个“无法导入名称重定向”的错误。好的。这是因为它不在模板模块中，而是在 Flask 本身中。所以现在应该没问题了。再试一次。好的，它在工作，但我们得到这个奇怪的错误。其实这不是错误，而是弃用警告。它甚至表示你可以设置一个配置变量来消除这个消息。
- en: So let's do that。 Restart server。
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们这样做。重启服务器。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_154.png)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_154.png)'
- en: And we are good。 Let's go to the root of our website。 Something is wrong。
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了。让我们去我们网站的根目录。有什么问题。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_156.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_156.png)'
- en: Ah， yeah。 We forgot to actually create the database。 So to fix that， let's go
    to our random。py。 Let's import the database and then actually let's drop and recreate
    the tables。 This will actually drop the table and recreate it each time we restart
    the server。 For this application， it's perfectly fine。 But normally you would
    probably want to preserve the database between server restarts。
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，是的。我们忘了实际创建数据库。所以为了修复这个问题，让我们去 `random.py` 文件。导入数据库，然后实际删除并重建表。这将确保每次重启服务器时都删除并重建表。对于这个应用程序来说，这完全没问题。但通常你可能希望在服务器重启之间保留数据库。
- en: So to do this， you could actually check if the database exists， if not created。
    So let's run our server again。
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你可以检查数据库是否存在，如果不存在则创建它。所以让我们再次运行服务器。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_158.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_158.png)'
- en: It's refreshed。 Oh， come on， still something。
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 它刷新了。哦，拜托，还是有点问题。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_160.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_160.png)'
- en: It turns out that starting our application with the launch JSON file is not
    actually。 creating the database。 So instead we have to either go to our console
    and run it like that or just execute the run。 p。y file by pressing this button。
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，使用 launch JSON 文件启动应用程序实际上并没有创建数据库。所以我们必须去控制台运行，或者直接通过按下这个按钮执行 `run.py`
    文件。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_162.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_162.png)'
- en: When we go to to do folder， you will see that now we actually have the to do。db
    file。
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入待办事项文件夹时，你会看到现在我们实际上有了 `todo.db` 文件。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_164.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_164.png)'
- en: And if we go to the browser， let's refresh。 We have our to do list and we can
    actually add tasks。 Perfect。 Now we need to add functions to mark tasks as done
    and to delete them。
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们去浏览器，刷新一下。我们有了待办事项列表，并且可以实际添加任务。太完美了。现在我们需要添加功能来标记任务为完成和删除任务。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_166.png)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_166.png)'
- en: But first， let's add some tests。 So let's stop the server。 Let's go to our tests
    directory and let's make a new file test up。py。 So we need two tests。 one for
    the list of tasks and another for creation of tasks。 [BLANK_AUDIO]， [BLANK_AUDIO]。
    First of all， this。 Of course。 And that should be fine。
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 但是首先，让我们添加一些测试。先停止服务器。接下来，进入我们的测试目录，创建一个新文件 `test_up.py`。我们需要两个测试，一个是任务列表，另一个是任务创建。[BLANK_AUDIO]，[BLANK_AUDIO]。首先是这个。当然。这样就可以了。
- en: The only problem here is that we don't have a database for tests。 We could use
    the same database as we are using for development， but， that's a terrible practice。
    So let's learn how we can create a separate database for our tests。 So here we
    will create a fake app that will be used in our tests。 So we can actually go to
    our inid。
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是我们没有用于测试的数据库。我们可以使用与开发中相同的数据库，但这是一个糟糕的做法。让我们学习如何为我们的测试创建一个单独的数据库。因此在这里，我们将创建一个假应用程序，在我们的测试中使用。我们实际上可以进入我们的
    `init`。
- en: py。 I have too many tabs。 And we can copy this。 And let's make some modifications。
    We don't want to use this database。 And to save ourselves the hassle of cleaning
    the database after all the tests。 let's use a database in memory。 If you have
    a huge test database。 you probably can't put it in the memory。 But since our database
    is tiny， we can get away with that。
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: py。我打开了太多的标签。我们可以复制这个文件。并做一些修改。我们不想使用这个数据库。为了省去在所有测试后清理数据库的麻烦，让我们使用内存中的数据库。如果你有一个巨大的测试数据库，可能无法放在内存中。但由于我们的数据库很小，所以我们可以这样做。
- en: Also set the app configuration to testing。 Okay， we need to do some imports。
    And this is a by test fixture， so we need a special decorator。 So this db。all
    is not actually needed since we are using a database in memory。 It's gonna be
    dropped anyway。 But with this simple fixture， you can actually use different types
    of database。
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要将应用程序配置设置为测试。好的，我们需要做一些导入。这是一个测试夹具，所以我们需要一个特殊的装饰器。这个 `db.all` 实际上不需要，因为我们使用的是内存数据库。无论如何它都会被删除。但通过这个简单的夹具，你实际上可以使用不同类型的数据库。
- en: So with this fixture， we can go back to our test， and。 we can make sure that
    it's using this test app。 Okay， so let's try to actually run our test。 Configure
    tests， by test tests。 Okay， and now we have a magic flask。 And also test discovery
    failed。 There was an error。 Yeah， okay， so that's the problem。 No module named
    to do。
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 所以通过这个设置，我们可以回到我们的测试，确保它使用这个测试应用程序。好的，接下来我们来实际运行测试。配置测试，通过测试测试。好的，现在我们有了魔法 flask。但测试发现失败了。有一个错误。是的，好的，这就是问题。没有名为待办事项的模块。
- en: If you get an error like that， make sure that you have init。py file in your
    test directory。 And this should fix it， otherwise you could run your test with
    Python minus M pi test。
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到这样的错误，请确保你的测试目录中有 init.py 文件。这应该可以修复，否则你可以用 Python -m pytest 运行你的测试。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_168.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_168.png)'
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_169.png)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_169.png)'
- en: Now we have it。 We have one test and it's green， so it's passing。 Next， let's
    test creating a task。 We also need to pass the test up。 Make sure we have one
    task。 Make sure it has a correct body and it's not done。 And this is not how you
    check for false。 This is how you check。 Two spaces here， and let's run this test。
    Perfect。
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了。我们有一个测试，并且它是绿色的，所以通过了。接下来，让我们测试创建一个任务。我们还需要通过测试。确保我们有一个任务。确保它有一个正确的正文并且未完成。这不是检查错误的方法。这是检查的方法。这里有两个空格，然后让我们运行这个测试。完美。
- en: so now we have two tests and both are passing。 Let's move on to marking task
    as done and deleting it。 And just for a change， let's actually start by writing
    tests。 Let's start with finishing a task。 To finish a task， we actually have to
    have a task。 So let's create one。 Let's make sure that we have a task。 This is
    not actually necessary because we are already testing the get_tasks function before。
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个测试，并且都通过了。让我们继续标记任务为完成并删除它。为了改变一下，让我们实际开始编写测试。让我们从完成一个任务开始。要完成一个任务，我们实际上必须有一个任务。所以让我们创建一个。让我们确保我们有一个任务。实际上这不是必要的，因为我们已经在测试
    get_tasks 函数了。
- en: but better saved and sorry。 Let's get our first task。 We need the idea of this
    task because we'll be finishing tasks based on their IDs。 Now let's call a function
    finish_task that we don't have yet。 And at the end。 we want to make sure that
    the done status of our get_milk task is true。
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 但宁可保存也不要后悔。让我们获取第一个任务。我们需要这个任务的 ID，因为我们将根据它们的 ID 完成任务。现在让我们调用一个尚不存在的 finish_task
    函数。最后，我们想确保我们的 get_milk 任务的完成状态为真。
- en: Now we have to actually go and write the finish_task function。 So let's go to
    our API。 Okay。 so we have a function。 Let's run the test。 Oh， let's import it。
    And let's run our test。 Perfect。 it's passing。 Now we have three tests。 So let's
    write a test for deleting tasks here。 But before we do that， let's make sure that
    in our test we are actually fetching the latest。
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须实际编写 finish_task 函数。所以我们去我们的 API。好的。我们有一个函数。让我们运行测试。哦，让我们导入它。然后运行我们的测试。完美。它通过了。现在我们有三个测试。所以让我们在这里为删除任务编写一个测试。但在此之前，让我们确保在测试中我们实际上是获取最新的。
- en: version of the task here。 So let's run the get_task again。 That way we are sure
    that we are not using some cached version that it's not actually done。 And now
    back to the test delete。 We can actually copy most of the code from the previous
    task。 and we need to change finish to delete task。 And now make sure we have no
    tasks。 And again。
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里获取任务的版本。所以让我们再次运行 get_task。这样我们可以确保没有使用某个未完成的缓存版本。现在返回到删除测试。我们实际上可以复制之前任务的大部分代码。我们需要将
    finish 改为 delete task。现在确保我们没有任务。再来一次。
- en: we have to write the delete_task function。 Let's import it。 And let's run our
    test。 Perfect。 all the tests are passing。 Final step is to actually connect those
    API functions to the views。 So let's open views， and let's create a function to
    finish a task。 Let's call it task done。 We will have to accept task ID， and we
    can get this from the route。
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须编写 delete_task 函数。让我们导入它。然后运行我们的测试。完美。所有测试都通过了。最后一步是将这些 API 函数连接到视图。所以让我们打开视图，创建一个函数来完成任务。我们称之为
    task_done。我们需要接受任务 ID，并且我们可以从路由中获取它。
- en: And now we just have to call finish function on our task。 And redirect back
    to the main page。 And this is undefined。 Great， so that's a route for finishing
    a task。 Now let's create another one for deleting the task。 It will look very
    similar。 so let's copy this code。 Let's import it。 That's it。 Let's start the
    server， go to the browser。
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要在我们的任务上调用 finish 函数。并重定向回主页面。这是未定义的。太好了，这就是完成任务的路径。现在让我们创建另一个用于删除任务的路径。它看起来非常相似。所以我们复制这段代码。我们导入它。就这样。让我们启动服务器，打开浏览器。
- en: and see if it's working。
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 并查看它是否工作。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_171.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_171.png)'
- en: Let's mark this one as done， and let's delete this task。 Perfect， if we refresh，
    it's working。 Great， so we have our simple to do application working。 The only
    missing part is the documentation。
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个标记为完成，并删除这个任务。完美，如果我们刷新，它就有效了。太好了，我们的简单待办应用程序已经在运行。唯一缺少的部分是文档。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_173.png)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_173.png)'
- en: Start the skeleton of our documentation， with SphinxQuickStart command。 And
    we're gonna use docs folder。 Let's go inside the docs。 And inside the source。
    And let's modify the index RST。
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的文档框架开始，使用 SphinxQuickStart 命令。我们将使用 docs 文件夹。让我们进入 docs。然后进入 source。接着修改
    index RST。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_175.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_175.png)'
- en: First let's get rid of this。 And now instead of writing something here by hand。
    I would actually be able to import whatever I already have， in the README file。
    As you probably noticed， my README is not in the markdown format， but it's in
    the RST。 And thanks to that， I can actually import it here。 And I want this。
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们去掉这个。现在，代替手动在这里写点什么，我实际上可以导入我已经在 README 文件中拥有的内容。如你所见，我的 README 不是以 markdown
    格式，而是以 RST 格式写的。正因如此，我可以在这里导入它。我想要这个。
- en: And I want to have actually two pages。 One with the usage instructions， and
    one for the API。 And I don't need this。 So now we have to create the usage page。
    Let's put a header。 And let's put some information on how you can use it to do
    up。 Okay。 you can add more information here， but let's say this is enough。 Next。
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我想实际拥有两页。一页是用法说明，另一页是 API。我不需要这个。所以现在我们必须创建用法页面。让我们加个标题。并放一些你如何使用它的信息。好的，你可以在这里添加更多信息，但我们假设这些已经足够了。接下来。
- en: we need to create an API file。 And here I want to have documentation for Views，
    Models， and the API。py file。 So let's call it API reference。 By the way。 those
    weird underscores is how you create headings in RST。 Let's copy this。 And we are
    good。 Now to make it actually work， we have to go to cont。py and include some
    extensions。 But first。
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个 API 文件。在这里我想为 Views、Models 和 API.py 文件提供文档。所以让我们称之为 API 参考。顺便说一下，那些奇怪的下划线就是你在
    RST 中创建标题的方式。让我们复制这个。现在可以了。为了使它真正工作，我们必须去 cont.py 并包含一些扩展。但是首先。
- en: make sure we have the correct system path。 It's the same trick that I showed
    you when we talked about Sphinx。 And we need to do this to make sure that Sphinx
    can import our to-do module。 Now let's go to extensions。 I want the Auto-Daw。
    And I want to have links to the source code。 And if you want to test your documentation
    from Sphinx， you can also put the doc test here。
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们有正确的系统路径。这和我在谈论 Sphinx 时给你展示的技巧是一样的。我们需要这样做，以确保 Sphinx 可以导入我们的待办模块。现在让我们去扩展。我想要
    Auto-Daw。我还想有链接到源代码。如果你想测试你的 Sphinx 文档，你也可以在这里放置文档测试。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_177.png)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_177.png)'
- en: Okay， we should be good。 Let's generate the HTML。 And let's open the documentation
    in the browser。
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们应该没问题。让我们生成 HTML。然后在浏览器中打开文档。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_179.png)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_179.png)'
- en: Great， it's working。 So here you can see we have the ReadMe nicely included。
    You can go to the usage that contains our simple instruction。 And then we can
    go to the API reference。 And since we did it in Boder to document our functions。
    it's empty。 So let's fix that。
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，它正在工作。所以在这里你可以看到我们已经很漂亮地包含了 ReadMe。你可以查看包含我们简单说明的用法部分。然后我们可以去 API 参考。由于我们在
    Boder 中记录了我们的函数，它是空的。让我们来解决这个问题。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_181.png)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_181.png)'
- en: Let's close some of the tabs。 And let's document some functions from the API。
    So here we have a create task function。 We actually have to use the Sphinx format
    to document the parameters。 So let's get rid of this。 Let's document one more
    function， maybe finish task。 Let's regenerate the documentation。
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关闭一些标签。然后记录一些 API 中的函数。所以这里我们有一个创建任务的函数。我们实际上必须使用 Sphinx 格式来记录参数。所以让我们去掉这个。再记录一个函数，也许是完成任务。让我们重新生成文档。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_183.png)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_183.png)'
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_184.png)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_184.png)'
- en: And let's refresh。 Perfect， we have a much nicer documentation here。 If we click
    the source。 we can see the body of our functions。 And that's it。 Our simple to
    do application is done。 It's very basic， but it has some tests。
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们刷新。完美，我们在这里有了更漂亮的文档。如果我们点击源代码，我们可以看到我们函数的主体。就是这样。我们的简单待办应用完成了。它非常基础，但有一些测试。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_186.png)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_186.png)'
- en: It has some documentation。 I suggest that you write the rest of the documentation
    on your own。
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一些文档。我建议你自己写剩下的文档。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_188.png)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_188.png)'
- en: To see the code for the final version， go to give up to this URL。 Make sure
    you're on the branch code finished。 And you can find all the code here。 Good job
    if you got so far。 I hope you learned something。 And I know that this workshop
    is already running a bit long。
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看最终版本的代码，请访问此网址。确保您在分支代码完成上。您可以在这里找到所有代码。如果您能做到这一点，做得很好。我希望您学到了一些东西。我知道这个研讨会已经有点长了。
- en: But I have one more topic to talk about。 And this topic is deployment。 There
    are many different ways how you can deploy your application。 And Docker is one
    of the popular ones nowadays。 If you don't know what Docker is。 then my short
    explanation is probably not going to help you match。 But in an nutshell。
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 但我还有一个话题要讨论。这个话题是部署。有很多不同的方式可以部署您的应用程序，Docker是目前流行的方法之一。如果您不知道Docker是什么，那么我的简短解释可能不会对您有帮助。但简单来说。
- en: Docker is a tool for containerizing your application。 Which means that it can
    create a package called image with the code of your application。 All the dependencies。
    So peep packages， but also packages that you install with AppGet。 And with the
    information on how to run your package。 Then you can send this image to a server。
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个用于将您的应用程序容器化的工具。这意味着它可以创建一个名为镜像的包，里面包含您的应用程序代码和所有依赖项。所以窥探包，还有您通过AppGet安装的包，以及如何运行您的包的信息。然后您可以将这个镜像发送到服务器。
- en: And if Docker is installed on that server， with just one command。 you can have
    your application up and running。 Docker takes away a lot of hassle with deployment。
    but it's not an easy tool。 I will show you a very basic example。 But if you want
    to make sure that your application is secure。
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Docker已安装在该服务器上，您只需一条命令，就可以让您的应用程序运行起来。Docker大大减少了部署的麻烦，但它并不是一个简单的工具。我将向您展示一个非常基本的示例。如果您想确保您的应用程序是安全的。
- en: you should really learn about the advanced features of Docker。 At the beginning。
    it can be frustrating because it's yet another tool that you have to learn how
    to use。 And if your application won't work， then you won't know if it's a problem
    with your code or if it's a problem with the Docker configuration。 But once you
    learn it， deploying your application will be much easier。 So in my opinion。
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 您真的应该了解Docker的高级功能。一开始，可能会很沮丧，因为这又是一个您必须学习如何使用的工具。如果您的应用程序无法工作，您将不知道是代码的问题还是Docker配置的问题。但一旦您学会了，部署应用程序会容易得多。所以在我看来。
- en: Docker is worth investing time。 Especially since nowadays it's becoming an essential
    skill。 Even for software developers， not just for DevOps。 So to dockerize our
    application。 we need to create a Docker file。 Here's an example of a very basic
    Docker file that will work。 So let's take this code and use it to create a new
    Docker file in our to-do application。
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: Docker值得花时间学习。尤其是现在，它已成为一种基本技能。即使对于软件开发人员，也不仅仅是针对DevOps。因此，要将我们的应用程序Docker化，我们需要创建一个Docker文件。这是一个非常基本的Docker文件示例，可以工作。让我们拿这段代码并用它在我们的待办应用程序中创建一个新的Docker文件。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_190.png)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_190.png)'
- en: Next， we need to run a command Docker build。
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要运行一个命令Docker build。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_192.png)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_192.png)'
- en: And optionally we can specify a tag。 And using a tag is usually a good idea
    because otherwise Docker will assign a completely random name like this one。
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们可以指定一个标签。使用标签通常是个好主意，因为否则Docker会分配一个完全随机的名字，比如这个。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_194.png)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_194.png)'
- en: So let's do this。 Make sure that you are in the same directory where the Docker
    file is。 and let's run the command。 And， once our image is built， we can start
    it。
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们来做这个。确保您在Docker文件所在的同一目录中，然后运行命令。一旦我们的镜像构建完成，我们就可以启动它。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_196.png)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_196.png)'
- en: And if we try to open the URL in the browser， it's not working。
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中尝试打开这个网址，效果不好。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_198.png)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_198.png)'
- en: Well， more debugging for me。 I forgot to make one change to the run。py file。
    By default。 the app run command will bind the flask application to the local host。
    And in Docker。 local host is not actually exposed， so we have to bind it to host
    0。0。0。0。
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我要多调试了。我忘了对run.py文件进行一次更改。默认情况下，应用程序运行命令将flask应用程序绑定到本地主机。而在Docker中，本地主机实际上并没有暴露，因此我们必须将其绑定到主机0.0.0.0。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_200.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_200.png)'
- en: And that should fix it。 So let's rebuild our Docker image。 As you can see。 it's
    reinstalling all the packages。 I will tell you in a moment why this is wrong and
    how we can fix it。 And finally it's done。 So let's start our server。
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该可以解决问题。那么让我们重建我们的 Docker 镜像。正如你所见，它正在重新安装所有包。我稍后会告诉你为什么这是错误的，以及我们如何修复它。最后完成了。那么让我们启动我们的服务器。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_202.png)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_202.png)'
- en: One more try。 Perfect。 It's working。 And we can add tasks， so the database is
    there。 We can mark them as done。 And tell it them。
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 再试一次。完美。它在工作。我们可以添加任务，所以数据库在那里。我们可以将它们标记为完成。并告诉它们。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_204.png)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_204.png)'
- en: Now that everything is working， let's talk about why our Docker file is wrong。
    First of all。 our application is not ready to be sent to production。 We are still
    using the SQL Lite database。 And the debugger is enabled。 Well， those two things
    can be fixed with a proper database like PostgreSQL。 Docker Compose， and Environment
    Variables。 But even disregarding the problems with our flask application。
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切正常，让我们谈谈为什么我们的 Docker 文件是错误的。首先，我们的应用程序尚未准备好发送到生产环境。我们仍在使用 SQL Lite 数据库。调试器是启用的。好吧，这两个问题可以通过适当的数据库，如
    PostgreSQL、Docker Compose 和环境变量来解决。但即使不考虑我们 Flask 应用程序的问题。
- en: the Docker file that we just， wrote is far from perfect。 Here are some problems。
    On the first line we are specifying Python as our base image。 But we are not specifying
    a tag。 so Docker will pull the latest image。 And at the time of writing， this
    is 3。8。2。 But then later the latest tag is going to be 3。8。3， 3。9， and so on。
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写的 Docker 文件远非完美。这里有一些问题。在第一行中，我们指定了 Python 作为我们的基础镜像。但我们没有指定标签，因此 Docker
    将拉取最新的镜像。在撰写本文时，这是 3.8.2。但是后来最新标签将变为 3.8.3、3.9 等等。
- en: And if a new version of Python introduces some breaking changes， you will only
    notice that。 after your application goes down。 So always specify a tag for the
    base image。 In the second step we copy everything from the current directory into
    the root of the container。 And this has a few problems。 The main issue is that
    we are not using caching。
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新版本的 Python 引入了一些重大变化，你只会在应用程序崩溃后才会注意到。所以始终为基础镜像指定一个标签。在第二步中，我们将当前目录中的所有内容复制到容器的根目录。这存在一些问题。主要问题是我们没有使用缓存。
- en: Docker will cache each step of the build stage。 And each command in the Docker
    file is a build step。 When you run the Docker build command， Docker will check
    if it needs to run this step or。 if it can reuse the cache。 For example， if you
    didn't change the base image。 Docker will use the cached one instead， of redownloading
    it。
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 将缓存构建阶段的每个步骤。Docker 文件中的每个命令都是一个构建步骤。当你运行 Docker build 命令时，Docker 将检查是否需要运行此步骤，或者它是否可以重用缓存。例如，如果你没有更改基础镜像，Docker
    将使用缓存的镜像，而不是重新下载它。
- en: If you have a command to app get install some packages and you don't modify
    it at least。 Docker will reuse the cached layer instead of reinstalling all the
    packages。 And once Docker gets to a step where it can't use the cache， it will
    rerun this and every。 next command。 So it's very important to understand how caching
    works and how to take advantage of it。
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个命令来使用 app get 安装一些包，而你没有至少修改它，Docker 将重用缓存层，而不是重新安装所有包。一旦 Docker 到达一个无法使用缓存的步骤，它将重新运行此步骤及后续的每个命令。因此，了解缓存的工作原理以及如何利用它是非常重要的。
- en: If you don't structure your Docker files properly， then the build time is going
    to take。 you minutes and you will be just waiting there。 In our case we copy all
    the files and then we run pip install。 Now each time we modify any file in our
    project， it will invalidate the cache and then the pip。 install will run again，
    even though we didn't actually add any new packages so it's not needed。
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有正确构建你的 Docker 文件，那么构建时间会很长，你会在那里等待。在我们的案例中，我们复制所有文件，然后运行 pip install。现在每次我们修改项目中的任何文件，它都会使缓存失效，然后
    pip install 会再次运行，尽管我们实际上没有添加任何新包，因此这并不需要。
- en: We could instead copy only the requirements。txt file first， run pip and then
    copy the rest。 of the files。 This is a very common practice and that way pip install
    step will only be invalidated when。 the requirements。txt file changes。 So in general
    you want to put the lines that are installing something on the top of the。 Docker
    file and put the lines that can change as low in the Docker file as possible。
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先仅复制 requirements.txt 文件，运行 pip，然后再复制其余文件。这是一种非常常见的做法，这样 pip install 步骤只有在
    requirements.txt 文件更改时才会失效。因此，通常您希望将安装某些内容的行放在 Docker 文件的顶部，并将可以更改的行尽可能放在 Docker
    文件的底部。
- en: If you're using the end of module and you have the end of directory inside the
    same。 folder as your project， you will notice that each time you try to build
    a Docker image。 it takes a couple of seconds to actually start。 This is because
    Docker is sending the current directory to the Docker daemon for the building。
    purpose。 And the V and folder is actually quite big comparing to the rest of the
    files。
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在模块结束时使用，并且目录的末尾在与您的项目相同的文件夹内，您会注意到每次尝试构建 Docker 镜像时，实际启动需要几秒钟。这是因为 Docker
    正在将当前目录发送到 Docker 守护进程进行构建。并且 V 和文件夹实际上相对于其他文件来说相当大。
- en: There's a few dozens of megabytes and actually Docker doesn't need this folder
    at all。 So you could move it somewhere else or you could write a Docker ignore
    file。 And we are also copying all the files to the root of the container。 Normally
    it doesn't matter but if you ever need to start a bar session in the container。
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹有几十兆，实际上 Docker 根本不需要这个文件夹。所以您可以将它移动到其他地方，或者您可以编写一个 Docker 忽略文件。同时我们也在将所有文件复制到容器的根目录。通常这无所谓，但如果您需要在容器中启动一个
    bar 会话，情况可能会有所不同。
- en: and move around there， it will be a mess to figure out which files belong to
    your project。 and which belong to the container。 So it's much better to copy your
    project into a separate directory。 And then we are also not specifying which version
    of PIP we want to use。 In our case。 it's probably not a big problem。 Python image
    will make sure that the PIP version it uses。
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在那里面四处移动，您将会发现很难弄清楚哪些文件属于您的项目，哪些文件属于容器。因此，将您的项目复制到一个单独的目录中会更好。同时，我们也没有指定要使用哪个版本的
    PIP。在我们的情况下，这可能不是大问题。Python 镜像会确保它使用的 PIP 版本。
- en: it's bug free。 But if you install packages with apt-get， it's a good idea to
    pin package versions。 So try to always specify which version of software you want
    to use。 99% of the time you should be fine without pin versions of apt packages，
    but it might。 save you from 1% of weird bugs。 And it will also help you with cache
    busting。
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 它是无 bug 的。但是，如果您使用 apt-get 安装软件包，锁定软件包版本是个好主意。因此，请尽量始终指定您想使用的软件版本。99% 的情况下，您在没有锁定
    apt 包版本的情况下应该没问题，但这可能会让您避免 1% 的奇怪 bug。同时，它也会帮助您进行缓存失效。
- en: So here we have an example of how to improve our Docker file。 We pin the Python
    version。 we copy the requirements。txt， we set the work directory for /project，
    then we run PIP install。 then we copy the rest of the files。 At this stage， most
    of the time your caching will stop working。 but this is fine because， just copying
    files and running a Python command is gonna take you milliseconds。
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个如何改进 Docker 文件的示例。我们锁定 Python 版本，复制 requirements.txt，设置工作目录为 /project，然后运行
    PIP install，接着复制其余文件。在这个阶段，您的缓存大多数时候会停止工作，但这没关系，因为仅仅复制文件和运行 Python 命令会花费您几毫秒。
- en: And finally we run Python run command。 So let's take this improved version of
    a Docker file。 let's rebuild our image and let's， send it to Docker Hub。
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 最后我们运行 Python run 命令。所以让我们来看看这个改进后的 Docker 文件，重建我们的镜像，然后将其发送到 Docker Hub。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_206.png)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_206.png)'
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_207.png)'
  id: totrans-504
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_207.png)'
- en: To follow this last part and use Docker Hub， you first need to register。 Docker
    Hub is like GitHub but for Docker images。 So first go to this URL。 click sign
    up and then create an account。
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成最后一部分并使用 Docker Hub，您首先需要注册。Docker Hub 就像 GitHub，但用于 Docker 镜像。因此，请首先访问这个网址。点击注册，然后创建一个帐户。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_209.png)'
  id: totrans-506
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_209.png)'
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_210.png)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_210.png)'
- en: Once you have an account， you'll have to log in by running Docker log in command
    in your。
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了帐户，就必须通过运行 Docker login 命令来登录。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_212.png)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_212.png)'
- en: terminal。 Our image has finished building。 Let's log in to Docker Hub。 Normally
    it would ask you for a password， since I was already logged in， I don't have to
    do。
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 终端。我们的镜像构建已完成。让我们登录到 Docker Hub。通常它会要求你输入密码，由于我已经登录，所以我不需要执行这个步骤。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_214.png)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_214.png)'
- en: this。 So first we need to tag our image。 Make sure you replace this part with
    your Docker Hub username。 Now we push this image to Docker Hub。
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们需要标记我们的镜像。确保将这一部分替换为你的 Docker Hub 用户名。现在我们将这个镜像推送到 Docker Hub。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_216.png)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_216.png)'
- en: This is going to take some time。
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要一些时间。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_218.png)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_218.png)'
- en: And now to run your application on a different computer， all you have to do
    is to specify the。 name of the image from Docker Hub。 So first is your username
    from Docker Hub and then the name of the image。 If you're doing this step on your
    computer， you probably want to verify that you're actually。 using the image from
    Docker Hub， not the one that you build locally。
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要在另一台计算机上运行你的应用，你只需指定 Docker Hub 上的镜像名称。所以首先是你在 Docker Hub 的用户名，然后是镜像的名称。如果你在自己的计算机上执行这个步骤，可能想要确认你确实是在使用
    Docker Hub 的镜像，而不是本地构建的那个。
- en: So first run this command to list all images and then delete them。
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 首先运行这个命令来列出所有镜像，然后删除它们。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_220.png)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_220.png)'
- en: Now if you do this Docker run command， you will see that it's unable to find
    image locally。 and it will pull it from Docker Hub。 If you want to test our image
    on a server。 we could create an AWS or Google Cloud Platform， account。 But that
    costs money and it takes time to set up。 For our simple application。
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你执行这个 Docker run 命令，你会看到它无法在本地找到镜像，并将从 Docker Hub 拉取。如果你想在服务器上测试我们的镜像，我们可以创建一个
    AWS 或 Google Cloud Platform 账户。但这需要花费金钱并且设置起来需要时间。对于我们的简单应用来说。
- en: we can use the free Play with Docker Playground。 It's not something that you
    can use for production。 but it's perfect way to test our to do app。 So let's go
    here。 You can log in with your Docker Hub credentials。 Once you log in。 you get
    the start button and this will create Playground session for you。
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用免费的 Play with Docker Playground。这不是一个适合生产环境的工具，但它是测试我们的待办事项应用的完美方式。所以让我们去这里。你可以用你的
    Docker Hub 凭据登录。一旦登录，你会看到开始按钮，这将为你创建 Playground 会话。
- en: It will be active for four hours。 After this time， everything inside this session
    is destroyed。 but you are free to start another， session。
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 它将持续四个小时。在此之后，这个会话中的所有内容都会被销毁。但你可以自由地启动另一个会话。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_222.png)'
  id: totrans-522
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_222.png)'
- en: So we add a new instance。 In the meantime， let's check if our image was pushed
    to。
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们添加一个新实例。在此期间，让我们检查一下我们的镜像是否已经推送成功。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_224.png)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_224.png)'
- en: Yeah。 So our image was pushed to Docker Hub。
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。我们的镜像已经推送到 Docker Hub。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_226.png)'
  id: totrans-526
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_226.png)'
- en: So now we can actually run the same command that we were running on local host。
    As you can see。 it's downloading the image。 And now you will see our app is running
    on port 5000。 And we actually have this button here that we can click。
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们实际上可以运行与在本地主机上相同的命令。如你所见，它正在下载镜像。现在你会看到我们的应用正在 5000 端口运行。而且我们这里有一个按钮可以点击。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_228.png)'
  id: totrans-528
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_228.png)'
- en: Ta-da。 So that's your to do application running on a server somewhere。 You can
    actually take this link and send it to someone and they will be able to see your。
    to do list， at least for the next four hours before the session gets destroyed。
    Great。 So that was the last part。 There are still some more things that you have
    to keep in mind with Docker like image sizes。
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 哒哒！这就是你的待办事项应用在某个服务器上运行。你实际上可以把这个链接发送给别人，他们将能够看到你的待办事项列表，至少在接下来的四个小时内，在会话被销毁之前。太好了。这是最后一部分。关于
    Docker 还有一些事情需要记住，比如镜像大小。
- en: multi-stage builds， separate user for the app and things like Docker swarm。
    And we only really scratched the surface with the Docker， but I wanted to show
    you the minimum。 amount of things that you need to know to actually deploy your
    applications somewhere。 And that concludes this tutorial。 Congratulations。 So
    we have reached the end of the tutorial。
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建，为应用程序分配单独的用户，还有Docker swarm等内容。我们只是初步接触了Docker，但我想向你展示实际部署应用所需了解的最基本内容。这就是本教程的结束，恭喜你！我们已经达到了教程的尾声。
- en: I hope you follow the long and you managed to set up everything nicely。 So I
    showed you how to set up VS code for writing Python。 We learned how to manage
    different versions of Python and its dependencies and how to structure。 a Python
    project。 We talked about testing and documentation。
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能顺利完成所有设置。我向你展示了如何设置VS Code以编写Python。我们学习了如何管理不同版本的Python及其依赖关系，以及如何构建一个Python项目的结构。我们还讨论了测试和文档。
- en: we built a small to do application and we deployed， it with Docker。 If you got
    lost somewhere on the way or if you have some questions that I didn't answer。
    you can find me on LinkedIn， on Twitter and I also have a contact form on my website。
    If you enjoyed this workshop and you would like to learn more， I have a two day
    long， version of it。
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个小的待办事项应用，并使用Docker进行了部署。如果你在过程中迷路，或者有我未回答的问题，可以在LinkedIn或Twitter上找到我，我的网站上也有联系表单。如果你喜欢这个研讨会并希望了解更多，我有一个为期两天的版本。
- en: The first day covers Python tools and best practices in more detail and on the
    second。 day we talk about deploying stuff。 I hope you enjoyed this tutorial and
    see you next year at Python or maybe one of the other。 Python conferences around
    the world。
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 第一天详细介绍了Python工具和最佳实践，第二天我们讨论了部署内容。希望你喜欢这个教程，明年在Python大会上见，或者其他全球的Python会议。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_230.png)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_230.png)'
- en: Take care。 [BLANK_AUDIO]。
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 保重。 [BLANK_AUDIO]。
- en: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_232.png)'
  id: totrans-536
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1842d3c14a35b4d4915acfc4044ad_232.png)'
