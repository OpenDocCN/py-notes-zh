- en: P64：Talk Reuven M. Lerner - Function dissection lab -- learn how functions -
    程序员百科书 - BV1rW4y1v7YG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P64：谈话鲁文·莱尔纳 - 函数剖析实验室 -- 学习如何使用函数 - 程序员百科书 - BV1rW4y1v7YG
- en: '![](img/60c13f72707c907d0fbb45b67db702f7_0.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60c13f72707c907d0fbb45b67db702f7_0.png)'
- en: 嗨，我是鲁本勒纳，欢迎来到我的蟒蛇对话功能部门实验室，把他们分开，关于我自己的几句话，我是一个全职的蟒蛇驯兽师，大多数时候，我在一个不同的城市，不同的国家，不同公司教蟒蛇，从
    python到非程序员。最近一直在高级蟒蛇车间工作，我没有经常旅行，但我仍在通过 webex和 zoom进行大量训练，我的网站上也有很多关于 python数据的课程，科学与垃圾，一系列课程来提高你的蟒蛇技能。我刚刚出版了一本叫巨蟒健身的书，我的"更好的开发人员"列表每周都有一万五千名开发人员提供python的提示和提示，但关于我的事已经说够了，让我们写一些代码，然后我们把它拆开，所以让我们考虑这段代码。我得到了x=10
    20 30，所以我定义了一个列表，然后d等于1，b，2，c，3，所以我在定义一个字典，然后我还要定义一个函数，你好 名字，回你好 名字，我们看着这个，我们想，好的，我定义了变量。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 嗨，我是鲁本·勒纳，欢迎来到我的蟒蛇对话功能部门实验室，把他们分开，关于我自己的几句话，我是一个全职的蟒蛇驯兽师，大多数时候，我在一个不同的城市，不同的国家，不同公司教蟒蛇，从Python到非程序员。最近一直在高级蟒蛇车间工作，我没有经常旅行，但我仍在通过Webex和Zoom进行大量训练，我的网站上也有很多关于Python数据的课程，科学与垃圾，一系列课程来提高你的蟒蛇技能。我刚刚出版了一本叫巨蟒健身的书，我的“更好的开发人员”列表每周都有一万五千名开发人员提供Python的提示和提示，但关于我的事已经说够了，让我们写一些代码，然后我们把它拆开，所以让我们考虑这段代码。我得到了x=10
    20 30，所以我定义了一个列表，然后d等于1，b，2，c，3，所以我在定义一个字典，然后我还要定义一个函数，你好名字，回你好名字，我们看着这个，我们想，好的，我定义了变量。
- en: 我在定义一个函数，但蟒蛇对此的看法非常不同，Python实际上把它们看作是大致相等的，我们可以很容易地看到，通过philip well所写的python家教网站，所以我们在这里看到三个全局变量，例如：
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我在定义一个函数，但蟒蛇对此的看法非常不同，Python实际上把它们看作是大致相等的，我们可以很容易地看到，通过Philip Well所写的Python家教网站，所以我们在这里看到三个全局变量，例如：
- en: （10）ten twenty third（30）参考字典，一个，b 2 c 3，hello指的是函数对象，你好，函数对象听起来有点滑稽，是啊，功能对象有点奇怪，因为它们让我们思考功能。不仅仅是我们可以执行和运行的动词，但也有我们可以使用的名词，所以当你用
    def创建一个函数，你实际上是在做两件不同的事情，你要创建一个函数对象，然后你把它分配给一个变量。那么了解和思考函数对象的好处是什么呢，实际上一旦我们开始考虑函数作为对象，我们可以记住函数，就像所有的对象都可以被分配给其他名称一样，所以如果我已经有了"你好"功能，我也可以说你好，对等人，你好。现在这两个变量，你好你好，引用完全相同的函数，好的，但我也可以把一个函数作为参数传递给另一个函数，或者一种方法，或对象构造函数，这是一个有趣的，我可以说你好，括号，你好，在这个例子中。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: （10）十 二十 三（30）参考字典，一个，b 2 c 3，hello指的是函数对象，你好，函数对象听起来有点滑稽，是啊，功能对象有点奇怪，因为它们让我们思考功能。不仅仅是我们可以执行和运行的动词，但也有我们可以使用的名词，所以当你用def创建一个函数，你实际上是在做两件不同的事情，你要创建一个函数对象，然后你把它分配给一个变量。那么了解和思考函数对象的好处是什么呢，实际上一旦我们开始考虑函数作为对象，我们可以记住函数，就像所有的对象都可以被分配给其他名称一样，所以如果我已经有了“你好”功能，我也可以说你好，对等人，你好。现在这两个变量，你好你好，引用完全相同的函数，好的，但我也可以把一个函数作为参数传递给另一个函数，或者一种方法，或对象构造函数，这是一个有趣的，我可以说你好，括号，你好，在这个例子中。
- en: 我正在执行hello函数，我把它当作动词，但我也通过了，你好，与名词本身的功能相同，所以我们可以把函数作为参数，没问题，我们一直在做的事，我还记得 python中的所有对象都有属性。所以如果你有一个
    b b是属于，不是局部变量，我们一直在用它们，我们可以得到一个对象上所有属性的列表，返回函数对象上的所有属性，好的，很好很有趣，除了 python如何使用函数的属性，好吧。让我们再定义一个函数，返回字符串，你好
    名字，现在让我们运行它，所以，如果我把"你好"作为一个属性作为一个参数，如果我们拿回绳子，你好 世界到目前为止一切都很好。如果我在没有参数的情况下调用这个函数
    会发生什么，你好 括号，好吧，然后我们得到一个错误，错误是 hello 缺少一个必需的位置参数名称，我的问题是，蟒蛇怎么知道，它怎么知道我们少了一个位置论点。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在执行hello函数，我把它当作动词，但我也通过了，你好，与名词本身的功能相同，所以我们可以把函数作为参数，没问题，我们一直在做的事，我还记得Python中的所有对象都有属性。所以如果你有一个b
    b是属于，不是局部变量，我们一直在用它们，我们可以得到一个对象上所有属性的列表，返回函数对象上的所有属性，好的，很好很有趣，除了Python如何使用函数的属性，嗯。让我们再定义一个函数，返回字符串，你好名字，现在让我们运行它，所以，如果我把“你好”作为一个属性作为一个参数，如果我们拿回绳子，你好世界到目前为止一切都很好。如果我在没有参数的情况下调用这个函数会发生什么，你好括号，嗯，然后我们得到一个错误，错误是hello缺少一个必需的位置参数名称，我的问题是，蟒蛇怎么知道，它怎么知道我们少了一个位置论点。
- en: 它又是怎么知道这个位置论点叫做名字的呢？答案是属性，函数对象上最重要的属性是 dunder code under under under，这是一种心脏，灵魂，大脑，不管你想描述什么函数对象。如果你不确定什么是字节码，记住蟒蛇不是一种解释语言，当我们定义一个函数，函数实际上被编译为一个中间形式，字节码，它们存储在函数对象内部，当我们运行我们的功能时，函数的字节码被用来执行它。我们稍后会讨论更多关于字节码的内容，那么python如何知道我们的函数对代码对象有多少参数呢？Dunder代码有自己的属性，因为它是一个物体，python中的所有对象都有属性。指示函数需要多少参数
    所以你好，暗号，CR计数显示一个是正确的，函数接受一个参数，所以当我们运行函数时，当我们跑的时候，你好，世界，蟒蛇说可以，上头说我们需要一个理由，用户传递了一个参数，一切都好。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 它又是怎么知道这个位置论点叫做名字的呢？答案是属性，函数对象上最重要的属性是 dunder code，这是一种心脏，灵魂，大脑，不管你想描述什么函数对象。如果你不确定什么是字节码，记住蟒蛇不是一种解释语言，当我们定义一个函数，函数实际上被编译为一个中间形式，字节码，它们存储在函数对象内部，当我们运行我们的功能时，函数的字节码被用来执行它。我们稍后会讨论更多关于字节码的内容，那么Python如何知道我们的函数对代码对象有多少参数呢？Dunder代码有自己的属性，因为它是一个物体，Python中的所有对象都有属性。指示函数需要多少参数，所以你好，暗号，CR计数显示一个是正确的，函数接受一个参数，所以当我们运行函数时，当我们跑的时候，你好，世界，蟒蛇说可以，上头说我们需要一个理由，用户传递了一个参数，一切都好。
- en: 但是当我们调用参数为零的函数时，会发生什么，好吧，蟒蛇会说，嗯，CR计数显示我们需要一个论点，这就是为什么我们现在得到了错误，这个名字怎么样，python如何知道我们的参数应该被分配给参数名。你不会惊讶地听到还有另一个属性，我们将在这里讨论很多属性，这个属性是
    Covar names，参数是局部变量，它们在函数体内部没有定义，但它们仍然被定义为，它们仍然是局部变量，我们的名字总是一组字符串。每个字符串是一个局部变量的名称，所以如果我们看看我们的名字，我们会看到它是一个只有一个元素的元组，一个字符串名称，所以
    python现在知道函数需要一个参数，这个参数将被指定为，如果我们没有争论。名称缺少一个值，当然，当我们在没有任何争论的情况下运行你好时，我们得到错误消息，Hello缺少一个必需的位置参数
    name，如果我们的函数有两个参数，DEO第一和最后，先还最后一口井。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们调用参数为零的函数时，会发生什么，嗯，蟒蛇会说，CR计数显示我们需要一个论点，这就是为什么我们现在得到了错误，这个名字怎么样，python如何知道我们的参数应该被分配给参数名。你不会惊讶地听到还有另一个属性，我们将在这里讨论很多属性，这个属性是
    Covar names，参数是局部变量，它们在函数体内部没有定义，但它们仍然被定义为，它们仍然是局部变量，我们的名字总是一组字符串。每个字符串是一个局部变量的名称，所以如果我们看看我们的名字，我们会看到它是一个只有一个元素的元组，一个字符串名称，所以Python现在知道函数需要一个参数，这个参数将被指定为，如果我们没有争论。名称缺少一个值，当然，当我们在没有任何争论的情况下运行你好时，我们得到错误消息，Hello缺少一个必需的位置参数
    name，如果我们的函数有两个参数，DEO第一和最后，先还最后一口井。
- en: 如果我们看看我们的计数，会是两个，如果我们看名字，这将是第一个也是最后一个，因此错误消息使用这些信息，我们无时无刻不在看到，如果我现在用这两个参数版本打电话给你好，你好
    鲁 文，我将会收到错误信息。说不，Hello仍然缺少一个必需的位置参数，叫做last，如果我打电话，我试着做一只聪明的麋鹿，对吧，我不只是通过立场论点，我把它作为一个关键字参数，好吧，它会说不不不，你仍然缺少一个先调用的位置参数。如果我试着用三个不同的参数来调用这个函数呢，它会说不不，你不能这么做，你还提供了三个，如果我也定义一个局部变量，所以让我们稍微改变一下我们的函数，所以现在，不是马上归还绳子，我们把它分配给一个局部变量。It"很好，我看着我们的计数，CR计数，它将向我表明，计数仍然是两个，我们仍然只有两个论点，第一次和最后一次，所以函数的参数通常是名字的前几个元素，有多少人，不管它说什么，是啊。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看我们的计数，会是两个，如果我们看名字，这将是第一个也是最后一个，因此错误消息使用这些信息，我们无时无刻不在看到，如果我现在用这两个参数版本打电话给你好，你好鲁文，我将会收到错误信息。说不，Hello仍然缺少一个必需的位置参数，叫做last，如果我打电话，我试着做一只聪明的麋鹿，对吧，我不只是通过立场论点，我把它作为一个关键字参数，嗯，它会说不不不，你仍然缺少一个先调用的位置参数。如果我试着用三个不同的参数来调用这个函数呢，它会说不不，你不能这么做，你还提供了三个，如果我也定义一个局部变量，所以让我们稍微改变一下我们的函数，所以现在，不是马上归还绳子，我们把它分配给一个局部变量。好的，我看着我们的计数，CR计数，它将向我表明，计数仍然是两个，我们仍然只有两个论点，第一次和最后一次，所以函数的参数通常是名字的前几个元素，有多少人，不管它说什么，是啊。
- en: 但是我们还有一些其他的参数，我们还没有用这个系统来描述，例如，会不会是飞溅的痕迹，飞溅弧，你可能知道，接受任何其他人不想要的额外位置参数，所以如果我先定义"你好"，最后的飞溅，它总是会是一个元组。所以在这里如果我打电话给你好，一个孩子会被分配到第一个，B将被分配到最后，其余的都会被分配成一个元组，到弧线，这真的很方便，所以如果我看看现在的人数，我会看到什么
    实际上两个。它不认为 args是一个正则参数，但如果我们看名字，所以 ARX是一个变量，它是一个局部变量，只是这不是争论的一部分，所以到底发生了什么，蟒蛇是怎么知道它应该做这种任务的，好吧，在这里我们有一点魔法。所以有一个变量叫做，或，我应该说一个叫做
    co flags和 co flags的属性是一个整数，但这不是普通的整数，它是一个整数 我们把它当作一组位域，所以如果你把它想象成一个二进制数字，每一个比特。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们还有一些其他的参数，还没有用这个系统来描述，例如，飞溅的痕迹，飞溅弧，你可能知道，接受任何其他人不想要的额外位置参数，所以如果我先定义“你好”，最后的飞溅，它总是会是一个元组。所以在这里如果我打电话给你好，一个孩子会被分配到第一个，B将被分配到最后，其余的都会被分配成一个元组，到弧线，这真的很方便，所以如果我看看现在的人数，我会看到什么，实际上两个。它不认为
    args是一个正则参数，但如果我们看名字，所以 ARX是一个变量，它是一个局部变量，这不是争论的一部分，所以到底发生了什么，蟒蛇是怎么知道它应该做这种任务的，嗯，在这里我们有一点魔法。所以有一个变量叫做，或者，我应该说一个叫做
    co flags和 co flags的属性是一个整数，但这不是普通的整数，它是一个整数，我们把它当作一组位域，所以如果你把它想象成一个二进制数字，每一个比特。
- en: 每个二进制数字可以是一，也可以是零，它指示事物是真的还是假的，例如，其中两个总是会被优化，以及新的当地人，这些在蟒蛇身上已经持续了很多年，它们表明很久以前做过的事情，不过，我们有飞溅的弧线。所以如果右边的第三个位有一个，然后函数有平坦的弧线，如果它是零，那就没有飞溅的弧线，类似地，如果将右边的第四个位设置为，然后函数接受关键字参数，权杖，如果没有，然后非嵌套函数。如果我在另一个函数中定义了一个函数，那么这个嵌套函数将是，那个部分会被打开，最后，如果你想知道python如何区分正则函数和生成器函数，它如何知道是应该执行函数还是返回生成器，那里有个发电机。如果那是开着的，然后是一个生成函数，所以我们可以把这些看作是，在许多方面，用十六进制来思考要容易得多，所以我可以这样想
    这些数字，十六进制一二四八，如果我想知道，如果设置了特定的位字段。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个二进制数字可以是一，也可以是零，它指示事物是真的还是假的，例如，其中两个总是会被优化，以及新的当地人，这些在蟒蛇身上已经持续了很多年，它们表明很久以前做过的事情，不过，我们有飞溅的弧线。所以如果右边的第三个位有一个，然后函数有平坦的弧线，如果它是零，那就没有飞溅的弧线，类似地，如果将右边的第四个位设置为，然后函数接受关键字参数，权杖，如果没有，然后非嵌套函数。如果我在另一个函数中定义了一个函数，那么这个嵌套函数将是，那个部分会被打开，最后，如果你想知道
    python 如何区分正则函数和生成器函数，它如何知道是应该执行函数还是返回生成器，那里有个发电机。如果那是开着的，然后是一个生成函数，所以我们可以把这些看作是，在许多方面，用十六进制来思考要容易得多，所以我可以这样想这些数字，十六进制一二四八，如果我想知道，如果设置了特定的位字段。
- en: 我只是按位和比较，所以，如果我想知道嘿，喂，采取飞溅弧线，我去拿旗子，按位使用，并使用十六进制零，以确保足够，我得到相同的价值，魔咒零四，这意味着这个位被设置好了，相比之下。如果我检查他们是
    kWR设置，我们乘双千瓦时吗？答案是否定的，我们得到零回来，如果我把它翻过来，如果我重新定义"你好"，所以它确实需要双倍的冰量，但不拿劈啪，所以现在我要检查嘿。它需要splat
    args吗？我要一点一点地做这个，不在那里，但如果我检查十六进制零8，果然，它现在就在那里，这是一个非常讨厌的肮脏，看这些小旗真恶心，有更好的办法。也就是使用带有
    python标准库和磁盘的 dis模块，反汇编有各种各样的函数，可以很容易地查看函数对象的字节码，所以如果我用磁盘显示代码，我们会看到 hello函数有各种各样有趣的信息。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是按位和比较，所以，如果我想知道嘿，喂，采取飞溅弧线，我去拿旗子，按位使用，并使用十六进制零，以确保足够，我得到相同的价值，魔咒零四，这意味着这个位被设置好了，相比之下。如果我检查他们是
    `kWR` 设置，我们乘双千瓦时吗？答案是否定的，我们得到零回来，如果我把它翻过来，如果我重新定义 "你好"，所以它确实需要双倍的冰量，但不拿劈啪，所以现在我要检查嘿。它需要
    `splat args` 吗？我要一点一点地做这个，不在那里，但如果我检查十六进制零八，果然，它现在就在那里，这是一个非常讨厌的肮脏，看这些小旗真恶心，有更好的办法。也就是使用带有
    python 标准库和磁盘的 `dis` 模块，反汇编有各种各样的函数，可以很容易地查看函数对象的字节码，所以如果我用 `dis` 显示代码，我们会看到 `hello`
    函数有各种各样有趣的信息。
- en: 我们现在不打算看所有的东西，但在其他事情中，我们看到了旗帜，上面写着优化新的当地人总是会被设置成，我们的关键词，这是蟒蛇谈论飞溅弧线的内在方式，我们的功能，对不起，双重飞溅，关键字的
    kWr。不管出于什么原因，这表明我们不是在一个嵌套的函数中，好的，好吧，这里还有一种奇怪的东西叫做常量，什么是常量，这些概念是，当你写函数的时候，翻译成字节码，任何文字，字符串、整数或其他没有实际存储的对象。与字节码一起，它们分别存储在常数中，然后在字节代码中
    他们提到常数1，常量二 常量三，这些总是存放在公司里，它总是函数对象上的另一个属性，现在零点元素，索引零处的项目，在一个公司里总是没有。这意味着每个功能都不总是可用的，你不需要为它做什么特别的事情，但其他东西也都存放在那里，我还发现有趣的是
    f弦被分解成几个部分，你好，在大括号和惊叹号之前，然后他们用索引号引用的字节码。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不打算看所有的东西，但在其他事情中，我们看到了旗帜，上面写着优化新的当地人总是会被设置成我们的关键词，这是蟒蛇谈论飞溅弧线的内在方式，我们的功能，对不起，双重飞溅，关键字的
    `kWr`。不管出于什么原因，这表明我们不是在一个嵌套的函数中，好的，好吧，这里还有一种奇怪的东西叫做常量，什么是常量，这些概念是，当你写函数的时候，翻译成字节码，任何文字，字符串、整数或其他没有实际存储的对象。与字节码一起，它们分别存储在常数中，然后在字节代码中提到常数1，常量二，常量三，这些总是存放在
    `co` 里，它总是函数对象上的另一个属性，现在零点元素，索引零处的项目，在一个 `co` 里总是没有。这意味着每个功能都不总是可用的，你不需要为它做什么特别的事情，但其他东西也都存放在那里，我还发现有趣的是
    `f` 弦被分解成几个部分，你好，在大括号和惊叹号之前，然后他们用索引号引用的字节码。
- en: 那么字节码本身呢，我们可以看看这些代码，CO代码是一个字节串，我想它是合适的，对，字节码和字节串，这就是现在一个函数的样子，如果你读不太懂的话，我知道嗯。所以让我们使用
    dis模块中的另一个函数来查看它，这分解了字节码，向我们展示了发生了什么，所以说负载常数，负载常数一，它正在查看co ah Conts，并在索引1检索项，快装，快装。表示使用本地变量格式值，这是一个格式字符串，加载常量感叹号，所以它把字符串拼凑起来，如我们所见，然后返回值，所以它会把绳子，好吧，你可能知道，函数可以有各种额外类型的参数，例如，违约怎么办。所以如果我说名字下的死亡等于世界，现在我的
    name参数有一个默认值，我不需要用参数调用这个函数，但是 cr计数发生了什么，结果都是一样的，所以我们的功能和以前一样，但我们知道我们可以毫无争议地打电话。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么字节码本身呢，我们可以看看这些代码，CO代码是一个字节串，我想它是合适的，对，字节码和字节串，这就是现在一个函数的样子，如果你读不太懂的话，我知道嗯。所以让我们使用
    `dis` 模块中的另一个函数来查看它，这分解了字节码，向我们展示了发生了什么，所以说负载常数，负载常数一，它正在查看 `co_consts`，并在索引1检索项，快装，快装。表示使用本地变量格式值，这是一个格式字符串，加载常量感叹号，所以它把字符串拼凑起来，如我们所见，然后返回值，所以它会把绳子，好吧，你可能知道，函数可以有各种额外类型的参数，例如，违约怎么办。所以如果我说
    `name` 下的 `death` 等于 `world`，现在我的 `name` 参数有一个默认值，我不需要用参数调用这个函数，但是 `cr` 计数发生了什么，结果都是一样的，所以我们的功能和以前一样，但我们知道我们可以毫无争议地打电话。
- en: 或者这将如何顺利地工作，还有另一个属性，这个属性叫做 dunder 默认值，它不在密码之下，相反，它是函数对象的一部分，所以它和雷雨衣差不多，所以所有的违约都存在，所以我们来看看，你好。敦德违约看起来像世界，默认值下的意思总是一个元组，如果没有违约，在函数定义中设置，所以我们可以总结一下
    当 python调用一个函数时，它比较了，有可数参数的个数，如果数字符合，传递参数，调用这个函数。一切都完成了，如果他们没有足够的理由，然后我们检查 dunder默认值是否可以缩小差距，如果是这样，我们将使用足够多的dunder默认值来计算，如果我们有太多的争论。然后我们要检查共同标记
    看看是由拼花标记定义的，如果是这样，我们就参考一下，我们将把剩下的参数分配给 splat arcs或任何在 co r count上以 co名称命名的变量。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 或者这将如何顺利地工作，还有另一个属性，这个属性叫做 `dunder` 默认值，它不在密码之下，相反，它是函数对象的一部分，所以它和雷雨衣差不多，所以所有的违约都存在，所以我们来看看，你好。`dunder`
    默认值看起来像世界，默认值下的意思总是一个元组，如果没有违约，在函数定义中设置，所以我们可以总结一下，当 python 调用一个函数时，它比较了，有可数参数的个数，如果数字符合，传递参数，调用这个函数。一切都完成了，如果他们没有足够的理由，然后我们检查
    `dunder` 默认值是否可以缩小差距，如果是这样，我们将使用足够多的 `dunder` 默认值来计算，如果我们有太多的争论。然后我们要检查共同标记，看看是由
    `splat` 标记定义的，如果是这样，我们就参考一下，我们将把剩下的参数分配
- en: 让我们来看看一些让很多人对违约感到恼火的事情，尽管这样考虑这个功能 死亡，加一 x点1的追加，所以我们在这里定义一个列表，我的单子10点20分30秒，然后我会打电话，在我的单子上加一个，现在怎么办。如果我把名单打印出来，我要回去
    10231，为什么 因为我通过了名单，我的函数列表，运行的函数在列表中添加了一个元素，太好了，名单变了，如果我再这样做，如果我再叫一个，再加一个。然后我会在这里打印打印我的列表，我们会得到10个21个31个，每次我们用我的列表调用函数，我们再加一个整数
    到最后，到目前为止一切都好，但现在让我们添加一个默认值，这个默认值将是一个空列表，假设是。很多人都有这样的假设 如果我调用这个函数 添加一个没有参数的函数，我们会得到一个分配给
    x的空列表，到目前为止，我们得到的价值是一个，所以很好，再来一次，打印加一个，我们得到的价值是，哦一个一个。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些让很多人对违约感到恼火的事情，尽管这样考虑这个功能 `death，加一 x点1` 的追加，所以我们在这里定义一个列表，我的单子 `10,
    20, 30`，然后我会打电话，在我的单子上加一个，现在怎么办。如果我把名单打印出来，我要回去 `10231`，为什么？因为我通过了名单，我的函数列表，运行的函数在列表中添加了一个元素，太好了，名单变了，如果我再这样做，如果我再叫一个，再加一个。然后我会在这里打印打印我的列表，我们会得到
    `10, 21, 31`，每次我们用我的列表调用函数，我们再加一个整数到最后，到目前为止一切都好，但现在让我们添加一个默认值，这个默认值将是一个空列表，假设是。很多人都有这样的假设，如果我调用这个函数添加一个没有参数的函数，我们会得到一个分配给
    `x` 的空列表，到目前为止，我们得到的价值是一个，所以很好，再来一次，打印加一个，我们得到的价值是，哦一个一个。
- en: 如果我们再做一次，价值是一个一个，发生了什么事 这么多，很多人认为当我们定义这样的函数时，我们告诉蟒蛇的是，如果我们不通过一个 x的参数，那么 x应该被分配到一个空列表中，但蟒蛇不是这么想的。蟒蛇想到了，然后它应该使用这个空列表
    是的，在默认情况下，它将这个空列表放入，当函数被创建时，记住在默认情况下是填充的，当函数被创建时，当它被定义的时候，所以每次我们在没有参数的情况下调用这个函数时。这个列表都会被检索到，它可以改变，也许默认值下是一个元组，不能改变，但其中的元素可以改变，所以结论是永远不要使用可变默认值，大问题，你不应该这么做，如果你用任何现代编辑或编辑，它会警告你。如果在命令行中使用
    pent，它还会告诉你，它会说嘿，你有一个危险的默认值，这里的空列表，别这样，还有最后一种争论，我想看看，这就是关键词，只有争论，这些在蟒蛇中相对较新。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再做一次，价值是一个一个，发生了什么事这么多，很多人认为当我们定义这样的函数时，我们告诉蟒蛇的是，如果我们不通过一个 `x` 的参数，那么 `x`
    应该被分配到一个空列表中，但蟒蛇不是这么想的。蟒蛇想到了，然后它应该使用这个空列表，是的，在默认情况下，它将这个空列表放入，当函数被创建时，记住在默认情况下是填充的，当函数被创建时，当它被定义的时候，所以每次我们在没有参数的情况下调用这个函数时。这个列表都会被检索到，它可以改变，也许默认值下是一个元组，不能改变，但其中的元素可以改变，所以结论是永远不要使用可变默认值，大问题，你不应该这么做，如果你用任何现代编辑或编辑，它会警告你。如果在命令行中使用
    `pent`，它还会告诉你，它会说嘿，你有一个危险的默认值，这里的空列表，别这样，还有最后一种争论，我想看看，这就是关键词，只有争论，这些在蟒蛇中相对较新。
- en: 这个想法是如果你想要一个参数的默认值，但你也想有飞溅的弧线，在早期版本的蟒蛇中 你不能这样做，所以我们现在有了关键词，只有在函数中表示在这里设置的参数具有空格的默认值，如果我们不明确指定。当我们调用这个函数
    你好，它就会一直默认，果然，如果我用sepp=星号呼叫abc的hello，然后我们会有星星在他们之间的 你好，那么蟒蛇在哪里跟踪，CR计数在这里是零。因为
    splat args不是 cr计数的一部分，因为我们的集合不是 cr计数的一部分，它在哪里 它在一个单独的属性中，只知道数量，这表明我们在那里有一个，所以我们看到。然后那条蟒蛇在很多地方检查我们的论点，CR计数，它检查默认情况下强制性位置参数的数量，这些是额外的值，使得r很重要，我们应该给splat
    args分配额外的位置参数吗？我们是否应该分配额外的关键字参数。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是如果你想要一个参数的默认值，但你也想有飞溅的弧线，在早期版本的蟒蛇中你不能这样做，所以我们现在有了关键词，只有在函数中表示在这里设置的参数具有空格的默认值，如果我们不明确指定。当我们调用这个函数
    `hello`，它就会一直默认，果然，如果我用 `sepp=星号` 呼叫 `abc` 的 `hello`，然后我们会有星星在他们之间的 `hello`，那么蟒蛇在哪里跟踪，`CR`
    计数在这里是零。因为 `splat args` 不是 `cr` 计数的一部分，因为我们的集合不是 `cr` 计数的一部分，它在哪里，它在一个单独的属性中，只知道数量，这表明我们在那里有一个，所以我们看到。然后那条蟒蛇在很多地方检查我们的论点，`CR`
    计数，它检查默认情况下强制性位置参数的数量，这些是额外的值，使得 `r` 很重要，我们应该给 `splat args` 分配额外的位置参数吗？我们是否应该分配额外的关键字参数。
- en: 这个是千瓦的两倍，最后我们知道只有论点才算数，只有关键字参数的个数，好的，稍微转换一下话题，让我们谈谈范围界定，如果我定义 x等于100全局变量，然后我定义这个函数，放克中的放克印刷。x等于
    x 调用这个函数，但首先让我们打印出 x的值是多少，在我们称之为，然后我们打电话给放克，我们会把它打印出来，当我们调用这个函数，当我们在这里调用打印，我们在寻找
    x的值。基本上 python说 x是一个全局变量，答案是肯定的，我们的价值是100，我们把它打印出来，我们得到了100英镑的回报，太棒了，所以我们拿回一百块，但是当我们调用我们的函数，发生什么好。现在是局部变量，Python需要检查它的作用域规则，这些作用域规则是用语言硬编码的，莱伊，Python会一直在这里查看所有这些，所以
    python会说 x是一个局部变量，答案是否定的，上面是这么说的。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个是千瓦的两倍，最后我们知道只有论点才算数，只有关键字参数的个数，好的，稍微转换一下话题，让我们谈谈范围界定，如果我定义 x等于100全局变量，然后我定义这个函数，放克中的放克印刷。x等于
    x 调用这个函数，但首先让我们打印出 x的值是多少，在我们称之为，然后我们打电话给放克，我们会把它打印出来，当我们调用这个函数，当我们在这里调用打印，我们在寻找
    x的值。基本上 python说 x是一个全局变量，答案是肯定的，我们的价值是100，我们把它打印出来，我们得到了100英镑的回报，太棒了，所以我们拿回一百块，但是当我们调用我们的函数，发生什么好。现在是局部变量，Python需要检查它的作用域规则，这些作用域规则是用语言硬编码的，莱伊，Python会一直在这里查看所有这些，所以
    python会说 x是一个局部变量，答案是否定的，上面是这么说的。
- en: 好的，我们没有函数中的函数，我们会忽略，它是一个全局变量，答案是肯定的，如你所见，到目前为止，我们已经赚了100英镑，所以很好，当然之后我们还能拿回100块，好的。但是python怎么知道x是一个局部变量呢？它检查了，它检查共同的名字，我们已经看过了，基本上
    python可以把 at x作为一个字符串，如果 x是 c名的字符串，如果是这样，它是一个局部变量。但如果没有，如果cr名称为空，不，因为x不是同名的，不是局部变量，让我们把事情变得更复杂一点，虽然，假设
    x和以前一样 等于100，但现在德芬克 x等于200，然后我们会打印出，所以这里发生了什么。好吧，当我们定义我们的函数时，我们编译我们的函数，蟒蛇给自己的笔记，x是一个局部变量，它看到这里的
    x等于，和笔记只是有一个哈哈，X是局部的，所以当我们在 x等于 x之前打印 然后放克，再打印。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们没有函数中的函数，我们会忽略，它是一个全局变量，答案是肯定的，如你所见，到目前为止，我们已经赚了100英镑，所以很好，当然之后我们还能拿回100块，好的。但是python怎么知道x是一个局部变量呢？它检查了，它检查共同的名字，我们已经看过了，基本上
    python可以把 at x作为一个字符串，如果 x是 c名的字符串，如果是这样，它是一个局部变量。但如果没有，如果cr名称为空，不，因为x不是同名的，不是局部变量，让我们把事情变得更复杂一点，虽然，假设
    x和以前一样 等于100，但现在德芬克 x等于200，然后我们会打印出，所以这里发生了什么。好吧，当我们定义我们的函数时，我们编译我们的函数，蟒蛇给自己的笔记，x是一个局部变量，它看到这里的
    x等于，和笔记只是有一个哈哈，X是局部的，所以当我们在 x等于 x之前打印 然后放克，再打印。
- en: 蟒蛇又要做它的 b，所以在功能之外，它会说这是全球性的，是的，有一个全局 x，它的价值是一百，然后我们要去放克，接下来会发生什么，它会说，嗯，这个 x，这是本地的，是的，是的，它是一个局部变量。它怎么知道，因为在共同的名字中，所以它检索到本地的x，也就是200，最后它又回来了，局部变量没了，我们只有全球，这很好，正如我们在这里看到的，如果我们看看科瓦尔的名字。果然
    x是在 covnames中定义的，这就是 python知道 co名称在编译时填充的原因，不在运行时，所以如果我们改变我们的功能和以前完全一样呢，不过，我要把这两条线，首先我要打印
    x的值。然后我会分配到200，所以在这里我将再次打印，放克和印刷，产量是多少，我会好起来的，它说在 x等于100之前，然后我得到了这个，这是怎么回事，未绑定本地错误，局部变量
    x在赋值前被引用，进展顺利。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 蟒蛇又要做它的 b，所以在功能之外，它会说这是全球性的，是的，有一个全局 x，它的价值是一百，然后我们要去放克，接下来会发生什么，它会说，嗯，这个 x，这是本地的，是的，是的，它是一个局部变量。它怎么知道，因为在共同的名字中，所以它检索到本地的x，也就是200，最后它又回来了，局部变量没了，我们只有全球，这很好，正如我们在这里看到的，如果我们看看科瓦尔的名字。果然
    x是在 covnames中定义的，这就是 python知道 co名称在编译时填充的原因，不在运行时，所以如果我们改变我们的功能和以前完全一样呢，不过，我要把这两条线，首先我要打印
    x的值。然后我会分配到200，所以在这里我将再次打印，放克和印刷，产量是多少，我会好起来的，它说在 x等于100之前，然后我得到了这个，这是怎么回事，未绑定本地错误，局部变量
    x在赋值前被引用，进展顺利。
- en: 我们定义了我们的函数和 python通知，当我们定义我们的函数时，我们在函数中有x等于，如果 x等于，这意味着 x一定是一个局部变量，x等于函数中的任意位置，使它成为一个局部变量，所以当我们运行函数时。我们到了打印的第一行，Python说实际上是一个局部变量，答案是肯定的，它的价值，在向下的局部层上绑定是一种奇特的说法，分配，喜欢给变量名赋值，所以非绑定局部变量基本上意味着你有一个没有值的局部变量。很奇怪，但在这里我们有它，我们已经到了一个角落，有点修复，现在你可能会说，好的，谁将打印一个值，你一定会很惊讶，但这个问题更常见的版本是
    如果我说 x等于100，现在我要定义函数，你看。我让你的 x加等于函数顶部的一条路，很多人会说，哦，我们将取值，全球一百倍，加1 2并分配给一个本地 x，但是没有，这等于说，x等于
    x加上一条蟒蛇会注意到 x等于，它会说啊哈，X是一个局部变量。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了我们的函数和 python通知，当我们定义我们的函数时，我们在函数中有x等于，如果 x等于，这意味着 x一定是一个局部变量，x等于函数中的任意位置，使它成为一个局部变量，所以当我们运行函数时。我们到了打印的第一行，Python说实际上是一个局部变量，答案是肯定的，它的价值，在向下的局部层上绑定是一种奇特的说法，分配，喜欢给变量名赋值，所以非绑定局部变量基本上意味着你有一个没有值的局部变量。很奇怪，但在这里我们有它，我们已经到了一个角落，有点修复，现在你可能会说，好的，谁将打印一个值，你一定会很惊讶，但这个问题更常见的版本是
    如果我说 x等于100，现在我要定义函数，你看。我让你的 x加等于函数顶部的一条路，很多人会说，哦，我们将取值，全球一百倍，加1 2并分配给一个本地 x，但是没有，这等于说，x等于
    x加上一条蟒蛇会注意到 x等于，它会说啊哈，X是一个局部变量。
- en: 我们会注意到，到了运行函数的时候，它会查找 x加1，x是什么 是本地的吗，是的，它的价值是什么，我们没有把它拆开，本地误差，现在我们可以做的另一件事是利用全球宣言。它能做什么
    它基本上是说我们不想把我们的名字写在一起，我们不想把它列成一个局部变量，所以当我们运行这个，会是一百两百，因为我们已经分配了200个，但它也会说200年，因为现在没有局部
    x。所以当我从函数内部给 x赋值时，我实际上是在给一个全局变量赋值，即使它不存在之前，它是一个全局变量，当然我们可以在这里看到，如果我们看看我们的名字，是空的，所以
    python用 leb来寻找 x。但在当地人身上找不到，所以我们就去环球影城，这很好，让我们使用磁盘来分解这些函数，并查看非全局版本和全局版本，如果 x的局部版本没有全局作用域，如果没有全球声明，快速存储和快速加载平均局部变量。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会注意到，到了运行函数的时候，它会查找 x加1，x是什么 是本地的吗，是的，它的价值是什么，我们没有把它拆开，本地误差，现在我们可以做的另一件事是利用全球宣言。它能做什么
    它基本上是说我们不想把我们的名字写在一起，我们不想把它列成一个局部变量，所以当我们运行这个，会是一百两百，因为我们已经分配了200个，但它也会说200年，因为现在没有局部
    x。所以当我从函数内部给 x赋值时，我实际上是在给一个全局变量赋值，即使它不存在之前，它是一个全局变量，当然我们可以在这里看到，如果我们看看我们的名字，是空的，所以
    python用 leb来寻找 x。但在当地人身上找不到，所以我们就去环球影城，这很好，让我们使用磁盘来分解这些函数，并查看非全局版本和全局版本，如果 x的局部版本没有全局作用域，如果没有全球声明，快速存储和快速加载平均局部变量。
- en: 现在变了，字节码更改为全局存储和全局加载，是时候变得更加复杂了，让我们讨论封闭函数或封闭作用域或嵌套作用域和函数，意思是我要定义一个函数，在这个函数里面，我将定义另一个函数。所以我的外在功能叫做外在功能，恰如其分的是
    它有两个局部变量，总共跑计数器，我要做的是，每次我运行函数的时候，我要添加到运行计数器，我要加上总数，挺好的，呵呵，现在，这有时被称为闭合。基本上如果我跑到外面，我要回去了，我要拿回那个函数对象，我可以分配它，就像我在这里放克一样，然后我可以运行放克，放克会得到一个参数x，然后我们会添加到运行计数器上
    我们会打印所有的东西 一切都会很好。当我运行它的时候，我得到一个未绑定的本地错误，如果我们回去一会儿，你会看到运行计数器加等于一，加起来等于，这正是粉笔几分钟前所说的，基本上等于1的结果就是我们失败了，把这些东西读一遍，好的。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在变了，字节码更改为全局存储和全局加载，是时候变得更加复杂了，让我们讨论封闭函数或封闭作用域或嵌套作用域和函数，意思是我要定义一个函数，在这个函数里面，我将定义另一个函数。所以我的外在功能叫做外在功能，恰如其分的是
    它有两个局部变量，总共跑计数器，我要做的是，每次我运行函数的时候，我要添加到运行计数器，我要加上总数，挺好的，呵呵，现在，这有时被称为闭合。基本上如果我跑到外面，我要回去了，我要拿回那个函数对象，我可以分配它，就像我在这里放克一样，然后我可以运行放克，放克会得到一个参数x，然后我们会添加到运行计数器上
    我们会打印所有的东西 一切都会很好。当我运行它的时候，我得到一个未绑定的本地错误，如果我们回去一会儿，你会看到运行计数器加等于一，加起来等于，这正是粉笔几分钟前所说的，基本上等于1的结果就是我们失败了，把这些东西读一遍，好的。
- en: 所以我们能做什么呢，我们可以使用非本地的，非本地告诉蟒蛇，不要把这些列作局部变量，但你要知道他们也不是全球性的，它们实际上在外部函数范围内，这些是属于外部函数的局部变量，所以当你修改它们的时候。不要在这里本地修改它们，不要寻找地球仪，但现在修改外部函数中的局部变量，如果这听起来很奇怪，让我们回到蟒蛇导师，我们会看到它是如何工作的，所以我们这里有一个外部的全局变量
    指向外部的函数。我们甚至看到一个堆栈帧 我们跑到外面回来的时候 我们在里面分配了一个放克，所以我们向右走函数对象，然后我们回到这个函数对象，它被称为放克和，我们在提到它时也有，它指的是定义它的范围，这是怎么工作的。它是如何跟踪外部作用域中的变量的，好吧，它有一个属性，总共跑柜台，我们用非局部变量声明的两个变量，但这不是单向的关系，原来外部函数也知道它的单元格
    ars属性，它知道哪些变量被定义了，并引用了它，好的。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们能做什么呢，我们可以使用非本地的，非本地告诉蟒蛇，不要把这些列作局部变量，但你要知道他们也不是全球性的，它们实际上在外部函数范围内，这些是属于外部函数的局部变量，所以当你修改它们的时候。不要在这里本地修改它们，不要寻找地球仪，但现在修改外部函数中的局部变量，如果这听起来很奇怪，让我们回到蟒蛇导师，我们会看到它是如何工作的，所以我们这里有一个外部的全局变量
    指向外部的函数。我们甚至看到一个堆栈帧 我们跑到外面回来的时候 我们在里面分配了一个放克，所以我们向右走函数对象，然后我们回到这个函数对象，它被称为放克和，我们在提到它时也有，它指的是定义它的范围，这是怎么工作的。它是如何跟踪外部作用域中的变量的，好吧，它有一个属性，总共跑柜台，我们用非局部变量声明的两个变量，但这不是单向的关系，原来外部函数也知道它的单元格
    ars属性，它知道哪些变量被定义了，并引用了它，好的。
- en: 我们学到了什么，首先，我们已经看到 def做了两件事，它定义了一个函数对象，它定义了函数对象，将函数对象分配给变量，第二，以及 python运行该函数的提示，最后，属性决定行为，我们认为理所当然。我们不太考虑争论，我们不太考虑范围，但事实是这些对我们的功能非常重要，它们都是由这些函数对象控制的，通过这些属性，如果，你有什么问题或意见，我很高兴在电子邮件或推特上收到你的来信。我希望明年在匹兹堡见到你。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到了什么，首先，我们已经看到 def做了两件事，它定义了一个函数对象，它定义了函数对象，将函数对象分配给变量，第二，以及 python运行该函数的提示，最后，属性决定行为，我们认为理所当然。我们不太考虑争论，我们不太考虑范围，但事实是这些对我们的功能非常重要，它们都是由这些函数对象控制的，通过这些属性，如果，你有什么问题或意见，我很高兴在电子邮件或推特上收到你的来信。我希望明年在匹兹堡见到你。
- en: '![](img/60c13f72707c907d0fbb45b67db702f7_2.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60c13f72707c907d0fbb45b67db702f7_2.png)'
