- en: P76：Tutorial Andrew Knight - Hands-On Web App Test Automation - 程序员百科书 - BV1rW4y1v7YG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_0.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: 你好，各位，我叫安迪•奈特，你可以简称我潘迪，我是个软件工程师，谁为测试问题构建解决方案，COM，本教程的标题是手在网络应用程序测试自动化，我非常兴奋能在网上把它作为蟒蛇20的一部分，在本教程中。在蟒蛇里，我们将使用圆周率测试作为我们的核心测试框架，我们将使用硒网络驱动程序来自动化与真正的实时网络浏览器的浏览器交互，本教程分为九个部分，每个部分都会有一个小的演讲片段。我已经将所有示例代码放入了Github存储库中，该存储库为本教程的每个部分提供了不同的分支，因此，您总是可以参考工作示例，可以这么说，你不需要任何测试经验作为先决条
    件。但是您需要中级的 python编程技能，所以如果你准备好了，这是我们教程的议程，我将首先做一个关于 web用户界面测试的入门讲座，将有九个部分我将在其中进行一些讨论，然后你们会在代码上做一些手工操作。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 本教程大约需要三个小时来完成，在我们开始上课之前，让我们设置我们的代码，转到这个 github链接，克隆存储库，它有所有的示例代码，以及自述文件中的所有教程说明，所以在这里暂停一下，克隆此回购。完成所有的安装步骤，然后继续讲课。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_2.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: 既然你的计划已经准备好了，让我们来谈谈 web用户界面测试。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_4.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
- en: 您如何定义测试，这是一个在软件工程中被广泛使用的词，我将测试定义为一种活动，它试图识别软件产品和特性中的优点和缺点，以保持质量，高测试可以通过有人敲打键盘来手动完成，在现场，部署或环境，然而。我注意到的一点是，当人们谈论测试时，对不同类型的测试活动有一个主要的误解，有时他们说的好像单元测试是唯一一种真正存在的测试，这不一定是真的，有很多种测试，单元测试只是直接测试小比特的代码。但我们也可以测试现场服务，API或
    web uis，在其他事情中，我在很多地方都见过这种误解，例如，它出现在2018年的蟒蛇开发者调查中，我非常。非常感谢 JetBrains和 Python软件基金会的调查，当我在2018年进行调查时，我真的很兴奋，因为我看到了一个关于测试框架的问题，我想这个问题已经被磨损了。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 类似于您在 python中使用的测试框架，然 而，当结果出来的时候 我看了报告，我注意到，在围绕测试框架答案的空话中，他们说引文引文，单元测试框架是这样那样的，哦，它，这让我很难过，因为它表明。并不是每个人都明白，这些框架中的一些，如pi测试，可以用于不仅仅是单元测试，测试代码和测试特性之间有一个根本的区别，当我们谈论测试代码时，我们指的是真正的蟒蛇密码，不管用什么语言，我们都会直接调用。与之互动，并对其做出断言，这种类型的测试称为白盒测试，我们想问的是，编写代码是为了做预期的事情吗，例如，它的预期是将两个数字相加，我可以有一大堆白盒测试，放入不同的数字组合，并断言和是返回的。很多时候我们称之为单元测试，单元测试，测试，个别职能或方法，我们也可以有另一种风格的白盒测试，称为皮下试验，不是单看单个单位，也许它在看一系列的电话或一堆东西在一起，总体情况。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 白盒测试是一种直接与代码交互的测试风格，测试可以调用那些函数，方法和模块，另一方面，有测试功能，当我说特征的时候，我不是说文字代码，我说的是我们在软件产品中构建的东西。特性是我们的最终用户要与最终用户交互的东西
    而不是直接与代码交互，例如，使用web ui应用程序，他们会点击按钮输入文本，他们不需要知道任何关于 javascript或 python的信息。他们只是在用它，比如产品或功能，所以当我们做所谓的黑匣子测试时，我们正在测试这个功能，不是密码，对，黑匣子测试没有直接调用的代码，黑匣子测试的目标有点不同，我们要问的问题是产品是否符合要求，2。这东西到底能不能用，我认为它应该做什么，它是将价值传递给最终用户吗，有很多，多种黑匣子测试，通常，当我们引用集成测试或端到端测试时，或者系统测试，这些是我们认为的黑匣子测试，因为它们不与代码交互。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 它们与实际功能或产品交互，我们需要有一个好的策略来决定何时运行不同类型的测试，这就是测试金字塔可以帮助我们的地 方，测试金字塔基本上只是根据测试的规模和强度
    将不同类型的测试分层，在金字塔的最底层。我们有所谓的单元测试，这些是那些白盒测试，将在单个一口大小的碎片中测试东西，因为单元测试快速且易于编写，他们也尽可能接近代码，他们很可能会很早就发现很多问题，如果我们在那里有很好的报道。所以我们希望有很多好的固体单元测试，他们就像第一道防线，然而，单凭单元测试是不够的，因为有时候当你把东西放在一起的时候就会出问题，这就是我们集成和端对端测试的地方，我们说过的那些黑匣子测试。集成测试通常意味着某种服务
    api调用端对端测试，根据你的申请，可能意味着 Web测试或终端应用程序测试或命令行测试，但为了我们的目的，因为这是一个关于 web应用测试自动化的教程。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 我们认为 Web应用程序是这里测试的主要产品，将金字塔移动到集成和端到端测试的更高位置，事情变得越艰难，考试更难写，他们有更多的依赖性，它们更有可能是片状的，就步骤数量而言，测试本身可能会更长。他们需要更多的时间来执行，考虑一下1的规则，在这个行业里，单元测试通常需要一毫秒的时间来运行，而一个端到端的
    web用户界面测试可能需要大约一分钟的时间来运行。除了团队为了实现集成和端到端测试的自动化而需要做的额外工作之外，还要加上这一点，像这样的黑匣子测试很快就变得非常昂贵，因此，我们不想有一套臃肿的测试，我们可能需要，也可能不需要，在这些更高的级别。因此金字塔的形状，更多的测试朝着底部，向顶部靠拢的
    按数量计算的测试更少，我们希望在平衡时间和投资回报的同时降低风险，所以现在让我们具体谈谈 web用户界面测试。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 什么是 web用户界面测试是通过实时浏览器对 web应用程序进行黑匣子测试，在这些测试中，我们会打开 chrome或者 firefox或者任何你想测试的浏览器，导航到网页，就像你是一个普通的人类用户。并与该页面上的东西互动，用户界面测试是否是功能测试，因为它像用户一样测试应用程序，它也是端对端测试，因为
    Web应用程序的所有部分都是一起使用的，考虑一下组成一个现代网络应用的所有部分。前端在由 html组成的浏览器中显示页面，你的 css，你的 javascript，您很可能还有一个服务层，像
    rest apis一样把数据传送到前端，您将拥有一个持久性层，你的数据库在后端。不管是 sql还是 nosql，在基础设施上，还有网络服务器和负载均衡器，你也可能有排队和工人为繁重的工作，需要去做异步处理或什么的，所以一个网络应用程序里有很多东西，不仅仅是表面层面，漂亮的一页。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 真的像一座冰山，你只看到一点点，但它背后有一吨重的重量，从好的方面来看，web用户界面测试有其利弊，你确实得到了很好的结束报道，所有的舞蹈在一起，测试还与产品交互，更像是一个真正的使用者。所以你能感觉到，成果有目共睹，可截图，你能发现明显的问题，比如如果你不能登录你的应用程序，或者如果页面上缺少一个元素，然而，这是有代价的，Webui测试的自动化要比单元测试复杂得多，就像我们说的。他们执行缓慢，当你有成百上千的web用户界面测试时，这真的很重要，它们也容易片状，因为您必须在等待页面加载的情况下处理比赛条件，最后，根本原因分析比单元测试更难，因为你的水平要高得多。所以你并不总是确切地知道问题发生在哪里，是什么造就了一个好的
    web用户界面测试，有几个指针，首先我可以给出一个很好的 web用户界面测试，应该关注 web ui应用程序中的一个主要行为。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 这可能是登录或创建新的配置文件 或上传特定的文档，你不希望一个测试做太多的事情，因为当测试失败时，你想知道到底是什么东西坏了，而且，好的检测要有清晰的分步流程。当你一步一步地阅读正在发生的事情和正在报道的事情时，直觉上应该是显而易见的，否则，分诊和根本原因分析可能要困难得多，一个好的
    web用户界面测试还涵盖了一个重要的核心特性。主要是坚持一个快乐的路径或一个基本的错误情况，并试图避免罕见的边缘情况，记住，web用户界面测试编写和运行都很昂贵，所以我们要确保从我们的测试中得到最大的价值，我们正在报道最重要的事情。作为基于风险的策略的一部分，避免测试某些东西可能是值得的，不是因为它们不容易坏，而是因为我们可能没有能力处理额外的数量，我们还想确保我们不会在
    web用户界面级别上自动化一些可以被单元测试覆盖的东西。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 服务测试或集成测试，如果能在较低的层次上处理一些事情，这意味着编写和运行测试更容易，执行测试更快，我们应该自动化剂量水平，而不是在更高的水平上，总的来说，这里有一个很好的问题可以用修辞的方式问自己。每当我们写一个测试，如果测试失败，人们会恐慌吗？他们会知道是什么打破了，如果答案是肯定的，因为
    web用户界面测试是昂贵的，把精力放在投资回报上，尽量从你的测试中得到最大的收获。无论这意味着良好的覆盖率，还是应用程序中最关键的部分，请记住，测试自动化并不是一个完美主义的挑战，它应该努力获得尽可能多的价值，它
    非常，当涉及到 web用户界面测试时 非常重要，在本教程中。我们将从头开始构建一个测试自动化解决方案，用蟒蛇，重要的是要记住，测试自动化是软件开发的一个特殊领域，就像我们有一些开发人员，他们制作网络应用程序或后端服务或其他任何可以开发的东西。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 测试自动化是软件产品，它需要同样的纪律，相同的最佳做法，相同的代码审查，工具堆，所有会进入其他领域的东西，所以我们需要把它当作是我们解决方案中的软件开发来对待，我们将使用
    python作为实现语言。我们将使用圆周率测试作为我们的核心测试框架，它将把我们所有的测试用例排成一行，并像多米诺骨牌一样将它们击倒，用于我们的用户界面交互，我们将使用一个称为页面对象模式的设计模式来对所有内容进行建模。那些点击得到文本，你所做的一切，从一个浏览器，最后，对于低级别的浏览器自动化本身，以下是我们的解决方案，如果我们把它画成一个图表，在左边，我们将有我们的测试自动化代码，我们将编写一系列圆周率测试案例。在这些pi测试中，我们将调用页面对象类，这些类建模更高级别的交互，比如登录或在页面对象方法中搜索，会有人呼吁硒网络驱动程序绑定，低层次的相互作用，咔嗒声，擦伤，所有这些东西。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: webdriver绑定将调用中间体，就像一个代理，如果我们在本地进行测试，在本教程中我们会讲到，这个代理就是我们所说的可执行的网络驱动程序，它将是一个在本地机器上运行的过程。它将作为运行中的测试自动化和实时浏览器之间的通信方式站，如果我们要在分布式环境中远程运行
    测试，我们可以使用像硒网格这样的工具，在本教程接近尾声的时候 我们会讲到，然后一直到右边那个网络驱动程序。可执行或盐度网格将接收来自测试自动化的请求，并将它们发送到正在测试的浏览器，所有主要的浏览器类型都支持，Firefox，狩猎歌剧，你说出来，测试自动化调用代理，代理向浏览器发送命令。浏览器向代理发送响应，它将返回到测试自动化，web
    ui测试自动化是如何工作的，我们的测试将指定应该做什么交互，然后它通过我们的中介体进入浏览器，简而言之，这就是web用户界面测试。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 在进入教程的下一部分之前，让我们暂停一下，休息一下。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_6.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: 第一节，用我们的第一个测试设置圆周率测试。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_8.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: 在本教程中，我们将在 python中从头开始实施一个测试自动化项目，为了做到这一点，我们将采用一个web ui测试用例，并在每个教程部分逐层实现，让我们在这里一起编写基本的网络测试
    作为最佳实践。我们总是希望在接触任何代码之前编写测试步骤，做那样的人真好，我们想确保我们有一个良好的程序，除了在自动化中实现它的代码之外，我们的教程，正在测试的产品将是鸭子搜索引擎。我选择用鸭子作为我们的产品来测试
    有几个原因，首先，每个人都知道如何使用搜索引擎，你输入一个搜索短语，点击回车键并获得结果，第二，杜柯自由了，任何人都可以去杜科，通信并使用它。第三个 Doko有一个相当简单的界面，很干净，它有基本的文本字段和结果链接，没什么不寻常的，所以我们编写第一个测试用例应该很容易，我们将为教程编写的测试用例
    是一个基本的搜索测试用例。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 我们要做的是去网站首页，我们将输入一个搜索短语，我们将从结果页面验证结果链接，我们一步一步来，好让我们都明白这个测试，我们要自动化，很明显，第一步是导航到鸭子，COM，当我们到达那里。我们应该看到这样的主页，它应该有标志和搜索栏，第二步是输入一个搜索短语，我们会把它打进去的，否则我们就会撞上沙漏标志或眼镜标志，不好意思，我们的下一步将是验证结果页面上的内容。我们应该能够验证我们在页面标题中输入的查询，我们应该能够在结果页面顶部的新搜索输入中验证查询，我们应该能够验证所有的结果链接都与搜索短语有关，我喜欢用一种叫做小黄瓜的语言。它在编写测试时使用这些给定的步骤，你不必这么做，但是我喜欢使用给定的格式，因为这有助于，建立行动和核查，有点像安排表演，断言模式，我们的测试用例基本上有五个步骤来进行基本的围棋搜索。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 当用户搜索panda时，将显示go主页，任意的搜索短语，很基本的，很简单，我们专注于一个关键的行为，2。我们有详细的说明书，以身作则，这是一个甜蜜的场景，涵盖了通过网络应用的一个非常非常关键的路径。如果这个测试失败了，鸭子有一个大问题，所以它作为一个测试案例有很好的价值，尽管这看起来很基本，我们的测试用例在手，让我们把这个测试放入圆周率测试，PI测试是
    Python中最流行的测试自动化框架之一。依我看，它也是所有语言中最好的测试自动化框架之一，在这里查看圆周率测试主页，你可以看到一个非常，圆周率测试用例的非常简单的例子，下划线答案，是两条线，注意它不是一个类，它只是一个函数。在这个函数里我们做了一个断言，断言是调用不同的方法或不同的函数，做一个基于值的比较，这是圆周率测试最美妙的事情之一，太简洁了，你不需要所有这些额外的团队来建立一个测试案例，很干净，它是功能性的，真漂亮。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 现在作为本教程的一部分，我们将使用圆周率测试，但我不一定要教圆周率测试，有时候我会指出一些事情，比如特性或测试功能，所有这些，但是如果你想更具体地了解圆周率测试作为一个框架。那么我建议你读这两本书中的一本，Python
    testing with pi testing by brian aken or pi testing quick start guide by bruno
    olivero。任何时候您想为您的项目安装 pi测试，它只是我们项目的一个 pip安装，从 github pi测试克隆的文件应该已经在 pip文件中了，所以如果你只是简单地在安装中做一个
    pip。如果您想将pi测试添加到新的项目中，它应该在那里。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_10.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: 只是做一个新的 pip 安装那些，如果您查看从 Github克隆的项目中的代码，您会注意到，在test目录下已经有了一个虚拟的pi测试，有一个名为 test下划线
    fw py的测试模块。它有一个测试用例 总是能通过测试，测试断言为真，我只是把它放在那里，因此，您可以确保您的测试项目开箱即用，如果要运行这里显示的 pi测试命令，如果在运行
    python和 pi测试中。你应该看到它从盒子里传出来。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_12.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: 所以让我们暂停这里的视频，现在是你动手编程的机会了，完成"读懂我"教程说明的第一部分，作为第一部分的代码，你应该需要大约五分钟，您将为此添加一个新的测试方法，去搜索测试到圆周率测试，以及它的票根。所以试试看，然后继续，我们会继续前进。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_14.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: 让我们看看第一部分的代码，在这里，我有一个项目打开在vs代码，我把它打开到我的测试文件夹中 第一节的示例分支，我已经添加了测试下划线搜索 pmodule，代码只是一个测试用例函数，所谓的测试基本去搜索。在底部我放置了一个异常来表明这个测试用例还没有准备好，如果我们试图运行它，它会说爆炸不完全测试，我也移除了那个旧的测试模块，测试下划线
    fw，因为我们不再需要它，让我们运行这个看看会发生什么。我打开了我项目目录的终端，所以我要用 pip env来做这个测试，运行 python dash m
    pi测试 shem是模块选项，PI测试将发现项目中的所有测试 并自动运行它们，所以我们可以看到这里。它在测试中发现了一个测试，斜杠试验，下划线搜索 py，但它失败了，就是那个
    f，因为它失败了，所以它把所有这些东西都洒出来寻找痕迹，我们有一个测试用例函数，我们有圆周率测试记录了故障发生的确切地点。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 如果测试失败，因为它引发了一个没有被处理的异常，所以这个不完整的测试，这正是我们所期望的，我们先编写了我们的测试用例，我们已经捕捉到了这个测试函数中的步骤，尽管它现在失败了。这为我们实现和自动化这个测试用例绘制了前进的道路，所以这是，尽管它在这个阶段对我们来说暂时失败了。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_16.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 这是件好事，现在让我们开始实现自动化的第二部分。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_18.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 设置硒网络驱动程序，webdriver本身是 w3c标准，硒项目是它最受欢迎的实现之一，webdriver可以处理各种类型的 web用户界面交互，例如点击，打字和刮擦文本。很多人将硒
    webdriver视为 web用户界面测试的代名词，只是带着蟒蛇的口音，如果你被网络驱动程序 应用程序接口卡住了，在这里查看阅读文档页面。您可能想知道 selenium
    webdriver可以处理什么浏览器类型，请注意，每个浏览器都有自己的怪癖，因此，您可能需要根据目标浏览器以不同的方式编写某些自动调用。它需要代理服务器或我们之前讨论过的中间主体来与活动浏览器进行通信，例如，它需要铬驱动程序来与铬一起工作，这是
    ChromeDriver的页面，其他浏览器需要其他类型的驱动程序，例如。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Firefox需要一个叫做 gecko driver的驱动程序，这些额外的驱动程序可以从他们的项目页面下载，您需要将它们安装到您的测试机器的系统路径上。许多人在首次建立新的测试自动化解决方案时
    忽略了这一步，他们不知道为什么他们的网络用户界面测试不能打开浏览器，如果您需要帮助安装这些驱动程序，请遵循 Github项目的自述文件说明，在我们的教程中。您应该已经安装了它们，作为警告，不过，要警惕浏览器版本，浏览器供应商经常发布更新，浏览器和驱动程序之间的版本不兼容可能会破坏测试，相信我，我以前被烧伤过几次，只要确保保持更新，在跳回代码之前。关于webdriver，我们还应该讨论一件事，每个测试用例都应该有自己的
    webdriver实例，每个测试都应该初始化一个新的webdriver实例，作为安装的一部分，作为清理的一部分，它应该退出实例。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 无论如何，这意味着任何测试用例都不应该与另一个测试用例共享任何资源或依赖项，否则，一个测试用例中的问题可能会影响其他共享web驱动程序实例的人，这似乎是一种提高效率的好方法，但是很危险。共享
    webdriver实例的测试 可以轻松地并行运行，在没有明确退出的情况下，在测试结束时退出网络驱动程序也是至关重要的，Web驱动程序和浏览器可能成为僵尸进程，确保
    Web驱动程序实例被退出。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_20.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: 无论如何，不管有什么特点或例外，让我们确保我们的机器准备好做一些硒网络驱动程序测试，我已经在系统路径上安装了 chrome驱动程序和 gecko驱动程序。我要在这里运行这些命令
    以确保它能正常工作 所以铬驱动程序能正常工作，看来壁虎司机也能用，很好，可能需要一分钟，但它应该很好地工作，让我们进入代码，所有权利进入代码。我们去典型的测试框架有设置和清理方法来处理事情，如初始化和退出硒网络驱动程序，在圆周率测试中，我们用所谓的固定装置，在我的测试文件夹里有一个叫做"竞赛"的模块，我有一个用圆周率测试夹具装饰的功能。在这里面我要做我的网络驱动程序的安装和清理，注意，我们需要导入pi测试和selenium
    webdriver模块，这个固定装置有四条线，我说硒网络驱动程序，点铬换铬，我把它存储在一个参考对象中。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 这将初始化 chromedriver实例，它会向我的本地机器发送命令，在路径上查找 chromedriver 并自动启动执行，第二行是将隐式等待时间设置为10秒钟。这意味着每次我们尝试用这个特定的
    webdriver实例在页面上找到一个元素时，webdriver将智能地等待长达十秒钟的该元素出现，与其马上死去，如果它找不到，我们将在后面的教程中更多地讨论重量。第三行是收益率，返回这个特定浏览器的webdriver实例，或者如果您熟悉python的话，返回这个特定fixture的webdriver实例，你可能会认出屈服是一个关键词。产量意味着这个函数实际上是一个生成器，它给出了一系列元素，当谈到夹具和圆周率测试夹具时，夹具可以是发电机，在收益声明之前发生的一切都是报价的一部分，未引用。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: fixture的安装阶段 并返回对某物的引用 将该对象返回到调用此 fixture的测试用例中，所有这些都将在测试用例执行之前发生，在pi测试夹具中。在yield语句之后发生的所有事情都是我们认为的清理例程的一部分，这将在函数执行之后自动调用，不管功能发生什么变化，即使它引发了一个未处理的异常，所以在这里的产量声明之后，我进入了清理阶段。当我清理一个网络驱动程序时，我想做什么，我想打电话给退出，以杀死那个网络驱动程序的例子，注意，我想使用退出和不关闭，因为它们意味着两种不同的东西，我们还需要更新我们的测试用例函数，所以去测试一下。下划线搜索
    py，你可以在这里看到我们的停止测试功能，为了调用这个fixture，我们需要做的唯一更改是添加fixtures名称作为测试函数的参数，这是圆周率测试的把戏。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 每当 pi测试看到带有 fixture名称的测试用例时，它将在相同的测试模块或名为 coughing test py的文件中寻找 fixtures，它会根据名字来匹配。既然我们的
    fixture名称是 browser，这个参数的名字是浏览器，当 pi测试运行这个测试用例时，它知道在这个测试用例运行之前 调用浏览器 fixture。然后在这个测试用例完成之后
    生成器的第二次迭代，这就是我们如何在 pi测试中使用 fixtures来安装和清理 web驱动程序。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_22.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: 现在该轮到您播放自述教程说明中的完整第二部分了，大概只要五分钟，在这里暂停视频，直到完成。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_24.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: 现在让我们运行我们的测试用例，我们已经实现了夹具，应该发生的是圆周率测试会发现，打电话给固定装置，初始化 webdriver，我们会看到铬在屏幕上闪烁，然后它很快就会关闭，因为在我们的测试案例中，而且。测试用例仍然会像上次一样失败，让我们看看如果发生这种情况，所以
    pip v run python and pytest。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_26.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_27.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: 和繁荣，哇，所以我们看到镀铬窗上下浮动，我们仍然因为同样的原因而失败，所以我们知道我们的比赛很成功，它在做它应该做的事情，这本身没有任何问题。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_29.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: 让我们转到第3部分，定义页面对象。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_31.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 页面对象是表示网页或组件的对象，页面对象有两个主要部分，它有查找页面上元素的定位器，它有与测试页面交互的交互方法，每个被测试的网页或组件应该有一个页面对象类页面对象封装低级的硒网络驱动程序调用。这样测试就可以缩短，可读的调用而不是复杂的调用，它有助于最大化代码重用，我们的测试用例与两个不同的页面交互，它与之交互的第一个页面是搜索页面，实际上有两种互动，是的，测试将加载搜索页面。它会在搜索页面上搜索一个短语，查看结果页面，从技术上讲，有三种相互作用，即使它不一定要在页面上做一些事情来不改变，相反，测试得到三个值，从某种意义上说，这仍然是一个网络用户界面互动。测试将从结果页面上得到的三个东西是结果链接标题，搜索输入值和标题。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_33.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: 让我们看看代码，看看如何在我们的项目中消除这些页面对象，我创建了一个新文件夹 叫做根级目录的页面，注意，页面的目录不在tests目录中，我们可以在项目中的任何地方导入它，即通过测试，我们来看看搜索页面。所以我创建了一个模块叫做搜索
    py，在这里我创建了一个类叫做 duckduckgo搜索页面，有一个 init方法将接受对浏览器的引用，它是来自测试用例的 webdriver实例。它在内部存储了对它的引用，我还创建了两个存根方法，一个用于加载页面，一个用于搜索页面，加载页面不需要任何输入，但是搜索页面需要他们两个的搜索短语，我已经留下了一个标签来做评论，以及"无操作通行证"命令。结果页面将再次使用类似的格式，我有一个类叫做结果页，同样，它也有雷鸣的方法，我需要从结果页面得到的三个东西
    每个都有自己的方法，结果链接标题，搜索输入值和标题，然而，而不是通过命令，每一个都返回一个值。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 因为这就是这些互动的重点，他们应该得到一些东西 并把它还给我，所以为了我的头衔，我现在要返回一个空列表，对于我的搜索输入值和我的标题，因为那些是弦，我要暂时归还一条空绳子，当我们的页面对象类被删除时。我们实际上可以实现测试用例函数。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_35.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: 把它打开，测试搜索 py，这是我的测试用例函数，导入两个页面对象类，在我顶部的测试用例中，我将初始化每一个页面对象类，我也把我的搜索短语变成了一个变量，只是为了便于参考。现在可以使用
    page对象调用来实现我的每个步骤，所以我的第一步是给鸭子去主页显示，我想说当用户搜索短语时，搜索页面加载，搜索页面搜索我的短语，我的三个断言步骤，断言该短语在我的结果页面标题中。断言我的短语等于结果页面搜索输入值，最后一个更复杂的，我需要做的是得到所有的标题
    从我的结果页面结果链接标题，我在这里用这个列表来看看我的标题和我的小写短语有多少匹配，我想确保我至少有一个。这可能不是最有力或最有力的断言，但考虑到搜索结果是如何变化的，它们是如何变化的，我认为对于一个基本的搜索测试案例，为了这个测试的目的，确保其中至少有一个是正确的就足够了。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 把它打开，测试搜索py，这是我的测试用例函数，导入两个页面对象类。在我顶部的测试用例中，我将初始化每一个页面对象类，我也把我的搜索短语变成了一个变量，只是为了便于参考。现在可以使用page对象调用来实现我的每个步骤，所以我的第一步是给鸭子去主页显示。我想说当用户搜索短语时，搜索页面加载，搜索页面搜索我的短语，我的三个断言步骤，断言该短语在我的结果页面标题中，断言我的短语等于结果页面搜索输入值，最后一个更复杂的，我需要做的是得到所有的标题，从我的结果页面结果链接标题。我在这里用这个列表来看看我的标题和我的小写短语有多少匹配，我想确保我至少有一个。这可能不是最有力或最有效的断言，但考虑到搜索结果是如何变化的，我认为对于一个基本的搜索测试案例，为了这个测试的目的，确保其中至少有一个是正确的就足够了。
- en: 我们可以有其他的测试来做更多的深度搜索和查询之类的事情，我们只是想确保在这里我们得到一些体面的好东西 在页面上，我仍然会把我的异常放在底部，因为即使我们已经实现了这个测试用例函数的所有代码。测试用例尚未实现自动化，因为这些方法实际上仍然是空的，他们只是票根，尽管如此，我们所做的实际上是相当强大的，尽管我们甚至没有做任何直接的网络驱动程序呼叫，然而。我们已经能够勾勒出这个web用户界面测试案例的全部轮廓，仅仅基于页面对象的接口，就像我之前说的，在编写代码之前总是三思而后行，我们有我们的测试案例，我们做了圆周率测试，我们把每个步骤都删掉了。再向下一层，我们填充了页面对象，并在测试用例中实现了这些步骤，所以在以后的课程中
    我们将继续逐层进行 直到我们把整个过程自动化，所以现在轮到你了，在这里暂停视频，并完成自述教程说明中的第三部分。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进行其他测试以进行更深入的搜索和查询，我们只是想确保在这里得到一些体面的好东西。在页面上，我仍然会把我的异常放在底部，因为即使我们已经实现了这个测试用例函数的所有代码，测试用例尚未实现自动化，因为这些方法实际上仍然是空的，它们只是票根。尽管如此，我们所做的实际上是相当强大的，尽管我们甚至没有做任何直接的网络驱动程序调用。然而，我们已经能够勾勒出这个web用户界面测试案例的全部轮廓，仅仅基于页面对象的接口，就像我之前说的，在编写代码之前总是三思而后行。我们有我们的测试案例，我们做了圆周率测试，我们把每个步骤都删掉了。再向下一层，我们填充了页面对象，并在测试用例中实现了这些步骤，所以在以后的课程中，我们将继续逐层进行，直到我们把整个过程自动化，现在轮到你了，在这里暂停视频，并完成自述教程说明中的第三部分。
- en: 你应该不会超过十分钟，然后在添加了页面目标代码之后，再次运行测试，确保它以同样的方式失败，以表明你没有弄坏任何东西。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该不会超过十分钟，然后在添加了页面目标代码之后，再次运行测试，确保它以同样的方式失败，以表明你没有弄坏任何东西。
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_37.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/274e64ac5dd581b44ee82ed902c54130_37.png)'
- en: 所以让我们测试一下。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们测试一下。
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_39.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/274e64ac5dd581b44ee82ed902c54130_39.png)'
- en: 我们应该会看到铬上下闪烁 我们现在看到了故障，即使它失败的方式与测试用例失败的方式相同，失败的原因其实有点不同，如果你注意到这里和圆周率测试留下的痕迹，它一开始就失败了。然后断言断言错误
    断言 panda在空字符串中，还记得我们把标题方法，这个 title方法只会返回空字符串，然而，一旦测试用例被完全实现，我们的断言，所以现在这个状态下的测试自然会失败，这是意料之中的。我们进入第四部分，寻找元素定位器。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该会看到铬上下闪烁。我们现在看到了故障，即使它失败的方式与测试用例失败的方式相同，失败的原因其实有点不同。如果你注意到这里和圆周率测试留下的痕迹，它一开始就失败了。然后断言断言错误，断言
    panda在空字符串中，还记得我们把标题方法，这个 title方法只会返回空字符串。然而，一旦测试用例被完全实现，我们的断言，所以现在这个状态下的测试自然会失败，这是意料之中的。我们进入第四部分，寻找元素定位器。
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_41.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/274e64ac5dd581b44ee82ed902c54130_41.png)'
- en: 网页元素是网页上的东西，像纽扣之类的东西，标签，文本输入就是我们所说的元素，事实上，你在页面上看到的一切都必须是一个网络元素，测试通过三个步骤与元素交互，第一，测试必须等待目标元素出现在页面上。想想当你登录某个地方，等待它加载时，这些元素可能需要一点时间才能从这里弹出，这是等待该元素出现的第一步，您不能与不存在的元素进行交互，但是交互的第二步是获取一个表示目标元素的对象。我们的自动化系统要做的是，我们会用寻人启事说，找到一个元素，给出了一些疑问，一些定位器，如果自动化系统成功地做到了这一点，您将得到一个web元素对象，它表示被发现的元素。交互的第三部分是向元素对象发送命令，它可能是一些应该在页面上做出改变的东西，例如单击一个元素，也可能是我们想从元素中获取属性，就像它的文本价值，或者一些
    html属性值。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 网页元素是网页上的东西，像纽扣之类的东西，标签，文本输入就是我们所说的元素。事实上，你在页面上看到的一切都必须是一个网络元素，测试通过三个步骤与元素交互，第一，测试必须等待目标元素出现在页面上。想想当你登录某个地方，等待它加载时，这些元素可能需要一点时间才能从这里弹出，这是等待该元素出现的第一步。您不能与不存在的元素进行交互，但是交互的第二步是获取一个表示目标元素的对象。我们的自动化系统要做的是，我们会用寻人启事说，找到一个元素，给出了一些疑问，一些定位器。如果自动化系统成功地做到了这一点，您将得到一个web元素对象，它表示被发现的元素。交互的第三部分是向元素对象发送命令，它可能是一些应该在页面上做出改变的东西，例如单击一个元素，也可能是我们想从元素中获取属性，就像它的文本价值，或者一些html属性值。
- en: 所有这些都是与元素相互作用的一部分，作为人类，我们不会三思而后行，我们去到一个页面，我们只是点击它或键入它或其他什么，但是我们需要在测试自动化中小心地处理这些问题，以便它们能够正确地完成。当我们试图在网页上找到一个元素时，我们需要使用所谓的定位器，定位器是在页面上查找元素的查询，有很多类型的定位器，我们可以通过元素的
    id属性找到它们，我们可以通过它们的名称属性找到它们。也许我们可以通过他们的 css类名找到他们，甚至通过一个完整的 css选择器，如果一切都失败了，即使这有点复杂，而且，含硒，我们还可以通过元素的链接文本来选择元素，通过部分链接文本，或者他们的标签名。让我们一起看一些元素定位器的例子，这里有一个非常简单的
    id定位器，如果我们有，假设一个 button元素的 id属性值为 django 下划线，好的，因为它有 id属性，我们可以使用 id定位器类型。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是与元素相互作用的一部分，作为人类，我们不会三思而后行。我们去到一个页面，我们只是点击它或键入它或其他什么，但是我们需要在测试自动化中小心地处理这些问题，以便它们能够正确地完成。当我们试图在网页上找到一个元素时，我们需要使用所谓的定位器，定位器是在页面上查找元素的查询。有很多类型的定位器，我们可以通过元素的id属性找到它们，我们可以通过它们的名称属性找到它们。也许我们可以通过他们的css类名找到他们，甚至通过一个完整的css选择器，如果一切都失败了，即使这有点复杂，而且，含硒，我们还可以通过元素的链接文本来选择元素，通过部分链接文本，或者他们的标签名。让我们一起看一些元素定位器的例子，这里有一个非常简单的id定位器，如果我们假设一个button元素的id属性值为django下划线，好的，因为它有id属性，我们可以使用id定位器类型。
- en: 我的定位器类型基本上是一个元组，它将是我的类型 是由下或由点 id，它是一个硒值，然后会有定位器的查询部分，在本例中是 id值 django 下划线，好的，身份定位器真的很不错。因为元素的
    id在网页上应该是唯一的，所以这只是得到我们想要的东西的一个关键值，现在，我总是推荐，即使在 web元素中看到 id，检查整个页面，以确保它是真正独特的，因为仅仅因为某样东西应该是单向的。这并不意味着它实际上是，但如果你有幸得到了，我建议你用这个，然而，并非所有元素都有
    id，所以我们可能需要，其他类型的定位器，CSS选择器是比 id更强大的定位器类型。因为使用 css表达式可以覆盖更多种类的元素，让我们再考虑一下按钮元素，但是没有
    id属性，假设它有一个类属性，我们可以很容易地编写一个 css选择器 定位器。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我的定位器类型基本上是一个元组，它将是我的类型，是由下或由点id，它是一个硒值，然后会有定位器的查询部分，在本例中是id值django下划线。好的，身份定位器真的很不错，因为元素的id在网页上应该是唯一的，所以这只是得到我们想要的东西的一个关键值。现在，我总是推荐，即使在web元素中看到id，检查整个页面，以确保它是真正独特的，因为仅仅因为某样东西应该是单向的，并不意味着它实际上是。但如果你有幸得到了，我建议你用这个，然而，并非所有元素都有id，所以我们可能需要其他类型的定位器，CSS选择器是比id更强大的定位器类型。因为使用css表达式可以覆盖更多种类的元素，让我们再考虑一下按钮元素，但是没有id属性，假设它有一个类属性，我们可以很容易地编写一个css选择器定位器。
- en: css选择器的优点在于它们支持 css语言中的任何东西，所以如果你熟悉 css，你可以把你的css知识放在这里，就像它很热一样，现在让我们看一个更具挑战性的例子，如果我们的按钮元素上没有任何属性怎么办。PAD可以唯一地标识页面上的任何元素，他们可以使用文本和索引来实现这一点，我用这个查询，这里，双斜杠表示我想从根元素搜索到任何子元素，按钮是元素的
    标签名称，方括号表示条件。在我的条件下 我将使用文本函数来得到元素的文本值，我想选择文本等于字符串的每个按钮，我们的测试用例需要在码头围棋网站上找到三个不同的元素，它需要在搜索页面上找到搜索
    输入。结果页上的搜索输入和结果页上的结果链接，现在您可能想知道结果页面的标题是什么，标题实际上不是页面上的元素，标题是页面的属性，所以我们需要使用一个稍微不同的网络驱动程序调用来获得它。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: css选择器的优点在于它们支持css语言中的任何东西，所以如果你熟悉css，你可以把你的css知识放在这里，就像它很热一样。现在让我们看一个更具挑战性的例子，如果我们的按钮元素上没有任何属性怎么办。PAD可以唯一地标识页面上的任何元素，他们可以使用文本和索引来实现这一点。我用这个查询，这里，双斜杠表示我想从根元素搜索到任何子元素，按钮是元素的标签名称，方括号表示条件。在我的条件下，我将使用文本函数来得到元素的文本值，我想选择文本等于字符串的每个按钮。我们的测试用例需要在码头围棋网站上找到三个不同的元素，它需要在搜索页面上找到搜索输入，结果页上的搜索输入和结果页上的结果链接，现在您可能想知道结果页面的标题是什么，标题实际上不是页面上的元素，标题是页面的属性，所以我们需要使用一个稍微不同的网络驱动程序调用来获得它。
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_43.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/274e64ac5dd581b44ee82ed902c54130_43.png)'
- en: 寻找元素的定位器可能是相当具有挑战性的，了解不同类型的定位器以及如何形成查询是一回事，当你已经知道这些属性是什么的时 候，但是我们如何找到元素 并找出活动页面上的这些属性。幸好
    chrome开发工具可以帮助我们，我喜欢使用 chrome开发工具，Chrome是市场上最受欢迎的浏览器之一，我们去管道，围棋主页，我将向你展示如何在搜索页面上获取搜索输入，如果你是对的。用
    chrome点击页面上的任何地方，你去检查，你会打开铬的显影剂工具 你会看到它在这边，现在这真的很酷，因为你看到我在页面上的不同元素上盘旋。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找元素的定位器可能是相当具有挑战性的，了解不同类型的定位器以及如何形成查询是一回事，当你已经知道这些属性是什么的时候，但我们如何找到元素并找出活动页面上的这些属性。幸好chrome开发工具可以帮助我们，我喜欢使用chrome开发工具，Chrome是市场上最受欢迎的浏览器之一。我们去管道，围棋主页，我将向你展示如何在搜索页面上获取搜索输入。如果你是对的，用chrome点击页面上的任何地方，你去检查，你会打开铬的显影剂工具，你会看到它在这边，现在这真的很酷，因为你看到我在页面上的不同元素上盘旋。
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_45.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/274e64ac5dd581b44ee82ed902c54130_45.png)'
- en: 在源代码中，你会看到 chrome会在实际的网页上突出显示这个元素。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码中，你会看到chrome会在实际的网页上突出显示这个元素。
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_47.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/274e64ac5dd581b44ee82ed902c54130_47.png)'
- en: 你也可以来到这个右上角的图标，用光标，点击它，会变成蓝色的，它也会链接到源代码 高亮显示，所以我想要这个搜索输入，所以我要点击它，你可以看到在这里，输入元素是输入，我想知道它还有个身份。id是搜索表单
    输入主页，我要在这里搜索那页，只是为了确保它在整个页面上是独一无二的，我将使用带有标签的 css选择器来搜索 id，我们可以看到其中一个，这在页面上是唯一的，所以我可以用这个
    id值。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以来到这个右上角的图标，用光标点击它，它会变成蓝色，并且链接到源代码高亮显示。因此，我想要这个搜索输入，所以我要点击它，你可以看到在这里，输入元素是输入，我想知道它还有个身份。id是搜索表单输入主页，我要在这里搜索那页，只是为了确保它在整个页面上是独一无二的。我将使用带有标签的css选择器来搜索id，我们可以看到其中一个，这在页面上是唯一的，所以我可以用这个id值。
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_49.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/274e64ac5dd581b44ee82ed902c54130_49.png)'
- en: 一旦我们确定了定位器，我们可以把它放入我们的页面目标代码中，所以我又把密码打开了，然后在我的页面中搜索 py模块，这堂课看起来应该很熟悉，但它仍然被扼杀了，但是现在这里的类级别属性。我要添加我的搜索
    输入定位器，我使用所有大写表示这是一个类级别的属性，我把我的定位器编码成一个元组，这就是我使用的括号作为我的类型，它来自于硒网络驱动程序，常见的模块，我已经在这里导入，所以我的定位器。它的类型，这将是我的元组的第一部分，元组的第二部分是id值，它是我使用chrome开发工具进行检查时得到的，在下一节中，在下面的方法中，我们将在我们的webdriver调用中使用此定位器。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了定位器，我们可以把它放入我们的页面目标代码中，所以我又把密码打开了，然后在我的页面中搜索py模块，这堂课看起来应该很熟悉，但它仍然被扼杀了，但是现在这里的类级别属性。我会添加我的搜索输入定位器，我使用所有大写表示这是一个类级别的属性，我把我的定位器编码成一个元组，这就是我使用的括号作为我的类型，它来自于硒网络驱动程序，常见的模块，我已经在这里导入，所以我的定位器。它的类型，这将是我的元组的第一部分，元组的第二部分是id值，它是我使用chrome开发工具进行检查时得到的，在下一节中，在下面的方法中，我们将在我们的webdriver调用中使用此定位器。
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_51.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/274e64ac5dd581b44ee82ed902c54130_51.png)'
- en: 所以现在轮到你尝试一下了，完成第四部分或自述教程说明，我建议你在结果页面上尝试自己使用 chrome开发工具，在示例代码中查找定位器之前，尝试找到它们，你大概需要15分钟，所以暂停你的视频，跳到上面去。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在轮到你尝试一下了，完成第四部分或自述教程说明，我建议你在结果页面上尝试自己使用chrome开发工具，在示例代码中查找定位器之前，尝试找到它们，你大概需要15分钟，所以暂停你的视频，跳到上面去。
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_53.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/274e64ac5dd581b44ee82ed902c54130_53.png)'
- en: 所以一旦你完成了这部分的代码，您的结果页面对象应该如下所示，现在你应该有两个定位器，结果链接和搜索输入，他们应该这样，也许你在检查页面时发现了一些不同的东西，但这正是我找到它时所拥有的。这就是我在我的示例代码中。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所以一旦你完成了这部分的代码，您的结果页面对象应该如下所示，现在你应该有两个定位器，结果链接和搜索输入，他们应该这样，也许你在检查页面时发现了一些不同的东西，但这正是我找到它时所拥有的。这就是我在我的示例代码中。
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_55.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/274e64ac5dd581b44ee82ed902c54130_55.png)'
- en: 如果您想了解更多关于如何编写好的 web元素定位器的知识，跳转到测试自动化，大学，我创建了一门叫做网络元素定位策略的课程，在这门课上，对于如何编写好的定位器，我用各种不同的策略涵盖了所有不同的类型。如果您想为
    web用户界面编写更多的测试和更健壮的测试，我强烈建议你上这门课，你可能也会对 tau的另一门课感兴趣，在这里查看这门课，杰森·阿林·艾为元素选择，这是一个短期课程，但它真的会扩展你的思维。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于如何编写好的web元素定位器的知识，跳转到测试自动化大学，我创建了一门叫做网络元素定位策略的课程，在这门课上，对于如何编写好的定位器，我用各种不同的策略涵盖了所有不同的类型。如果您想为web用户界面编写更多的测试和更健壮的测试，我强烈建议你上这门课，你可能也会对tau的另一门课感兴趣，在这里查看这门课，杰森·阿林·艾为元素选择，这是一个短期课程，但它真的会扩展你的思维。
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_57.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/274e64ac5dd581b44ee82ed902c54130_57.png)'
- en: 我们进入第五区，拨打网络驱动程序电话。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入第五区，拨打网络驱动程序电话。
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_59.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/274e64ac5dd581b44ee82ed902c54130_59.png)'
- en: Webdriver可以处理与网页的任何类型的交互，然而，它是一个复杂的api，值得庆幸的是，它在不同的编程语言之间非常相似，如果你被困住了，我建议经常在线阅读文件，我指的是这一页，为了让事情更容易理解。在尝试将它们应用到我们的测试自动化项目之前，让我们一起讨论一些最常见的调用，左列显示直接来自
    webdriver实例的调用，我们在代码中命名为浏览器，当前 url返回浏览器中当前加载的页面的 url。find元素返回 表示定位器找到的第一个元素的对象，如果找不到元素，然后这个方法抛出一个异常，find
    elements plural 返回由定位器找到的元素对象列表，如果找不到元素，与其破例。此方法返回一个空列表，通常我不使用这些方法，因为我更喜欢使用两部分定位器元组，但许多人喜欢较短的语法，get方法在浏览器中加载给定的
    url，最大化窗口，最大化浏览器的窗口大小，关闭浏览器并终止进程。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Webdriver可以处理与网页的任何类型的交互，然而，它是一个复杂的api，值得庆幸的是，它在不同的编程语言之间非常相似。如果你被困住了，我建议经常在线阅读文件，我指的是这一页，为了让事情更容易理解。在尝试将它们应用到我们的测试自动化项目之前，让我们一起讨论一些最常见的调用，左列显示直接来自webdriver实例的调用，我们在代码中命名为浏览器，当前url返回浏览器中当前加载的页面的url。find元素返回表示定位器找到的第一个元素的对象，如果找不到元素，那么这个方法会抛出一个异常，find
    elements复数返回由定位器找到的元素对象列表，如果找不到元素，则返回一个空列表，通常我不使用这些方法，因为我更喜欢使用两部分定位器元组，但许多人喜欢较短的语法。get方法在浏览器中加载给定的url，最大化窗口，最大化浏览器的窗口大小，关闭浏览器并终止进程。
- en: 刷新当前页面，保存截图将捕获当前浏览器窗口 并将其保存到图像文件中，title返回页面的标题，右列显示对 find element方法返回的 element对象的调用。CLEAR从文本字段中删除所有文本，单击单击，elements
    find elements方法将定位以当前元素作为根元素开始的元素，get属性返回html属性的值，get属性返回显示html属性的值。如果元素直观地出现在页面上
    并且位于，结果是假的，否则，location 返回元素的 x和 y像素坐标，Keys向元素发送击键，以模拟用户键入，size返回元素的像素尺寸，最后。text返回元素的text值。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新当前页面，保存截图将捕获当前浏览器窗口并将其保存到图像文件中，title返回页面的标题，右列显示对find.element方法返回的element对象的调用。CLEAR从文本字段中删除所有文本，单击单击，elements
    find elements方法将定位以当前元素作为根元素开始的元素，get属性返回html属性的值，get属性返回显示html属性的值。如果元素直观地出现在页面上并且位于，结果是假的，否则，location返回元素的x和y像素坐标，Keys向元素发送击键，以模拟用户键入，size返回元素的像素尺寸，最后text返回元素的text值。
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_61.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/274e64ac5dd581b44ee82ed902c54130_61.png)'
- en: 我们要做的是，我将向您展示我的页面对象的代码，有了网络驱动程序 呼叫，我们应该始终尝试将我们的 webdriver调用放在页面对象中，因此，测试用例将调用页面对象。而不是直接调用selenium
    webdriver，我已经打开了搜索py模块，我们将看到它现在被实现了，我不仅有我以前用过的 init方法 还有我以前用过的定位器，但现在这些方法已经实现了，尸体。先看加载方法，所以
    load方法应该是加载 duckgo搜索页面，为了做到这一点，我需要使用浏览器获取方法，我需要通过目标网址，所以我说自我点浏览器，因为这是为了加载页面而传入的浏览器引用。然后把自己的网址通过网址，我在这里将
    url设置为类属性，https冒号斜杠，点点滴滴，这就是这个方法所需要的，搜索方法有点有趣，因为搜索方法需要做一个web元素交互。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是，我将向您展示我的页面对象的代码，有了网络驱动程序调用，我们应该始终尝试将我们的webdriver调用放在页面对象中，因此，测试用例将调用页面对象，而不是直接调用selenium
    webdriver。我已经打开了搜索py模块，我们将看到它现在被实现了。我不仅有我以前用过的init方法，还有我以前用过的定位器，但现在这些方法已经实现了，尸体。先看加载方法，所以load方法应该是加载duckgo搜索页面，为了做到这一点，我需要使用浏览器获取方法，我需要通过目标网址，所以我说自我点浏览器，因为这是为了加载页面而传入的浏览器引用。然后把自己的网址通过网址，我在这里将url设置为类属性，https冒号斜杠，点点滴滴，这就是这个方法所需要的，搜索方法有点有趣，因为搜索方法需要做一个web元素交互。
- en: 所以首先我需要做的是 我需要得到网络元素，我将使用self，dot，browser，dot，find，element方法，如你所想，find element方法将返回一个元素对象。表示通过定位器找到的元素，我想使用的定位器是我们在上一节中实现的搜索输入定位器，所以我会把它传递到这个查找元素方法中，如果你注意到它前面有一个星号操作符，find
    element方法需要两个参数。定位器类型和定位器查询，但是因为我把我的定位器存储为元组，我需要对我的元组做一个参数扩展，这样元组中的每个元素都可以被这个方法中的参数位置替换，在
    python中星号操作员就是这么做的。它是一个参数扩展算子，这样我就可以声明性地将我的定位器实现为可读元组，并简单地通过引用来传递它们，使用参数展开，如果这个电话成功了，然后它会返回我的元素对象，我想把它存储在一个叫做搜索输入的变量中。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所以首先我需要做的是，我需要得到网络元素，我将使用self.dot.browser.dot.find.element方法，如你所想，find.element方法将返回一个元素对象，表示通过定位器找到的元素。我想使用的定位器是我们在上一节中实现的搜索输入定位器，所以我会把它传递到这个查找元素方法中。如果你注意到它前面有一个星号操作符，find.element方法需要两个参数，定位器类型和定位器查询，但是因为我把我的定位器存储为元组，我需要对我的元组做一个参数扩展，这样元组中的每个元素都可以被这个方法中的参数位置替换。在python中，星号操作员就是这么做的。它是一个参数扩展算子，这样我就可以声明性地将我的定位器实现为可读元组，并简单地通过引用来传递它们，使用参数展开。如果这个电话成功了，然后它会返回我的元素对象，我想把它存储在一个叫做搜索输入的变量中。
- en: 如果你回想一下我们的比赛，我们含蓄地等了十秒钟，这意味着浏览器将隐式地等待该元素出现长达十秒钟，而不是窒息，如果它不马上找到它，所以这是件好事，一旦我们有了我们的元素，我们终于可以向它发送命令了。所以如果我想输入搜索短语，我想说的是，搜索输入点，发送钥匙，因为它模拟了用户的击键，我想给出的关键是搜索短语，然后我还要加上返回键，因为这将模拟用户点击回车键提交要搜索的搜索。这个
    keys类来自 selenium webdriver common keys模块，这就是实现我们的搜索页面所需要的，接下来让我们看看我们的结果页，因此结果页面将类似于搜索页面，我们已经有定位器了。我们已经有了
    init方法，现在我们有了新的交互方法，结果链接标题将需要使用结果链接，如果你注意到这里，而不是说浏览器点，求元素奇异，它说浏览器点，找到多元元素，原因是结果页面上会有多个结果链接。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 我想让所有的人，所以我用了 get elements的复数形式，我把它存储到一个叫做链接的对象中，现在链接代表一个列表，元素对象，我不想返回元素对象本身，相反，我想返回元素对象的title字符串。因为我可以对标题字符串做出断言，所以我要做的是，我会做一个非常简单的列表理解，我会说我的标题等于链接列表中所有链接的链接点
    文本列表，这本质上是一个映射，从你的元素映射到那些元素标题。所以这个列表将是所有标题的字符串列表，从所有的链接，标题来自 get text属性，我终于有了我的书名清单，我会把它还给你的，是另一个元素查找方法，所以对于这个，我想做什么，我想去搜索输入。我想知道输入那个字段的文字，所以我会用self-dot浏览器，求元素奇异，因为这一页上只有一个，我把我的搜索输入定位器，我会把它存储在我的元素对象中。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 现在你可能会认为 因为我试图把文本从这个元素中提取出来，我可以使用点文本属性，就像我为我的链接所做的那样，但是这个搜索输入有点特殊，因为它不只是任何类型的
    html元素，它是一个输入元素。如果你在输入元素上做点文字，你实际上会得到空的字符串，这可能是令人困惑和不直观的，在html实际上是正确的，为了将值输入到输入字段中，我们需要得到名为
    value的属性，一旦我们有了搜索输入。我们会说搜索输入，获取属性值 以获取该输入字段的文本值，我们会还给你的，当你第一次接触硒时，你会有点困惑，这确实让我恼火了一两次，所以小心点，在结果类中实现的第三个也是最后一个方法是现在的标题方法。正如我在上一节中所说，页面标题实际上不是页面上的元素，而是页面的属性，而不是试图为标题找到一个元素
    并从中获取文本。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 带 selenium驱动程序 api的 title属性实际上直接来自 webdriver实例，所以为了标题，我们说，返回浏览器点标题，所以说了很多话，并解释了似乎只是一点点代码。但是我希望通过这些页面对象方法来理解
    webdriver api。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_63.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: 我们应该怎么称呼它，所以让我们再次暂停，让你们有机会做一些编码，完成自述训练说明中的第五部分，您将把这些 webdriver调用添加到页面对象存根中，一旦你把它们加起来，同时尝试运行测试。因为现在测试应该完全实现了
    并且应该能成功运行。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_65.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: 让我们进行测试 以确保它有效，在这一点上，测试全面实施，所以当我们运行它的时候，我们应该看到圆周率测试横幅，我们应该看到镀铬窗打开，输入的搜索短语，结果页面出现，铬关闭，和一个绿色的通过结果，试试看。所以在这一点上，我的手离开了鼠标和键盘，我们看到铬搜索短语结果页关闭
    通过做得很好，我们的测试成功了，如果由于某些原因 你的本地代码不工作，这是我可以建议检查的几件事，首先。确保 webdriver安装正确，铬驱动程序应该在你的道路上，铬以及铬驱动程序的版本应该是最新最伟大的，其次，仔细检查你的python代码，确保它看起来像我们在示例代码中看到的那样，如果你有任何错别字。或者你做了一些不同的事情，那么你的测试可能不起作用，就像我的一样。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_67.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: 我们的基本测试自动化项目正在运行，这是个好消息。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_69.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: 就像我们之前说的，硒网络驱动程序兼容所有主要操作系统上的所有主要浏览器，当涉及到我们的测试策略时，由我们来决定我们应该或不应该测试哪些浏览器，我们应该考虑市场份额和用户群等因素来做出最好的决定。无论如何，尽管我们编写的
    web用户界面测试应该能够轻松地在多种浏览器类型上运行，而且，无头浏览器非常适合测试自动化，无头浏览器运行网页，但不会在屏幕上直观地呈现它们，这使得无头浏览器运行更有效。chrome和
    firefox都有无头模式，在开发自动化测试时，我通常不会在无头模式下使用，在连续集成系统中运行测试时采用无头模式，浏览器或无头模式不是唯一的选择。测试自动化通常需要像
    urls这样的输入，用户名，密码，当测试套件开始运行时，甚至需要将默认的超时值输入传递到自动化系统中，它们不应该硬编码到自动化代码中，尤其是如果它们是敏感的值，如密码。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 它们应该单独处理，这样它们的值就可以很容易地针对不同的测试套件进行更改，而且这样秘密就不会被源代码控制，有几种方法可以将输入传递到测试自动化中，可以说，最简单的方法是使用基于文本的配置文件。配置文件可以有多种格式，就像
    json，YAML，二，或 csv，它们只是有一堆不同的值，可以使用标准模块读取和解析，使用基于文本的格式 而不是不同类型的格式的原因，例如，比如卓越队。当涉及到代码审查时，基于文本的格式很容易区分，你也可以使用加密的文件，这可能更安全
    但更难处理，代替文件，您还可以尝试使用环境变量 将输入传递到自动化中。您可以使用 python的 os模块直接读取环境变量，然 而，环境变量输入仅限于一维字符串，一个更有力、更严肃的解决方案是使用一个关键的管理服务，就像
    AWS，KMS或天蓝色钥匙拱顶。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 关键经理把秘密储存在安全的地方，自动化可以发出诱人的调用来检索秘密，然而，小型自动化项目，您可能想知道 pi测试是否可以在命令行中接受参数，尽管 pi测试有几个有用的命令行选项，不幸的是。它不能接受自定义参数，因此，试图通过命令行将自定义参数传递到pi测试中是一个显示停止器，你得采取另一种策略，依我看，我认为
    json配置文件作为一种文件格式是最简单的解决方案。JSON具有可读性和层次性，从编码的角度来看，json模块是 python标准库的一部分，用一行 python代码，您可以将json文件读入python字典，并通过键名引用它。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_71.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: 超简单超简单，让我们看看如何使用基于 json的配置文件来读取测试自动化项目中的输入，我又把密码打开了，我创建了一个名为 config dot json的文件，它在我们的根层，它是一个json对象。有两个值，我创建了一个名为浏览器的值，它将采用所需的浏览器名称，我还增加了一个内隐权重，这将在我们的
    webdriver实例上设置隐式权重字段，把它参数化很好，因为当我们尝试在不同的环境中运行时。我们可能需要调整权重值，使其适当，读取此配置文件的最佳方法是在contest
    py中创建一个fixture，与我们的浏览器fixture一起读取它，我们去比武吧，这里我添加了一个新的配置夹具。我们创建了它，就像我们做浏览器固定装置一样，不过，对于我的配置夹具，我将作用域设置为
    session，我想把瞄准镜缝起来，因此这个夹具在整个测试套件运行时被调用一次，不需要为每个测试重读相同的配置文件。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 因为那样效率很低，我可以读一次就写完了，这样也更安全，因为如果有一个糟糕的参与者试图在运行过程中更改配置文件的值，这可能会导致测试自动化出现一些问题，所以如果我们读一遍
    然后把它留下。那么对于套件中的每个测试来说都是一样的，配置夹具有几个不同的，几个不同的部分，我们需要做的第一件事就是读取配置文件，这一点也不神奇，这只是简单的旧蟒蛇代码，因此，使用打开的配置文件路径作为配置文件指针。我的配置对象是
    json dot load配置文件，来自 json模块，我从这里进口的，只要一行字，你就可以把json文件读进字典，配置工具的第二部分是，我想确保我的配置文件中的值是可接受的。如果我们输入了一个糟糕的浏览器名称或有一个错别字，那就真的很臭了，它导致每一个测试都失败了，所以让我们在任何事情发生之前抓住它，如果有什么问题，我们可以马上中止，省去一些时间和麻烦。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 所以我想确保配置中的浏览器值是我支持的浏览器类型之一，火狐 Chrome还是无头 Chrome，我还想确保隐式权值是大于零的整数，如果这些断言都通过了，然后我知道我的配置是好的，我可以返回配置对象。以便其他测试用例和夹具可以使用它，最后，我还需要更新我们的浏览器夹具，因为浏览器夹具是初始化
    web驱动程序的工具，浏览器的选择来自配置，下面我有我的浏览器夹具。注意它是如何将config声明为依赖项的，pi测试所做的是每次它看到浏览器夹具时，它将调用配置夹具，因此，这个配置输入将被依赖项注入到这个浏览器夹具中，就好像这是一个测试案例，太酷了。让我们看看我们必须在浏览器中进行的更改，所以我们以前只需要一个电话来初始化
    chrome的 web驱动程序，现在我们要做一个选择，我们必须根据配置浏览器值进行选择，如果是火狐，我们会让火狐。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 如果是铬合金，我们会把铬，如果是无头铬合金，我们需要使用 chrome选项 将 headless参数添加到浏览器初始化中，我会告诉你这些选择，当我初始化卷曲网络驱动程序时，如果这些都没有找到，提出例外。因为这一点都不酷，我们比赛的其他三个部分几乎是一样的，唯一的区别是我的隐含权重调用，我需要从配置中传递隐式权重值，否则也一样，在测试搜索中，我们不需要更改测试用例本身。测试用例仍然会从
    fixture中获得浏览器依赖项，现在，通过调用config，在浏览器fixture中产生了额外的魔力，测试用例本身，并且，页面对象不需要任何代码更改。这些更改显示了测试自动化框架中关注点的良好分离，配置更改后，现在让我们做无头铬的测试，我已经在config
    json文件中设置了headless chrome，如你所见，所以当我们去做测试的时候。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 这次我们应该看到圆周率测试，但我们不应该看到镀铬窗弹出，因为它应该是无头模式，我们试试看，就这样了，铬还没有出现，繁荣，测试用例通过，而且它比 chrome没有无头模式时花的时间少了一点，太酷了。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_73.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: 还有其他方法可以处理浏览器选择，你可能会问，为什么不使用 pi测试标记参数化浏览器选择，参数化你可以这样做，但我反对，原因是浏览器选择是测试的一个方面，它不是一个测试用例值，或者是你想要的测试用例变体。但更确切地说，这是测试的一个方面，还有那个，理论上，每个测试都应该在每个支持的浏览器上运行，而且，从执行的角度来看，如果用不同的浏览器选项对每个测试用例进行参数化，当您使用配置文件或其他输入机制时。会产生大量的重复代码，每个测试用例运行将针对一个特定的浏览器，如果你想运行多个浏览器，您只需使用不同的输入值启动多个测试套件运行，所以你在保存你自己的代码，你省去了麻烦，让我们在这里暂停一下。这样您就有机会尝试使用配置输入来运行headless
    chrome，完成第六部分 芦苇满足教程说明，一旦你得到所有的代码更改，你应该需要大约15分钟，尝试运行所有三个浏览器，无头铬和火狐。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 让我们看看会发生什么。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_75.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: 所以我展示了用铬跑步，无头镀铬，现在我要向大家展示火狐也应该这么做，但我们要确保，所以我们看到火狐，它会去寻找它失败的原因。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_77.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 这没有任何意义，代码是一样的，同样的测试程序，但仅仅是在不同的浏览器上运行 它就取得了突破，那可不好，我们将在下一节中找出原因。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_79.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: 当参与者在同一时间访问相同的资源而不遵循操作顺序时，就会发生竞争条件，在任何类型的黑匣子测试中，比赛条件都因导致薄片而臭名昭著，但特别是对于 web用户界面测试，通过
    web用户界面测试。在它准备好缓解这种比赛条件之前，我们应该总是等待页面上的东西准备好，不管是对等点的元素 还是要更改的属性，我们可以做两种加权，我们可以做内隐加权或外显加权，隐式权重被指定一次，并应用于所有交互。我们的解决方案有一个隐式权重，我们在初始化webdriver实例时设置了这个权重，对于没有太多交互的小项目来说，隐式权重是很好的，或者大多数互动所需时间大致相同的地方，显式权重，另一方面。必须为每个交互指定，它们更复杂来实现你，需要执行这些建议，如我所说，每一次互动，然而，它们确实让你更好地控制正在等待的东西，作为警告，不要混合隐式和显式权重，你的解决方案必须使用这样或那样的方法。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 这是由 lena项目自己直接提出的建议，如果你试图把你的含蓄，显式权重，你可能会以一些非正统的行为结束，如果你想了解更多关于不同重量的信息。我强烈建议阅读
    python的 funding webdriver的 read the docs页面，他们有一整页的重量，有明确权重的例子。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_81.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: 让我们再看一下我们的测试用例失败，在这个失败是由于比赛条件之前，但是让我们看看为什么如果我们看一下圆周率测试案例中的痕迹，我们会看到失败的断言是这个断言，我的短语在结果页标题中，作为结果页标题的值。我们知道此时测试用例应该已经切换到结果页面，因此更新了标题，但这并没有发生，这显然是搜索页面上的标题，这意味着这里的竞争条件是，自动化在结果页标题准备好并翻转之前执行了这个断言。显然
    chrome更改标题的速度比火狐还快，这是浏览器之间不寻常和奇特的区别，但这些事情可能会发生，有几种方法可以尝试修复代码中的竞争条件，一种方法是引入一个艰难的睡眠，我可以加一个硬套。在检查标题之前等待五秒钟，然而，我们永远不应该在我们的自动化中增加硬性睡眠或硬性重量，它们使我们的测试花了比必要的更多的时间，即使我们加上一些延迟时间，这里还有比赛条件，对。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 仍然有演员在自动化等待和页面加载之间竞争如此激烈，睡眠几乎总是一个糟糕的解决方案，另一个解决方案是在这里添加一个显式权重，我们可以显式地让它，等待标题更改，然而，对于我们的小解决方案来说。这并不完全实用，然后，我们必须撤销隐式权重，并更新所有其他交互，有一个明显的重量，既笨重又痛苦，并且超出本教程的范围，谢天谢地，还有第三种方式
    可能看起来有点逃避，但它仍然完成了工作。这是唯一不能与 web元素一起工作的断言，这两个断言适用于 web元素，我们放在 web驱动程序上的隐式权重应用于
    web元素，但与网络驱动程序的属性无关，如果我们只是简单地重新排序我们的步骤。使标题检查发生在最后，然后它强制以隐式的方式在页面上加载，当测试进行到这一步时，标题肯定会改变，所以让我们试试看看看会发生什么。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_83.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 让我们尝试一下我们更新的测试用例，这一次过得很好，所以你自己试试，在这里暂停一下，完成自述教程说明中的第七部分，当您更改代码时，大约需要花费您10分钟的时间，在所有三个浏览器中运行它，无头铬和火狐。并确保这三个工作。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_85.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: 让我们进入第八部分并行运行测试。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_87.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: 不幸的是，与只需几分之一秒的单元测试相比，web用户界面测试速度较慢，web用户界面测试可能需要几分钟的时间来运行，对于我们当前的测试解决方案来说，这似乎没什么大不了的，因为我们只有一个测试。而且速度很快，但是在这个行业里，对于一般的web用户界面测试来说，执行大约需要一分钟，这是非常典型的，每次测试一分钟，根据我所看到的，范围在三十秒到一分半钟之间，通常取决于环境因素和测试中应用的性能。但一分钟是一个相当合理的基准，如果现在每个人都需要一分钟，大概要17个小时，和大型网络应用，老实说，一千个测试并不是一个很大的测试套件，因此，我们需要一种方法来加快我们的测试。如果我们要用自动化来有效地测试我们的应用程序。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_89.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: 为了展示，我们可以很容易地给自己带来一点这种痛苦，让我们进入我们的测试用例，让我们用测试函数上的多个输入对它进行参数化，我从圆周率测试模块中添加了参数化的圆周率测试标记。这个列表将使这个测试用例对每个输入运行三次，这个短语将作为一个论点在这里传递，所以与其在测试函数中设置短语，我从参数值中得到的，现在让我们做这些测试，我们把它们从1乘以3，而且应该需要更长的时间。第一个完成了，第二个完成了，第三个已经完成了，这三次测试用了14秒，以工业标准来看
    这实际上是相当不错的，但我肯定坐在那里等着那些测试完成 感觉很痛苦。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_91.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: 即使他们在无头铬合金中运行，现在并行运行测试并不总是像打开开关那么容易，但是如果您构建了具有良好原则的测试解决方案，圆周率测试应该不会太难。我们可以通过pip
    install调用安装pi test x test插件，使我们能够并行地运行测试用例，PI测试 xis不仅让我们在本地机器上并行运行，但它也使我们能够将测试分发到多台机器上。它们不能有任何冲突，在这种冲突中，测试将访问用于自动化代码中冲突的共享状态，意思是，比如没有全局变量或静态变量什么的，但产品和测试中的功能也有冲突，对，如果有两个测试同时访问同一个数据库，理论上。这些测试可能会互相撤销，所以你要确保避免这样的碰撞，最后，您需要确保每个单独的测试本身都有良好的性能，对，我们可以平行直到奶牛回家，但如果单个测试需要5分钟，八分钟，十二分钟。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 每个单独的测试都需要有自己的表现，意思是没有难眠，嗯，也许使用rest api调用来查看数据，而不是用眼睛去看这样的数据技术。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_93.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: 所以让我们使用 pi test x test并行地运行这些测试，我已经完成了用于 pi测试 x测试的 pippin v安装，所以我会在这里做测试，我们将使用相同的
    pi测试调用命令。但现在我们要添加破折号选项，dash n选项允许您指定要运行多少线程，我要用三根线，横幅看起来有点不一样，但如你所见，我们在9秒内完成了三个测试，从14秒下降到。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_95.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: 所以试试这个，完成自述教程说明中的第8部分 大约需要10分钟，安装 pi测试 x测试，尝试并行运行测试，确保你也尝试了每个浏览器，以确保我们仍然兼容，在我们结束这一节之前。我想分享更多关于并行运行测试的信息，在一台机器上运行测试很方便，但是对于大规模的并行测试来说，它不能很好地扩展，这就是硒网格可以帮助的地方。Selenium
    grid是一个来自Selenium项目的免费开源工具，用于运行远程webdriver会话，网格有一个集线器，用于接收所有请求和具有不同浏览器的多个节点。操作系统和版本自动化可以向集线器请求具有特定标准的会话，集线器将从其节点分配一个可用的会话，硒栅格不仅能实现并行测试，例如，测试可以在
    windows机器上运行。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 在 mac os机器上请求 safari会话，硒栅格也有两种使用方式，您可以设置自己的实例 并自己管理基础架构，或者你可以付钱作为一项服务，像酱油实验室这样的几家公司，lambda测试浏览器堆栈。眉毛在测试，其他人都提供了基于云的网络驱动程序会话，带有额外的功能，如日志视频和测试报告，如果您的团队需要测试多种配置，这些服务可以是一个很好的解决方案，或者不想把资源花在基础设施上。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_97.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: 查看这个名为docker carlos扩展测试的测试自动化大学课程。基德曼做得很好，他展示了如何快速旋转码头工人容器，用任何数量的节点建立硒网格。查看我的文章
    to infinity and beyond a guide to parallel testing on automation panda com。这篇文章详细介绍了为并行测试准备测试以及扩展的不同方法。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这个名为 docker carlos 扩展测试的测试自动化大学课程。基德曼做得很好，他展示了如何快速旋转码头工人容器，用任何数量的节点建立硒网格。查看我的文章
    [to infinity and beyond a guide to parallel testing on automation panda com](https://automationpanda.com/to-infinity-and-beyond-a-guide-to-parallel-testing/)。这篇文章详细介绍了为并行测试准备测试以及扩展的不同方法。
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_99.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/274e64ac5dd581b44ee82ed902c54130_99.png)'
- en: 让我们做我们的最后一节，奖金部分。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行最后一节，奖金部分。
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_101.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/274e64ac5dd581b44ee82ed902c54130_101.png)'
- en: 增加更多测试，至此，您已经完成了本教程的指导部分，恭喜你，我希望你学到了很多，熟能生巧，我们有一个python测试自动化项目，它可以作为更多测试的基础。我想让你们做的是尝试在你们自己的项目中添加更多的测试，我列出了一些测试的想法，应该很容易，基于我们已经为鸭子做的基本搜索测试，你可以继续写鸭子测试，例如点击按钮进行搜索，而不是键入返回或单击搜索结果。也许扩展更多的结果
    或做不同类型的搜索，甚至改变设置，如果你真的想挑战，尝试为其他 Web应用程序实现测试，使用启动器项目，我祝愿您在测试和自动化的旅程中一切顺利。我希望您发现本教程是有价值的、有帮助的和信息丰富的，谢谢你坚持到最后，而且，我很想听听你对教程的看法，以及你写了哪些额外的测试。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 增加更多的测试，现在您已经完成了本教程的指导部分，恭喜你，我希望你学到了很多，熟能生巧。我们有一个 Python 测试自动化项目，它可以作为更多测试的基础。我想让你们尝试在你们自己的项目中添加更多的测试。我列出了一些测试的想法，应该很简单，基于我们已经为鸭子做的基本搜索测试，你可以继续编写鸭子测试，例如通过点击按钮进行搜索，而不是键入返回或单击搜索结果。也许扩展更多的结果，或者进行不同类型的搜索，甚至改变设置。如果你真的想挑战一下，尝试为其他
    Web 应用程序实现测试，使用启动器项目。我祝愿您在测试和自动化的旅程中一切顺利。我希望您发现本教程是有价值的、有帮助的和信息丰富的，谢谢你坚持到最后，而且，我很想听听你对教程的看法，以及你写了哪些额外的测试。
- en: '![](img/274e64ac5dd581b44ee82ed902c54130_103.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/274e64ac5dd581b44ee82ed902c54130_103.png)'
