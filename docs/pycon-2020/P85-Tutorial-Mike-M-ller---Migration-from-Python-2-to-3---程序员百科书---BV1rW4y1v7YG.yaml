- en: P85：Tutorial Mike Müller - Migration from Python 2 to 3 - 程序员百科书 - BV1rW4y1v7YG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P85：教程Mike Müller - 从Python 2迁移到3 - 程序员百科书 - BV1rW4y1v7YG
- en: '[silence]。'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[沉默]。'
- en: '![](img/91b215d5b38cdccc024726453d81019b_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91b215d5b38cdccc024726453d81019b_1.png)'
- en: A can。 It is a tutorial migration from Python 2 to Python 3。 A few words about
    myself。 I have been a Python user since 1999， starting with Python version 1。52。
    I have been using Python ever since on a daily basis。 I gave my first Python training
    in 2006。 and I have been doing Python training in a full-time basis since 2010。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 可以的。这是一个从Python 2迁移到Python 3的教程。关于我自己的一些话。我从1999年开始使用Python，最初是Python 1.52。从那时起我每天都在使用Python。我在2006年进行了第一次Python培训，并自2010年起全职进行Python培训。
- en: I worked for Python Academy doing Python training。 Let's get started and download
    the material。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾在Python学院进行Python培训。让我们开始并下载资料。
- en: '![](img/91b215d5b38cdccc024726453d81019b_3.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91b215d5b38cdccc024726453d81019b_3.png)'
- en: Please go to this link and download the material。 Once you have downloaded the
    material。 you will find two folders。 One is a source code and one is a PDF。 Let's
    have a quick look in the PDF。 Once you open the PDF， you will find the table of
    content。 I will go through the table of content so you can see what they are doing。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 请访问这个链接下载资料。一旦你下载了资料，你会找到两个文件夹。一个是源代码，一个是PDF。让我们快速查看PDF。一旦打开PDF，你会找到内容目录。我将浏览一下内容目录，以便你了解它们在做什么。
- en: I will give you a short overview over this tutorial。 The first part is an overview
    of the differences between Python 2 and Python 3。 Quite a few of them。 I picked
    the most important ones。 I think it is important to understand what the difference
    between these two Python versions are。 We have different parts。 The first one
    would be cleaning up your Python 2。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我将简要概述这个教程。第一部分是Python 2和Python 3之间差异的概述。有很多差异。我挑选了最重要的。我认为理解这两个Python版本之间的区别很重要。我们有不同的部分。第一部分是清理你的Python
    2。
- en: 7 code to make it better with Python 3。 The next part is an overview of converting
    strategies。 There are different ways to convert from Python 2 to Python 3。 Then
    we go through some of them in more detail。 For smaller projects。 you might be
    fine to write your own layer。 You can also start from scratch。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 7代码使其在Python 3中更好。下一部分是关于转换策略的概述。有不同的方法可以从Python 2转换到Python 3。然后我们将更详细地了解其中一些。对于较小的项目，你可能可以编写自己的层。你也可以从头开始。
- en: Then there are two different ways to start from Python 2。 You might have a Python
    3 project。 All of this will be interactive examples。 We will look at some example
    Python code。 Now we would like to set up some development environments。 Since
    we work with Python 2 and Python 3。 we need to have both versions installed。 If
    you have to set up on your machine already。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然后有两种不同的方法可以从Python 2开始。你可能有一个Python 3项目。所有这些将是交互示例。我们将查看一些示例Python代码。现在我们想要设置一些开发环境。由于我们使用Python
    2和Python 3，我们需要安装这两个版本。如果你已经在机器上设置好了。
- en: then it is okay。 You can skip forward。 Otherwise， you can try the same setup。
    I do use Conda。 You can also use pip and pip and the same way。 I use Conda to
    create environments。 Then I set up these environments， install Python 2。7 and
    Python 3。8。 These are the two versions I am going to use here。 The most recent
    version currently is Python 3。8。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这样可以。你可以直接跳过。否则，你可以尝试相同的设置。我确实使用Conda。你也可以使用pip，以同样的方式。我使用Conda创建环境。然后设置这些环境，安装Python
    2.7和Python 3.8。这是我将在这里使用的两个版本。目前最新的版本是Python 3.8。
- en: We want to migrate from Python 2。7。 Theoretically， you could do something Python
    2。6。 but they would strongly augment the port。 Everything from Python 2。6 to 7。
    If you still have this very old Python 2。6 code。 I use Conda。 Conda allows to
    create environments which are very similar to virtual amps。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要从Python 2.7迁移。理论上，你可以使用Python 2.6，但这会大大增加移植的工作量。从Python 2.6到7。如果你仍有非常旧的Python
    2.6代码，我使用Conda。Conda允许创建与虚拟环境非常相似的环境。
- en: You can create this pip on the end。 Since I like Conda better， I do this one。
    but if you have all the way， creating these environments， it is totally fine。
    I create this environment with Conda。 Create minus name。 Put the tutorial to 7。
    I say Python equals to 7。 Then I would like to install some software and I can
    already install Jupit or Lab。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在最后创建这个pip。因为我更喜欢Conda，所以我使用这个。但如果你全程都这样创建环境也是完全可以的。我使用Conda创建这个环境。创建-名称。将教程设置为7。我说Python等于7。然后我想安装一些软件，我可以已经安装Jupyter或Lab。
- en: I use Jupit or Notebooks here to do the work。 I use Jupit or Lab。 You don't
    have to do this。 but you can follow this。 These things can be done in different
    environments， in the file。 whatever you would like to。 Jupit or Lab is a good
    teaching tool。 In the end。 I can give you all these notebooks and also in HTML
    or PDF version。 If you prefer。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用Jupyter Notebook进行工作。我使用Jupyter Lab。你不必这样做，但你可以跟随这些。这些工作可以在不同的环境中进行，文件中，无论你想要什么。Jupyter
    Lab是一个很好的教学工具。最后，我可以将所有这些笔记本提供给你，也可以以HTML或PDF版本。如果你喜欢的话。
- en: you don't need to install Jupit or Lab， or you can still read through what I
    did here。 That takes a while， so I have to check what's out there and then it
    needs to install the Python version and the required software。 Later on， we will
    install more software， but we do this step by step。 We don't need too much。 we
    need only two tools， I think， and the whole tutorial。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要安装Jupyter Lab，或者你仍然可以阅读我在这里做的事情。那需要一些时间，所以我必须检查外面的情况，然后需要安装Python版本和所需软件。之后我们会安装更多软件，但我们一步一步来。我们不需要太多，我想我们只需要两个工具，以及整个教程。
- en: I will show you and give you all these links and of course you can also install
    them in this pit。 It's not required to use Kanda for these purposes。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我会展示给你并提供所有这些链接，当然你也可以在这个环境中安装它们。为了这些目的，不必使用Konda。
- en: '![](img/91b215d5b38cdccc024726453d81019b_5.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91b215d5b38cdccc024726453d81019b_5.png)'
- en: Okay， now I've installed our first environment。 Let's do the same thing with
    our second environment。 so we use Python 3。8 and do the same thing with Python
    3。8。 Of course， we call this 3。8。 so we have second environment。 Okay， now we
    have two environments and I would like to activate them and you can see the command
    here to activate the environment and I make two new terminals。 I activate 27，
    which gives me now the 2。7 tutorial terminal and I do the same thing for 3。8。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我已经安装了我们的第一个环境。让我们对第二个环境做同样的事情。所以我们使用Python 3.8，并对Python 3.8做同样的事情。当然，我们称之为3.8，所以我们有了第二个环境。好的，现在我们有两个环境，我想激活它们，你可以看到这里激活环境的命令，我打开了两个新的终端。我激活27，这样我就得到了2.7的教程终端，我对3.8做同样的事情。
- en: Now I have two environments and if I check the Python versions， I do have 3。8
    here and I do have 27 here。 The next step is starting Jupyter or Lab and I will
    give you a short introduction to Jupyter。 I type Jupyter like the planet and space
    and Lab and I have to specify a port because I have all those Jupyter running。
    You don't necessarily have to specify this port but you can just make up some
    number and then you start Jupyter。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我有两个环境，如果我检查Python版本，我确实有3.8和2.7。下一步是启动Jupyter Lab，我将给你一个Jupyter的简短介绍。我输入Jupyter，就像行星和空间，和Lab，我必须指定一个端口，因为我有所有的Jupyter在运行。你不一定需要指定这个端口，但你可以随便编个数字，然后启动Jupyter。
- en: Lab takes it a little bit so then it starts to serve on the background and it
    will open a new tab in the browser。 You see now in the browser is the open Jupyter。Lab
    and localhost and you can drop this Jupyter。 This is now Python 2 version。 They
    have a bunch of other things installed you might not see。 They see here on the
    left hand side this is the handout and the source from the zip file。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Lab需要一点时间，然后它开始在后台服务，并将在浏览器中打开一个新标签。你现在在浏览器中看到的是打开的Jupyter Lab和localhost，你可以关闭这个Jupyter。这是Python
    2版本。他们安装了一些其他的东西，你可能看不到。在左侧栏你可以看到，这是手册和来自zip文件的源代码。
- en: You can look in the link and then you have a Python 2 launch sources。 This is
    our notebook in Python 2 and if I double click on this I get a Python 2 notebook
    which is an untitled notebook which is not a very good name。 I get everything
    a bit bigger and I can also turn off the left hand side here and the first thing
    I do I rename the notebook and call this Python 2 and then we run Python 2。 You
    will see that we run Python 2 print without parentheses which is the first thing
    works which wouldn't work in Python 2。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看链接，然后你会找到Python 2的启动源。这是我们的Python 2笔记本，如果我双击它，我会得到一个Python 2的笔记本，这是一个未命名的笔记本，这个名字不是很好。我把一切都变得大一点，我也可以关闭左侧栏，第一件事我做的是重命名笔记本，称之为Python
    2，然后我们运行Python 2。你会看到我们运行Python 2的print没有括号，这在Python 2中是第一件有效的事情，而在Python 3中却不能工作。
- en: You can also check the version internally here and then you see you get the
    Python version 2 7 15 for March。 So very latest Python version here。 Good。 This
    is Python 2。 Now we do the same thing for Python 3。 Same procedure and then I'm
    going to show you a few basics about Jupyter。Lab。 If you know there's a writing
    you can again skip ahead to the next section。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在这里检查内部版本，然后你会看到得到的Python版本是2.7.15，发布日期为3月。所以这是最新的Python版本。好的。这是Python 2。现在我们对Python
    3做同样的事情。相同的程序，然后我将向你展示一些关于Jupyter Lab的基础知识。如果你知道有写作，你可以跳过到下一部分。
- en: So I go back to my console and I go to the Python 3 and type exactly the same
    command。 And I use a different port。 And then again it will start a new tab in
    my browser and I get a second notebook which looks exactly the same and we can
    do a Python 3。 So there's something small error messages that doesn't matter and
    I get another one and then I call this Python 3。 It's important that you rename
    it otherwise you might end up in the wrong notebook。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我回到我的控制台，去到Python 3并输入完全相同的命令。我使用不同的端口。然后，它会在我的浏览器中启动一个新标签，并且我会得到一个看起来完全相同的第二个笔记本，我们可以使用Python
    3。所以有一些小错误信息，但这没关系，我又得到了一个，然后我把它叫做Python 3。重命名是很重要的，否则你可能会进入错误的笔记本。
- en: And then there's a question I want this kernel， Python 3 and then usually give
    a start with something like this。 And I do this and I start a notebook and I do
    rename the notebook to Python 3。 If you're interested in the notebook you can
    discover some of these menus up here。 You can look at them with a pretty self-explanatory。
    They have a lot of options。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我想问一个问题，我想要这个内核，Python 3，通常是从这样的内容开始。我这样做，然后启动一个笔记本，并将笔记本重命名为Python 3。如果你对这个笔记本感兴趣，可以在这里发现一些菜单。你可以查看它们，它们的意思非常明确。它们有很多选项。
- en: We don't need all of them。 Now you can turn off the sidebar which gives us a
    bit more space and you can make it bigger。 And just a few words about this Jupyter
    lab if you don't know how this works。 So we have a cell in the cell as a Python
    code cell。 When I press Shift enter or click on this error up there you see then
    the executed cell。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要所有的这些。现在你可以关闭侧边栏，这样可以给我们更多空间，你可以将其放大。关于这个Jupyter lab，如果你不知道它是如何工作的，我简单说几句。我们有一个单元，这个单元是一个Python代码单元。当我按Shift
    + Enter或点击上面的这个错误时，你会看到执行的单元。
- en: You can write a full Python program in a cell。 So if you like you can define
    a function here and then this function will be available later。 So it takes a
    little bit and then it takes a little bit of a react and then you can use the
    function here and calculate something。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一个单元中写一个完整的Python程序。如果你愿意，可以在这里定义一个函数，然后这个函数在之后将会可用。所以这需要一点时间，然后需要一点反应，然后你可以在这里使用这个函数来计算一些东西。
- en: In addition to this one you can also use Markdown。 So you can change the type
    of the cell。 So you can do this via this menu or also with a keyboard shortcut
    which is SKM for Markdown。 And you can turn to Markdown and then you can write
    Markdown。 I hope probably you're familiar with Markdown。 So Markdown is a lightweight
    Markup language that's what's called Markdown。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，你还可以使用Markdown。因此，你可以更改单元的类型。你可以通过这个菜单进行更改，或者使用键盘快捷键SKM来进行Markdown。你可以切换到Markdown，然后你可以编写Markdown。我希望你对Markdown是熟悉的。Markdown是一种轻量级的标记语言，这就是它被称为Markdown的原因。
- en: And I can write a header， force order and a header， second order。 And I can
    write a bullet list。 This is a space。 You have to put a space and you see you
    get syntax highlighting and I can do something like this。 So you get some basic
    syntax highlighting and formatting and then you can write text。 That's pretty
    much all those features we're going to use here。 That's what we're doing。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以写一个标题，强制顺序和一个标题，第二顺序。我可以写一个项目符号列表。这是一个空格。你必须留一个空格，你会看到获得语法高亮，我可以做这样的事情。所以你获得一些基本的语法高亮和格式化，然后你可以写文本。这就是我们将在这里使用的所有功能。这就是我们要做的。
- en: Otherwise we switch back and forth between these notebooks。 You can also start
    a terminal。 So if you like then you have the terminal with a Python version that's
    also possible。 And about all of the links in there is a lot of help。 So if you
    go to help you find a little help about Python and other packages。 So yes。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们在这些笔记本之间来回切换。你也可以启动一个终端。如果你愿意，那么你可以得到一个带有Python版本的终端，这也是可能的。在所有的链接中，有很多帮助。所以如果你去帮助那里，你会发现关于Python和其他包的一些小帮助。所以是的。
- en: you can see here that a lot of scientific packages because JupyterLab is used
    for scientific purposes。 But you can still use it even if you don't do any scientific
    computing。 JupyterLab is a very nice to test something to play something。 And
    that's most of what we're going to do here。 We want to play with something and
    therefore the rock is JupyterLab。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里有很多科学包，因为 JupyterLab 是用于科学目的。但即使你不进行任何科学计算，你仍然可以使用它。JupyterLab 是一个很好测试和玩耍的工具。这就是我们在这里要做的大部分工作。我们想要玩一些东西，因此
    JupyterLab 是一个很好的选择。
- en: So we're going to play with exactly the same in this notebook here。 So you can
    do this。 If you would like to insert a cell I can press escape A for insert a
    buff escape A escape A。 Then you have a new cell and then I'll say escape one
    to have a header markdown cell and I can just write something here。 So you can
    write something up here and now we have a Python 2 and a Python 3 environment。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将确切地在这个笔记本上进行实验。如果你想插入一个单元格，我可以按 Escape 和 A 来插入一个新的单元格，然后你有一个新的单元格，我可以按
    Escape 和 1 来创建一个标题 markdown 单元格，我可以在这里写一些东西。所以你可以在这里写一些东西，现在我们有一个 Python 2 和一个
    Python 3 的环境。
- en: '![](img/91b215d5b38cdccc024726453d81019b_7.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91b215d5b38cdccc024726453d81019b_7.png)'
- en: '![](img/91b215d5b38cdccc024726453d81019b_8.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91b215d5b38cdccc024726453d81019b_8.png)'
- en: Now you would like to look at the differences between Python 2 and Python 3。
    I will go through them step by step and show you all the major differences between
    these two versions。 For this you should make new notebooks。 So I'm making new
    notebook in Python 3 and one in Python 2 so I can switch back and forth between
    these two versions。 So I may be new notebook and rename this difference in straight。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你想看看 Python 2 和 Python 3 之间的差异。我将逐步讲解，并向你展示这两个版本之间的所有主要差异。为此你应该创建新的笔记本。所以我在
    Python 3 中创建新的笔记本，并在 Python 2 中创建一个，这样我可以在这两个版本之间切换。所以我可能会创建一个新笔记本，并将其重命名为“差异”。
- en: And I do the same thing in Python 2 so you have a notebook is a difference。
    So now we can look at the difference。 So first thing that is different is the
    print function。 So。 print function is the first thing。 The simplest one most of
    you will know about it。 But yet we can start with it and we can see how it works。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 2 中我做同样的事情，所以你有一个笔记本，这是个不同之处。现在我们可以查看差异。首先不同的是打印函数。所以，打印函数是第一件事。最简单的，大多数人都知道。但是我们可以从中开始，看看它是如何工作的。
- en: So print here is a statement so I have to say one plus one and I get to an effort
    with the same thing in Python 3。 So I go now to my Python 3。 And do the print
    function if I try the same thing print one plus one。 I do get a syntax error and
    it helps me。 I need to add some parentheses to get print so I can do the print
    function。 And I say one plus one which gives me to this works。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里的打印是一个语句，所以我得说 1 加 1，我在 Python 3 中也得到同样的结果。所以我现在去我的 Python 3。如果我尝试相同的事情，打印
    1 加 1，我会得到一个语法错误，这对我很有帮助。我需要添加一些括号来执行打印函数。我说 1 加 1，这给我结果是 2，这可以工作。
- en: The print is interesting now print is a function。 And this gives you a little
    bit more possibilities because now you see a print 123 and it puts a space but
    the print function provides an option argument is called set neck can change this
    separator to set。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打印是有趣的，打印是一个函数。这给你更多的可能性，因为你看到打印 123，并且它添加了一个空格，但打印函数提供了一个选项参数，称为 set neck，可以将这个分隔符更改为
    set。
- en: So you can put a separate to something else。 And now you see instead of space
    I do get a comma and a space。 This does not work in Python 2。 So go back to Python
    2 the print function。 So you can put the parentheses but that's not the same to
    people that you can do this because this parentheses just groups so that Python
    just kind of removed the parentheses。 So if you want to try something like this。
    You get a 2 plus so that's unfortunate because it still works。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以把某个东西单独放在其他地方。现在你看到的是，我得到的是一个逗号和一个空格，而不是空格。这在 Python 2 中是无法使用的。所以回到 Python
    2 的打印函数。你可以加上括号，但这对人们来说并不相同，因为这个括号只是用于分组，Python 会把括号去掉。如果你想尝试这样的事情，你得到的是 2 加，这很不幸，因为它仍然可以工作。
- en: Yeah， but the result is obviously different because now you create a 2 plus
    and then you feed the 2 plus print statement。 But now we have one of them from
    future imports。 So Python has this from future import。 And this is not necessary
    connecting with Python 2 and Python 3。 This exists earlier so in Python 2。5 you
    can say import context managers or something like this so you can import a feature
    that comes with the next version of Python。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，但结果显然不同，因为现在你创建了一个 `2 plus`，然后你给 `2 plus` 打印语句传入。现在我们从未来导入了其中一个。所以 Python
    有这个从未来导入的功能。这与 Python 2 和 Python 3 并不一定有关系。它早在 Python 2.5 之前就存在，你可以说导入上下文管理器或类似的东西，因此你可以导入一个伴随下一个版本的
    Python 的特性。
- en: Now the version to some degree。 And now if I do this print。 Now I do the same
    thing as just copy my line and I do get my print looking exactly the same。 And
    I can now also use my set here。 And it works。 Now my print function。 If you look
    at this is now the print function。 It might look a bit different in Python。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在版本在某种程度上。现在如果我执行这个打印。现在我做同样的事情，只需复制我的行，我的打印看起来完全相同。我现在也可以在这里使用我的集合。并且它工作了。现在我的打印函数，如果你看看这个，现在是打印函数。它在
    Python 中可能看起来有点不同。
- en: Three so in Python 3 for a type print。 Exactly the same so it's exactly the
    same now we have a print function。 So there are a bunch of features you can actually
    from future import。 And this is probably the easiest thing you can do。 So if you
    still have to do something in Python 2 from future import that ever makes sense
    here and use a new version and then you don't have to do anything in Python 3。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3 中，对于类型的打印是完全相同的，所以现在我们有一个打印函数。所以你可以实际从未来导入一堆功能。这可能是你可以做的最简单的事情。所以如果你仍然需要在
    Python 2 中做一些事情，从未来导入在这里就会有意义，然后你在 Python 3 中就不需要做任何事情。
- en: You can use pass from future important Python 3 I copy this line。 There is nothing
    that prevents you writing this is that does have any effect it doesn't change
    anything because you are in the future already。 So from future import doesn't
    change anything so it's pretty safe to do it because it's just like a note。 No，
    it doesn't do anything。 But this is the first thing so you have this future。 So
    it's important。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用从未来导入的 Python 3，我复制了这一行。没有任何东西阻止你写这个，它没有任何效果，不会改变任何东西，因为你已经在未来了。所以从未来导入并不会改变任何东西，所以这样做是相当安全的，因为这就像一个注释。不，它并不会做任何事情。但这是第一件事，所以你有这个未来。因此，它是重要的。
- en: Next thing iterators。 In Python 3 you will get iterators at many places。 For
    instance。 when you zip something。 So if I zip this two strings together。 It's
    a zip function。 I do get a zip object which is not too useful that's why I called
    it。 Then if I use next on it then you will see it provides next because it's neutral
    Rachel。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是迭代器。在 Python 3 中，你会在很多地方看到迭代器。例如，当你压缩某些东西时。所以如果我将这两个字符串压缩在一起。这是一个压缩函数。我确实得到了一个压缩对象，这并不太有用，这就是我称之为的。然后如果我在上面使用
    `next`，你将看到它提供下一个，因为它是中性的。
- en: So I do the same thing in Python 2 so I go back to my Python 2 version and I
    write my same photo。 And I look at iterators in Python 2 and you can see this
    one gives you back a list。 So this is always ego that gives you back a list in
    Python 2。 In Python 3 it is an iterator which is a lazy thing。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我在 Python 2 中做同样的事情，所以我回到我的 Python 2 版本，并写下我的同样的照片。我查看 Python 2 中的迭代器，你可以看到这一点返回一个列表。所以在
    Python 2 中总是返回一个列表。在 Python 3 中是一个迭代器，这是懒惰的。
- en: If you want to achieve the same thing you have to convert it to a list。 So you
    have to materialize it to actually create this tuple。 Otherwise you get an iterator
    which can be very beneficial。 If you work with bigger structures then you might
    not need to create this in the immediate structure。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想实现相同的功能，你必须将其转换为列表。所以你必须将其具体化，以实际创建这个元组。否则你会得到一个迭代器，这在处理更大的结构时可能非常有益，因此你可能不需要立即创建这个结构。
- en: If you might like to find a fit to the dict like if you would like to create
    a dict。 Then you don't have to create a list before you create a dict。 You can
    create a dict。 You might be faster and also you might save the immediate memory。
    You don't have to allocate it。 The same thing goes for other commands。 A zip or
    functions。 The zip function map。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可能想为字典找到一个适合的，如果你想创建一个字典。那么你不必在创建字典之前创建一个列表。你可以创建一个字典。你可能会更快，并且你可能也会节省即时内存。你不必分配它。其他命令也是如此。压缩或函数。压缩函数映射。
- en: same thing map gives you a neutral writer。 If you still use map you can use
    this term by instance map is not really necessary。 If you have a list of things
    that you want to do in the same way you want to create a list。 There is a bunch
    of these things here that give you iterators。 This would be one thing。 You will
    get iterators in many places。 You will see some programs that check at lists like
    this or the place to convert your zip。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的事情，map 给你一个中立的写入器。如果你仍然使用 map，你可以用这个术语，实例 map 并不是非常必要。如果你有一个想要以相同方式处理的事物列表，你想要创建一个列表。这里有很多东西可以给你迭代器。这将是其中之一。你会在很多地方获得迭代器。你会看到一些程序像这样检查列表，或者转换你的
    zip 的地方。
- en: to a list which prevents you from saving the memory but makes you compatible
    with Python。 2 and Python 3 because now you can index into this list and you cannot
    do this in the。 neutral writer。 The next thing is range。 In Python 3 looks a bit
    different than range in Python 2。 First of all you can use range with a very big
    number because range generates a range object。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为列表，这会阻止你节省内存，但使你与 Python 2 和 Python 3 兼容，因为现在你可以对这个列表进行索引，而你不能在中立写入器中这样做。下一个是范围。在
    Python 3 中看起来与 Python 2 中的范围略有不同。首先，你可以用一个非常大的数字使用范围，因为范围生成一个范围对象。
- en: If I do this in Python 2 range generates a list right away。 It is materialized
    so it is very similar to a new writer but somehow similar to the behavior。 This
    one creates a list immediately and that is it。 In Python 3 it generates a range
    object。 You can do a bunch of things with this range object because it is also
    lazy so I can give it the name range。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在 Python 2 中这样做，范围会立即生成一个列表。它是物化的，因此与新的写入器非常相似，但在某种程度上与行为相似。这个立即创建一个列表，就是这样。在
    Python 3 中，它生成一个范围对象。你可以用这个范围对象做很多事情，因为它也是惰性的，所以我可以给它命名为范围。
- en: I can now do something with it。 I can convert it to a list。 If you do not believe
    me that is not a iterator， I can convert it again and again。 If you do not believe
    me that is not an iterator， if you try next， then I do get an exception here。
    It is not an iterator so it says explicitly it is not an iterator。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在可以用它做一些事情。我可以将其转换为列表。如果你不相信我它不是一个迭代器，我可以一次又一次地转换它。如果你不相信我它不是一个迭代器，如果你尝试 next，那么我这里会抛出一个异常。它不是一个迭代器，所以明确表示它不是一个迭代器。
- en: It does not work but you can convert it again and again and again。 You can do
    a bunch of more things here。 You can take one because range objects theoretically
    you can do something like this。 Don't do this in Python 2 because I try to create
    a list of the size which is not really healthy。 Because it is used up all your
    memory or you get a memory error。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不奏效，但你可以一次又一次地转换它。你可以在这里做许多其他事情。你可以取一个，因为范围对象理论上可以这样做。不要在 Python 2 中这样做，因为我尝试创建一个大小不太健康的列表。因为它会用尽你所有的内存，或者你会得到内存错误。
- en: Otherwise your computer might get a bit slower。 This range object can also be
    sliced so you can slice here and you can see here now it can run。 Slice inside
    range and it can get parts of the range。 This does not work with X range so in
    Python 2 you do have something called X range。 X range is very similar because
    it does not create the list。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 否则你的计算机可能会变得有点慢。这个范围对象也可以被切片，所以你可以在这里切片，你现在可以看到它可以运行。在范围内切片，并可以获得范围的一部分。这在 X
    范围中不起作用，所以在 Python 2 中你有一个叫 X 范围的东西。X 范围非常相似，因为它不创建列表。
- en: If I call this thing X10 for my X range then I can convert this one to a list
    and can do this again。 This regardless is the same but you cannot do this fancy
    slicing thing so if you try this one。 then it does not like you and tells you
    you cannot slice it。 The difference X range was kind of in the media in Python
    2 and in Python 3。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我把这个东西称为 X10，用于我的 X 范围，那么我可以将这个转换为列表，并可以再次这样做。这无论如何都是一样的，但你不能做这种花哨的切片，所以如果你尝试这个，那么它不喜欢你，并告诉你你不能切片。X
    范围在 Python 2 中算是中介，而在 Python 3 中。
- en: Often people say X range got renamed to range which is partially true so it
    is very similar but you see slicing and all those nice advanced features。 It does
    not work with X range but it works with CIR。 This is a size wise if you try to
    make a very big one and you say X power of fun。 Then you can overflow error so
    it does not work with big ints or long in Python 2 and it only works with normal
    ints。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常说 X 范围被重命名为范围，这部分是正确的，所以它非常相似，但你会看到切片和所有那些很好的高级功能。它在 X 范围中不起作用，但在 CIR 中可以工作。这在大小方面，如果你尝试制作一个非常大的对象并说
    X 的幂次方。然后你可能会溢出错误，因此在 Python 2 中它不能与大整数或长整型一起工作，只能与普通整数一起工作。
- en: So in Python 3 the distinction is gone you will see this in one minute therefore
    you have this。 The difference。 Okay next topic dictionary。 So if I have a dictionary
    here。 If I have a dictionary I can say keys and keys is a list。 If I say k is
    keys then keys looks like this and if I do change my dictionary。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在 Python 3 中，这种区别消失了，你将在一分钟内看到，因此你有这个。区别。好的，下一个主题是字典。如果我在这里有一个字典。如果我有一个字典，我可以说
    keys，keys 是一个列表。如果我说 k 是 keys，那么 keys 看起来像这样，如果我改变我的字典。
- en: And my dictionary changes but my keys since it is a list which is decoupled
    does not change the states。 This is different if you go to Python 3。 This will
    be different。 I copy this header so we have the same header here so you can follow
    along in both versions。 But dictionary keys so I can copy my dictionary from this。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 而我的字典发生了变化，但我的键由于它是一个解耦的列表，所以状态没有变化。这在你进入 Python 3 时会不同。这会有所不同。我复制这个头部，因此我们在这里有相同的头部，你可以在两个版本中跟随。但字典键，所以我可以从这里复制我的字典。
- en: If you can see this we have this D and if I say k equals keys so the command
    is the same。 Then I do get k keys。 And now I modify my dictionary exactly the
    same way as we did before。 And now you can see the picture has changed and the
    keys reflect this。 The keys reflect this we do have now key views that are connected
    to the dictionary and they don't have the data。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能看到这一点，我们有这个 D，如果我说 k 等于 keys，那么命令是相同的。然后我得到 k keys。现在我以完全相同的方式修改我的字典，和之前一样。现在你可以看到图像发生了变化，键反映了这一点。键反映了这一点，我们现在确实有与字典相连的键视图，而它们没有数据。
- en: They just get the keys directly from the dictionary and if the dictionary gets
    modified the key here it is different also。 And the same is true for values and
    items。 They also give you lists in Python 2 and new objects in Python 3 so that's
    exactly the same thing。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 它们直接从字典中获取键，如果字典被修改，这里的键也会不同。同样的道理适用于值和项目。它们在 Python 2 中也给你列表，在 Python 3 中则给你新对象，所以这完全是一样的事情。
- en: I don't need to show this one。 There are new things in Python 3。6。 A dictionary
    is guaranteed order so they do have an order so you can show this。 So if I have
    the dictionary and I delete the key A。 I need the dictionary key A。 Now my dictionary
    doesn't have A。 Now I insert A again and you see now A is at the end。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我不需要展示这个。在 Python 3.6 中有新的东西。字典是有序的，所以它们确实有一个顺序，所以你可以展示这个。所以如果我有字典并删除键 A。我需要字典键
    A。现在我的字典没有 A。现在我再次插入 A，你会看到现在 A 在最后。
- en: It's not only shown at the end actually if it's right over it will come out
    last。 If you do the same thing in Python 2 so we do the same thing here。 So I
    delete。 First I write no order。 No order。 So if I delete A from my dictionary
    of course it's gone。 That's not different here so it's gone。 But if I put it back
    and you look at this again you see now it's not at the end it's the beginning。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它不仅在最后显示，如果它在上面，将会最后出现。如果你在 Python 2 中做同样的事情，那么我们在这里也做同样的事情。所以我删除了。首先我写的是无序。无序。因此，如果我从字典中删除
    A，那当然它就消失了。这在这里没有不同，所以它消失了。但如果我把它放回去，再次查看，你会发现现在它不在最后，而是在开头。
- en: It's different。 A dictionary implementation has changed in Python 3。6 and it's
    guaranteed that the instruction order is preserved in Python 3。7。 So that's a
    different thing so you have to be careful。 A lot of people assume some kind of
    order in Python 2 and if they assume this order it kind of always came out this
    way but it was not guaranteed。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这很不同。字典的实现已经在 Python 3.6 中改变，并且在 Python 3.7 中保证保留指令顺序。所以这是不同的事情，因此你必须小心。很多人假设
    Python 2 中某种顺序，如果他们假设这个顺序，它总是以这种方式出现，但并不是保证的。
- en: So you assume something your assumptions kind of shaky。 It's not given。 You
    always not guaranteed。 And then you might have a problem and you have to be very
    careful because as you can see here now if you iterate over the keys they come
    out in a different order。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你假设了一些东西，你的假设有点不稳固。这并不是给定的。你永远不会得到保证。然后你可能会遇到问题，你必须非常小心，因为正如你现在看到的，如果你迭代键，它们会以不同的顺序出现。
- en: If you do something like this。 Good。 One of the most important things I would
    say are comparisons。 Comparison but you can compare。 You can compare things and
    then you see。 I can。 I try to compare something like this and it doesn't work
    and I do get。 An error message。 If I do the same thing in Python 2。 Yeah， so I
    try to。 Try to compare。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做。很好。我想说的最重要的事情之一是比较。比较，但是你可以进行比较。你可以比较事物，然后你会看到。我可以。我尝试比较这样的东西，但它不起作用，我确实得到了。一个错误信息。如果我在
    Python 2 中做同样的事情。是的，所以我尝试。尝试比较。
- en: I just copy my code from the other notebook and it works。 So this gives you
    a true and if I do it the other way around。 And that's something I still remember
    when I saw it was Python 1 5。 They talked about this already to be in the problem
    and all the books。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是从另一个笔记本中复制了我的代码，它能正常工作。所以这给你带来了真实的结果，如果我反过来做的话。至今我仍然记得我看到的是 Python 1.5。他们已经在问题和所有书籍中提到过这一点。
- en: This time it's just a handful of books。 They had this prominently somewhere
    else that okay that's a problem to be careful。 You can compare these things that
    might be a trap。 You might compare something that's not supposed to be compared。
    So the next one would be。 The integers。 So in Python 2 you have two integers you
    have。 The integer。 It and you do have a type。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这次只有一小堆书。他们在别的地方显眼地提到过，所以这可能是一个需要小心的问题。你可以比较这些东西，这可能是一个陷阱。你可能会比较一些不应该比较的东西。所以下一个将是。整数。在
    Python 2 中你有两个整数，你有。整数。它和你确实有一个类型。
- en: Long you get along。 So if you make an integer very big then。 You get along。
    So this max。 In there's a max in here in Python。 In Python 2。 And if I multiply
    this by 2 I do get along you see it was a trailing out。 So just know the difference
    between ins and long say of get control automatically。 But you get a string representation
    with the L you have to data types。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 长整型你能得到。所以如果你将一个整数变得非常大。那么你能得到。所以这里有一个最大值，在 Python 中也有一个最大值。在 Python 2 中。如果我将这个乘以
    2，我确实得到了，你看到它是一个尾随的结果。所以只需了解整型和长整型之间的区别，它会自动控制。但你会得到一个带有 L 的字符串表示形式。
- en: In Python 3 you don't have this it's gone which makes your life much easier。
    So if we go here so you can say。 Interse and you have type。 One yeah it's ined
    and if you now try to put an L。 It tells you it's not going to work it's in that
    syntax and you can have a very very big number。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3 中，你没有这个，它消失了，这让你的生活容易多了。所以如果我们在这里，你可以说。整型，你有类型。一个，是的，它是无穷大，如果你现在尝试放入
    L。它会告诉你这不会工作，它的语法，并且你可以有一个非常非常大的数字。
- en: And this is a very big number and still in it。 So that's only one integer which
    makes your life easier。 This was kind of a regular process in Python that the
    difference is between longs and in small and small。 And therefore just get rid
    of。 The next thing is mathematical the decision so if you do this。 You can divide。
    Methematically so I'm a Python 3 now and if I say one divided by two。 I do get
    zero。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常大的数字，仍然在其中。所以这只有一个整数，这让你的生活更容易。这在 Python 中是一个常规过程，长整型和整型之间的区别。所以只需去掉。接下来是数学上的除法，如果你这样做。你可以进行除法。在
    Python 3 中，如果我说 1 除以 2，我确实得到了零。
- en: Five。 Yeah， so I can I divide to integers I do get。 A float。 If I don't want
    this I can do something called flow division and you do get zero。 You have to
    be careful it's flow division。 And therefore it doesn't go that's good down。 Yeah。
    so this one if you want to calculate an index you don't want to float result。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 五，是的，所以我可以将两个整数相除，我确实得到了。一个浮点数。如果我不想要这个，我可以进行一种叫做整除的操作，你会得到零。你必须小心，这是整除。因此它不会向下取整。是的。所以如果你想计算一个索引，你不想要浮点结果。
- en: Therefore you can do something like this and it will calculate。 The integer
    cutting off this decimal fraction there。 But going down。 So here's a bit different
    in Python to。 So if you have to divide something like this if I divide one by
    two I do get a zero。 I do get a zero but I can force it I can say one。 This always
    works so if I do this。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以像这样做，它会进行计算。整数会去掉这个小数部分。但向下去。所以在 Python 2 中有所不同。如果你有这样的除法，如果我将 1 除以 2，我确实得到了零。我确实得到了零，但我可以强制，我可以说
    1。这总是有效的，所以如果我这样做。
- en: I can force it if this one works already you do get。 If you want to force it
    you can do something like this if you like。 If you use one integer there but it
    still get a zero you don't get a 0。5 you would need to convert both of them first
    to。 I'm sorry。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个已经可以工作，我可以强制执行。如果你想强制执行，可以像这样做，如果你愿意的话。如果你使用一个整数，但仍然得到零，你不会得到 0.5，你需要先将它们都转换成。抱歉。
- en: My name is may of course you do get the 0。5 is one of them is a float。 That
    would work so you can do something like this。 But again there is a future in port
    and if you use a future in port here。 By the way this for future in ports can
    only be used in top of the file。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我叫 May，当然你会得到 0.5，这其中一个是浮点数。这是可行的，所以你可以像这样做。但再一次，这里有一个未来的导入，如果你在这里使用未来的导入。顺便说一下，这个未来的导入只能在文件顶部使用。
- en: In the notebook here I can do this in the middle of the notebook。 Which is a
    bit strange because。 And it changes the state and if you're actually the cell
    before it will be different but it's nice to show the effect。 So I can say from
    future in port the decision and and works and change the behavior。 You see now
    it is the same thing one divided by two and that it is your five and one。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个笔记本中，我可以在笔记本的中间做这个。这有点奇怪，因为它改变了状态，如果你实际上在它之前的单元会有所不同，但这很好地展示了效果。所以我可以说从未来导入决定，并且它会工作并改变行为。你会看到现在是一回事一除以二，那就是你的五和一。
- en: Here I do get this and of course this also。 This you。 The negative number so
    it has exactly the same behavior so from future in port the decision will solve
    it。 So you can import it and if you do this。 In Python to seven anyway then you
    don't have any problems in those surprises when you move to Python straight。 Okay。
    The next one。 Strings。 Strings is a big topic。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我得到了这个，当然还有这个。这个 u。负数，因此它具有完全相同的行为，所以从未来导入决定将解决它。所以你可以导入它，如果你这样做。在 Python
    2.7 中，无论如何，当你迁移到 Python 3 时，你不会遇到任何问题和惊讶。好的，下一个。字符串。字符串是一个大主题。
- en: And there's probably the biggest change at least in terms of implications you
    can have and you move your program。 When you have a string in Python。 To。 You
    see you have a gives a type string but this is a type string。 A bit string sorry
    and if you want to have the Unicode you have the use the you in front of it to
    make。 Make Unicode string。 Yeah。 To make it work。 Make it a unicorn string so
    you have to add the you。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是至少在隐含意义上最大的变化，当你移动你的程序时。当你在 Python 中有一个字符串时。你会看到它给出了一个类型字符串，但这是一个类型字符串。抱歉，是一个字节字符串，如果你想要
    Unicode，你需要在前面加上 u 来制作。制作 Unicode 字符串。是的。为了让它工作。使它成为一个 Unicode 字符串，所以你必须添加 u。
- en: You can actually add the beat to make it a by string which is the same。 So if
    you look at this type here。 You do have a string type whereas if you look at this
    type you do have a Unicode type。 Yeah。 So Unicode get into that got introduced
    in Python later and then get there for if you want to have a little Unicode you
    have to put you and you can you can you can type。 If you're the same thing in
    Python three it's different。 So I go back to my Python three here。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上可以添加字节使其成为字节字符串，二者是相同的。所以如果你查看这个类型。你确实有一个字符串类型，而如果你查看这个类型，你确实有一个 Unicode
    类型。是的。所以 Unicode 是在 Python 后来引入的，如果你想要小的 Unicode，你必须放 u，你可以，你可以，你可以输入。如果你在 Python
    3 中做同样的事情，那就不同了。所以我回到我的 Python 3。
- en: So type string。 Type the type of string。 It's a string so it's be careful and
    say string but it's a different string because this is Unicode default。 So if
    I put you in front of it which is possible though in Python zero zero you was
    gone and then I think it's a straight street you came back because it makes it
    much easier to at least put the you and now you get a Unicode string but it's
    called string because it's a default type。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所以类型字符串。类型字符串的类型。它是一个字符串，所以要小心并说字符串，但它是不同的字符串，因为这是 Unicode 默认值。所以如果我在前面放 u，这是可能的，虽然在
    Python 2 中 u 已经消失，然后我认为它是一个直字符串你又回来了，因为这使得至少放 u 更容易，现在你得到了一个 Unicode 字符串，但它被称为字符串，因为这是默认类型。
- en: Whereas if you use the beam or byte string then you do get byte straight。 Now
    there's no Unicode type more because anymore because now you have this。 Unicode
    as a default there's no other string just to be careful。 You have to be careful
    you have to really really careful then you work here that you do take care of
    the strict networks you can always put you and be in front of it。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 而如果你使用字节或字节字符串，那么你确实会得到字节字符串。现在没有 Unicode 类型了，因为现在你有这个。Unicode 是默认值，没有其他字符串，所以要小心。你必须非常小心，然后你在这里工作，你确实要注意严格的网络，你可以总是在前面加
    u 和 b。
- en: You can do this in Python two and Python three and to some degree that's also
    your problems。 So you have to be careful post those built in functions many functions
    except sometimes only strings not Unicode or something like this you have to be
    careful what works or doesn't work you might do some encoding。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python 2 和 Python 3 中做到这一点，在某种程度上这也是你的问题。所以你必须小心那些内置函数，许多函数有时只接受字符串而不接受
    Unicode 或其他东西，你必须小心哪些有效或无效，你可能需要一些编码。
- en: So it depends on libraries use and how they are they think about these strings。
    So these are the biggest difference and there's can be a lot of work if you use
    a lot of Unicode invites can be a lot of work converting the program from two
    to three。 So one is a encoding source code encoding。 So the source the default
    source code encoding in。 Python three is UTFA。 So if you don't say anything you
    do get a few days you can still in the beginning of the file do something like
    this。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这取决于库的使用以及他们如何看待这些字符串。因此，这些是最大的区别，如果你使用很多Unicode，转换程序从Python 2到3会有很多工作。所以一个是编码源代码的编码。因此，Python
    3中的默认源代码编码是UTF-8。如果你什么都不说，你可以在文件的开头做这样的事情。
- en: You can write coding。 Yeah。 And then you say UTF-8。 Yeah。 something like this
    and you would probably。 So this is actually the same so the fault is UTF-8 and
    you do get。 It is recommended unless you have a very strong reason to use something
    else I would recommend using this one。 Yeah， it's different。 Here it's ASCII。
    Yeah， ASCII and you do have to。 Specify UTF-8。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以写编码。是的。然后你说UTF-8。是的。像这样，你可能会发现。所以实际上这是相同的，默认是UTF-8，且你得到了。建议你使用这个，除非你有非常强的理由使用其他编码。是的，这里是不同的。这里是ASCII。是的，ASCII你必须指定UTF-8。
- en: So if you put you to a fade anyway it doesn't matter you have to。 A。 Another
    one in this direction is bytes。 The bytes in string chains bytes also changed。
    So you have the bytes data type。 Bites we are still in Python two here。 So if
    I say bytes。 I do get this spot it looks exactly like a string because bytes are
    strings。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你放置在一个fade中，无论如何都没关系，你必须。另一个方向是字节。字符串中的字节链也发生了变化。所以你有字节数据类型。我们仍然在Python
    2中。因此，如果我说字节。我会得到这个位置，它看起来就像字符串，因为字节是字符串。
- en: If I do the same thing in Python three so again back to Python three and I try
    to do bytes。 I do get bytes。 As you can see here it looks very different。 You
    do get bytes representation of bytes and you have to be careful。 What you're doing。
    The next thing is pageability and actually now we probably could go to source。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在Python 3中做同样的事情，所以再次回到Python 3，我尝试做字节。我会得到字节。如你所见，它看起来非常不同。你得到了字节的表示，你必须小心你在做什么。下一个主题是可分页性，实际上现在我们可能可以去源代码。
- en: This is source directory because I do have some of these labels as files。 A
    source you don't have to。 You might not have to type everything here。 I'm just
    not sure if I have it。 I don't have anything here。 I have some files。 The next
    topic is pageability。 Let's look in the ability。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是源目录，因为我有一些标签作为文件。在源中你不必。你可能不需要在这里输入所有内容。我只是不确定我是否有它。我在这里没有任何内容。我有一些文件。下一个主题是可分页性。让我们看看能力。
- en: For this one you write a small example here。 I have a class X。 I do write an
    inherit from object so I can copy this over to Python two。 If I have a class that
    doesn't do anything。 I do have something like this equal。 I return true。 Then
    I try to hash this thing。 If I want to hash this one I do get a narrow。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个，你写一个小示例。我有一个类X。我确实从对象继承，所以我可以把这个复制到Python 2。如果我有一个不执行任何操作的类。我有这样的等式。我返回真。那么我尝试对这个进行哈希。如果我想对这个进行哈希，我会得到一个错误。
- en: I have to also define a hash。 Special method hash is to underscore。 I just make
    up hash here。 I use the ID here as a hash。 I can do the same thing and try to
    hash it。 That's what you have to do here。 If I do the same thing and try to hash
    it。 If I do hash it。 This works。 It gives you some value in Python。 If you want
    to use your own objects as key and dictionary you might need to change something。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我还必须定义一个哈希。特殊方法哈希是双下划线。我在这里虚构了一个哈希。我使用ID作为哈希。我可以做同样的事情并尝试哈希。这就是你在这里需要做的。如果我做同样的事情并尝试哈希。如果我哈希它。这是有效的。它在Python中给你一个值。如果你想将自己的对象用作字典的键，可能需要改变一些东西。
- en: If you have a hash。 If you add things that are different。 There are a bunch
    of things changed here。 X is a statement。 You have to write X。 Now A is defined。
    There is something you can do here。 In Python 3 it changes。 If I have this here。
    I try to use X。 I do get a narrow message and it tells me already we have to add
    parentheses because it became。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个哈希。如果你添加不同的东西。这里有一堆事情发生了变化。X是一个语句。你必须写X。现在A被定义。你可以在这里做一些事情。在Python 3中它会改变。如果我在这里有这个。我尝试使用X。我会收到一个错误信息，告诉我必须添加括号，因为它变了。
- en: a function。 It's a built-in function but not a keyword anymore。 It's a key word。
    It should be bold。 If I do something like this。 If I do something like this。 If
    I do something like this。 If I do something like this。 If I do something like
    this。 If I do something like this。 If I do something like this。 If I do something
    like this。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数。这是一个内置函数，但不再是关键字。它是一个关键字。应该是粗体。如果我这样做。如果我这样做。如果我这样做。如果我这样做。如果我这样做。如果我这样做。如果我这样做。如果我这样做。
- en: If I do this in Python 2 it's a meta class。 You might not use meta classes yourself
    but you might use libraries。 You might see some problems here。 multi-class。 The
    meta-class syntax is different and I define a meta-class。 This is the same。 So
    the meta-class inherits from type mode from object。 This makes a meta-class。 So
    the meta-class， is to class what the class is to mean since so exactly the same
    thing。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在 Python 2 中这样做，这是一个元类。你可能不会自己使用元类，但你可能会使用库。你可能会在这里看到一些问题。多类。元类语法不同，我定义一个元类。这是相同的。因此，元类从对象的类型模式继承。这构成了一个元类。因此，元类与类的关系就像类与意义的关系，完全是同样的事情。
- en: the only one level higher。 So when I just overwrite this representation。 so
    when I type the class I will see something different。 So I have my representation
    and here I do get the class another self。 You can name it whatever you like but
    it makes a little sense to call this class。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一高一层。因此，当我覆盖这个表示时，当我输入类时，我会看到一些不同的东西。我有我的表示，在这里我得到另一个类。你可以随意命名，但称之为这个类是有些道理的。
- en: And I write something。 That's a new meta class and now I would like to apply
    this class and I'm in Python 2 still。 So I still need an inheritance object。 We
    come to this。 So we have to inherit an inheritance object at this place。 And then
    I can look at A and if you look at A here I do get this representation。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我写了一些东西。这是一个新的元类，现在我想应用这个类，而我仍然在 Python 2。因此，我仍然需要一个继承对象。我们来到这里。所以我们必须在这个地方继承一个继承对象。然后我可以查看
    A，如果你看看 A，这里我得到了这个表示。
- en: That's how A looks like。 Now I'll make a class B， call it B。 And now I'll provide
    the meta class and to provide the meta class I have to do something like this。
    Now if I look at B， equal sign is missing。 And if I look at B。 it looks different
    because now I overwrite the representation。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 A 的样子。现在我会创建一个类 B，叫它 B。现在我会提供元类，而要提供元类，我必须这样做。现在如果我查看 B，等号缺失了。如果我查看 B，它看起来不同，因为我现在覆盖了表示。
- en: Now this is a sign that the meta class works。 So if you don't understand that
    the meta class doesn't matter too much。 you might not use them yourself but if
    any library is with meta classes。 then you see the difference here。 So now let's
    move this to our Python 3。 So I can actually copy the whole thing。 As a book，
    the way I wanted it。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是一个元类工作的标志。所以如果你不理解元类并不太重要，你可能不会自己使用它们，但如果任何库使用了元类，那么你会看到这里的区别。现在让我们把这个转移到我们的
    Python 3。因此我实际上可以复制整个内容。作为一本书，这是我想要的方式。
- en: I thought I can export all the cells。 Yeah， let's do it step by step。 So we
    do it step by step。 So we have the meta class。 This is the same syntax。 So we
    do it step by step。 That's too defined。 So this is the same syntax or nothing
    changed that's works。 You can still copy this code directly here。 So you wouldn't
    need object but it doesn't work or it's the same thing。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我可以导出所有单元格。是的，让我们一步一步来。所以我们一步一步来。我们有元类。这是相同的语法。所以我们一步一步来。这定义得太过了。这是相同的语法，没有改变，可以直接在这里复制这段代码。所以你不需要对象，但它不起作用，或者说是同样的事情。
- en: And now if I do this one here with a meta class and I try something like this。
    That's no effect。 There's no effect as you can see here。 There's no effect whatsoever
    looks the same because you have to do something different。 So let's call this
    scene。 And I have to say meta class。 And I put my meta and I can get rid of this
    line of the put it， put it pass。 And if you see now。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我在这里做这个，有一个元类，我尝试这样的事情。没有效果。正如你所看到的，没有任何效果，看起来一样，因为你必须做一些不同的事情。所以让我们称之为场景。我必须说元类。我把我的元放进去，我可以去掉这一行，把它放进去，放它通过。如果你现在看到。
- en: you get the meta class。 So the syntax changes。 And that's a bit tricky because
    it's really hard to do something there so we'll run it later on but it makes it
    makes it easier。 So you're going to have to go in and have to change this syntax
    and it makes it more difficult to write a single source code which is something
    you can do。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到元类。因此语法发生了变化。这有点棘手，因为在那里做某事真的很难，所以我们稍后会运行它，但这确实使它变得更简单。所以你必须进去，改变这个语法，这使得编写单一源代码变得更加困难。
- en: Good。 Good。 Next one。 This is a nice one。 This is a nice super。 Yeah。 So if
    I'm in Python to。 I have a class。 Parent。 Parent。 Just an object and doesn't do
    anything just just has a method。 So I have a method。 And of course I run it inherit
    the super otherwise it doesn't make too much sense。 And I say， self。 Or something
    else return。 So this is a parent。 And now I have a child。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。好的。下一个。这是一个不错的例子。这是一个不错的super。是的。所以如果我在Python 2中。我有一个类。父类。只是一个对象，不做任何事情，只是有一个方法。所以我有一个方法。当然我运行它继承super，否则就没有太多意义。我说self。或者其他返回。所以这是一个父类。现在我有一个子类。
- en: Which inherits from parent。 And I do override。 I do override this method。 Same
    signature。 And now I call super。 And when I call super， I always have to provide
    the current class and have to provide self。 Theoretic you can write whatever you
    like but the only thing that really makes sense is this haven't seen anything
    else。 So， and now I'm。 Do this and I just say return。 So it doesn't do anything
    useful here。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这继承自父类。我确实重写了这个方法。相同的签名。现在我调用super。当我调用super时，我总是必须提供当前类，并且必须提供self。从理论上讲，你可以写任何你喜欢的，但实际上唯一合理的就是我没有见过其他东西。所以，现在我这样做，我只是说返回。所以这里没有做任何有用的事情。
- en: But you have to write the syntax to actually get。 Now it works you see you have
    to write the syntax。 You do have to write the syntax。 So again， you can copy this
    one to Python three。 And in Python three this works it still works it hasn't changed
    in this regard。 So you can still use it。 But it makes your life easier。 So I have
    to do this。 And I copy over my。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但你必须编写语法才能实现。现在它工作了，你看到你必须编写语法。你确实必须编写语法。所以再一次，你可以把这个复制到Python 3。在Python 3中它仍然有效，在这方面没有变化。所以你仍然可以使用它。但这使你的生活更容易。所以我必须这样做。我复制我的代码。
- en: And now I make a child instance。 And I call。 My method。 But you don't have to
    make it so complicated in Python three。 You can just keep super empty and it fills
    in exactly this。 That's nice if you later change the class name maybe you don't
    have to change it here。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我创建一个子类实例。我调用。我的方法。但你在Python 3中不必把它弄得如此复杂。你可以保持super为空，它会准确填充。这很好，如果你稍后更改类名，可能不必在这里更改。
- en: You don't have to change it here also。 And now I call this child to just to
    show the difference。 So if I make a child to instance。 Still box。 Okay， if I try
    this in Python。 In Python two it doesn't work out of the box if I try this one。
    Of course it makes a class but later on it does。 Give me a problem。 Yeah， so I
    do get this arrow。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里也不必改变它。现在我调用这个子类以展示区别。所以如果我实例化一个子类。仍然是盒子。好吧，如果我在Python中尝试这个。在Python 2中，它不能开箱即用，如果我尝试这个。当然它会生成一个类，但后来会出现问题。是的，我确实得到了这个错误。
- en: You see super takes at least one argument and so on。 And I'm going to use this。
    Strange error。 But。 You will see later on the other way to actually kind of backport
    this one to Python two。 It is there's no from future import here you cannot say
    in future import super。 It's not there but。 You will see that some libraries that
    can happen。 This makes it much much easier。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到super至少需要一个参数等等。我将使用这个。奇怪的错误。但是。你稍后会看到另一种方法来将这个回退到Python 2。这里没有from future
    import，你不能说在未来导入super。它不存在，但你会看到一些库可以实现。这使得事情变得更简单。
- en: Why do not put the other all the same so I would make it easier。 Okay。 one more
    thing that's you might not know the rounding。 Rounding is different。 So if I round
    something。 Yeah。 If I round。 I do get a three and if I if I round。 Three point
    five。 I do get a four。 Yeah， and if I round。 Four point five。 I do get a five。
    So the other rounds up。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不把其他的都一样，这样我会让它更简单。好吧。还有一件事你可能不知道的四舍五入。四舍五入是不同的。所以如果我四舍五入某个数。是的。如果我四舍五入。得到3，如果我四舍五入3.5。得到4。是的，如果我四舍五入4.5。得到5。所以其他的都是向上取整。
- en: In Python three， this changed。 And it changed to what's called no change round。
    So if I round here。 If I round here。 Two point five， you see now the rounds down
    and also gives me an integer by the way。 And here round。 Three point five rounds
    up to the next even number it always runs to the next even number。 So it ends
    to five。 Then it rounds to even number and therefore this rounding changed a bit。
    Yeah。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python三中，这有所改变。它改变为所谓的无变化舍入。所以如果我在这里舍入。如果我在这里舍入。二点五，你现在看到它舍入到下方，并且顺便说一下，它也给我一个整数。在这里，三点五舍入到下一个偶数，它总是舍入到下一个偶数。因此它最终舍入到五。然后它舍入到偶数，因此这个舍入有些改变。是的。
- en: so four five rounds to four。 So if you have to be careful， if you do rounding。
    So first the round says even number and as you can see here。 This one gives you
    always a float here。 It gives you an integer minute rounds。 So the rounding changed
    a bit。 And the step of it。 you might have noticed it。 Yeah， until you have something
    you don't expect。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所以四到五舍入到四。所以如果你在舍入时要小心。首先，舍入说偶数，正如你在这里看到的。这总是给你一个浮点数。它给你一个整数分钟舍入。所以舍入有些改变。你可能注意到了。是的，直到你得到一些你没有预料到的东西。
- en: So you have to be careful。 Then you use round that you might get a different
    result。 Good。 One more thing is scoping of exceptions。 So if I have an exception。
    if I do something stupid like this， as they try， one divided by zero。 Except zero
    division error。 As I can say pass。 Now I can access L later。 This rocks and I
    do get the instance。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你必须小心。当你使用舍入时，可能会得到不同的结果。好的。还有一件事是异常的作用域。所以如果我有一个异常。如果我做一些愚蠢的事情，比如说，尝试一除以零。除了零除错误。我可以说跳过。现在我可以稍后访问L。这太棒了，我确实得到了实例。
- en: If I do the same thing here。 If I do the same thing in Python three you will
    see a difference。 You will see a difference。 If I try to access L here。 It gives
    me an exception。 I can access it only here because it is only alive in this indentation。
    So inside the exception clause if you are outside errors not there。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在这里做同样的事情。如果我在Python三中做同样的事情，你会看到差异。你会看到差异。如果我在这里尝试访问L。它给我一个异常。我只能在这里访问它，因为它只在这个缩进中存在。所以在异常子句内部，如果你在外面，错误就不存在。
- en: So that's something the exception doesn't slip out anymore。 And you have to
    be careful if you want to do something。 These are important differences。 There
    are a few more things I would like to show you。 There are some new syntax。 So
    let's look at some new syntax which you don't have in Python two in which you
    can actually not read back in one way or the other。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个异常不再滑出。你必须小心，如果你想做一些事情。这些是重要的差异。我还有一些事情想给你展示。还有一些新的语法。所以让我们看看一些在Python二中没有的新语法，实际上你无法以某种方式读取回去。
- en: New syntax。 But new syntax to be have here。 The first thing is key word only
    arguments。 You can have key word only arguments。 And let's give you an example。
    I cannot join in Python two because there is no such thing。 If I have this one
    I define a function。 I define a function。 Or the function is missing。 Yeah。 Function。
    I define a function。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 新语法。但是这里有新的语法。第一件事是关键字仅参数。你可以有关键字仅参数。让我们举个例子。我无法在Python中加入两个，因为没有这样的东西。如果我有这个，我定义一个函数。我定义一个函数。或者函数缺失。是的。函数。我定义一个函数。
- en: And this function takes a A。 Then there is a star and then there is a B。 And
    this function is a B。 Now I can call this function。 This function A is one and
    B is two。 No problem。 This works。 I can also call it with A as a position argument。
    Let's see works。 But if I want to call this one with just two position arguments。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个A。然后是一个星号，然后是一个B。这个函数是一个B。现在我可以调用这个函数。这个函数A是一个，而B是二。没问题。这有效。我也可以将A作为位置参数来调用它。让我们看看效果。如果我想用两个位置参数来调用这个函数。
- en: It doesn't allow me because we have the key word。 The start has a new meaning
    here。 Actually it's starting from the start。 You have to supply。 Key word arguments。
    Key word arguments。 And this B can only supply this key word argument if not you
    can。 It makes a lot of sense。 It makes your life easier。 You can enforce key word
    arguments。 Then you write a function。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 它不允许我，因为我们有关键字。星号在这里有了新含义。实际上，它是从开始开始的。你必须提供。关键字参数。关键字参数。只有当这个B提供这个关键字参数时，你才能使用。如果不然，你就不能。这很有道理。它让你的生活更轻松。你可以强制使用关键字参数。然后你写一个函数。
- en: There is a new key word in Python 3。 And that's called non-local。 Now I have
    a function。 Auto。 And I define x equals one。 And I have a function。 You know。
    And I say x equals ten。 And I call the inner and the outer。 And I return x。 Obviously
    if you call outer now。 You get one。 You can change this behavior by now。 I have
    my outer two here。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3中有一个新的关键字。叫做非本地。现在我有一个函数。自动。定义x等于一。我有一个函数。你知道。我说x等于十。我调用内部和外部。我返回x。显然，如果你现在调用外部，你会得到一。你可以通过现在来改变这种行为。我这里有我的外部两个。
- en: And now I use this non-local key word and I make x a non-local。 And I do call
    my outer two。 And you see now I get back a ten。 Now this inner function can modify
    the x from the outer function。 It's a little bit like global。 So it looks like
    global but it's different。 Of course it doesn't actually go to the global scope。
    It only goes to the next outer scope。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我使用这个非本地关键字，并将x设置为非本地。我调用我的外部两个。你现在看到我得到了十。现在这个内部函数可以修改外部函数的x。这有点像全局变量。看起来像全局，但它是不同的。当然，它实际上并不会进入全局范围。它只进入下一个外部范围。
- en: It stays inside the def。 So it doesn't go to the global scope。 And usually this
    inner function is not going to move up a way。 Whereas functions in a module might
    move somewhere else。 And then you might use your global and it might have a problem。
    So that's why something is something you can do here。 Another nice feature we
    have here is design packing。 So you can unpack iterabits。 So if you have a list。
    If I have a list L， it looks like this。 Now I can unpack something in different
    ways。 So I could unpack and say start middle。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 它保持在def内部。所以它不会进入全局范围。通常这个内部函数不会上升。而模块中的函数可能会移动到其他地方。然后你可能会使用全局，这可能会有问题。这就是为什么在这里你可以做某些事情。我们这里还有另一个不错的功能是设计解包。你可以解包可迭代对象。如果你有一个列表。如果我有一个列表L，它看起来像这样。现在我可以以不同的方式解包一些东西。所以我可以解包并说开始中间。
- en: And you see I use a star again。 There's another useful the star。 And I unpack
    my list and now it's the start。 The end is the end in the middle。 It's everything
    but left in the middle。 And this works for all kinds of sequences。 Not only lists
    of course。 So you can have different combinations here。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到我又用了星号。这是另一个有用的星号。我解包我的列表，现在它是开始。结束是在中间的结束。它是所有的，但在中间留空。这适用于各种序列，当然不仅仅是列表。所以你可以在这里有不同的组合。
- en: You can also just have a start and rest if you like。 So if you do the same thing。
    And I copy this and you just call this rest。 And then you can collect all the
    rest right there。 Yeah， the start is still start。 And the rest contains the rest。
    So that's to go or generate iterabits。 Unpacking not only lists or to put many
    others and you can have any kind of combinations。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以开始休息，如果你喜欢的话。所以如果你做同样的事情。我复制这个，你就叫它休息。然后你可以在那儿收集所有的休息。是的，开始还是开始。休息包含休息。这就是去生成可迭代的内容。不仅仅是解包列表，也可以组合许多其他的，你可以有任何种类的组合。
- en: Good。 Another one。 Two faults。 Two and fours made it to actually none。 True。
    And false on a Python keywords are not only buildings。 Yeah。 So you can see this
    easily if I try true here or false。 Then it's a keyword。 And if I do if I try
    something。 Try something stupid like this。 It gives me an error message。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。另一个。两个错误。两个和四使它实际上没有。真的。Python关键字中的真和假不仅仅是构建。是的。所以你可以很容易地看到，如果我在这里尝试真或假。那么它是一个关键字。如果我尝试某些东西。尝试一些愚蠢的事情。它会给我一个错误信息。
- en: Now I can go back to here。 Python two。 And here I can actually。 I can actually
    say。 True zero。 And it works now true zero。 This is certainly not recommended。
    Yeah。 And therefore they changed it。 You can still do this。 Don't do it。 Don't
    do it。 You write the whole program。 But it's possible to do it。 And you can even
    choose a bit and you can even overwrite the bit in true。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以回到这里。Python 2。在这里我实际上可以。我实际上可以说。真零。现在有效，真的零。这当然不推荐。是的。因此他们改变了这一点。你仍然可以这样做。不要这样做。不要这样做。你写整个程序。但这样做是可能的。你甚至可以选择一个位，甚至可以在真中覆盖这个位。
- en: So if you look in the built in true。 It's still true。 If we now say it's true
    equal to true。 Then it gives you false because now zero。 So that will make a lot
    of sense。 Yeah。 Now they have two different trolls。 Yeah。 Yeah。 Don't do it。 In
    Python straight you cannot do this anymore。 That's gone。 Another one are list
    comprehension。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你看内置的真值，它仍然是真的。如果我们现在说真值等于真值。那么它会给你假，因为现在是零。这会让很多事情变得有意义。是的。现在他们有两个不同的“假”。是的。不要这样做。在Python中，你不能再这样做了。那已经不行了。另一个是列表推导。
- en: Which makes makes Python。 Three a bit more consistent。 So if I have。 And this
    compare。 So if I create a new list， I must say X。 For X in。 Range。 Ten。 Yeah。
    So making new list。 And you write X also works。 So if for X and X in range ten。
    Then the X leaks in the last X is right here。 If I do this。 Here。 Now try to access
    X。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 Python 3 更加一致。所以如果我有。而且这个比较。所以如果我创建一个新列表，我必须说 X。对于 X 在。范围。十。是的。所以创建新列表。而且你写
    X 也可以。所以如果对于 X 和 X 在范围十。那么最后的 X 就在这里。如果我这样做。这里。现在尝试访问 X。
- en: X is not defined。 Unless they would have defined it before。 But it wouldn't
    be behind them。 So X is not defined where X doesn't leak out anymore of this。
    Scope of the list comprehension。 So this X is confined to the list comprehension
    scope。 Which makes things much more useful。 Because you don't create a X。 By accident。
    Just using。 And。 Is comprehension。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: X 没有定义。除非他们在之前定义了它。但它不会落在他们身后。所以 X 在这里没有定义，其中 X 不再泄漏出这个。列表推导的作用域。所以这个 X 限制在列表推导的作用域内。这使事情更加有用。因为你不会意外创建一个
    X。只需使用。和。是推导。
- en: So another thing that Python three。 Is。 So I have to。 The ins in module has
    changed。 And we have some strange name to build ins。 So instead of built in。 So
    when I make this here to。 And here have to。 Okay。 So here it's called。 Yeah。 Actually。
    but still there but the module has changed。 So it's called。 In Python two it's
    called built in。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 Python 3 的另一个问题是。所以我必须。模块中的内置内容已经改变。而且我们有一些奇怪的内置名称。所以不再是内置的。所以当我在这里做这个的时候。而且这里必须。好吧。所以这里被称为。是的。实际上。但它仍然存在，但模块已改变。所以在
    Python 2 中被称为内置的。
- en: They have to be careful。 There might be some small changes。 There's a few more
    things。 And you have。 In Python three， seven， you have a sink。 You do have。 And
    you have a sink。 And you don't do any asynchronous programming here so we don't
    go into any more detail。 How this works。 But these are two new keywords that。
    Are here。 In Python three， seven。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 他们必须小心。可能会有一些小的变化。还有更多的事情。而且你有。在 Python 3.7 中，你有一个 sink。你确实有。而且你有一个 sink。而且你在这里不做任何异步编程，所以我们不再详细介绍。这是如何工作的。但这两个新关键字。出现在
    Python 3.7 中。
- en: so you have to be。 Careful。 And you have to be able to do something。 And you
    have to be able to do something。 And you have to be able to do something。 And
    you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你必须小心。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。而且你必须能够做某事。
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: And you can see some of the things that are very obvious。 You can exception。
    It's very easy to fix。 Some of the things still work。 But the result is different。
    And that's way harder。 So you have to be really careful。 But this key thing with
    the dictionary here can be a problem。 If you get an exception， then you need to
    fix it。 Otherwise your problem doesn't run。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: It runs through with them。 And stately coming out。 You need to really check
    them。 Okay。 That's an exercise。 And you have to be able to do something。 And you
    have to be able to do something。 And you have to be able to do something。 And
    you have to be able to do something。 And you have to be able to do something。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。
- en: And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 And you have to be able to do something。
    And you have to be able to do something。 Okay。 The first thing I would like to
    point out is no classic classes。 So Python 2 has something called classic classes。
    They're very old。 They're very old。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。你必须能够做某件事。好的，我想指出的第一件事是没有经典类。因此 Python
    2 有一种称为经典类的东西。它们非常古老。它们非常古老。
- en: And they should not be used。 So if you define a class， classic。 that would be
    a classic class in Python。 So we don't need to do anything。 And this would be
    what's called a new style class。 Where you inherit from objects。 So you inherit
    from object makes a new style class。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不应该被使用。所以如果你定义一个类，经典的。那在 Python 中就是经典类。所以我们不需要做任何事情。这将被称为新风格类。你从对象继承。因此从对象继承创建了一个新风格类。
- en: And now if you look at the type of these classes， it's a class object rather
    type of this new style class。 It's a type。 So don't use old style classes because
    when you have them， few things won't work。 The scriptals won't work。 Proper Stephen
    broke。 Metaclasses won't work in other things。 In Python 3。 there's no such thing
    as classic classes。 There's only a class。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你查看这些类的类型，它是一个类对象，而不是这种新风格类的类型。它是一个类型。因此不要使用旧风格类，因为当你有它们时，有些事情将无法工作。脚本将无法工作。适当的
    Stephen 会坏掉。元类在其他事情中将无法工作。在 Python 3 中，没有经典类这种东西。只有一个类。
- en: And it doesn't matter if you inherit from object or not。 So this one， let's
    call it class A。 And this would be class B， which inherits from object actually。
    So I have an object and you will see there's no difference。 See if you look at
    the type of both classes。 And then you can see the type of the class B。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否从对象继承都无所谓。那么这个我们称之为类 A。这将是类 B，实际上它从对象继承。因此我有一个对象，你会看到没有区别。如果你查看这两个类的类型，然后你可以看到类
    B 的类型。
- en: And there's no difference。 So take home messages， don't use class class anymore。
    Use new style classes。 They've been around for literally decades。 Another thing，
    no back ticks。 So Python 2 has something called back ticks。 So with back ticks
    you could do something like this。 If I define A here， I could get the value of
    A with back ticks。 So if I do this。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 没有区别。所以主要的信息是，不要再使用经典类了。使用新风格类。它们已经存在了几十年。另一个事情，不要使用反引号。因此 Python 2 有一种称为反引号的东西。用反引号你可以这样做。如果我在这里定义
    A，我可以用反引号获取 A 的值。如果我这样做。
- en: you see back ticks and they don't exist anymore。 Back to back to three。 No back
    ticks。 That's right。 So one means don't use back ticks here。 That means there
    are no back ticks。 So if I try to do the same thing and try to use back ticks，
    it doesn't work。 So that's a feature that doesn't exist anymore。 So don't use
    it。 Okay。 The next。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到反引号，它们不再存在。回到Python 3。没有反引号。没错。所以一个意味着不要在这里使用反引号。这意味着没有反引号。如果我尝试做同样的事情并尝试使用反引号，它就无效。这是一个不再存在的特性。所以不要使用它。好的，下一个。
- en: don't use old operators。 In one of the old operators you should not use。 It's
    not equal operator。 which looks like this。 So here you can do something like this。
    This works。 But better if this does exist。 This also works in Python 3。 There's
    no such thing anymore。 So you cannot use it。 Therefore better remove it in Python。
    So if I try to do something like this。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用旧的操作符。在其中一个旧操作符中你不应该使用。它不是等于操作符，看起来是这样的。所以在这里你可以做一些这样的事情。这是有效的。但如果这个存在就更好了。这在Python
    3中也有效。这样的东西不再存在。所以你不能使用它。因此在Python中最好删除它。如果我尝试做这样的事情。
- en: I get an error message， because this one works。 Simple thing， such a code changes。
    makes a code more modern。 It works better。 The next one is exceptions。 So in Python
    2。 you can write an exception like this， which looks useful， but maybe it's not。
    One divided by zero。 And then I have an accept。 And I do accept， of course， a
    zero division error。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我收到一个错误信息，因为这个有效。简单的事情，这样的代码更改使代码更现代。它运行得更好。下一个是异常。在Python 2中，你可以这样写一个异常，看起来很有用，但也许并不是。1除以0。然后我有一个接受。当然，我接受一个零除错误。
- en: But they also accept something else， like a variable。 At least I attend to。
    So now if I print。 This class here。 Then you will see the value error looks very
    strange。 And in fact the value error is not what you think。 So I have overrode
    value error here。 which is not a good idea， because actually what you actually
    wanted is this。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 但他们也接受其他东西，比如变量。至少我倾向于这样。所以现在如果我打印这个类。然后你会看到值错误看起来很奇怪。实际上，值错误并不是你想的那样。因此我在这里重写了值错误，这是个坏主意，因为你实际上想要的是这个。
- en: You wanted to have this。 Now this is an old syntax that you have an instance
    of this error。 You see now if I print now instead of this value you see that's
    what you wanted。 And this is an old syntax you can do。 Don't do this。 Use this
    syntax。 Use a S syntax which needs to be exactly the same。 And it is more modern。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要的是这个。现在这是一个旧语法，你有这个错误的实例。你看到现在如果我打印这个值，你会看到那是你想要的。这是一个你可以做到的旧语法。不要这样做。使用这个语法。使用一个需要完全相同的S语法。它更现代。
- en: So now I killed my value error， which is not good if you don't have any exception
    here anymore。 It can be very misleading if I want to use value error。 Therefore
    I just delete value error。 And then value error is back。 And now we get a built-in
    value error because I believe my total value error。 If I copy exactly this one
    to Python 3， you see it's different。 Yeah， it seems that syntax。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我解决了我的值错误，如果你这里没有任何异常，那是不好的。如果我想使用值错误，这可能会很误导。因此我只是删除值错误。然后值错误回来了。现在我们得到了一个内置的值错误，因为我相信我的总值错误。如果我把这个准确地复制到Python
    3中，你会看到它不同。是的，似乎是语法的问题。
- en: It's in the syntax you have to use the S and then use the S and then it works
    as expected。 So and you can do this in Python 2 already。 Do it。 Next one is no
    leading theorem numbers。 So no leading theorem numbers。 In Python 2 you can do
    something like this。 You can use leading theorem。 You see it's turned red already
    because my syntax I left and show something wrong。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法中你必须使用S，然后再使用S，然后它按预期工作。所以你在Python 2中已经可以做到这一点。去做。下一个是没有前导定理编号。所以没有前导定理编号。在Python
    2中你可以这样做。你可以使用前导定理。你会看到它已经变红，因为我的语法我留着，显示一些错误。
- en: It still works。 If I do the same thing in Python 3， so again something back
    to Python 3。 And then the same thing in Python 3， then I tried to write this。
    It doesn't work。 I get syntax errors。 The solution would be using zero， okay，
    so seven。 This would be an octal seven。 So if you want to write octal numbers
    for some reason， then use this syntax。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然有效。如果我在Python 3中做同样的事情，回到Python 3。然后在Python 3中做同样的事情，我尝试写这个。它无效。我得到语法错误。解决方案是使用零，好吧，所以七。这将是一个八进制的七。所以如果你出于某种原因想写八进制数字，那么使用这个语法。
- en: And this syntax already works here。 So you don't lose anything in use it。 It
    looks much better and it works in Python。 The next one is open。 The next one is
    open text files in text mode。 Open text files in text mode。 So I do have a file
    which is called whom。 So there's a file called in love。 And now I try to open。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法在这里已经有效。所以你在使用它时不会失去任何东西。它看起来更好，并且在Python中有效。下一个是open。下一个是在文本模式下打开文本文件。在文本模式下打开文本文件。所以我有一个名为whom的文件。还有一个名为in
    love的文件。现在我尝试打开。
- en: So I do it nicely with nothing。 Now you can use with open。 I try to open this
    file。 And I try to read and print its content。 So I just print the whole file
    content。 So I read the whole thing。 You see and I try this and it doesn't look
    nice。 If you do this in command line， you get an error message。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我用什么都不做得很好。现在你可以使用with open。我尝试打开这个文件。我尝试读取并打印其内容。所以我只是打印整个文件内容。我读取了全部。你看，我尝试这个，它看起来不好。如果你在命令行中这样做，你会收到错误消息。
- en: So it doesn't look nice because I didn't specify the encoding。 It just read
    it as it is。 And it's not new to F8 encoded as the minute book assumes it gets
    a new to F8 encoded string。 So I need to specify the encoding。 So if I try to
    do this， I can open this here。 And say encoding is less than one。 I know that's
    one because I made a little one。 And if I do this。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所以看起来不好，因为我没有指定编码。它只是按原样读取。而且它不是新的F8编码，因为当前书本假设它得到了新的F8编码字符串。所以我需要指定编码。所以如果我尝试这样做，我可以在这里打开。说编码小于一。我知道那是因为我做了一个小的。如果我这样做。
- en: I get an error message and tells me book。 There is no shouting as encoding from
    my opening。 So I can specify encoding。 I can specify the coding by reading。 But
    you can say import。 Import IO。 So there's an IO module。 And now I swap out the
    built in IO。 And it does not work。 So I can print my name。 And you see it works。
    And this is now very similar to doing the same thing in Python 3。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我收到一个错误消息，告诉我书本。没有从我的打开中大声喊出编码。所以我可以指定编码。我可以通过读取指定编码。但是你可以说导入。导入IO。所以有一个IO模块。现在我交换内置的IO。这是行不通的。所以我可以打印我的名字。你看这有效。这现在与在Python
    3中做同样的事情非常相似。
- en: So if I copy this， I can actually do both of them in Python 3。 And I write an
    empty lazy to type the whole thing as I copy the header also。 So you know it's
    the same topic。 And I can actually import IO。 And it works。 It works the same
    thing。 But I can also just use this one。 And drop IO because it's not an open。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我复制这个，我实际上可以在Python 3中做两者。我写了一个空的懒惰，逐字复制整个内容，因为我也复制了标题。所以你知道这是同一个话题。我实际上可以导入IO。它有效。它是同样的事情。但我也可以只用这个。然后放弃IO，因为它不是一个open。
- en: That's exactly the same。 So this works here in Python 3。 And you can still use
    IO open。 Of course in Python 2 you could just say that from IO import open and
    override the built in open。 But you have to be careful that you have to be open。
    You have to make it consistent。 So that's a good thing to do it right away。 So
    next topic。 Use next。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全一样。所以在Python 3中这有效。你仍然可以使用IO的open。当然在Python 2中你可以直接说从IO导入open并覆盖内置的open。但你必须小心，你必须打开。你需要保持一致性。所以最好立即做这个。接下来的话题。使用next。
- en: So use the built in function next instead of the method。 So if I have an iterator。
    Yeah。 In Python 2 I can say iterator。next。 And it works。 But I can also use it
    in function next。 And then it also works。 So in Python 3 there's no just thing
    as a。 Next method on the iterator therefore wouldn't work。 So if I try to do the
    same thing here。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所以使用内置函数next，而不是方法。如果我有一个迭代器。是的。在Python 2中我可以说iterator.next。它有效。但我也可以在函数next中使用它。然后它也有效。所以在Python
    3中，迭代器上没有next方法，因此无法工作。所以如果我在这里尝试做同样的事情。
- en: So I have to make it more time。 Try the same thing here in Python 3。 So I make
    my iterator。 And I try to say next。 Then it doesn't like me and tells me no there's
    no job thing。 And then if I say next I。 It works。 It works here。 And it works
    in both。 Okay。 These are the most important changes。 Other changes that you have
    to be aware of。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我必须花更多时间。在这里尝试同样的事情，用Python 3。于是我创建了我的迭代器。我尝试调用next。然后它不喜欢我，告诉我没有工作项。如果我说next，我。这就有效。这里有效，并且在两者中都有效。好的。这些是最重要的变化。你必须注意的其他变化。
- en: I would like to make it aware。 So reduce still exists。 Reduce here。 So you can
    use a bit in reduce。 This doesn't exist in Python 3。 Go back to Python 3。 Just
    to make it consistent now。 Other changes。 There's no job thing as。 As reduce if
    I try to reduce it tells me no there's no job thing。 I can import from fun tools。
    Import。 Reduce。 And then you have it。 And now you can use reduce。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: I move to fun tools。 Another thing is you could use apply。 If I have a function
    then you can use apply。 For instance。 I have a function。 Get sums。 The arguments。
    I have my arcs。 I can put my arcs in the list。 And now I could say apply。 And
    I put my function。 Instead of spelling out my arguments I just give it as a two-poo。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: And then it would work in the ads or these numbers。 I can use my style syntax。
    I can say my sum。 And I use this style here。 And I give my arcs。 And this works。
    This works in Python。 So we also took just to show。 So Python 3。 I was not just
    saying apply if I try but you can use the style syntax。 And I can use the arcs
    first。 Specify the arcs first。 And now it works。 So that's the way to do it。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Another thing is the raw input。 You do have raw input and Python。 So I can create
    a prompt which will be translated to window here。 And you see whatever I type
    into raw input。 So I type 1 plus 1 which will be written back as the string。 1
    plus 1。 As opposed to input。 Input。 If I do input。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: I look the same superficially but if I say 1 plus 1， it will evaluate my expression。
    And I get back。 That's not nice。 So if you use input， then you potentially execute
    code somebody type in your program。 You really don't want to do this。 Therefore，
    they change to the Python 3 input。 If I ask for input and I type 1 plus 1， then
    it gives me the string。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: And if I want to have the same effect， I have to write a value around it explicitly
    and。 do something like this。 And there's no raw input anymore。 It's gone。 So you
    need to change your program。 Of course you can rename these things。 You can rename
    or name raw input input and then you can do this。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Another thing is you have a reload module。 It's not too much recommended to
    use it but you can reload things at runtime。 This one doesn't exist。 It's passing
    2。 This one doesn't exist in Python 3。 If I try reload here。 reload， then it doesn't
    exist。 But you can say from import lib， import reload and there you have。 Now
    it's the same reload。 If there's a bunch of these things， they changed。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: There are some ways to work around it but you have to be a part of it。 Next
    is an exercise。 So please go to the directory for the exercises which will be，
    the extra exercises。 And there you'll find a file called old style。 It looks like
    this。 And make this file more modern。 So if everything stays Python 3， but please
    make this file more modern。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: please make this file more modern。 And keep it in。 Everything stays Python 2。
    Of course。 make it modern Python 2。 And make it modern Python 3。 Okay。 Let's have
    a look at some steps we can do here。 Some solutions。 We have our exercise。 You
    can look through the code。 It's not very interesting code but I put a few things
    in here。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请使这个文件更现代化。并保持它。所有内容都保持在 Python 2 中。当然。使其现代化为 Python 2。并使其现代化为 Python 3。好的。让我们看看我们可以在这里做的一些步骤。一些解决方案。我们有我们的练习。你可以查看代码。虽然代码不是很有趣，但我在这里放了一些东西。
- en: And you see what I did。 I can go through and I can look at some of these things。
    So you can say from future import print function。 And when you do this， you get
    an exception。 And then you have to change all the prints with parentheses and
    then， rock those print。 That's the first thing。 Another thing you can do， you
    can replace this。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你看我做了什么。我可以逐个查看这些东西。所以你可以使用 `from future import print_function`。当你这样做时，你会遇到一个异常。然后你必须把所有的打印语句改成带括号的形式，然后使用那些打印语句。这是第一件事。另一件你可以做的事情是，你可以替换这个。
- en: And all the equal times is a new and equal time。 So you just go there and replace
    it here。 This position。 That's something you can do。 The next thing you can do
    to make it more modern is from future。 import divisitions。 So you don't need to
    divide by the float。 You see up here。 I convert to a float and divide by 3。 You
    can do away with a float if you have some future import。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 所有相等的时间都是新的和相等的时间。所以你只需到那里并在这里替换。这一位置。这是你可以做的事情。接下来你可以做的事情是从 `future` 导入除法。因此你不需要使用浮点数进行除法。你在这里看到。我将其转换为浮点数并除以
    3。如果你有一些未来的导入，你可以去掉浮点数。
- en: And then you have this possibility just to do the divisitions without it。 Also
    the next one。 do this divisitions here。 So you can have this floor。 Then you don't
    have to rely on it。 It works and it's more explicit to do this。 So that's nicer。
    We'll do it。 It doesn't change the thing yet but makes it more future proof。 You
    can use list range。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你有这个可能性，可以进行除法运算而不需要它。还有下一个。这里进行除法运算。所以你可以使用这个向下取整。这样你就不必依赖它了。这样做有效，而且更加明确。所以这样更好。我们这样做。它暂时没有改变事情，但为将来做好了准备。你可以使用
    `list(range)`。
- en: You see here because I rely that range gives me a back list because I index
    it in there。 So if you put list around， it doesn't change the thing but it makes
    it future proof for later on。 The next one， you can convert the octal number to
    this。 It works and makes it future proof for Python 3。 So there's a different
    way of writing this。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到，因为我依赖于 `range` 给我一个反向列表，因为我在这里索引它。所以如果你加上 `list`，它不会改变事情，但可以为将来做准备。接下来，你可以把八进制数转换成这个。它有效，并且为
    Python 3 做了准备。所以这是一种不同的写法。
- en: You can also use this exception。 You see the exception up here。 It uses this
    old comma version which is kind of problematic because of one broken Python 3。
    So use a S to make it more explicit。 Use a modern version。 This is S here and
    then a wood broken Python 3。 Then you can also use IOPEN。 IOPEN。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用这个异常。你在这里看到的异常。它使用了旧的逗号版本，这在 Python 3 中有点问题。因此，使用 S 使其更加明确。使用现代版本。这是 S，然后是一个在
    Python 3 中损坏的情况。然后你也可以使用 `IOPEN`。`IOPEN`。
- en: And then you have to use a Unicode string。 You might even consider encoding
    if you like but if you do this here。 you import this as open and over-rided。 Then
    you need to specify the Unicode string here。 This position was otherwise。 It doesn't
    work。 You have the Unicode to put a U here which also would work in Python string。
    So these are a few things you can do here。 There's one more you see。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要使用 Unicode 字符串。如果你愿意，你甚至可以考虑编码，但如果你在这里这样做。你将其导入为 `open` 并覆盖。然后你需要在这里指定
    Unicode 字符串。这一位置是不同的。它不工作。你需要在这里放一个 U，这在 Python 字符串中也会有效。所以这些是你可以在这里做的几件事情。还有一件你可以看到。
- en: So use a next here and you can now also improve the next。 So let's do another
    step and do the next。 So you can use next instead of using this one。 So here you
    can replace the dot next。 So that's why you can go slowly through。 Whenever you
    see something like this。 you can replace it and make it more modern。 If you have
    to still broken Python 2。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这里使用 `next`，你现在也可以改进下一步。所以让我们再做一步，进行下一步。所以你可以使用 `next` 而不是使用这个。因此，在这里你可以替换
    `dot next`。所以这就是为什么你可以慢慢进行。当你看到这样的东西时。你可以替换它，使其更现代。如果你仍然在处理损坏的 Python 2。
- en: you use a new way of doing things。 That's it。 Okay， not good。 Really the next。
    So this would work now because now it's doing the next。 There's a bunch of things
    you can do and you can slowly go through the code and see if there's anything
    else you can do here。 So here， yeah， so that's okay。 And we have the decision。
    We have this one。 We have our next。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: You can use the width syntax。 So this would be another one。 Here， this is old。
    You might inherit old code like this， but you could also use width open to open
    and close。 which is always a good thing。 So that's what I'm going to do here now。
    So I say with open。 Yeah。 we use the width open thing and I just copy the code
    and get another time。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: So you can see step by step， how this goes and it just do here with open。 And
    then we even save this one line and it's going。 So step by step， you can improve
    the code。 make it more modern and this makes it easier later on to move to Python
    3。 Good。 Nothing changed。 Works in Python 2。 Make those things modern。 This is
    something if you have a little bit spare time go through and do it。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Makes your life easier later on and also makes the Python code better without
    changing anything in Python 2 and then you're ready to go into Python 3。 So， I'm
    going to go into the Python 3。 Our next topic are converting strategies。 So we'll
    have different strategies for conversion。 You can do everything on your own。 So
    you can roll your own kind of small library。 That might be useful for loading
    something for sure。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: If you have only a small project， it might be okay。 You don't have any dependencies
    and you have full control of the process。 Of course you have also full responsibility
    and you can do it quite a bit。 If it gets bigger。 it can be a lot of work and
    of course you might miss quite a few things that you don't know and it's very
    easy to make mistakes。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Another strategy would be using external libraries。 The two most prominent ones
    are six in the future。 So six has been around for quite a while and backward compatible
    with Python 2。5。 The thing is you have to modify your code and you have to put
    special function calls in there and it makes your pricing to code compatible with
    Python 3。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: So you have the single source thing but you have to modify the code。 Another
    tool is Future。 You'll find it at Python Future or and we actually can look at
    this a little bit more。 This is the interesting tool that allows you pretty much
    programming Python 3 style in Python 2。 So you can have Python 3 code more or
    less in Python 2 running。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Of course you cannot use all the latest features but a lot of things can be
    done and that's really much better。 And using this tool they are different options。
    You can start from scratch。 You develop a new library and you want to modify C2
    and C3 at the same time。 That can be something。 Or you have a Python 2 library
    and you want to move to Python 3 which is probably the most common case。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Or you have a Python 3 library that you would like to backport to make a block
    with your old Python 2 code if you needed。 All those 3 things can be done and
    you look at some examples。 So the first thing is writing your small own como tibilator。
    Small projects avoid dependencies and these are the things that you can do and
    we will use some of these things。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你有一个 Python 3 库，想要回迁以与你的旧 Python 2 代码块在一起（如果需要的话）。这三件事都可以完成，你可以查看一些示例。因此，第一件事是编写你自己的小可兼容性器。小项目避免依赖，这些都是你可以做的事情，我们会使用其中的一些。
- en: So you get rid of all these old things we just did it。 Move， make your Python
    2 new layer model。 Use all the future imports and you should have tests in place。
    You can really find buildings such as range。 You can install backports。 They are
    live backport libraries。 You can look at some of them and then you can many fix
    strings and bytes and use more than input out。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以摆脱我们刚才做的所有这些旧东西。移动，创建你的 Python 2 新层模型。使用所有未来导入，你应该有测试在位。你可以真正找到像 range
    这样的构建。你可以安装回迁库。它们是实时的回迁库。你可以查看其中一些，然后你可以修复字符串和字节，并使用更多的输入输出。
- en: So a lot of things you can do。 And this is what we just did use all the model
    tools。 The next thing I would like to show you is something about， absolute imports。
    And therefore you make a notebook。 We un-pise the tool here。 And I make a notebook。
    And we call it strategies。 There are a bunch of things I would like to show you
    and strategies with a notebook。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以做很多事情。这就是我们刚才使用所有模型工具所做的。接下来我想给你展示一些关于绝对导入的内容。因此你需要创建一个笔记本。我们在这里解压工具。我创建一个笔记本。我们称之为策略。我有很多事情想和你展示以及笔记本中的策略。
- en: So the first thing I would like to show you is absolute imports。 That's an interesting
    topic。 For this one I made a small example library。 If you go to source you will
    find the package。 So I'm looking at the package。 So this is very simple package。
    And you see we have several files in there。 It's not a really important name but
    it's in the package so it should be a different OS。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我想给你展示的第一件事是绝对导入。这是一个有趣的话题。为此我做了一个小的示例库。如果你去源代码，你会找到这个包。所以我在查看这个包。这是一个非常简单的包。你会看到我们里面有几个文件。这个名字并不是特别重要，但它在包里，所以它应该是一个不同的
    OS。
- en: And now let's have a look at how this works。 First we open some of these files
    and see how they look like。 And I go inside my package and I load these files
    and see how these files look like。 I load this file。 And then I have this file
    use。 This uses OS。 It imports OS and from this library it tries to import OS as
    my OS。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这个是如何工作的。首先我们打开这些文件中的一些，看看它们的样子。我进入我的包，加载这些文件，看看这些文件的样子。我加载这个文件。然后我有这个文件
    use。这个文件使用 OS。它导入 OS，并尝试从这个库导入 OS 作为我的 OS。
- en: And then it prints out what OS is and what my OS is。 And the third library which
    is use absolute and you look at this one。 Use OS absolute and see here I import
    from future import absolute。 Okay let's go to terminal and do this from the terminal
    because we want to do some import。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它打印出什么是 OS，什么是我的 OS。第三个库是使用绝对导入，你查看这个。使用 OS 绝对导入，看看这里我从未来导入绝对导入。好的，让我们去终端，从终端做这个，因为我们想做一些导入。
- en: '![](img/91b215d5b38cdccc024726453d81019b_10.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91b215d5b38cdccc024726453d81019b_10.png)'
- en: So it's easier you don't want to import things again and again and again。 So
    you probably do this from a terminal。 If you only import once you don't actually
    have to be a terminal。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这更简单，你不想一次又一次导入东西。因此你可能是从终端这样做的。如果你只导入一次，其实不需要使用终端。
- en: '![](img/91b215d5b38cdccc024726453d81019b_12.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91b215d5b38cdccc024726453d81019b_12.png)'
- en: You can do this from here only if you want to import several times。 So I go
    up one directory again。 I go up one directory and now I say from my package import
    use OS。 And you see when I do this I get this use OS and then I can say use OS
    dot use。 And when I do this then you see OS and my OS is the same package。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能从这里做这个，如果你想多次导入。因此我再上升一个目录。我再上升一个目录，现在我说从我的包中导入 use OS。你会看到，当我这样做时，我得到了这个
    use OS，然后我可以说 use OS.dot use。当我这样做时，你会看到 OS 和我的 OS 是同一个包。
- en: Because when I imported my OS package takes precedence over the built-in library
    OS package。 But if I do the same thing and I import this absolute import。 Now
    use the same thing。 I'll do the same thing and call this function from this one。
    Now you see my OS is still this my package OS but OS is the built-in and Python
    to seven。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因为当我导入我的 OS 包时，它优先于内置库 OS 包。但是如果我做同样的事情，导入这个绝对导入。现在使用同样的事情。我将做同样的事情并调用这个函数。现在你会看到我的
    OS 仍然是我的包中的 OS，但 OS 是内置的，Python 2.7。
- en: Build in some library OS。 So we should use this from future import absolute
    import。 This makes your code nicer and then those absolute imports work and it
    works the same in Python 3。 That's no difference。 That's always absolutely important
    on those no such all inputs。 So absolute imports is a good thing to do and then
    you do it yourself and you should do this for sure。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 内置库OS。所以我们应该使用从未来导入绝对导入。这使你的代码更美观，然后那些绝对导入可以正常工作，在Python 3中也是如此。没有区别。在这些没有这样的所有输入中，总是绝对重要的。所以绝对导入是个好主意，你一定要这样做。
- en: You have to be careful。 Unicode literals you can do something like this。 And
    say from future import Unicode literals。 And this makes if I do this here that
    should be fine。 Now all the literals are typed are actually just that types and
    text。 And now the text is a Unicode not string anymore。 And normally it would
    be a str。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须小心。Unicode字面量你可以这样做。并且说从未来导入Unicode字面量。这意味着如果我在这里这样做就没问题。现在所有的字面量实际上都是那种类型和文本。现在文本是Unicode而不是字符串了。通常它应该是一个str。
- en: You pass into by now it's Unicode and everything you type becomes Unicode without
    you。 The can cause problems if you handle things to some libraries that expect
    strings and not Unicode then you might get an error message。 So you have to be
    careful and if you want to have your strings you have to put a D in front of it
    and it should work。 Because it's not a little anymore but by the way you want
    to put a B-pad just put you if you want Unicode one。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在传入的是Unicode，所有你输入的内容都变成了Unicode。如果你将内容传递给一些期望字符串而不是Unicode的库，可能会导致问题，因此你必须小心。如果你想要字符串，必须在前面加个D，这样就可以工作了。因为这不再是一个小写字母，但如果你想要Unicode的，可以加个B-pad。
- en: So this is something you have to be careful maybe not a good idea to do this
    so you might have problems。 Then you should version testing。 You should do some
    version testing。 So if you test for the version you can get version or you can
    get version info so you use version info。 And then you have major and you should
    check major less than three。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一件你需要小心的事情，可能这样做并不是一个好主意，因此你可能会遇到问题。那么你应该进行版本测试。你应该进行一些版本测试。如果你测试版本，你可以获取版本或获取版本信息，所以你使用版本信息。然后你有主要版本，应该检查主要版本是否小于三。
- en: That's something you want to check。 Then this would also drop for Python 4 later
    on just in case Python 4 will come sooner or later。 Then you don't have to do
    changes。 If you still do version checks。 I don't know how long it takes to help
    this inside but it's a recommended way。 So do make。 You can also override build
    ins you have to be careful how to do it but it's possible。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你想要检查的内容。那么这在Python 4中也会弃用，以防Python 4早晚会出现。这样你就不需要做任何更改。如果你仍然做版本检查。我不知道帮助这方面需要多长时间，但这是推荐的方法。所以请务必这样做。你也可以覆盖内置，当然要小心怎么做，但这是可能的。
- en: I do have a small script that lets you do this so you override build ins。 So
    if you look here。 And there's two ways of doing it。 You can do it explicitly first。
    So you can do something like this。 I have import a bunch of things like from it
    all tools。 I put it all tools and then I go and check if the major version is
    less than three。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个小脚本可以让你这样做，所以你可以覆盖内置。所以如果你看这里，有两种做法。你可以先显式地这样做。所以你可以做类似这样的事情。我导入了一堆东西，比如从所有工具中导入。我放入所有工具，然后检查主要版本是否小于三。
- en: I replace the name space here。 You see and I replace filter with input with
    raw input。 You can use it。 Now I have this new explicit。 You import your script。
    The only thing you need to do is import your script。 You do the future imports。
    You import your script。 And then you say override build ins you hand in the global
    namespace。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里替换了命名空间。你看，我把过滤器替换成了输入，使用原始输入。你可以使用它。现在我有了这个新的显式。你导入你的脚本。你需要做的唯一事情就是导入你的脚本。你做未来的导入。你导入你的脚本。然后你说覆盖内置，你交给全局命名空间。
- en: This will change the global namespace。 When you do this and you execute it you
    will see。 Now the zip is equal to the changes x range and the open is i。 That's
    something you can do。 You have to call this here and hand in the global namespace。
    You can also do it implicitly。 So override it。 You can now take advantage of the
    fact of this。 I define this all which is a list。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这将改变全局命名空间。当你这样做并执行时，你会看到。现在zip等于更改的x范围，open等于i。这是你可以做到的。你需要在这里调用这个，并交给全局命名空间。你也可以隐式地这样做。所以覆盖它。你现在可以利用这一点。我定义了这个所有的内容，这是一个列表。
- en: I fill this list only if my version is less than three。 I just define all these
    things and import these things。 I export all these things I would like to export
    here in my name space。 It's easy to use it。 You just have to import it and now
    you have to do a star import。 You have to use star import。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在我的版本低于3时，我才填充这个列表。我只定义所有这些内容并导入它们。我导出所有我希望在我的命名空间中导出的东西。使用起来很简单。你只需导入它，现在你必须进行星号导入。你必须使用星号导入。
- en: You have to use star import everything that's in all and then it will replace。
    It's pretty hefty。 You're changing quite a bit of build ins。 You overwrite them
    in your global namespace here。 You have to be comfortable with this but at least
    you can do something。 In addition there's a bunch of standard library back ports。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须使用星号导入所有在所有中的内容，然后它将被替换。这是相当大的改动。你改变了相当多的内置项。你在你的全局命名空间中覆盖它们。你必须对此感到舒适，但至少你可以做一些事情。此外，还有一堆标准库的回退库。
- en: The last thing I would like to show you is back ports。 There's a bunch of back
    ports。 For instance there's a font tool back ports where you can have a new cache。
    In Python 3 we do have a new cache。 I don't have it here。 In Python 3 I make a
    new notebook。 Not to follow this notebook here。 In Python I can say from font
    tools。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我想向你展示的最后一件事是回退库。有很多回退库。例如，有一个字体工具的回退库，你可以拥有一个新的缓存。在Python 3中我们确实有一个新的缓存。我在这里没有它。在Python
    3中我创建了一个新的笔记本。不用遵循这里的这个笔记本。在Python中，我可以说从字体工具。
- en: In Python 3 I can use a new cache。 In Python 2 this does not work。 If you try
    to do this it does not work but you can actually install back ports。 If you do
    this then it will work。 Take the tool， hit or something else and install the back
    ports package。 Then you will get the back ports font tools that are a new cache。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3中我可以使用一个新的缓存。在Python 2中这是不工作的。如果你尝试这样做，它不起作用，但你实际上可以安装回退库。如果你这样做，它就会工作。拿工具，点击或其他东西，安装回退库包。然后你会得到回退库的字体工具，这是一个新的缓存。
- en: So there's a bunch of these back ports。 You can search the Python package for
    them and you will find back ports for a bunch of these new libraries。 Next is
    the exercise。 If you could use a PDF you will find the exercise。 The exercise
    is to convert the Python files manually。 The old style of them from Python 2 to
    Python 3 and using this compatibility layer。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 所以有很多这些回退库。你可以在Python包中搜索它们，你会发现一堆新库的回退库。接下来是练习。如果你能使用PDF，你会找到练习。练习是手动转换Python文件。将它们从Python
    2的旧样式转换为Python 3，并使用这个兼容层。
- en: You can use this layer and convert the manually from Python 2 to Python 3。 Let's
    look at the exercises。 If you need to import this override explicit over our buildings。
    You have to do the future import because I cannot put it there。 You have to put
    it in the module and then you set it。 There's one more thing。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个层，将Python 2手动转换为Python 3。让我们看看练习。如果你需要导入这个覆盖，我们的构建就显式了。你必须进行未来导入，因为我不能放在那里。你必须把它放在模块里，然后设置它。还有一件事。
- en: If you run it you will see you have to fix a print。 Once you do it then you
    get a program that is compatible with work。 You can run it in Python 2 and run
    it in Python 3。 You should work with both of these ones。 No problem。 You can work
    with both of those。 You can use the program to open both of those。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行它，你会看到你需要修复一个打印语句。一旦你这样做了，你就得到了一个兼容的程序。你可以在Python 2中运行它，也可以在Python 3中运行它。你应该同时使用这两个版本。没问题。你可以同时使用这两个。你可以用这个程序打开这两个。
- en: This would be easy。 You have to do it in every file。 The old looks the same。
    If you do the same thing， load old style explicit。 You see I have to do exactly
    the same。 In addition， I have to make this for Unicode。 In addition， I have to
    make this for Unicode。 The rest is the same。 Copy this stuff on the top of the
    file。 Set the global and delegate。 Implicit。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这会很简单。你必须在每个文件中这样做。旧的看起来是一样的。如果你做同样的事情，明确加载旧样式。你会看到我必须做完全相同的事情。此外，我还必须为Unicode做这个。其余的都是一样的。把这些东西复制到文件顶部。设置全局和委托。隐式。
- en: similar， not very difficult。 If you work here， manual， implicit。 If you look
    at this copy and top fix a print。 Now it's a bit less。 You just have to do the
    import here。 You can do this。 You don't need to do it on the other one。 Then you
    should be able to run it。 Once you get it， you have the same。 Same output。 Okay。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 类似，不是很难。如果你在这里工作，手动，隐式。如果你查看这个副本并在顶部修复打印语句。现在简单一些。你只需要在这里进行导入。你可以做到这一点。你不需要在另一个地方这样做。然后你应该能够运行它。一旦你得到了，就会是相同的。相同的输出。好的。
- en: Old implicit is also old style implicit。 Same thing。 You have to copy this on
    top。 Do the same steps。 Then you have to make this for Unicode。 If you run your
    own or your own。 you can do something like this。 I don't recommend it。 It's more
    like an exercise to see what's possible。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的隐式方式也是旧风格的隐式方式。一样的道理。你必须将这个复制到顶部。按同样的步骤进行。然后你需要为 Unicode 做这个。如果你运行你自己的代码，你可以这样做。我不推荐这样做。这更像是一个练习，看看什么是可能的。
- en: You should use a library and that's what we're going to do next。 Next。 we want
    to start from scratch。 I make a new file。 You can use a new notebook and rename
    it。 This is something you want to develop a new library and make it work with
    Python 2 and Python 3 for some reason because you still have to hold Python projects。
    You want to support this library。 Then you can do this。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用一个库，这就是我们接下来要做的。接下来。我们想从头开始。我创建一个新文件。你可以使用一个新的笔记本并重命名。这是你想开发一个新的库，并让它在某些原因下兼容
    Python 2 和 Python 3，因为你仍然需要维护 Python 项目。你想支持这个库。然后你可以这样做。
- en: I wouldn't recommend it too much but you can do it here。 I just show you what
    you need to do there。 Let's go to the PDF and go through。 We don't have to do
    much here。 You might need this。 You can use future。 We will look at future in
    a minute。 Then you just need to add this code in the beginning。 You can install
    future。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会过于推荐，但你可以在这里做到。我只是告诉你在那儿需要做什么。让我们去看 PDF，然后逐步讲解。我们在这里不需要做太多。你可能需要这个。你可以使用
    future。我们过一会儿再看看 future。然后你只需在开头添加这段代码。你可以安装 future。
- en: Once you install future， you add this code in the beginning and then that's
    pretty much it。 You can write Python 3 code and you don't use any new Python 3
    syntax。 That's something you can do。 You should create two environments。 We did
    this already and now we need to install future。 I'll show you how to install future。
    Of course， we installed it in both Python 2 and Python 3。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了 future，你就在开头添加这段代码，然后差不多就是这样。你可以编写 Python 3 代码，而不使用任何新的 Python 3 语法。这是你可以做到的。你应该创建两个环境。我们已经做过这个，现在我们需要安装
    future。我会告诉你如何安装 future。当然，我们在 Python 2 和 Python 3 中都安装了它。
- en: We can make it work here。 We can do a terminal in Python 2 and then install
    future。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里使它工作。我们可以在 Python 2 中使用终端，然后安装 future。
- en: '![](img/91b215d5b38cdccc024726453d81019b_14.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91b215d5b38cdccc024726453d81019b_14.png)'
- en: This is the future。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是未来。
- en: '![](img/91b215d5b38cdccc024726453d81019b_16.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91b215d5b38cdccc024726453d81019b_16.png)'
- en: In the mean bind， I can do the same thing in Python 3。 I also go to the terminal
    and I can store a new terminal。 Maybe it's just a bit so crowded。 Maybe the terminal。
    Yeah， I'll install future。 It takes a bit and then it's a future。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我可以在 Python 3 中做同样的事情。我也可以去终端，然后可以打开一个新的终端。也许只是有点拥挤。也许是终端。是的，我要安装 future。这需要一点时间，然后它就是
    future。
- en: '![](img/91b215d5b38cdccc024726453d81019b_18.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91b215d5b38cdccc024726453d81019b_18.png)'
- en: Of course， you can also store this as pip。 That would be a problem。 It takes
    a bit and once you install it， you can use the future library。 Yeah。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以将其存储为 pip。这将是一个问题。这需要一点时间，一旦你安装了它，你就可以使用 future 库。是的。
- en: '![](img/91b215d5b38cdccc024726453d81019b_20.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91b215d5b38cdccc024726453d81019b_20.png)'
- en: Okay， now we have installed future and then you can actually use future and
    apply it。 These are here。 You just have to import this one。 Then you keep programming。
    Then you should be able to develop a library that's Python 2 and Python 3。 If
    you take care of a few things。 We don't want to focus on this one。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经安装了 future，你实际上可以使用 future 并应用它。这些在这里。你只需导入这个。然后继续编程。你应该能够开发一个兼容 Python
    2 和 Python 3 的库。如果你处理好几个方面。我们不想专注于这一点。
- en: We want to focus actually starting from Python 2 and migrating to Python 3。
    That's what the title of the tutorial is。 So， book。 And then we start in the fun
    story。 So。 it's falling from two。 So， now I have a few examples of this source
    code。 And then we have very。 very easy one。 And we would like to control this
    one to two。 So， I load this file。 I load this file。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上想从 Python 2 开始，并迁移到 Python 3。这就是教程的标题。所以，书本。然后我们开始有趣的故事。所以，它从二开始。因此，现在我有几个这个源代码的例子。然后我们有非常非常简单的一个。我们想控制这个一到二。因此，我加载这个文件。我加载这个文件。
- en: So， it's very， very easy file。 So， we only do it with a very easy example。 So。
    that's not a real world。 It's artificial small example， but we learn how to use
    it。 We learn how to use it。 So， you have a file that uses string I/O， makes a
    string I/O object。 and this is next here and prints are done。 That's all。 That's
    what it's doing。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这个文件非常非常简单。所以，我们只用一个非常简单的例子来做。所以，这不是一个真实的世界。这是一个人工的小例子，但我们学习如何使用它。我们学习如何使用它。所以，你有一个使用字符串
    I/O 的文件，创建一个字符串 I/O 对象。这是下一个，并打印完成。这就是全部。这就是它所做的。
- en: But that's a Python 2 file。 Actually， it's not going to work。 I'm in Python
    3， I guess here。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这是一个 Python 2 文件。实际上，它将无法工作。我想我在 Python 3 里。
- en: '![](img/91b215d5b38cdccc024726453d81019b_22.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91b215d5b38cdccc024726453d81019b_22.png)'
- en: So， that's not really good。 Therefore， I have to go here and make a new notebook
    here。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这并不是很好。因此，我必须在这里创建一个新的笔记本。
- en: '![](img/91b215d5b38cdccc024726453d81019b_24.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91b215d5b38cdccc024726453d81019b_24.png)'
- en: And do the same thing here to show you that it works。 So， I can rename it and
    save it directly。 So。 I go to the source and I load this file。 I go to the source
    and load this file。 And I can execute here because it's Python 2。 It runs and
    you see it prints done。 Now。 I would like to convert it and I can convert it in
    the console。 So， I go to the console。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 并在这里做同样的事情，向你展示它有效。所以，我可以重命名并直接保存它。所以，我去源文件，加载这个文件。我去源文件，加载这个文件。我可以在这里执行，因为它是
    Python 2。它运行，你看到打印完成。现在。我想转换它，我可以在控制台中转换。所以，我去控制台。
- en: I just add here。 It doesn't really matter which one。 So， I go to the console
    and I。 I go to the same directory。 Source， 3。 And now， I would like to use feature
    rights to translate this file from Python to the Python。 3。 So， if you type "future
    rights"， you get the help but it's surprised。 You see that it has a lot of options。
    This is a program that comes with future and has a lot of options。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里添加，它实际上无关紧要是哪一个。所以，我去控制台，我去同一个目录。源，3。现在，我想使用未来权利来将这个文件从 Python 转换为 Python
    3。所以，如果你输入“未来权利”，你会得到帮助，但它很惊讶。你会看到它有很多选项。这是一个附带未来的程序，有很多选项。
- en: And I use future rights。 Now， there's a bunch of options to convert。 So。 I use
    the option list fixes。 Of course， I want to see something。 I use the list one
    list fixes。 I want to see the fixes。 I want to specify a new output directory
    because I don't want to override my file。 I want to reuse it。 You can use no backups。
    Otherwise， it makes a file。bak。 Generates a backup file。
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用未来权利。现在，有很多选项可以转换。所以，我使用选项列表修复。当然，我想看看一些内容。我使用列表一的列表修复。我想查看修复。我想指定一个新的输出目录，因为我不想覆盖我的文件。我想重用它。你可以选择不备份。否则，它会生成一个文件.bak。生成一个备份文件。
- en: It would be other strategy if you move it a different directory。 That should
    be fine。 So。 I don't have to do this。 And also， I say write the modified file
    back。 I do all these as you modified。 So， I use L and W。 And I specify an output。
    And now。 I would like to move it into directory stage one。 So， stage one。 This
    directory， they're ready。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将其移动到不同的目录，那将是另一种策略。这样应该没问题。所以，我不需要这样做。此外，我说将修改后的文件写回去。我做所有这些就像你修改的一样。所以，我使用
    L 和 W。我指定一个输出。现在，我想将它移动到目录阶段一。所以，阶段一。这个目录，他们准备好了。
- en: And I want to move my file by center。 So， and if I do this， it tells me what
    it's doing。 Yeah。 so I have， I use the list option， which gives me a long output
    here。 And you see now。 it tells me what it did。 So， it lists all over。 I know，
    it's not the L， sorry。 You don't want to list it。 It's a one。 You want to have
    stage one changes。 Stage one changes。 No。
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我想通过中心移动我的文件。所以，如果我这样做，它会告诉我它在做什么。是的，所以我使用了列表选项，这给了我一个很长的输出。你现在看到，它告诉我它做了什么。所以，它列出了所有内容。我知道，不是
    L，抱歉。你不想列出它。是一个。你想有阶段一的变化。阶段一变化。不。
- en: the list changes。 So， stage one because I'm different stages。 Now， I have a
    stage one change。 And you see， it's going to hit。 So， let's look at this one and
    a two。 Yeah， so， stage two。 People with stage one modernized Python only。 Yeah，
    no comment with this Python three。 This would be make a still Python two， develop
    Python two。 But you get the word of all the features。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表发生了变化。所以，阶段一，因为我有不同的阶段。现在，我有一个阶段一的变化。你看，它将会影响。所以，让我们看看这个和那个。是的，所以，阶段二。只有阶段一现代化的
    Python。是的，关于这个 Python 3 没有评论。这将仍然是 Python 2，开发 Python 2。但你可以获取所有特性的词。
- en: And then you can have stage two。 And then stage two actually gets you new Python
    three。 and you can also do both stages。 So， we did stage one first。 So， I run
    stage one。 I run stage one。 And you see it。 It tells you what it did。 So， it shows
    you a diff。 And if you look in the file。 you'll see the diff。 So， it changed the
    next， the dot next to the next。 So。
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以有阶段二。然后阶段二实际上给你带来了新的 Python 3。你也可以同时执行两个阶段。所以，我们先做了阶段一。所以，我运行阶段一。我运行阶段一。你看到它。它告诉你它做了什么。所以，它显示了一个差异。如果你查看文件，你会看到这个差异。所以，它改变了下一个，点下一个旁边的内容。所以。
- en: one of these things we did manually。 So， it's good to do it manually。 First。
    you know what it's doing。 We did manually。 So， it moved the method dot next to
    the built-in function next。 The rest state the same。 No。 It also added the print
    function here。 And it saved from future import print function。 So， if you look
    at the file。 Yeah。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们手动做的这些事情之一。所以，手动做是好的。首先。你知道它在做什么。我们是手动做的。所以，它将方法点移到内置函数下一个。其余的保持不变。不。它还在这里添加了打印功能。并且它保存了来自未来导入打印功能。所以，如果你查看文件。是的。
- en: You see now it looks like this and this is added here。 So， I had a comment in
    there。 So。 the comment should be in top。 But it doesn't look because the， the，
    the， the， the， the， the。 from future import has to be the very top thing anyway。
    So。 you put it in top and then the rest is changing。 So， this is something you
    can do。
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在看到它看起来像这样，这里添加了这个。所以，我在里面有一个评论。所以，评论应该在顶部。但是它看起来并不是这样，因为，来自未来导入的内容必须在最顶部。无论如何。所以，你把它放在顶部，然后其余的部分进行更改。所以，这是你可以做的事情。
- en: And this might be helpful。 If you do this， it should still run in Python 27。
    And then you can convert a code step by step to Python 27。 This is too weak to
    do it by hand。 Good。 Now， you did step one， stage one。 Now we can do the same
    thing for stage two。 So， we use again。 future rice。 Future rice， stage two。 The
    same options。 So， if you don't want to back up。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会很有帮助。如果你这样做，它应该仍然可以在 Python 2.7 中运行。然后你可以一步一步地将代码转换为 Python 2.7。这手动操作太弱了。好。现在，你完成了一步，一阶段一。现在我们可以对阶段二做同样的事情。所以，我们再次使用未来的
    rice。未来的 rice，阶段二。相同的选项。所以，如果你不想备份。
- en: so you don't know right because we， specify an output， an output directory，
    which is a stage two。 And we take the one from stage one。 And we convert it to
    stage two。 And it's doing it and tells us what it did。 You see it does now a few
    more things。 It removes string IO and imports the future standard library。 And
    makes a new standard library。 So。
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你不知道，对吧，因为我们指定了一个输出，一个输出目录，这是一阶段二。我们从阶段一获取那个。然后我们把它转换为阶段二。它正在执行这个操作并告诉我们它做了什么。你看到它现在做了一些更多的事情。它移除了字符串
    IO，并导入了未来标准库。并创建了一个新的标准库。所以。
- en: some of every names。 It imports the build in next。 It was an access different。
    It has a small changes。 So， they've actually haven't talked about it。 There are
    some changes to next also。 And it imports IO。 And because it's used now a string
    IO instead of IO。 The name of the module is different。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一些每个名称。它导入了内置的下一个。它有一个不同的访问。它有一些小的变化。所以，他们实际上没有谈论过。下一个也有一些变化。而且它导入了 IO。因为现在使用的是字符串
    IO 而不是 IO。模块的名称不同。
- en: It has not capitalized string IO， but IO。 And it's there。 And now it works。
    And this now。 if you run this code， it should work with Python two。 And Python
    three， like。 You can try this。 So。 if you go here。 And I go to converted stage
    two。 And actually I try to run。 I can run it。 I can load it。 Just see if it's
    loaded。 It also should work when you load this thing。 And。 Yeah， so。
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有大写字符串 IO，而是 IO。并且在那儿。现在它可以工作。如果你运行这段代码，它应该可以在 Python 2 和 Python 3 中工作。你可以试一下。所以。如果你去这里。我去转换的阶段二。实际上我尝试运行。我可以运行它。我可以加载它。看看它是否已加载。当你加载这个东西时，它也应该可以工作。而且。是的，所以。
- en: as you said， cool。 So， if it's now loaded and if I run this， it should now work
    in Python three。 And it does。 And if it is the same thing， it still runs in Python
    two。 And the。 Everything is now pretty much the same as in Python three。 And it's
    not the same thing。 And it's not the same thing。 And it's not the same thing。
    And it's not the same thing。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所说，酷。所以，如果现在已经加载，并且我运行这个，它现在应该可以在 Python 3 中工作。确实可以。如果它是同样的东西，它在 Python 2
    中仍然可以运行。而且。现在一切几乎和 Python 3 一样。并且它不是同样的东西。并且它不是同样的东西。并且它不是同样的东西。并且它不是同样的东西。
- en: And it's not the same thing。 And it's not the same thing。 And it's not the same
    thing。 And it's not the same thing。 And it's not the same thing。 And it's not
    the same thing。 And it's not the same thing。 And it's not the same thing。 And
    it's not the same thing。 And it's not the same thing。 And it's not the same thing。
    And it's not the same thing。
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: And it's not the same thing。 And it's not the same thing。 And it's not the same
    thing。 And it's not the same thing。 And it's not the same thing。 And it's not
    the same thing。 And it's not the same thing。 And it's not the same thing。 And
    it's not the same thing。 And it's not the same thing。 And it's not the same thing。
    And it's not the same thing。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: And it's not the same thing。 And it's not the same thing。 And it's not the same
    thing。 And it's not the same thing。 And it's not the same thing。 And it's not
    the same thing。 And it's not the same thing。 And it's not the same thing。 And
    it's not the same thing。 And it's not the same thing。 And it's not the same thing。
    And it's not the same thing。
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: And it's not the same thing。 And it's not the same thing。 And it's not the same
    thing。 And it's not the same thing。 And it's not the same thing。 And it's not
    the same thing。 And it's not the same thing。 And it's not the same thing。 And
    it's not the same thing。 And it's not the same thing。 And it's not the same thing。
    And it's not the same thing。
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: And it's not the same thing。 And it's not the same thing。 And it's not the same
    thing。 And it's not the same thing。 And it's not the same thing。 And it's not
    the same thing。 And it's not the same thing。 And it's not the same thing。 And
    it's not the same thing。 And it's not the same thing。 And it's not the same thing。
    And it's not the same thing。
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: And it's not the same thing。 And it's not the same thing。 And it's not the same
    thing。 And it's not the same thing。 And it's not the same thing。 And it's not
    the same thing。 And it's not the same thing。 And it's not the same thing。 And
    it's not the same thing。 And it's not the same thing。 And it's not the same thing。
    And it's not the same thing。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: And it's not the same thing。 And it's not the same thing。 And it's not the same
    thing。 And it's not the same thing。 And it's not the same thing。 And it's not
    the same thing。 And it's not the same thing。 And it's not the same thing。 And
    it's not the same thing。 And it's not the same thing。 And it's not the same thing。
    And it's not the same thing。
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: And it's not the same thing。 And it's not the same thing。 And it's not the same
    thing。 And it's not the same thing。 And it's not the same thing。 And it's not
    the same thing。 And it's not the same thing。 And it's not the same thing。 And
    it's not the same thing。 And it's not the same thing。 And it's not the same thing。
    And it's not the same thing。
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: And it's not the same thing。 And it's not the same thing。 And it's not the same
    thing。 And it's not the same thing。 And it's not the same thing。 And it's not
    the same thing。 And it's not the same thing。 And it's not the same thing。 And
    it's not the same thing。 And it's not the same thing。 And it's not the same thing。
    And it's not the same thing。
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: And it's not the same thing。 And it's not the same thing。 And it's not the same
    thing。 And it's not the same thing。 And it's not the same thing。 And it's not
    the same thing。 And it's not the same thing。 And it's not the same thing。 And
    it's not the same thing。 And it's not the same thing。 And it's not the same thing。
    And it's not the same thing。
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: And it's not the same thing。 And it's not the same thing。 And it's not the same
    thing。 And it's not the same thing。 And it's not the same thing。 And it's not
    the same thing。 And it's not the same thing。 And it's not the same thing。 And
    it's not the same thing。 And it's not the same thing。 And it's not the same thing。
    And it's not the same thing。
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: And it's not the same thing。 And it's not the same thing。 And it's not the same
    thing。 And it's not the same thing。 And it's not the same thing。 And it's not
    the same thing。 And it's not the same thing。 And it's not the same thing。 And
    it's not the same thing。 And it's not the same thing。 And it's not the same thing。
    And it's not the same thing。
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: And it's not the same thing。 And it's not the same thing。 And it's not the same
    thing。 And it's not the same thing。 And it's not the same thing。 And it's not
    the same thing。 And it's not the same thing。 And it's not the same thing。 And
    it's not the same thing。 And it's not the same thing。 And it's not the same thing。
    And it's not the same thing。
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: And it's not the same thing。 And it's not the same thing。 And it's not the same
    thing。 And it's not the same thing。 And it's not the same thing。 And you specify
    what's fixed in one fixes。 Fix next。 So this will only fix next。 And then I specify
    my true sample。 File。 And then just fixes this own thing。 Yeah。 So it doesn't
    need to be modified。 By。
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Probably I'm in the wrong directory。 Yeah， so I have to check。 Add the price
    sample。 I must have fixed it in place。 It tells me it doesn't need nothing to
    be modified。 Because it's obviously modified already。 Yeah。 Yeah。 There's a modified
    already。 This is a modified file。 I must have over it in this modified file。 At
    this place。
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: But we still have。 We still have it。 We still have this original file。 And now
    I can save this one。 And save this file。 And I can save this one。 So I have to
    save this。 So 12。 Okay。 I have this now a safe cell 12 in the new file。 And then
    if I do this same thing with this file。 That's what happens if you。 Yeah， I do
    pie。 It looks like this。 Okay。 And now I can use future rice。
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: And I use my pie too。 And then it tells you what it did。 And then。 Yeah。 It
    tells you it has to change only the next。 It doesn't leave the other things alone。
    So you can go fix by fix if you like。 And there's many fixes。 You can go through
    all these fixes。 That's possible。 Or you can fix stage one， stage two。 And then
    stage one is just。
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: All the things to make pricing to seven more modern。 And then。 Stage two actually
    make it prices free。 Compose。 Good。 Of course if you do this。 you see it's still
    important to have tests in place。 You should have your source could cover this
    test。 Otherwise you might see it in between some problems。 And those tools are
    not perfect。 You have to have core environments。 I did this contact here that
    you can work with Python tool and Python three。 and test things。 Of course。 You
    can go through control of things that you can。 We do undo things later on。 And
    you can go fix by steps or go stage by。
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: So these are the strategies you can apply。 And what works for you。 If you want
    to do all files in one or just one file at a time。 They're different ways of doing
    it。 Okay。 Let's do an exercise。 So。 If you go to the PDF， you will find an exercise。
    And。 So use use rise and convert。 Is files manual and old style step by step。
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: So we use two stages approaches。 Apply stage on first and then the next one。
    Then also apply both stages and check if it works。 And if there's any needs。 just
    we need to edit later by hand。 It's anything missing。 Okay。 Let's have a look
    at the solutions。 So solutions are very easy。 You have to use future rights and
    you just need to use the。
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: These commands。 So the future rights command for。 Stage one would be minus one
    switch to your eyes command for stage two is minus two。 And future is proposed
    stage is zero。 So if you do this and you just apply it。 To those files， then。
    It works in your specify。 Specify the data。 So if I do this， I just。 Goes this
    here and it goes to the terminal。 And。 I need to go to the。 Direct rate。
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: And then just copy the files over and you can apply。 Yeah， so。 I have my。 File
    here。 And it just need to futureize my。 After good exercise first， correct。 So
    in exercises you have exercises files and you can do this directly。 Yeah。 And
    you might want to。 Create this。 Directory first， so if you try this one。 Yeah。
    It created a directory， obviously。
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: So now you can go inside to directory and you can have your memory。 And it creates
    it。 Now it created the value file in stage one。 As you can see here by applying
    this command。 And you see what it's did。 Yeah， it changed it。 It changed the print。
    And it did print from future。 And now of course you can do the same thing。 For
    stage two。 So this menu for the open。
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: You can also do this。 Yeah， stage two。 And apply it to。 And then you go and
    then you have your stage。 Stage two， and of course you have to say。 Specify stage
    one。 And you did take the bond。 And you can do it to stage two。 And the addition。
    Now convert your keys to a list for instance。 And there's a bunch of other effects。
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: You can do the same thing。 For this old。 Style file。 Yeah。 and then it's controlling
    it to stage one。 And it will tell you what it did。 So the print is mounting。 And
    also it does a next。 And it gets rid of the。 Unequal sign here and there's also
    doing the。 Change of。 The option number。 So everything we did。
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: By hand before。 It was doing it for you and even more because it knows more
    about it。 And has more fixes。 It has more fixes than we have here。 And because
    there's a lot of small corner case things。 You might not think about it and that
    it changed。 That's the way to go。 Use futurize apply。
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: It's always good to know what you're doing。 That's why it's really helpful to
    have a basic understanding of the main changes。 And there are more than 50 different
    fixes。 So read up on the fixes。 But they actually need。 Okay。 so we moved our
    code from Python to to Pisces three。 There's yet another way you have Pisces three
    code and you might want to make the city of Pisces three library available。
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Pison to we can。 Actually start from Pisces three。 That's that's going to work。
    So I made a new notebook and we say from starting from Pisces three。 That's maybe
    not that common but not。 Impossible。 That's why I show you how to do it。 Starting
    from three。 So we have a very simple。 Very simple file。
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: There's into file and this is simply fine。 You would like to convert。 Oh， it's
    kept me in this。 So we should。 We go to this source directory again and then we
    have a file。 Which is very。 very simple。 It is a。 Pi three。 Yeah。 So actually
    that's that's one。 I started this so the Pisces three sample looks like this。
    And this is just very。
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: very simple file and Pisces three。 And now I want to show you there's another
    tool called pasteurize and this pasteurize file。 It's actually doing something
    with this file。 It's converting it in a way that it also runs the same in Pisces
    three。 So let's have a look how this works。 What you need to do。 So I。 Miss pasteurize。
    First。 I go to the terminal。 Yeah， I do this is a terminal and I go up one directory
    and I copy my。
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Pi three sample start。 It was a good in place to。 Pi three sample。 Oh， good。
    So I now I can use。 The pasteurize command。 Which is adding all kinds of stuff
    and I use write。 So it writes it directly in there and I say， Pisces three sample。
    Dot D。Y。 And now it tells you what it's doing。 So it adds a bunch of stuff。
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: it runs a lot of from future import statements。 It imports a bit in sip and
    it ports the range。 the sound library and so on。 It seems quite a bit， but you
    don't have to do it yourself。 And now when you run the program， it does exactly
    the same in Pisces two as in Pisces three。 Yeah。 so pasteurize is adding all the
    things。 You can do it yourself。
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: but this one will only add the needed changes。 Yeah， so it only imports it if
    you need it。 if you don't need simply one important。 Yeah， and so kind of things。
    So this one can be useful。 Maybe not the common case， the common case is moving
    from two to three。 But here you can also move from three to two if you need to。
    So this concludes this tutorial。
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: I hope you learned something。 So we covered quite a few things here。 So we looked
    at the look that although all these features or many features that change from
    two to three。 we spent a little bit of time doing it by hand， which I think is
    good。 And we saw our few tools out there， future seems like the best。
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: There's my opinion and you can apply it and you still need to know what you're
    doing。 And those tools are pretty good to help you converting your Pisces two
    to Pisces three。 So I hope you don't have to convert too much and you will have
    the luck to work with Pisces three entirely in the future。 I hope you learned
    something in the tutorial and wish you all the best with your Pisces in Dallas。
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[BLANK_AUDIO]， [BLANK_AUDIO]， [BLANK_AUDIO]。'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91b215d5b38cdccc024726453d81019b_26.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
