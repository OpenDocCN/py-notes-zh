- en: P22：Talk Anthony Shaw - Why is Python slow - 程序员百科书 - BV1rW4y1v7YG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](img/273ff8050c916f394321761fef571bc0_0.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: 嗨，欢迎大家来到虚拟蟒蛇，很高兴今天能做这个演讲，它是关于为什么蟒蛇慢，这是一个颇有争议的话题，但希望我们能在这里得到一些事实，专注于，我想是工程学和科学
    而不是观点，所以我们要深入了解。就像蟒蛇编译器和，在未来可能会有性能改进的地方，第二，我只想说，谢谢你的加入，希望大家在家都平安，也非常感谢你，给蟒蛇组织者，在这种疯狂的情况下，已经发生了20年了，所以是的，希望你喜欢这个。让我们开始吧，所以如果我说蟒蛇很慢，当我谈到蟒蛇的时候，我指的是巨蟒，这就是你在
    python org下载的 python版本，与苹果苹果捆绑在一起的那个，商店橱窗上的那个。所以如果我们看一下 cpu密集基准，这就是著名的 n体程序 它模拟了木星的轨道，土星，天王星和海王星，一项我们经常做的工作，嗯，所以
    c和 c蟒蛇是以，它写的语言。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: python是用 c编写和编译的 python解释器，但是如果比较 c中相同算法的执行时间，七秒对 十四分钟，就表现而言，它甚至不在同一个星球上，所以也许我的意思是
    c和 c蟒蛇不是一个很好的比较。这真是苹果和橘子，C是一种强类型编译语言，python是一种动态类型的解释语言，但是节点 js呢，我是说 node js在
    google上面，veight javascript引擎。这实际上是一个更好的比较，因为它也是动态类型的，它也被解释为，那么节点有什么，这使得它比蟒蛇快得多，当计算行星的轨道时，在我说这个之前，让我们回顾一下
    c python实际上是如何运行代码的。所以 python代码是可移植的，您可以下载 python源文件，他们会在窗户上奔跑，Linux，Mac OS，当代码被实际读取时，它被解析成一个抽象的语法树，这是让蟒蛇，Python。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 它是一个代表函数的树，发言，业务，您期望在 python应用程序中看到的所有内容，所以在完成分析任务后，解释器对操作有一个 aswith，职能，python代码的类和名称空间，编译器的工作。不过是把指令变成指令，CPU实际上可以理解，你不能让
    cpu和 asst执行，cpu真的只能理解一些小的指令，小型行动，它本质上只是一个非常强大的计算器，编译任务实际上分为两部分，有一个编译器可以遍历。它是一棵树，它创造了一种叫做控制流图或cfg的东西，控制流图基本上表示逻辑序列，代码将如何实际运行，不是密码是什么，然后是汇编器
    基本上是通过控制流图，然后把它变成连续的陈述，它们被称为字节码。这个字节码实际上是 python应用程序的原子级，它不会比这更小，在评估循环中，获取并执行每个字节码指令，使用基于堆栈框架的系统，堆栈帧是许多运行时使用的数据类型，不仅仅是蟒蛇。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 但是堆栈框架允许调用函数和在函数之间返回变量，局部变量，和其他有状态信息，以及要执行的代码，嗯，以及他们生活的环境，以及它们应该运行的线，所以每个函数调用都有一个堆栈框架，它们堆叠在一起。这就是为什么他们说它们是按顺序堆叠的，他们是按照什么顺序被召来的，您有一个未处理的异常，它能打印出，这就是为什么它被称为堆栈跟踪，它跟踪整个堆栈，并告诉您正在执行哪些帧，当错误发生时，阅读。解析和编译
    python代码非常耗时，工作量很大，会给 CPU带来压力，所以编译的代码实际上是缓存的，这是住在你的雷饼缓存文件夹里的东西，每次你再次运行代码，如果代码没有改变，然后缓存版本是红色的。嗯和红色，利用马歇尔模块，行以上的任何优化，所以在阅读方面，解析之类的东西
    不会对基准产生任何影响，因为它不会影响，代码实际执行的速度有多快，因为 c python编译器被称为超前编译器。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 或 aot编译器，所以这都是事先编译好的，当 c python执行编译后的代码时，它在一个叫做"圆点c"的文件里，如果你想去看看，嗯，需要一段时间来让你的头，但这个循环基本上只是一个大循环。所有的字节码指令，它在里面，一个巨大的开关声明，它说如果是这个字节码，做到这一点，如果是那个字节码，这样做，它从值堆栈中获取值，哪些是典型的变量，或者还有其他事情，它通过循环中的每个操作，它评估它。但是因为很多
    c python都是基于编译后的 c代码，很多字节码操作实际上只是调用已编译的 c函数，那么为什么编译c代码要比c python快得多呢？它只是运行编译的
    c代码，好吧。我觉得线索就在那个循环里，所以这个循环的每个循环都不是自由的，它实际上需要，实际上，对于每个字节码操作，机器操作需要遍历每个字节码操作，任务越短，实际运行字节码操作所需的时间越短，循环越多。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 当你看时间时，开销就变得越重要，或者实际上当你看基准时 这是很重要的，所以当你比较 n体基准和 c体基准和 c python时，绝对慢，因为这个基准使用了非常紧密的循环，它使用了很多非常小的算术运算。它们不是复杂的操作，这就像，把这个数字加到这个数字上，但要做数百万次，所以
    c python解释器基本上就是在循环中运行，一次又一次，它花了很多时间在循环中，要访问下一个字节码，所以，if c。Python可以知道它将执行一个紧密的循环，当然，它可以插入一些捷径，或者类似于短线的东西，为了理解
    我们真的需要看看编译器，以及编译器是如何工作的，所以有两种类型的编译器。像 c python这样的超前编译器，或者有一个及时的编译器或者喷气机，编译器是非常不同的，因为它们编译及时，他们不通过密码，来得正是时候，他们提前通过密码，典型的，然后他们经常来。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 解析器和编译器之间的某种中间表示，所以这是一个较低的层次，这不是抽象语法树，是一个比这更低的水平，嗯，这发生在预编译器阶段，基本上它没有那么具体，它是一个像
    python一样的编译代码对象，嗯。但它比抽象语法树低得多，喷射式编译器最大的优点之一就是，它真的很擅长解决紧张的问题，闭环问题，PI就是一个很好的例子，皮伊，是另一种蟒蛇解释器，您可以使用它来执行现有的
    python代码，它是开源的。它能理解蟒蛇三点六的语法，也不像 c蟒，皮皮是用蟒蛇写的，所以用 c编写的 python编译器，pi pi编译器是用 python编写的，实际上整个圆周率都是用蟒蛇写的。所以如果我的主导陈述是真的
    而蟒蛇是缓慢的，然后是蟒蛇的成分，一个用蟒蛇写的翻译 一定慢得可笑，很好，其实没有，它不适合 n体算法，PI实际上比c python快650%。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 所以我会暂停一下 让你明白这一点，这有几个原因，但它们都与优化有关，我们正在研究的问题是闭环问题，因为ππ{\displaystyle\pi}使用喷射器，它基本上能够评估算法和数据流，决定如何执行。它可以及时改变执行结构，与其把这些都事先决定好，执行结构被优化到给定的问题集，所以，JIT在重复和循环方面非常有效，所以如果他们能评估问题集
    然后说啊，这里重复了很多，这些被称为热点。喷气编译器可以做的是，他们可以说这段代码会在很多地方运行，很多，所以我会让这变得非常有效，它确实有一个开销，我们以后再谈，但是
    jet编译器可以改变代码的编译方式，它们可以在行语句中。所以基本上把它们挤在一起，所以与其绕圈，把所有东西按顺序堆叠起来，你可以想象 c蟒蛇，如果它有这个特征，比如在那个特定的问题上，皮皮不是唯一的蟒蛇，在外面。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 实际上 number是另一个专门针对 jit编译器的，实际上是为了麻木的使用，您可以通过导入 jit decorator来使用 number，如果你在做紧循环或任何重复的数字。计算数字实际上是
    c python的一个很好的替代品，实际上你用它和 c蟒蛇一起用，所以它是，可以用数字喷气来优化，尤其是你用了很多麻药，所以这不是唯一的选择，当涉及到消除计算循环的开销时。当
    c python运行在已编译的 c扩展中的函数时，所以这就是 c蟒蛇最大的好处之一，它能很好地处理 c代码，字节码是一个单一的操作，所以如果你想调用一个 c函数
    它是一个字节码。所有的紧密循环都可能发生在这张图表的右边，但这并没有真正回答最初的问题 为什么蟒蛇行动缓慢，它实际上是说如果我们把它全部转移到一个编译，C职能，那么蟒蛇更快。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 但是通过使用 c而不是 python 基本上解决了这个问题，所以如果 js真的很快，然后执行前面展示的基准上的所有编译器，他们一定都有喷射机，哦，又好了，没有嗯，所以有很多编译器。所以rush
    c c+，另外，这些都是强类型语言，它们会有静态的内存分配 动态的或自动的，它们的工作方式与蟒蛇的工作方式非常不同，甚至节点或 java或 c sharp分配内存并处理对象。所以用粉笔和奶酪来比较锈或碳或碳，加加加蟒蛇，嗯，一个公平的比较实际上是节点js，所以节点
    js是服务器端 javascript运行时，但是在铬八引擎上，铬八引擎。是 chrome浏览器中的 javascript引擎，它还被用来驱动许多其他东西，应用程序，嗯，你可能已经在你的桌面上，我的意思是松弛是一个很好的例子，但是你可以在基准上看到。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 节点实际上比 python快得多，所以 javascript和 python有更多的相似之处，在语言和动态类型方面，例如，但是前面我提到了 jit编译器是如何使用中间表示的。所以
    c python也有一个中间表示法，一张基本框图，所以当你的 python代码被编译的时候，执行顺序，在编译器中确定发出控制流图中的框架块，我之前说过，所以如果你拿一个简单的for循环来说。它实际上有很多部分，所以最后会有很多的框架块，不仅仅是整个
    for循环语句，因为在循环中你可能有一个块，这可能会导致一些其他的代码，它可以召唤出框架，你还可以在循环中加入其他语句，我一直不明白为什么。但你能做到，嗯，所以控制流图，实际上
    for循环可能相当复杂，但它是刚性的，这是一个，上面说，这就是代码将如何执行，所有这些都被送到汇编器，然后它吐出顺序字节码，如果你把它与稍后编译的 jit进行对比。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 喷气式飞机使用的一些中间表示实际上要灵活得多，在执行路径上，所以代码会以你期望的方式运行，这不是重点，毫不奇怪，换了一家分店，更多的是关于如何，编译器实际上看的是，嗯，代码块或操作的语句。以及组成代码的值，以及它是如何决定把这些东西送到
    cpu去执行的，这实际上是为了确保 cpu以最有效的方式使用，所以一个中间表示属性叫做静态单赋值，所以如果你看一下 v8jit优化器。这是 v8的优化编译器，它叫涡轮风扇，它用静态的单赋值
    中间表示做了一些很酷的事情，所以所有的值和操作在 python等价中，那将是，你知道吗，所有变量和所有操作都是语句的组成部分。所有这些东西都变成了这个巨大图表中的节点，蟒蛇也有类似的症状，但当真正执行时，全都是顺序字节码，如果你把它和节点进行比较，基本上，所有这些东西都变成了节点，在一个巨大的图表中足够奇怪，这张图并不是根据。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 就像这里，图表上所有的边，以下是它应该如何执行，这个图实际上是根据依赖关系和数据流来确定的，所以编译器优化器实际上决定了热代码和死代码，它在图中绘制边，以优化代码的执行方式。所以通过找到死码并确保它不会被安排，或制作或寻找热门代码，确保计划妥当，你可以获得一些巨大的效率收益，所以这就是为什么在基准节点中，即使它是动态的，是因为它是喷气的，编译器能够非常聪明地。它基本上优化了应用程序的某些部分，所以
    V8并不是唯一使用 SSA最现代的飞机，它也使用 ssa，圆周率和数字，jet也使用 ssa表示，所以如果 JIT这么棒，为什么巨蟒不能有一个 jit。我已经提到这个线索好几次了，C
    python和 C扩展齐头并进，一半的 c蟒蛇在蟒蛇体内，另一半是在编译的 c代码中编译的，C代码不能 jitting，它是岩石，固体它不会去任何地方，嗯。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 该死的是有效的，jit编译器需要能够对，代码结构和数据流，以及执行的方式，但从蟒蛇的角度来看，然后，compile c模块就变成了一个黑匣子，就像你不知道里面有什么，你看不到那些编译模块中的控制流。所以喷气机只能在蟒蛇这边工作，然后你就得在飞机上贴上，你不会得到任何接近效率增益的地方，你会有在，就像一个纯粹的
    jit编译器，所以我想这就是为什么，C python不能有 jit编译器。关于 JIT还有一点我没有提到的是 他们有一个，他们有管理费用，所以你知道所有这些聪明的优化都是有代价的，首先，他们有一个内存开销，我不知道你有没有注意到，但是节点用了很多内存，嗯，这不是唯一的原因。但这架飞机是相当大的，复杂的软件，它不是来冷冻的，第二，他们有一个头顶上的启动，所以对于一个快速奔跑的人来说，它有一个启动时间，所以如果你把喷射器插进巨蟒体内，C蟒蛇现在开始要花更长的时间。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 对大多数人来说，这听起来可能不是一个问题，在命令行输入 python，涟漪升起，我不知道快，c python编译器也从未被设计为优化，对于一个特定的问题集，它应该是通用的编译器。它说在编译器的设计说明中应该是简单的，所以引入喷气式飞机真的违背了设计原则，就像我们讨论过的闭环问题，但实际上还有其他方法可以解决这个问题，当前存在的，所以，这并不是说
    c，Python没有任何优化。因为它有一些叫做 pg或 profile引导优化的东西，c python源代码被编译为二进制文件，然后这个二进制位被赋予，所以
    python基本上是和测试应用程序一起运行的。测试应用程序实际上是单元测试程序的一部分，但在测试中，应用程序被描述为，然后看看蟒蛇二进制的哪些部分被使用，最，这就产生了一种叫做侧写的东西，并确定应用程序上有哪些热点，这些热点基本上是优化的。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 就像喷气式飞机，但这已经做了一次了，以前也这么做过，这个版本的python是为大家提供下载的，一个人就可以做到，所以发布经理可能会运行 pga进程。这些配置文件基本上是硬编码到
    c python二进制文件中的，如果你想运行你自己的个人资料，您可以下载源代码并运行自己的配置文件，嗯，但你可能会想出一个相似的答案，其中有一部分是巨蟒双星，它们经常运行。键杯和散列算法，诸如此类的事情，有一些小的功能，它们在巨蟒的一生中经常奔跑，已经优化过了，因此，回顾一下几乎变成关于JIT的谈话，喷射机可以在运行时进行优化，一个人工智能不能做出这样的区分。它很适合重复数学，任务繁重，但对于不可预知的任务，他们不是很好，我们以后会讨论，如果你有时间上的问题，然后你应该使用一些圆周率，你就可以免费得到一架喷气式飞机，你得到了所有那些巨大的性能提升。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 但就像我之前说的，JIT不是免费的，我说就成本而言是免费的，但就 cpu而言不是免费的，我们纯粹是在比较速度，n体问题的节点和 c python的速度。但实际上如果你去看看基准节点确实完成了这个任务
    很好，但它使用了超过四倍的内存，所以如果阿喀琉斯，巨蟒的脚后跟就是这些小圈圈，那么其他类型的任务呢，比如它擅长哪些类型的任务，比如哪些是有效的。其中一个任务是文本处理，所以另一个基准基本上是在随机的
    dna字符串上做正则表达式，C python明显快于节点 js，实际上和一些静态类型的算法是一样的，所以也不全是坏消息，在某些应用中。c python编译器的设计实际上是非常有效的，但这一切都是关于缓慢，这不仅仅是编译器的问题，那么c
    python还有其他优化功能吗？内存分配怎么办，所以不仅仅是在内存的数量上。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 以及如何使用 cpu分配和取消分配内存，所以每当你创建对象和销毁对象时，这在应用程序的生命周期中经常发生，你知道吗，当你把函数带进或带出范围时，成千上万次对象来来去去，例如。那么
    c蟒蛇这样做的效率有多高呢，因为这增加了内存 而且 cpu达到了一个很好的基准，是二叉树基准，这个特定的基准基本上构建了，横越，一次又一次地破坏二叉树，对于内存分配开销来说，这是一个很好的基准。因为它表明了很多关于垃圾收集算法，它还会检查它是否使用了，它还考虑了内存分配的成本，所以创建所有的节点，本质上是分配内存和不分配内存，所以因为不，它有一个与蟒蛇相似的记忆管理故事，我又要挑节点的毛病了。嗯，C，Python有两种策略来确保你的应用程序，别把你的羊都吃了，第一个很简单，每个人都应该明白这一点，蟒蛇里的每一个东西都是一个物体，对，所以每个对象都有一个引用计数，如果这个数字变成零。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 对象被销毁，内存被释放，但是如果您有像列表字典集这样的容器类型，例如，他们可以引用自己，你可能会认为这是一个有点做作的例子，但实际上发生的比你想象的要多得多，即使是刚开始的蟒蛇，这种情况也会发生。我想我测试了几千次，它创建循环引用，所以如果你只是依靠一个参考计数器，你是气球的记忆，整个过程就会爆炸，所以使用了另一个工具，叫做垃圾回收，它基本上着眼于循环引用，然后减少那些，所以对象可以被释放。巨蟒有一个停止一切，垃圾收集器，所以在一定次数的循环之后，它将要求每个容器对象检查自身是否有循环引用，所以它会去找每一本字典，在整个应用程序空间中分配的每个列表，它会去让它检查。看看它是否有周期性的参考，所以这只是时不时地做，它只做了一定数量的循环，因为这对
    cpu来说是相当昂贵的，然后它去标记那些需要移除的，所以如果它有周期性的参考，它减少了这个数字，到了零点，那个物体是。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 实际上从来没有人提到过，所以它可以被释放，这发生在主线上，所以当这一切发生的时候，在查字典的同时，每个名单都在检查中，没有别的东西在运行，没有其他操作在
    c python进程上运行，如果你比较一下。例如八引擎，它遵循类似的策略，它有一个停止一切垃圾收集器，但它实际上使用了一种稍微不同的技术来使其更快，因为它阻止了一切，停止所需的时间，你希望它尽可能小，所以穿越。对象的标记实际上是在两个助手线程上完成的，所以基本上是平行进行的，在主线程暂停之前，意味着很多扫码过程在短时间内完成，主线程只暂停了一小部分时间，否则，所以这听起来像是一个微小的区别，它是毫秒，嗯。但是在某些基准测试和很多应用中，因为你在分配分配对象，那么这种优化将使一个很好的，提速，所以在这个特定的基准上，很明显，所以这听起来像是一个花哨的功能，所以我看不到蟒蛇，有一个这样的，所以快速暂停一下。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 铬发动机是由世界上最大的公司之一开发和拥有的，是公司赚了几十亿的利润，铬项目就像我在吉瑟布看到的，我可以看到至少有30个人在全职工作，一周五天，他们都是非常有经验的开发人员，所以即使你只是想。比如管理团队的成本，可能会有30个以上的开发商在上面运行，我不认为这实际上是一个公平的比较，C蟒蛇是社区办项目，它是由志愿者开发的，所有在
    c python编译器上编写和工作的人，有白天的工作。所以我觉得把节点 js比作蟒蛇，因为我认识在巨蟒上工作的人，好像他们都是超级聪明的人，但他们自愿，他们在业余时间做这件事，所以说，看看你能得到的所有这些闪亮的功能，如果你每年有一千万美元花在发展上。太好了，但作为一个项目，我们没有那个，嗯，可能我的意思是，从技术上讲，这是可能的，我不认为这和公会有什么关系，这不是为什么还没有做的原因，只是关于谁来做这件事，谁有时间谁有经验，所以这就是我的停顿。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 我只想说，嗯，因为我知道有些观众，嗯，一些观看这段视频的人，对不起，我们会加入开发团队，感觉我只是在攻击这个项目。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/273ff8050c916f394321761fef571bc0_2.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 我真的不是这样，关于鳃的话题是什么 扼杀了表演，嗯，这不是恶言恶语，所以对于 cpu的密集任务，如果你想让它们平行运行，然后决心这样做，今天看到蟒蛇，绕过鳃，你只需要找出。你如何把你的工作量分成足够大的部分，启动新流程的开销
    不会对执行时间产生影响，或者，数字可以做一个没有鳃的喷气机，挺好的，像我提到的多处理确实有开销，不仅仅是开始一个单独的过程，但实际上运行过程的开销。其实并不重要，因为如果你说平行，那么你有多少个
    cpus和多少个 core，如果你说的是四八个，那么，运行python进程并不是一个重要的开销，如果这不是那种问题。那么异步 i o和多线程实际上是一个更好的解决方案，在这个基准测试中
    这是我写的，嗯，这是一个用于测试目的的 tcp端口扫描仪，我只是想看看，就像，如果您想同时运行一个任务，比如检查20个 tcp端口。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 那么每次接近的距离有多近，因为最小的一秒，因为如果其中一个港口关闭了，但它离那个有多近，所以伊诺斯，那是最快的，因为这是个人工智能问题，这不是 CPU的问题，所以女孩们在这个特定的基准中没有任何关系。异步
    i o实际上是最好的方 法，因为它在运行并发任务方面的开销最小，但有时你会遇到既是 io绑定 又是 cpu绑定的问题，所以在那些情况下，新的解决方案将在三点九出现
    是子解释器，这将是新的热门。我非常兴奋，但它仍然是实验性的，基本上，它使您能够运行多个解释器，而不是多个进程。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/273ff8050c916f394321761fef571bc0_4.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/273ff8050c916f394321761fef571bc0_4.png)'
- en: 口译员的足迹要小得多，而且口译员之间分享记忆之类的东西 更容易，但绝对没有异步那么容易，我也是，如果你有 cpu绑定和 i绑定的问题，那么这可能是一个很好的选择，总之，现代编译器的现代速度是关于优化的。紧环，但闭环问题真的伤害了
    c蟒蛇，它的编译器不是为这个问题设计的，如果你看看这些基准，会很难看的，并非所有问题都是闭环问题，如果你真的有这个问题，可提供其他实现，在三点九和三点十以口译员的形式出现。还有很多工作要做，如果你真的想帮忙的话，那就太好了，但我不希望看到像一个巨大的改善
    只是一般的问题，在某些问题空间中的一般应用，但最后，优化需要花钱，也需要时间，它们需要付出努力，他们的成本计划。这些都是复杂的事情，这不是一件简单的事情，我们只需输入几行代码，C蟒蛇是通用的，所以如果我们进行优化，优化伴随着妥协，而且有优化可用，关于蟒蛇
    还有其他方法，所以我的首要问题是蟒蛇慢，好吧，其实答案是。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 口译员的足迹要小得多，而且口译员之间分享记忆之类的东西更容易，但绝对没有异步那么容易，我也是，如果你有 `cpu` 绑定和 `i` 绑定的问题，那么这可能是一个很好的选择，总之，现代编译器的现代速度是关于优化的。紧环，但闭环问题真的伤害了
    `c python`，它的编译器不是为这个问题设计的，如果你看看这些基准，会很难看的，并非所有问题都是闭环问题，如果你真的有这个问题，可提供其他实现，在 `3.9`
    和 `3.10` 以口译员的形式出现。还有很多工作要做，如果你真的想帮忙的话，那就太好了，但我不希望看到像一个巨大的改善只是一般的问题，在某些问题空间中的一般应用，但最后，优化需要花钱，也需要时间，它们需要付出努力，他们的成本计划。这些都是复杂的事情，这不是一件简单的事情，我们只需输入几行代码，`C
    python` 是通用的，所以如果我们进行优化，优化伴随着妥协，而且有优化可用，关于蟒蛇还有其他方法，所以我的首要问题是蟒蛇慢，好吧，其实答案是。
- en: 你可以选择不同的口译员，解释器被设计成不同的问题空间，每个解释器都被优化到不同的问题空间，实际上是一个非常快的，所以如果你，挑一个通用的，把它应用到一个问题空间，它不是为这个设计的，你知道吗。如果你用鱼爬树的能力来衡量它，你不会得到最好的结果，所以最后我希望你喜欢我的谈话，做这个演讲
    做计划真的很有趣，嗯，我也在工作，现在已经完成了，一本关于 c python内部结构的书。我正在和真正的蟒蛇船员一起出版，嗯，这将在一个月左右的时间里 作为一本实体书出版，如果蟒蛇要面对面，我们本来打算在巨蟒书店买一堆书，所以这是一个真正的耻辱，但基本上我深入到编译器，其实。几乎所有在
    c python中的源代码，不管怎样，这是一次真正的技术深潜，看看我的网站，如果你有任何问题，给我发邮件，嗯，或者你可以在推特上找到我，在通常的地址，所以非常感谢你，为了让这一切发生。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择不同的口译员，解释器被设计成不同的问题空间，每个解释器都被优化到不同的问题空间，实际上是一个非常快的，所以如果你挑一个通用的，把它应用到一个问题空间，它不是为这个设计的，你知道吗。如果你用鱼爬树的能力来衡量它，你不会得到最好的结果，所以最后我希望你喜欢我的谈话，做这个演讲真的很有趣，嗯，我也在工作，现在已经完成了一本关于
    `c python` 内部结构的书。我正在和真正的蟒蛇船员一起出版，嗯，这将在一个月左右的时间里作为一本实体书出版，如果蟒蛇要面对面，我们本来打算在巨蟒书店买一堆书，所以这是一个真正的耻辱，但基本上我深入到编译器，其实几乎所有在
    `c python` 中的源代码，不管怎样，这是一次真正的技术深潜，看看我的网站，如果你有任何问题，给我发邮件，嗯，或者你可以在推特上找到我，在通常的地址，所以非常感谢你，为了让这一切发生。
- en: 也请大家捐款给 psf。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 也请大家捐款给 psf。
- en: '![](img/273ff8050c916f394321761fef571bc0_6.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/273ff8050c916f394321761fef571bc0_6.png)'
