- en: P13：Sponsor Workshop Jason Lantz - Salesforce How Python Powers Salesforce.org's
    Uni - 程序员百科书 - BV1rW4y1v7YG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P13：赞助商研讨会 Jason Lantz - Salesforce Python 如何推动 Salesforce.org 的独特模式 - 程序员百科书
    - BV1rW4y1v7YG
- en: Hello， and thanks for watching。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大家好，感谢观看。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_1.png)'
- en: I'm Jason Lance。 I'm Senior Director of Release Engineering at Salesforce。org。
    and I'm really excited， to talk to you today in the context of PyCon about how
    Python is powering Salesforce。org's， unique open-source model， and also how you
    might be able to use some of the Python tooling。 that we build to build integrations
    with Salesforce into your own Python web application projects。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我是 Jason Lance。我是 Salesforce.org 的高级发布工程总监。我非常兴奋能在 PyCon 的背景下与大家讨论 Python 如何推动
    Salesforce.org 独特的开源模式，以及你如何能够使用我们构建的一些 Python 工具来为自己的 Python 网络应用程序项目构建与 Salesforce
    的集成。
- en: Before we begin， just a quick legal disclaimer， we're going to talk about some
    forward-looking。 things。 Don't make any investment decisions based on any of this
    forward-looking content。 Only make your investment decisions based on what is
    currently available in the market。 Now with that out of the way， let's get into
    some， or cover the agenda real quick。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，先来个法律免责声明，我们将谈论一些前瞻性的内容。不要根据这些前瞻性内容做出任何投资决策。请仅根据当前市场上的可用信息做出投资决策。好了，废话不多说，让我们快速了解一下议程。
- en: We're going to go through some quick introductions about me， Salesforce， and
    Salesforce。org。 Then we're going to talk about open-source at Salesforce。org。
    Then we're going to look at the main Python tooling framework that we built at
    Salesforce。org。 and made available as open-source。 Then we will get into the bulk
    of the session。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对我自己、Salesforce 和 Salesforce.org 进行一些简单介绍。然后我们将讨论 Salesforce.org 的开源项目。接着，我们将查看我们在
    Salesforce.org 建立并作为开源提供的主要 Python 工具框架。之后我们将进入本次会议的主要内容。
- en: which is going to be three demos that build， on top of each other。 In the first
    demo。 we'll show creating a new Salesforce development project using Cumulus，
    CI。 Then in the second demo。 we'll show the three web applications that we built
    on top of Cumulus， CI using Python。 Those are Meteko， Metacai， and Metadploy。
    Then in the final demo。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行三个逐步构建的演示。在第一个演示中，我们将展示如何使用 Cumulus 和 CI 创建一个新的 Salesforce 开发项目。然后在第二个演示中，我们将展示在
    Cumulus 和 CI 上使用 Python 构建的三个网络应用程序，它们是 Meteko、Metacai 和 Metadploy。最后，在最后一个演示中。
- en: we'll bring it all together and apply it to you as a Python developer。 to show
    how you can integrate a Python web application with Salesforce。 Why would you
    want to do that？ There are plenty of users of Salesforce and having the ability
    to integrate your application。 with Salesforce， still develop your application
    in Python， but build that integration for your。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把所有内容结合在一起，展示如何作为 Python 开发者将 Python 网络应用程序与 Salesforce 集成。你为什么想要这样做？Salesforce
    有大量用户，能够将你的应用程序与 Salesforce 集成，同时仍然使用 Python 开发应用程序，这将为你的项目增添价值。
- en: users。 It potentially opens up a whole new user base for you and adds a lot
    of value for those。 users that are using Salesforce。 Let's start with the introductions。
    Who am I？ Why am I here？
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 用户。这可能为你打开一个全新的用户群，并为那些使用 Salesforce 的用户增加很多价值。让我们从介绍开始。我是谁？我为什么在这里？
- en: Aside from the obvious philosophical question there， we'll just get into the
    context of why。 I'm here at Python。 I started my career as a Unix administrator。
    quickly realized I wasn't a very good administrator。 and started diving into open
    source projects and really discovered that I like building， things。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除了明显的哲学问题之外，我们直接进入我为什么会出现在 Python 的背景下。我最开始的职业是 Unix 管理员，但很快意识到我并不是一个很好的管理员，因此开始深入开源项目，并真正发现我喜欢构建事物。
- en: I really like prototyping things。 Back in about 2003。 I discovered this new
    Python project just starting out called Plone。 back when it was in version one。
    I started playing around in Plone。 really fell in love with it as a content management
    system。 That inspired me to want to learn Python。 As somebody who didn't come
    from a computer science or a programming background。 Python， was a really great
    fit for me。 It seemed very elegant。 The projects that were out there had just
    seemed really well written。 I learned a lot of what I know about programming from
    Python。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢原型设计。大约在2003年，我发现了一个刚刚起步的新Python项目，叫做Plone，当时还在第一个版本。我开始在Plone中玩耍，真的爱上了这个内容管理系统。这激励我想要学习Python。作为一个没有计算机科学或编程背景的人，Python对我来说是一个非常合适的选择。它看起来非常优雅。那些项目似乎写得非常好。我从Python中学到了我所知道的编程知识。
- en: Very excited to have the opportunity to present at Python。 Then in about 2008。
    I made the transition from building corporate web applications to。 working for
    nonprofit organizations。 I worked for two amazing nonprofits in New York City
    during that time。 Then I got the opportunity to join Salesforce。org in 2013。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 非常兴奋有机会在Python会议上演讲。大约在2008年，我从构建企业网页应用程序转向为非营利组织工作。在那段时间，我为纽约市的两个了不起的非营利组织工作。然后我在2013年获得了加入Salesforce.org的机会。
- en: This was really an opportunity rather than working for just a single nonprofit
    to maximize。 the impact that I can create in the world by applying my technology
    skills to benefit tens。 of thousands of nonprofit and now education organizations
    that are using Salesforce for。 their day-to-day work。 My job at Salesforce。org
    has been focused on making DevOps easier for the Salesforce community。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个机会，而不是仅仅为单一非营利组织工作，以最大化我在世界上创造影响的能力，通过应用我的技术技能来帮助成千上万的非营利和现在的教育组织，它们正在使用Salesforce进行日常工作。我在Salesforce.org的工作重点是让DevOps对Salesforce社区变得更容易。
- en: I think my background in the Python， especially with Python open-source projects
    and Python。 CMS and web projects has really helped me think about DevOps and bring
    a different perspective。 of DevOps to the Salesforce community。 I think that has
    actually allowed me to create a lot of the things that I've been able to。 create
    over that time。 Now if you haven't heard of Salesforce before。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我在Python方面的背景，尤其是在Python开源项目和Python内容管理系统及网页项目方面，真的帮助我思考DevOps，并为Salesforce社区带来了不同的DevOps视角。我认为这实际上让我能够创造出很多我在那段时间所能创造的东西。如果你之前没有听说过Salesforce。
- en: Salesforce is a customer relationship management， solution that brings companies
    and customers together。 It's one integrated CRM platform that gives all your departments，
    including marketing， sales。 commerce and service， a single shared view of every
    customer。 We bring companies and customers together to deliver the personalized
    experiences that。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Salesforce是一个客户关系管理解决方案，将公司和客户联系在一起。这是一个集成的CRM平台，为所有部门，包括市场营销、销售、商务和服务，提供每个客户的单一共享视图。我们将公司和客户结合在一起，以提供客户所期望的个性化体验。
- en: your customers expect by using the integrated CRM platform that we call Salesforce
    customer， 360。 Now， what does Salesforce believe in？ This is actually really personal
    to me and why I'm here。 Our core values help us make Salesforce a platform for
    change。 You'll see our core values over on the right here。 Trust， customer success，
    innovation and equality。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Salesforce相信什么？这对我来说真的很重要，这也是我在这里的原因。我们的核心价值观帮助我们将Salesforce打造为变革的平台。你会在右侧看到我们的核心价值观：信任、客户成功、创新和平等。
- en: Those are our core values。 That's the order of the ranking of our core values。
    And it's a lot more than just a plaque that's somewhere posted in our office。
    Over my years here。 I've seen the company use these core values to guide decision
    making。 so that we can focus on doing the right thing by our customers and the
    right thing by the， world。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们的核心价值观。这是我们核心价值观的排名顺序。这远不止是张贴在办公室某处的牌匾。在我多年的工作中，我看到公司利用这些核心价值观来指导决策，以便我们能够专注于为客户做正确的事，以及为世界做正确的事。
- en: IWork@Salesforce。org and Salesforce。org is a business unit inside of Salesforce。
    We are the social impact center of Salesforce。 So we believe that the purpose
    of business should be to improve the state of the world。 We provide access to
    powerful technology that empowers change makers to build a better world。 We are
    a unique business unit dedicated to creating solutions for nonprofit， educational。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: IWork@Salesforce.org和Salesforce.org是Salesforce内部的一个业务单位。我们是Salesforce的社会影响中心。因此，我们相信商业的目的应该是改善世界的状态。我们提供强大技术的访问，赋予变革者构建更美好世界的能力。我们是一个独特的业务单位，致力于为非营利和教育领域创造解决方案。
- en: and philanthropic organizations so that they can have greater impact。 A really
    essential part of that and the part of the organization that I work in in our。
    product development team is the grant of either free and then additional licenses
    at a heavily。 discounted rate for nonprofit and education organizations。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与慈善组织合作，使其能够产生更大的影响。我所在的产品开发团队的一个核心部分是为非营利和教育组织提供免费和额外许可的折扣许可证。
- en: We have nonprofit and education organizations all over the world using Salesforce，
    using。 these grants。 For example， in the United States， most any 501(c)(3) nonprofit
    organization。 no matter， how big or small， can get 10 free enterprise edition
    licenses to Salesforce。 For small organizations， and actually that represents
    the vast majority of the nonprofits。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在全球范围内有非营利和教育组织使用Salesforce，利用这些补助。例如，在美国，几乎任何501(c)(3)非营利组织，无论大小，都可以获得10个免费的企业版Salesforce许可证。对于小型组织来说，这实际上代表了绝大多数非营利组织。
- en: that use us， they pay us nothing。 They can work within the 10 free licenses
    that they have。 And I think that's an amazing benefit that we're providing to
    the world of this platform。 that we built for corporations and the marketing and
    sales needs of corporations and being。 able to leverage all of that investment，
    all of that innovation to apply to this community。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的组织，他们不需要支付费用。可以在他们拥有的10个免费许可证内进行工作。我认为这是我们为这个平台的世界提供的一个惊人福利，平台是为了满足企业及其市场和销售需求而构建的，能够利用所有这些投资和创新来服务这个社区。
- en: of change makers that we service。 To date， we've got over 44。000 nonprofit and
    education organizations around the world that。 are using Salesforce through Salesforce。org。
    And we invest heavily in building products that adapt Salesforce customer 360
    to the needs。 of a nonprofit or of an education organization。 So we flip from
    a customer relationship management to constituent relationship management。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务的变革者。截至目前，我们在全球拥有超过44,000个非营利和教育组织，正在通过Salesforce.org使用Salesforce。我们在构建能够将Salesforce客户360适应非营利或教育组织需求的产品上投入了大量资金。因此，我们将客户关系管理转变为利益相关者关系管理。
- en: Let's talk a little bit about open source at Salesforce。org。 And when you think
    about open source at Salesforce。org， there's kind of three main types of open。
    source that I want to talk about and cover today。 The first is we have open source
    products。 And I think this is where our kind of unique open source model really
    lives。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们聊聊Salesforce.org的开源。当你想到Salesforce.org的开源时，我想谈谈并涵盖三种主要类型的开源。首先，我们有开源产品。我认为这正是我们独特开源模式的所在。
- en: We have open source products to provide a common trusted platform for innovation
    in the nonprofit。 and education sectors。 Salesforce。org， our partners and our
    customers build solutions on top of these products。 We also have tooling that
    we've developed to solve our common DevOps needs and challenges。 that we've faced
    in our development projects on top of the Salesforce platform。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有开源产品，以为非营利和教育领域提供一个共同的可信平台。Salesforce.org、我们的合作伙伴和客户在这些产品上构建解决方案。我们还开发了工具，以解决我们在Salesforce平台开发项目中面临的共同DevOps需求和挑战。
- en: And we make those tools available as open source to the entire Salesforce community。
    These tools are all written in Python。 And then the web based tools are using
    Django that we run out on Heroku。 We'll be taking a lot of a lot more look at
    this tooling today。 But kind of the reason for that tooling is in addition to
    support our products。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些工具作为开源提供给整个Salesforce社区。这些工具都是用Python编写的，而基于Web的工具则使用Django，并在Heroku上运行。今天我们将会深入探讨这些工具，但这些工具的原因除了支持我们的产品之外。
- en: But really where my heart is is in supporting our community。 We built this amazing
    or actually the community has sort of spawned into an amazing open source。 community
    that we kind of help facilitate in whatever way we can。 And the newest way that
    we've done that is the Salesforce。org open source commons。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但我的心真正归属在支持我们的社区上。我们建立了这个惊人的，或者说社区发展成为了一个令人惊叹的开源社区，我们尽可能以各种方式帮助促进。我们最新的做法是Salesforce.org的开源公共平台。
- en: Where we host community sprints throughout the year to bring together customers，
    partners。 and staff to build open source solutions focused on making the world
    a better place and making。 life easier for nonprofit and education organizations
    to fulfill their missions。 The Salesforce。org open source commons also helps incubate
    sustainable open source projects。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们全年举办社区冲刺活动，将客户、合作伙伴和员工聚集在一起，构建专注于改善世界的开源解决方案，让非营利和教育组织更容易实现其使命。Salesforce.org的开源公共平台还帮助孵化可持续的开源项目。
- en: by leveraging Salesforce。org's expertise， access and tooling to benefit those
    projects。 We'll talk about each of these in a little bit more detail。 Let's dig
    in on open source products。 So when I say that we've got a unique open source
    model here at Salesforce。org， I think。 this kind of represents it a little bit。
    In this pyramid on the left， the arrow on the left side。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Salesforce.org的专业知识、访问和工具来惠及这些项目。我们会更详细地讨论每一个。让我们深入了解开源产品。当我说我们在Salesforce.org有独特的开源模型时，我认为这在某种程度上代表了它。在左侧的金字塔中，左侧的箭头。
- en: you can see that easier for， developers is down at the bottom of this pyramid，
    at least initially。 You write some code， you put it in a GitHub repository， no
    docs， no packaging。 Don't think about anything， you just kind of push commits
    up into the repository。 It's very easy for you to get your code out to the world。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，对于开发者来说，最初在这个金字塔的底部是更简单的。你编写一些代码，放入GitHub库中，没有文档，没有打包。不要考虑任何事情，只需将提交推送到库中。将你的代码推向世界是非常简单的。
- en: But as you'll see in the first arrow on the right， that is not easier for users。
    That's actually going to be the hardest for users to be able to use。 So if you
    want to get users of your application， have something more than just the field
    of， dreams。 but actually get people playing on it， you need to start actually
    focusing on。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如你在右侧的第一根箭头所看到的，这对用户来说并不容易。实际上，这对用户来说是最难使用的。因此，如果你想吸引应用程序的用户，必须有比“梦想之田”更多的东西，实际上让人们参与其中，你需要开始真正专注于。
- en: building documentation， creating releases of your product， creating an installable
    package。 of your product， maybe creating some pre-configured templates that customers
    can start from， but。 then build out their own implementations。 The challenge is
    the overall maintenance for the end user of that。 they have to continually， upgrade
    and integrate their changes with new releases that you come out with。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 构建文档，创建产品的发行版，创建可安装的产品包，可能创建一些预配置的模板，以便客户可以从中开始，然后构建自己的实现。挑战在于最终用户的整体维护。他们必须不断地升级并将自己的更改与新版本整合。
- en: At the top of the pyramid here is really where we target our open source model，
    which is。 the idea of providing pre-configured， fully hosted instances of our
    software with automatic。 upgrades on a regular basis。 We cut in new releases of
    all of our products every two weeks and push upgrade those to。 all of our existing
    customers。 So there's 44，000 plus organizations using us。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个金字塔的顶端，实际上是我们针对开源模型的目标，提供预配置、完全托管的软件实例，并定期进行自动升级。我们每两周推出所有产品的新版本，并将其升级到所有现有客户。因此，使用我们的组织超过44,000个。
- en: And the way we're able to do that is because we have this unique combination
    of open source。 products and corporate philanthropy。 The corporate philanthropy
    provides the platform that our open source model is based upon。 And then we innovate
    and provide these products that we deliver out to the world。 So for those small
    nonprofit organizations that pay us nothing， they're living in the。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以能够做到这一点，是因为我们拥有独特的开源产品与企业慈善的结合。企业慈善为我们的开源模式提供了基础平台。然后，我们创新并提供这些产品，推向全球。对于那些不支付任何费用的小型非营利组织来说，他们生活在。
- en: top wrong of this triangle， getting the best of both worlds， the hosting and
    the open source。 product development， the open source community around it。 Now
    the arrow on the far right here。 you can see that easier for developers at scale。
    As you start getting more customers or more users of your open source project。
    scaling， the support of that is a challenge。 And by having these pre-configured
    hosted instances that are always updated so everybody's always。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个三角形的顶端，获得两全其美的托管和开源产品开发，以及围绕它的开源社区。现在最右边的箭头，你可以看到，这使得大规模开发者更容易。随着客户或开源项目用户的增加，支持的扩展是一个挑战。通过这些预配置的托管实例，所有实例都会始终更新，以确保每个人都在使用最新版本。
- en: running on the latest release， we've really been able to scale our development
    efforts。 to create huge impact in the world。 As far as I know。 I don't think that
    there's another open source project in the world that。 really does this combination
    of corporate philanthropy to provide hosting in an enterprise。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新版本的支持下，我们能够扩展开发工作，为世界创造巨大的影响。据我所知，我认为世界上没有另一个开源项目能够真正做到将企业慈善与企业级托管相结合。
- en: class platform of the open source projects that they're building。 I think it's
    a really unique model and something I'm really excited to be a part of。 Our open
    source products at Salesforce。org are divided between two of our main clouds，
    the。 nonprofit cloud and the education cloud。 On the nonprofit cloud， we have
    three open source products。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 开源项目的类平台。我认为这是一个非常独特的模式，我对此非常兴奋。我们在Salesforce.org的开源产品分为两个主要云：非营利云和教育云。在非营利云中，我们有三个开源产品。
- en: the nonprofit success pack， or NPSP， which provides a foundation for the data
    tracking needs of nonprofit organizations。 things like managing their relationships
    with constituents， their households， fundraising， efforts。 relationships and affiliations
    between people and organizations。 And then our newest open source project is the
    program management module that just launched。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 非营利成功包（NPSP）为非营利组织的数据追踪需求提供了基础，比如管理与利益相关者、家庭和筹款工作的关系与关联。我们的最新开源项目是刚刚启动的项目管理模块。
- en: about two weeks ago and the program management module provides a kind of data
    schema， a common。 data schema for nonprofit organizations to be able to track
    their programmatic work。 For instance。 for food banks， the number of meals served
    for pet rescue organizations。 the number of puppies saved。 And then finally， volunteers
    for Salesforce is an additional open source project of ours。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大约两周前，项目管理模块提供了一种数据架构，为非营利组织追踪其项目工作提供了通用数据架构。例如，对于食品银行，提供的餐数；对于宠物救助组织，拯救的小狗数。最后，Salesforce的志愿者是我们另一个开源项目。
- en: in the nonprofit cloud and volunteers for Salesforce helps thousands of nonprofit
    organizations。 around the world track and manage their volunteer efforts。 On the
    education side， like NPSP。 we have the education data architecture or EDA， which。
    provides a common framework for building education applications。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 非营利云和Salesforce的志愿者帮助全球数千个非营利组织追踪和管理他们的志愿者工作。在教育方面，像NPSP一样，我们有教育数据架构（EDA），为构建教育应用程序提供了一个通用框架。
- en: There's a whole bunch of different applications that are built on top of EDA，
    both by our partners。 and by us。 EDA provides， for instance， objects for being
    able to track terms and course offerings and。 course enrollments。 And the basic
    kind of data structure that you need in order to build any sort of solution。 in
    the education space， it's open source， it's a trusted platform in the education
    sector。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多不同的应用程序是建立在EDA之上的，既有我们的合作伙伴，也有我们自己。EDA提供了，例如，跟踪学期和课程设置、课程注册的对象。以及构建任何类型解决方案所需的基本数据结构。它是开源的，也是教育领域值得信赖的平台。
- en: especially of those organizations that are running on Salesforce。 And then we've
    also built the K12 architecture kit， which extends EDA and adds additional。 schema
    elements that are important for a K12 use case in the education context。 So those
    are our five main open source managed package products that we make available
    through。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是那些在Salesforce上运行的组织。我们还构建了K12架构工具包，扩展了EDA并添加了在教育背景下K12用例的重要额外架构元素。这是我们提供的五个主要开源托管包产品。
- en: this unique open source model combined with corporate philanthropy。 Now let's
    talk about our open source tooling。 So the main part of our open source tooling。
    as I mentioned earlier， is Cumulus CI， which， is a Python framework for portable
    automation for Salesforce projects。 It was built to solve the unique DevOps needs
    of Salesforce development projects。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个独特的开源模型结合了企业慈善。现在让我们谈谈我们的开源工具。我们开源工具的主要部分，如我之前提到的，是Cumulus CI，这是一个用于Salesforce项目的便携式自动化Python框架。它旨在解决Salesforce开发项目独特的DevOps需求。
- en: It's used every day by Salesforce。org's product development teams。 And I don't
    just mean developers。 I mean our QEs， our doc writers， our UX people， our， project
    managers。 even our partners doing implementations or utilizing this。 It's developed
    in a public GitHub repository at SFDO tooling/ Cumulus CI。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Salesforce.org产品开发团队每天使用的工具。我不仅仅指开发人员，我还指我们的质量工程师、文档编写人员、用户体验人员和项目经理，甚至我们的合作伙伴在进行实施或使用这个工具。它在SFDO
    tooling/Cumulus CI的公共GitHub仓库中开发。
- en: And also just in March something I'm really proud of， we worked for a long time
    trying。 to get a learning module together to teach Cumulus CI and how to work
    with it。 So if you're interested in any of the demo content today， I definitely
    recommend going。 out and going through this trail。 Trailhead is Salesforce's free
    online learning system。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 而且就在三月份，我非常自豪的是，我们花了很长时间尝试整理一个学习模块，以教授Cumulus CI及其工作方式。因此，如果你对今天的任何演示内容感兴趣，我强烈建议你去浏览这个学习路径。Trailhead是Salesforce的免费在线学习系统。
- en: So you can go learn about the Salesforce platform， but there's also tons of
    additional。 learning out there just about agile processes and things like that。
    And it really has just a ton of amazing content that's all available for free。
    Now in addition to Cumulus CI， kind of the framework， we built three different
    web applications。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以去学习Salesforce平台，但还有大量关于敏捷流程等方面的额外学习内容。而且它确实有很多精彩的内容，全部免费提供。除了Cumulus CI这个框架，我们还构建了三个不同的Web应用。
- en: that are using Django and Heroku that sit on top of Cumulus CI and extend the
    automation。 in a context that we call portable automation， which I'll explain
    a little bit more later。 The first of those web applications is MetaCI， which
    is a custom CI app that's run on Heroku。 for scalable continuous integration of
    Salesforce projects that are using Cumulus CI。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目使用Django和Heroku，建立在Cumulus CI之上，扩展了自动化。在我们称之为便携式自动化的背景下，我稍后会详细解释。第一个这样的Web应用是MetaCI，它是一个自定义CI应用，运行在Heroku上，支持使用Cumulus
    CI的Salesforce项目的可扩展持续集成。
- en: The reason that we built our own custom CI app is because the needs of Salesforce
    development。 projects are a little bit unique in comparison to most development
    projects where you can。 run your code in a virtual machine or in a Docker container。
    Our builds are actually more client APIs that are installing things into a Salesforce
    instance。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建自定义CI应用的原因是Salesforce开发项目的需求与大多数开发项目相比有些独特，在这些项目中，你可以在虚拟机或Docker容器中运行代码。我们的构建实际上是更多客户端API，正在将东西安装到Salesforce实例中。
- en: And because of that difference， we found that it really made sense to build
    a tailor-made。 CI system specifically for this use case。 We still use other CI
    systems to build our Python projects and things like that because。 they're plentiful。
    But the Salesforce DevOps space was unique enough that it made sense to go ahead
    and build our。 own CI system。 Meta deploy is a customer-facing installer and automation
    tool providing bring-your-own。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正因为这个差异，我们发现为这种用例专门构建一个量身定制的CI系统是合理的。我们仍然使用其他CI系统来构建我们的Python项目，因为它们很多。但Salesforce
    DevOps领域的独特性使得构建我们自己的CI系统是合理的。Meta deploy是一个面向客户的安装程序和自动化工具，提供自带工具的选项。
- en: network access to a project's Cumulus CI automation through a simple web interface。
    Now when I say org here in the Salesforce world， that's how we refer to an instance。
    or a tenant in the Salesforce platform。 So every customer has their Salesforce
    org。 usually a production org。 They have sandboxes off of that。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单的Web界面访问项目的Cumulus CI自动化。当我在Salesforce世界中提到“组织”时，就是指实例或Salesforce平台上的租户。因此，每个客户都有他们的Salesforce组织，通常是一个生产组织，此外还有沙箱。
- en: There's other types of orgs that we'll talk about and show in today's demo。
    But the key thing about Meta deploy is it's about customers being able to bring
    their own。 Salesforce instance and install our products into it。 And all the automation
    necessary to get them installed and configured。 And then the newest tool。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天的演示将讨论其他类型的组织。但Meta部署的关键在于客户能够带入自己的Salesforce实例，并将我们的产品安装到其中，以及安装和配置所需的所有自动化。然后是最新的工具。
- en: which I'm really excited about， that we've been working on， for almost a year
    now。 So therefore。 the coming soon we've been doing some kind of pilot testing
    of this。 But this tool is called Meteko。 And Meteko is designed to empower Salesforce
    admins to contribute to open-source projects。 through clicks， not code， without
    any knowledge of Cumulus CI or GitHub or Python。 They can just。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我对此感到非常兴奋，我们已经为此工作了将近一年。因此，我们一直在进行某种试点测试。这个工具被称为Meteko。Meteko旨在赋能Salesforce管理员通过点击而非代码参与开源项目，而无需了解Cumulus
    CI、GitHub或Python。
- en: through a simple web interface， contribute to projects that are on GitHub。 Using
    the skill set that they built up of doing declarative configuration through Salesforce's。
    web interface。 But get the best of breed combination of that with version control
    based development。 And we'll take a look at all of these apps in our second demo。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单的网页界面，贡献于GitHub上的项目。利用他们通过Salesforce网页界面构建的声明性配置的技能，但与基于版本控制的开发相结合，获得最佳的组合。我们将在第二个演示中查看所有这些应用程序。
- en: So let's talk about our open source community。 In the nonprofit and education
    sectors。 if you've ever had the opportunity of working， with any nonprofits or
    education organizations。 you'll find that there's really an inherent， desire to
    share。 Food banks don't compete with each other。 You know。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈我们的开源社区。在非营利和教育领域。如果你曾有机会与任何非营利或教育组织合作，你会发现他们有一种内在的分享欲望。食品银行之间并不竞争。
- en: a food bank in one county doesn't compete with a food bank in the next county。
    They just want people to be fed。 Pet rescue organizations don't compete with each
    other。 They want pets to be defined good homes。 But the real challenge is how
    to share these kind of technical solutions that are built。 They have a lot of
    power for the organizations that make the investment in building them。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个县的食品银行并不与下一个县的食品银行竞争。他们只想让人们得到食物。宠物救助组织之间也不竞争。他们希望宠物能找到好的家庭。但真正的挑战是如何分享这些技术解决方案，这些解决方案对于投资于构建它们的组织具有很大的价值。
- en: But how do you share those solutions out with others in your sector？
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但你如何与行业内的其他人分享这些解决方案呢？
- en: And our way of addressing that has been creating what we call the Salesforce。org
    open source。 commons。 And the open source commons has two main components to it。
    The first。 as I mentioned before， is we run these open source community sprints。
    Now there were open source community sprints in the Salesforce。org world。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解决方案是创建我们称之为Salesforce.org开源公共社区。开源公共社区有两个主要组成部分。首先，正如我之前提到的，我们举办这些开源社区冲刺。现在在Salesforce.org世界中有开源社区冲刺。
- en: Long before we had the open source commons。 There's a long history going back
    many years。 In fact。 NPSP， our largest open source project with tens of thousands
    of users， originally。 started as a community created open source project that
    we started collaborating with。 the community and putting real investment effort
    behind evolving and developing out that system。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们拥有开源社区之前，这背后有着很长的历史。实际上，NPSP，我们最大的开源项目，有成千上万的用户，最初是一个由社区创建的开源项目，我们开始与社区合作，并投入真正的资源来发展和完善该系统。
- en: So these open source community sprints are two day in person and now in the
    COVID-19 world。 virtual events。 We just had our first open source community sprint。
    It was supposed to be an in person event in Atlanta at the beginning of April。
    But we wound up having to cancel that and switch it to a virtual event。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些开源社区冲刺是为期两天的面对面活动，现在在COVID-19的背景下是虚拟活动。我们刚刚举行了第一次开源社区冲刺。原本计划在四月初在亚特兰大进行面对面活动，但我们不得不取消并转为虚拟活动。
- en: Our virtual event had over a hundred attendees there for two days building some
    really amazing。 solutions。 And it was awesome seeing the energy that was there
    in the room。 And really I think a testament to the passion that exists inside
    of our community。 There are technical and non-technical projects。 So people want
    to build solutions on top of the Salesforce platform that they can release。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的虚拟活动有超过一百名与会者，持续两天，构建了一些非常惊人的解决方案。看到房间里迸发的能量真的很棒，这也证明了我们社区内部存在的热情。项目分为技术性和非技术性，因此人们希望在Salesforce平台上构建可以发布的解决方案。
- en: as a package and other people can install under their instances。 There's also
    people just creating documentation or videos or other ways to help people。 And
    really all of those ideas start as just a brainstorming in a very un-conference
    type。 configuration where people brainstorm and announce the ideas that they have。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个包，其他人可以在他们的实例下安装。还有一些人创建文档或视频，或者其他方式来帮助人们。所有这些想法其实都是从一种非常非正式的会议配置中开始的，人们进行头脑风暴并宣布他们的想法。
- en: People that are interested kind of group up at different round tables around
    the room。 or in different breakout rooms in a virtual event。 And all of these
    projects are developed both a technical and non-technical using GitHub。 repositories
    out on the SFDO community sprints GitHub organization。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些感兴趣的人会在房间周围的不同圆桌上聚集，或在虚拟活动的不同分组房间中。所有这些项目都是通过技术和非技术的方式在GitHub上开发的，存在于SFDO社区冲刺的GitHub组织中。
- en: Now the second part of the open source commons is this program to support community
    run open。 source projects that are sustainable。 And we provide the process and
    the infrastructure to facilitate these community run open source。 projects for
    the nonprofit and education sectors。 The projects have to meet sustainability
    requirements to be accepted。 So it's not just that somebody built something cool。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开源共享的第二部分是支持社区运营的可持续开源项目的程序。我们提供过程和基础设施来促进这些社区运营的开源项目，特别是针对非营利和教育领域。这些项目必须满足可持续性要求才能被接受，因此不仅仅是某人构建了一些酷东西。
- en: It's that there's a team of people that are committed to maintaining the project
    and meeting。 regularly to creating releases as there's new features available，
    reviewing pull requests。 in the GitHub repository。 All of the projects that get
    accepted then get moved into our GitHub organization SFDO。 community which is
    the organization for official open source commons projects。 Salesforce。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一组致力于维护项目的人，他们定期会议以创建新特性可用时的版本，审查GitHub存储库中的拉取请求。所有被接受的项目随后会被移动到我们的GitHub组织SFDO社区，这是官方开源共享项目的组织。
- en: org provides all of our tooling， meta CI， meta deploy and meta go for those。
    open source community projects to be able to manage the kind of packaging and
    the testing。 and all of that at scale with a minimal amount of investment or involvement
    needed from them。 So we really want to lower the bar as much as possible to community
    projects that have。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: org为这些开源社区项目提供所有工具，包括meta CI、meta deploy和meta go，以便他们能够管理打包和测试，并在规模上以最小的投资或参与。我们真的希望尽可能降低社区项目的门槛。
- en: a community behind them but maybe just don't know how to do all of these things
    or some。 of these things without this tooling are really time intensive。 And so
    we don't want that to be a barrier to sharing。 And then finally we facilitate
    getting a Salesforce ISV security review on the packages that are。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 背后有一个社区，但可能只是不知道如何做所有这些事情，或者有些事情在没有这些工具的情况下确实耗时。因此，我们不希望这成为共享的障碍。最后，我们还促进对这些包进行Salesforce
    ISV安全审核。
- en: coming from these projects and getting those packages published and available
    to the Salesforce。 community。 Now we talked about this kind of unique open source
    model and where I see all of this is。 that with the open source commons and the
    potential to tap into this whole community of innovators。 we really have this
    new layer on top of it。 A layer of exponential impact by empowering community
    driven open source solutions to common。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 来自这些项目并将这些包发布到Salesforce社区。我们谈到了这种独特的开源模型，我看到这一切是通过开源共享和潜在利用这一整个创新者社区，我们真的在它之上有了一个新层次。这一层通过赋能社区驱动的开源解决方案实现了指数级的影响。
- en: and sector specific challenges。 And this goes way beyond the engineering capabilities
    of our team no matter how big。 we grew our team to be it could never match what
    our community is capable of doing if。 we're effective at empowering them to do
    it。 Alright so let's shift gears and talk a little bit more technical now and
    let's talk about。 Cumulus CI as this is kind of the core framework and we're going
    to be looking at this throughout。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以及特定领域的挑战。这远远超出了我们团队的工程能力，无论我们将团队发展到多大，都无法与我们的社区在赋能他们时所能做的相匹配。好的，让我们换个话题，稍微谈谈技术方面，让我们讨论
    Cumulus CI，因为这是核心框架，我们将持续关注它。
- en: the demos today。 Now when you think about DevOps for Salesforce I really think
    there's kind of one primary。 challenge and it's a common DevOps challenge of getting
    environments。 But the challenge in Salesforce is a little bit different than most
    other DevOps environments。 in the sense that you can't run any of our code in
    a virtual machine or in a Docker image。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的演示。当您想到 Salesforce 的 DevOps 时，我真的认为有一个主要挑战，这是一个常见的 DevOps 挑战，即获取环境。但 Salesforce
    中的挑战与大多数其他 DevOps 环境略有不同，因为您无法在虚拟机或 Docker 镜像中运行我们的任何代码。
- en: Your Salesforce code or metadata as it's called in the Salesforce world has
    to be deployed。 into an instance or an org of Salesforce running in the cloud。
    And you know for a long time the Salesforce made available developer edition or
    developer。 edition orgs that anybody could go out and fill out a web form get
    a developer edition。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 Salesforce 代码或元数据（在 Salesforce 领域称为元数据）必须部署到运行在云中的 Salesforce 实例或组织中。您知道很久以前
    Salesforce 提供了开发者版或开发者组织，任何人都可以填写网页表单以获取开发者版。
- en: org it was a persistent org you could deploy metadata into it you could create
    data inside。 of it it was always around。 But as we know from general DevOps best
    practices it's really not a good idea to have a persistent。 always there test
    environment or development environment。 Better practices to be able to create
    and destroy them easily。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 组织是一个持久的组织，您可以将元数据部署到其中，可以在其中创建数据，它总是存在。但正如我们从一般的 DevOps 最佳实践中所知，始终存在的测试环境或开发环境并不是一个好主意。更好的做法是能够轻松创建和销毁它们。
- en: So a few years ago Salesforce DX or the Salesforce developer experience was
    a project launched。 by Salesforce and created a command line interface the Salesforce
    CLI which the command is SFDX。 we'll see that here a little bit later。 And it
    made this whole process better by introducing this concept of scratch orgs which
    are temporary。 Salesforce instances that you can provision and destroy via API
    calls。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，Salesforce DX 或 Salesforce 开发者体验是 Salesforce 启动的一个项目，创建了一个命令行界面 Salesforce
    CLI，其命令为 SFDX。稍后我们将在这里看到它。它通过引入临时的 scratch orgs 改进了整个过程，这些 scratch org 是您可以通过
    API 调用配置和销毁的临时 Salesforce 实例。
- en: The thing about scratch orgs is they start from sort of an org shape which is
    a JSON。 file where you define the Salesforce edition the features and the settings
    that you want。 to have in your Salesforce org。 But that's not really setting up
    anything that's project specific that's kind of just。 which bits are on in the
    base Salesforce system。 But Salesforce has kind of a platform for custom development
    what these projects are。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 scratch orgs 的一点是，它们从一种 org 形状开始，这是一种 JSON 文件，您可以在其中定义 Salesforce 版、功能和您希望在
    Salesforce 组织中拥有的设置。但这并没有真正设置任何项目特定的内容，仅仅是定义基础 Salesforce 系统中哪些功能是启用的。Salesforce
    还提供了一个用于自定义开发的平台。
- en: focused on is building custom solutions on top of what Salesforce has built。
    And to be able to do that you really need to be able to have automation that can
    build。 you usable scratch org environments for development and QA。 And that requires
    installing other packages deploying metadata into your instance and also。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们专注于在 Salesforce 建立的基础上构建自定义解决方案。为了做到这一点，您真的需要能够自动化构建可用于开发和 QA 的 scratch org
    环境。这需要安装其他软件包，将元数据部署到您的实例中。
- en: loading data so that when a tester goes in to get an environment from a feature
    branch。 the environment that they get just by running the automation is actually
    fully ready for。 them to start testing。 And that's really the core of the challenge
    that Cumulus CI was built to provide a framework。 for orchestrating all of those
    changes on a project by project basis in a highly configurable， way。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 加载数据，这样当测试人员从功能分支获取环境时，他们通过运行自动化得到的环境实际上是完全准备好的，以便开始测试。这正是 Cumulus CI 构建的核心挑战，为每个项目提供一个高度可配置的框架，以协调所有这些变化。
- en: So let's take a quick look at the structure of Cumulus CI and sort of how it's
    set up。 There are four main parts to Cumulus CI which is a Python package that
    we build。 It's available on PyPy you can install it with pip install Cumulus CI。
    And the first component of Cumulus CI is the Cumulus CI。yaml file。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看看 Cumulus CI 的结构及其设置。有四个主要部分，Cumulus CI 是我们构建的一个 Python 包。它可以在 PyPy 上获取，你可以通过
    `pip install Cumulus CI` 安装。Cumulus CI 的第一个组件是 Cumulus CI.yaml 文件。
- en: Cumulus CI is a very configuration driven framework and all of the configuration
    gets。 mapped through this Cumulus CI。yaml file。 The base Cumulus CI。yaml file
    makes up what we call the global configuration and has all。 of the best practice
    defaults that we find helpful across most every project。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Cumulus CI 是一个非常依赖配置的框架，所有配置通过这个 Cumulus CI.yaml 文件进行映射。基础的 Cumulus CI.yaml
    文件构成我们所称的全局配置，并包含我们在大多数项目中发现的所有最佳实践默认值。
- en: Then the second component is Cumulus CI's keychain which is its credential store。
    It stores credentials， OAuth connections to persistent Salesforce orgs。 And also
    has the ability to interact with Salesforce DX to spin up scratch orgs and delete。
    scratch orgs。 And then also has the ability to store third party service credentials
    to things like the。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个组件是 Cumulus CI 的钥匙链，即其凭证存储。它存储凭证、持久 Salesforce 组织的 OAuth 连接，并具备与 Salesforce
    DX 交互的能力，以创建和删除临时组织。
- en: GitHub API that you might need when you're writing your automation for your
    projects。 The third part of Cumulus CI is tasks。 And really tasks are kind of
    the bulk of everything that Cumulus CI does。 We've got a bunch of different tasks
    you can see listed here for all sorts of different。 things that we find helpful
    throughout the development process。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub API 是你在为项目编写自动化时可能需要的。Cumulus CI 的第三部分是任务。任务实际上是 Cumulus CI 所做工作的主要部分。我们有很多不同的任务，你可以在这里看到，涵盖了开发过程中我们认为有用的各种事项。
- en: And tasks are the basic unit of work in Cumulus CI's automation。 And then on
    top of tasks are flows。 Flows are sequences that ultimately reduce down to tasks。
    Flows can call other flows but ultimately that reduces down to a sequential list
    of tasks。 And Cumulus CI ships with a number of flows out of the box by default
    that we find helpful。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 任务是 Cumulus CI 自动化中的基本工作单位。任务之上是流程。流程是最终简化为任务的序列。流程可以调用其他流程，但最终都会减少为一个顺序的任务列表。Cumulus
    CI 默认随附许多我们认为有用的流程。
- en: in almost any Salesforce development project。 So flows like the Dev Workflow
    and the QA org flow which respectively get you a fully。 configured scratch org
    ready to start doing development work or a fully configured scratch。 org ready
    to start doing QA work。 There's also flows for testing kind of the managed version。
    If you're building a managed package， we'll talk about that a little bit later。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在任何 Salesforce 开发项目中都可以使用。因此，像开发工作流和 QA 组织流这样的流程，分别可以让你获得一个完全配置好的临时组织，准备开始开发工作，或者一个完全配置好的临时组织，准备开始
    QA 工作。还有用于测试管理版本的流程。如果你在构建一个管理包，我们稍后会谈到这个。
- en: To kind of build the kind of release side where the customer environment is
    going to look， like。 There's some flows that we provide for running in CI systems
    like CI feature which is a flow。 for testing feature branches。 And then also flows
    for automating release management processes to create a new beta。 release or a
    new production release of a package。 Now as a configuration driven system。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为构建客户环境的发布侧提供一些流程，类似于 CI 特性，这是一个用于测试功能分支的流程。还有用于自动化发布管理过程的流程，以创建新的测试版本或新版本包。作为一个基于配置的系统。
- en: all of these tasks in Cumulus CI are defined in the， cumulus CI。yaml file in
    the global configuration file。 So here's an example of what the deploy task looks
    like for deploying metadata。 And you can see that it's defaulted the task specific
    option path to the directory called， SRC。 All of these tasks can define their
    own custom task options。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Cumulus CI 中的所有任务都在 cumulus CI.yaml 文件的全局配置文件中定义。这里是一个关于部署元数据的部署任务的示例。你可以看到，它将任务特定选项路径默认为名为
    SRC 的目录。所有这些任务可以定义自己的自定义任务选项。
- en: So we try to make it a very declarative driven system。 Most people that are
    using Cumulus CI don't know anything about Python。 But they can do a ton of customization
    of how Cumulus CI works just by modifying these。 YAML or the YAML syntax。 The
    other thing that's important about the options in this YAML syntax is we like
    to。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们努力使其成为一个非常声明式驱动的系统。使用 Cumulus CI 的大多数人对 Python 一无所知。但他们可以通过修改这些 YAML 或 YAML
    语法来大量自定义 Cumulus CI 的工作方式。关于这个 YAML 语法中的选项，另一件重要的事情是我们喜欢。
- en: bake all of the options into the project's configuration。 So you're not having
    to remember a whole bunch of command line flags when you go to。 run the different
    automation。 Now likewise flows are defined in YAML。 Flow definition is really
    simple。 It's just steps with numbered slots。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有选项整合到项目的配置中。因此，当你运行不同的自动化时，就不必记住一堆命令行标志。同样，流程是在 YAML 中定义的。流程定义非常简单。它只是带有编号插槽的步骤。
- en: And flows can call other flows or they can call a task。 So in this case， to
    set up a dev work。 we've got to run the dependencies flow， run the deploy， unmanaged
    flow。 which will get kind of the source code for our project deployed， and then，
    run the config_dev flow。 which will configure our environment for development
    use。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 流程可以调用其他流程或任务。因此，在这种情况下，为了设置开发工作，我们必须运行依赖流程，运行部署、未管理流程，这将获得我们项目的源代码进行部署，然后运行
    config_dev 流程，为我们的开发环境配置。
- en: And then finally called the task snapshot changes to reset the source tracking
    so that。 we can kind of track everything that we do from that point forward。 Now
    obviously every project is going to have different needs for what it means to
    get a。 dev work or a QA work。 And that's where Cumulus CI's project configuration
    comes in。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后最后调用任务快照更改，以重置源跟踪，以便我们能够跟踪从那时起我们所做的所有事情。显然，每个项目对于什么是开发工作或 QA 工作都有不同的需求。这就是
    Cumulus CI 项目配置的作用。
- en: So in the GitHub project repository， there's also a cumulus CI。yaml file。 That
    file gets parsed into a dictionary and then we do a dictionary merge on top of
    Cumulus。 CI's global configuration。 So the only thing that goes in the cumulus
    CI。yaml file in a project is overrides and， extensions of the global configuration。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 项目存储库中，还有一个 cumulus CI.yaml 文件。该文件会被解析为一个字典，然后我们在 Cumulus CI 的全局配置上进行字典合并。因此，项目中的
    cumulus CI.yaml 文件中唯一包含的是对全局配置的覆盖和扩展。
- en: So you might have new custom tasks that you've written。 You might have new custom
    flows that you've written。 You might have dependencies that you need to your project
    that you need to be able to， define。 So what that might look like if， for instance，
    this is actually a sample from the nonprofit。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可能有新编写的自定义任务。你可能有新编写的自定义流程。你可能有需要定义到你项目中的依赖关系。这看起来可能像是，举例来说，这是一个来自非营利组织的示例。
- en: success pack repository that shows how NPSP is modifying the config dev flow，
    which as。 we saw just a minute ago， which as we saw just a minute ago， presenting
    from home， it's， lovely。 is a flow that runs in step three of the dev work flow。
    So this config dev flow in the global configuration of cumulus CI normally just
    has a single。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 成功包存储库展示了 NPSP 如何修改配置开发流程，正如我们刚刚看到的，从主页呈现时，这是一个很好的流程。这个配置开发流程在 Cumulus CI 的开发工作流第三步中运行。因此，这个配置开发流程在
    Cumulus CI 的全局配置中通常只有一个。
- en: it normally just has two steps in it。 So in this case。 this project's adding
    three additional steps onto the end of the flow。 So every dev work is going to
    have these steps run against it automatically。 So the projects overrides of the
    configuration of cumulus CI's default configuration is really。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常只有两个步骤。所以在这种情况下，这个项目在流程的末尾添加了三个额外的步骤。因此，每个开发工作将自动运行这些步骤。因此，项目对 Cumulus CI
    默认配置的覆盖实际上是。
- en: what we mean when we talk about the portable automation for cumulus CI。 It's
    all the automation needs of the project defined in the abstract。 And then on top
    of that。 we build client applications like CCI， our command line interface， for
    accessing running tasks。 running flows， creating scratch words。 And then also
    our web applications are clients of this framework。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论cumulus CI的可移植自动化时，我们指的是项目中所有自动化需求的抽象定义。在此基础上，我们构建了客户端应用程序，如CCI，我们的命令行接口，用于访问运行任务、执行流程、创建临时工作。我们的Web应用程序也是该框架的客户端。
- en: They're clients of the portable automation defined for each individual project。
    So Metacie uses a project's portable automation defined in the cumulus CIAM file
    to go run。 flows to run builds， triggered by GitHub web hooks or manually by a
    user。 Metadploy， likewise。 is just running cumulus CI tasks but against a customer
    org where。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是为每个单独项目定义的可移植自动化的客户端。因此，Metacie使用cumulus CIAM文件中定义的项目可移植自动化来运行流程、构建，这些可以由GitHub
    web hooks触发或由用户手动触发。类似地，Metadploy只是针对客户组织运行cumulus CI任务。
- en: they've granted access through OAuth。 And that allows us to really service all
    the potential users of this automation。 So automation is not really something
    just for your Jenkins system。 It's something that your developers need to run
    locally or QA people need to run locally。 or doc writers， your product managers，
    your implementation partners and ultimately even。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 他们通过OAuth授予了访问权限。这使我们能够真正为所有潜在的自动化用户提供服务。因此，自动化并不仅仅是为您的Jenkins系统而设。它是开发人员需要在本地运行的东西，或QA人员需要在本地运行的东西，或文档撰写者、产品经理、实施合作伙伴，最终甚至是。
- en: your customers。 So that's the general introduction to cumulus CI。 And I do want
    to take a quick minute just to call out some of the Python projects that。 we're
    using in cumulus CI。 I thought a lot thinking about this session of how would
    I answer the question of why。 do we build cumulus CIAM Python？ And to be honest。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您的客户。因此，这就是cumulus CI的一般介绍。我想花一点时间提到一些我们在cumulus CI中使用的Python项目。我考虑了很久，思考如何回答“为什么我们构建cumulus
    CI用Python”这个问题。老实说。
- en: there was definitely an aspect of personal bias in it。 I come from a Python
    background。 It was something that I knew and it was easy to get this project bootstrap
    using it。 But in addition to that， cumulus CI has leveraged a lot of what's amazing
    about Python in the。 Python community。 So we use applications like click for building
    CCI， the command line interface。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这其中确实有个人偏见的因素。我来自Python背景。这是我熟悉的内容，使用它启动这个项目很简单。但除此之外，cumulus CI还利用了Python社区中许多优秀的特性。因此，我们使用像click这样的应用程序来构建CCI，即命令行接口。
- en: We're using Faker for test data generation。 We're using GitHub 3。py for interacting
    with the GitHub API。 We're using GINDA2 for templatize configuration files。 The
    request framework obviously gets lots of heavy use as we're making a lot of different。
    API calls。 We're using robot framework and the robot framework Selenium library
    to build a really。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Faker来生成测试数据。我们使用GitHub 3.py与GitHub API进行交互。我们使用GINDA2来模板化配置文件。请求框架显然被大量使用，因为我们进行许多不同的API调用。我们使用robot
    framework和robot framework Selenium库来构建一个真正的。
- en: rich Selenium testing framework for self-force development projects。 We have
    an additional library that we built for robot framework that provides a bunch。
    of keywords for driving the UI and interacting with the APIs of a Salesforce instance。
    There's also the Salesforce bulk library that interacts with the Salesforce bulk
    API for， querying。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 针对自我开发项目的丰富Selenium测试框架。我们为robot framework构建了一个附加库，提供了一系列关键词，用于驱动用户界面并与Salesforce实例的API进行交互。还有与Salesforce批量API交互的Salesforce批量库，用于查询。
- en: inserting， updating， and deleting records。 We're using Sarge for subprocess
    callouts。 We're using simple Salesforce for interaction with the Salesforce REST
    API and SQL alchemy。 for our functionality that can capture and load datasets
    to and from Salesforce org。 Now giving back to that whole community， I want to
    kind of briefly introduce one of。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 插入、更新和删除记录。我们使用Sarge进行子进程调用。我们使用simple Salesforce与Salesforce REST API进行交互，并使用SQL
    alchemy来捕获和加载数据集进出Salesforce组织。现在，回馈整个社区，我想简要介绍一下。
- en: our newest open source tool， which is called Snowfakery。 And unlike all the
    other stuff that we've been talking about， Snowfakery is a tool that。 you can
    use immediately。 And you don't have to be using Salesforce at all in order to
    use Snowfakery。 Snowfakery is a declarative framework for fake relational data
    generation。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最新的开源工具叫做 Snowfakery。与我们谈论的其他所有东西不同，Snowfakery 是一个你可以立即使用的工具。你根本不需要使用 Salesforce
    就可以使用 Snowfakery。Snowfakery 是一个用于生成虚假关系数据的声明性框架。
- en: And it's capable of it has plugins to faker。 You can write all sorts of customer
    routines in it。 randomize data and stuff like that。 You can use it to generate
    small datasets。 You can have a description of a dataset shape and then say， give
    me a million of those records。 So you can generate large volumes of data and it
    just writes into a relational database。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有对 faker 的插件。你可以在其中编写各种客户例程，随机生成数据等等。你可以用它生成小型数据集。你可以描述一个数据集的形状，然后说，给我一百万条记录。所以你可以生成大量数据，它直接写入关系数据库。
- en: because behind in the back end it's using SQL alchemy。 So it should work with
    anything that SQL alchemy works with。 We have tested it internally with SQLite
    and PostgreSQL。 Now if you are using Humilis CI and doing a Salesforce development
    project， Snowfakery。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在后端它使用 SQLAlchemy。所以它应该与任何 SQLAlchemy 能够处理的东西一起工作。我们已经在内部使用 SQLite 和 PostgreSQL
    进行了测试。如果你正在使用 Humilis CI 并进行 Salesforce 开发项目，Snowfakery。
- en: plugs in with Cumilis CI's bulk API tasks to be able to populate Salesforce
    orgs with。 the data that's generated from these definition files。 That sounds
    interesting to you。 Definitely go check out the repository SFDO tooling， Snowfakery。
    There's great documentation and really great examples in there that kind of show
    all of。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Cumilis CI 的批量 API 任务可以与之连接，以便填充 Salesforce 组织。生成的数据来自这些定义文件。听起来对你很有趣。一定要去查看
    SFDO 工具库，Snowfakery。里面有很棒的文档和示例，可以展示所有内容。
- en: the power of this framework。 Now let's jump into our demos。 This is the part
    that I'm most excited about getting hands-on with this tooling and showing。 you
    what you can do。 Alright so for our first demo we're going to show how to start
    a Salesforce development。 project using Cumilis CI。 Now why would you want to
    do this as a Python developer？
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架的强大之处。现在让我们进入演示部分。这是我最兴奋的部分，亲自体验这个工具并向你展示你可以做什么。好的，在我们的第一个演示中，我们将展示如何使用
    Cumilis CI 开始 Salesforce 开发项目。作为 Python 开发人员，你为什么想这样做呢？
- en: Kind of two reasons。 First it's pretty cool that we built all of this stuff
    using Python。 But say you're a Python web application developer and you build
    a web application that collects。 information from your users and your users might
    be organizations or companies that might。 use Salesforce as their CRM system。
    And you start getting requests to integrate data from your application with Salesforce。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有两个原因。首先，我们用 Python 构建了所有这些东西，真是很酷。但是假设你是一名 Python 网络应用程序开发人员，你构建了一个收集用户信息的网络应用程序，而你的用户可能是使用
    Salesforce 作为其 CRM 系统的组织或公司。你开始接到请求，将你的应用程序中的数据与 Salesforce 集成。
- en: Well if you're going to integrate data from your application， probably there's
    some specific。 schema to that application。 And we're going to talk a lot about
    schema here。 And if you want to integrate that data with Salesforce， you're going
    to need to create。 the schema in Salesforce。 So these first two parts are really
    getting these first two demos are going to show you。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要从你的应用程序集成数据，可能会有一些特定的架构。我们将在这里详细讨论架构。如果你想将这些数据与 Salesforce 集成，你需要在 Salesforce
    中创建架构。所以这前两部分实际上是为了展示这两个演示。
- en: how you would go about creating schema， packaging it up and making it available
    for your customers。 to install into their Salesforce instance so that you can
    get the plumbing in place for。 your integration。 And then in the third demo we'll
    take a look at actually building an integration like that。 as an example。 So for
    this first demo we're going to get a project started just to show you what it's。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你将如何创建架构，打包并让客户可以安装到他们的 Salesforce 实例中，以便为你的集成建立管道。在第三个演示中，我们将看看实际构建这样的集成作为示例。所以在第一个演示中，我们将开始一个项目，仅仅是为了展示它的内容。
- en: like to do development with Kimul C。I。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢与 Kimul C。I。进行开发。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_3.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_3.png)'
- en: And I'm going to go ahead and jump over to Visual Studio Code。 Now I already
    have CCI。 the command line interface for Kimul C。I。 installed here。 I've got a
    couple of other tools set up and configured SFDX in particular which is the。 Salesforce
    CLI。 In our Kimul C。I。 trailhead trail。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我将跳转到 Visual Studio Code。我已经安装了 Kimul C.I. 的命令行界面。这里还有其他工具的设置，特别是配置了 SFDX，也就是
    Salesforce CLI。在我们的 Kimul C.I. Trailhead 课程中。
- en: the second module walks through all the setup instructions。 for this if you
    want to actually do this on your own computer。 So the first thing that I'm going
    to do is make a directory called PyCon demo。 I'm going to change into that directory。
    And then I'm going to initialize it as a Git repository。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个模块介绍了所有的设置说明，如果你想在自己的电脑上实际执行这些操作。首先，我将创建一个名为 PyCon demo 的目录。我将进入该目录，然后初始化为
    Git 仓库。
- en: Kimul C。I。 is designed to work inside of Git repositories。 And then I'm going
    to run this command。 CCI project init， which is going to initialize， my project。
    I'm going to provide it some basic values here。 The name of the project。 The package
    name which is what the package will look like in Salesforce org。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Kimul C.I. 旨在在 Git 仓库内工作。接下来我要运行这个命令：`CCI project init`，它将初始化我的项目。我将提供一些基本值，比如项目名称和在
    Salesforce 组织中显示的包名称。
- en: I'm going to go ahead and say that I want to make a manage package out of this
    project。 Manage packages in Salesforce have a globally unique namespace assigned
    to them。 Everybody can create a Salesforce developer edition org and go reserve
    one of those namespaces。 And that's your namespace。 That org becomes essentially
    the packaging org where you can upload packaged versions。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续表示我希望将这个项目制作成管理包。Salesforce 中的管理包有一个全球唯一的命名空间分配给它们。每个人都可以创建一个 Salesforce
    开发者版本的组织并去预留其中一个命名空间。那就是你的命名空间。这个组织本质上成为打包组织，你可以上传打包版本。
- en: of whatever customizations that you built。 And I will use the latest Salesforce
    API version。 I'm going to use， we have two different source format options。 I'll
    use SFDX source format。 which is the newer source format。 It's a little bit more
    friendly to work with。 And in this case。 we're building a standalone project。
    But I mentioned earlier that key millisci in projects can define dependencies。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你构建了什么自定义内容。我将使用最新的 Salesforce API 版本。我们有两种不同的源格式选项。我将使用 SFDX 源格式，这是较新的源格式，更易于使用。在这种情况下，我们正在构建一个独立项目。但我之前提到的，key
    millisci 项目可以定义依赖关系。
- en: So say you wanted to build something on top of NPSP or EDA， our open source
    projects for。 education and nonprofit。 You could just say yes here and then it
    would give you a menu of options where you could。 tell it。 I want NPSP installed
    in all of my environments automatically。 It's pretty easy to do in the Python
    world with PIP。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说你想在 NPSP 或 EDA 上构建一些东西，我们的教育和非营利开源项目。你可以在这里简单地回答“是”，然后它会给你一个选项菜单，你可以告诉它我希望在所有环境中自动安装
    NPSP。在 Python 世界中，使用 PIP 这非常简单。
- en: It's a lot more challenging to do in the Salesforce world and kind of one of
    the unique features。 that key millisci I hope solve for。 And I'm going to accept
    the default branch and tag naming conventions for the project。 And when I'm done，
    go ahead and just add this project to my workspace here。 All right。 So I've got
    this project added in my workspace and it's created a whole bunch of skeleton，
    for me。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Salesforce 世界中，这更具挑战性，也是 key millisci 希望解决的独特功能之一。我将接受项目的默认分支和标签命名约定。当我完成后，继续将这个项目添加到我的工作区。好的，我在工作区中添加了这个项目，并为我创建了许多骨架。
- en: And the first thing that we want to look at is the key millisci yaml。 You can
    see it's only 20 lines of code or of configuration because it's inheriting all。
    of the configuration from key millisci's global config。 So all of the tasks that
    are available in key millisci's global config。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要查看的第一件事是 key millisci yaml。你可以看到它只有 20 行代码或配置，因为它继承了 key millisci 的全局配置的所有内容。所以
    key millisci 全局配置中可用的所有任务。
- en: I'm going to type the command rate。 And then the key millisci task list on the
    command line will list off all the different。 tasks that are available。 You can
    see there's a ton of them grouped by interactions with GitHub。 data operations，
    interactions with Salesforce DX， a bunch of Salesforce specific automation。 integration，
    with packaging and things like that。 There's a ton in that list that's already
    available。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我将输入命令rate。然后命令行上的key millisci任务列表将列出所有可用的不同任务。你可以看到，有很多任务按与GitHub的交互、数据操作、与Salesforce
    DX的交互以及一系列Salesforce特定的自动化、集成和打包等分组。在这个列表中，有很多已经可用。
- en: And then also I have all of my flows that come in the global configuration of
    key millisci。 with the dev org and the QA org flow。 I can get information about
    the dev org flow by using CCI flow info dev。 And this will show me the dependencies
    flow， but then also the tasks that are contained inside。 of that。 So we're going
    to install the dependencies and then deploy the package source code。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我还有所有在key millisci的全局配置中的流程，包括dev org和QA org流程。我可以通过使用CCI flow info dev获取dev
    org流程的信息。这将向我展示依赖流程，以及其中包含的任务。所以我们将安装依赖项，然后部署包源代码。
- en: You'll notice these are GINDA2 style GINDA2 expressions for creating conditional
    steps， in a flow。 And then run the config dev flow。 Now the last thing that key
    millisci is provided out of the box for me is a default setup for。 five different
    types of scratch orgs。 Configurations were different types of orgs that we find
    helpful throughout the development。 process。 These are lazy configurations， so
    they're grayed out because they haven't been woken up。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这些是GINDA2风格的GINDA2表达式，用于在流程中创建条件步骤。然后运行配置dev流程。现在key millisci为我提供的最后一件事是五种不同类型临时组织的默认设置。不同类型组织的配置，在开发过程中我们发现很有帮助。这些是懒惰配置，所以它们被灰显，因为它们还没有被唤醒。
- en: You have to run something against them in order to wake them。 So let's go ahead
    and run something against them。 We'll run the dev org flow against the org configuration
    named dev。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须对它们运行某些东西以唤醒它们。所以让我们继续对它们运行一些东西。我们将针对名为dev的组织配置运行开发组织流程。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_5.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_5.png)'
- en: And this will kick off and basically when this is done， I will have a fully
    configured。 development environment for my project。 Now this command， CCI flow
    run dev org minus minus org dev。 is the exact same command that， you run in any
    QMLCI project to get a dev org。 It's the project's job to extend and override
    anything that it needs to in the QMLCI YAML。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动，当这完成时，我将拥有一个完全配置的项目开发环境。现在这个命令，CCI flow run dev org minus minus org dev。是你在任何QMLCI项目中获取dev
    org时运行的完全相同的命令。这个项目的工作是扩展和重写在QMLCI YAML中需要的任何内容。
- en: to make that into a usable development environment。 But it makes it really easy
    for users working across multiple different projects to have。 that consistency。
    So you only have to remember a handful of commands really to use most of the power
    of QMLCI。 So you'll see in the start here that it called out to Salesforce DX
    force org create and passed。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将其变成可用的开发环境。但这让跨多个不同项目的用户保持一致性变得非常简单。所以你只需要记住少量命令就能使用QMLCI的大部分功能。因此，你会在开始时看到它调用了Salesforce
    DX force org create并传递了。
- en: it a configuration file， this orgs dev。json file。 This is the scratch org definition
    file that defines the org shape that we want it to generate。 So I want to develop
    a developer edition Salesforce instance。 I want these different settings enabled
    in the org by default。 And close that file。 it looks like that flow has now completed。
    I scroll down to the bottom now。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个配置文件，即该组织的dev.json文件。这是定义我们希望生成的组织形状的临时组织定义文件。所以我想开发一个开发者版的Salesforce实例。我希望这些不同的设置在组织中默认启用。然后关闭该文件。看起来这个流程现在已经完成。我现在滚动到最底部。
- en: I can jump into that org with running CCI org browser。 And this will go open
    up that Salesforce instance that was just created for me on the fly。 Now all of
    this， this is available to you free of charge。 You don't have to pay any licenses
    to be able to use this if you want to get in and kind。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以通过运行CCI org browser跳入该组织。这将打开为我即时创建的Salesforce实例。现在所有这些对你都是免费的。你不必支付任何许可证就能使用这些，如果你想要进入并进行。
- en: of play around and try some development on top of Salesforce。 Now before we
    jump in and actually build some things there， I want to show one other。 thing
    real quick because I mentioned that we've built this integration with that in
    line。 All right。 so we built this integration with robot framework and I want
    to show briefly。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Salesforce 上进行一些开发。在我们实际开始构建一些东西之前，我想快速展示另一件事，因为我提到我们已经与它建立了集成。好的，我们建立了与 Robot
    框架的集成，我想简要展示一下。
- en: what one of these tests look like。 When we initialize a cumulistii project at
    first。 we build your first regression test case， which is testing to make sure
    that nothing you do breaks the ability to create a contact。 which is kind of core
    in Salesforce。 And so if you've seen Robot before。 you'll recognize some of this。
    If you haven't， it's a pretty simple keyword-driven testing framework based in
    Python。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试的样子是什么。当我们首次初始化一个 cumulistii 项目时，我们构建你的第一个回归测试用例，目的是确保你所做的任何事情不会破坏创建联系人的能力，这在
    Salesforce 中是非常核心的。因此，如果你之前见过 Robot，你会认出其中的一些内容。如果没有，这其实是一个基于 Python 的相当简单的关键字驱动测试框架。
- en: Robot keywords are effectively just a Python method behind the scenes。 And in
    the settings section。 we load in some resource libraries that come from cumulistii。
    This Salesforce。Robot resource is actually pulling in our library of keywords
    for driving。 the browser through the Salesforce UI。 This via the API test is using
    Faker to generate some fake first and last names using our Salesforce。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Robot 关键字实际上就是在幕后运行的 Python 方法。在设置部分，我们加载一些来自 cumulistii 的资源库。这个 Salesforce.Robot
    资源实际上引入了我们用于通过 Salesforce UI 驱动浏览器的关键字库。这个 API 测试使用 Faker 生成一些假的名字和姓氏，使用我们的 Salesforce。
- en: insert keyword and Salesforce get keyword to go create and then query a contact。
    And then it's using a custom defined keyword here in this test case later in the
    file to。 validate the contact。 Now it gets more fun when you get into the Selenium
    side when you do it via the UI。 You use our page object keywords， go to page，
    home for the object contact， click the object。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 插入关键字和 Salesforce 获取关键字以去创建并查询一个联系人。然后它在文件后面的测试用例中使用一个自定义定义的关键字来验证联系人。当你通过 UI
    进行时，进入 Selenium 方面就会变得更加有趣。你使用我们的页面对象关键字，去页面，联系人的主页，点击对象。
- en: button new， wait for the new contact modal to pop up， and then populate the
    form using。 the form labels that appear there。 First and last name using our fake
    first and last name above。 hit save， etc。 And then on validate contact， we want
    to go validate in the UI and in the API。 So I can run this whole suite of tests
    that got created for me automatically by running。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮新建，等待新的联系人模态弹出，然后使用出现的表单标签填充表单。使用我们上面生成的假名字和姓氏。点击保存，等等。然后在验证联系人时，我们想要在 UI
    和 API 中进行验证。因此，我可以运行这整套自动为我创建的测试。
- en: the task named robot in cumulistii。 This will run all the dot robot files under
    your test directory in the project。 It should open up a new browser and remember
    the first test is going to go through the， API。 So what it's doing here is it's
    already created the contact through the API and now it's going。 to come up in
    the old UI for some reason。 So it's created the contact through the API and now
    it should go and that test failed。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 cumulistii 中命名为 robot 的任务。这将运行项目中测试目录下的所有 .robot 文件。它应该会打开一个新的浏览器，并且记住第一个测试将通过
    API 进行。因此，它在这里所做的是，它已经通过 API 创建了联系人，现在出于某种原因，它将会在旧的 UI 中出现。因此，它通过 API 创建了联系人，现在测试失败了。
- en: Alright， something to look at。 So but that gives you a general idea of the ability
    that we built in to be able to build。 browser tests on the Salesforce side of
    the work that you're doing there which is really。 really handy to have those automated
    test suites。 Now I'm going to go ahead back into that scratch org here。 Switch
    over to lightning experience， the new UI and in setup， I want to go start creating。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，有一些可以查看的内容。因此，这给了你一个关于我们构建的能力的一般想法，以便能够在你在 Salesforce 上工作的过程中构建浏览器测试，这真的非常方便，有这些自动化测试套件。现在我将回到那个
    scratch org。切换到 Lightning 体验，新 UI 中的设置，我想开始创建。
- en: the schema。 And the use case that we want to go through here is for a food bank
    to be able to track。 deliveries。 So I'm going to create a custom object or a table
    or a model in systems you might be。 familiar with working with and I'm going to
    create an object called delivery， select， some options。 I want to be able to do
    reports and activities on it。 I want to launch a new custom tab wizard。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 架构。我们希望在这里经过的用例是食品银行能够跟踪交付。因此，我将创建一个自定义对象或表，或您可能熟悉的模型，我将创建一个名为交付的对象，选择一些选项。我希望能够对此进行报告和活动。我想启动一个新的自定义标签向导。
- en: Tabs are the tabs over the top in the Salesforce interface and they generally
    relate to an individual。 model and inside that tab you can work with the records
    of that model。 So to do this。 I've got to select an icon for it。 I'll pick the
    truck icon because it's for deliveries and there's a bunch of configuration。 I
    can do here。 I can pick what profiles this tab is visible and what applications
    which are just grouping。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是 Salesforce 界面顶部的标签，通常与单个模型相关，您可以在该标签内处理该模型的记录。因此，为此，我需要选择一个图标。我将选择卡车图标，因为它是用于交付的，还有很多配置可以在这里进行。我可以选择哪些配置文件可以看到这个标签，以及哪些应用程序只是分组。
- en: of tabs mostly。 You can come in and configure this but for the sake of demo。
    I'm just going to kind of， go through and accept a lot of the defaults here。 Now
    I've just created a new object called delivery。 That delivery object has a few
    kind of auditing related fields automatically on it。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 主要是标签。您可以进入并配置，但为了演示的目的，我只会通过接受很多默认设置。现在我刚刚创建了一个名为交付的新对象。该交付对象自动具有一些审计相关的字段。
- en: And now I want to go ahead and add a couple of fields here。 The first field
    that I'm going to add is a pick list field。 We want to track the status of the
    delivery。 I can enter in values here。 So scheduled。 delivered and canceled。 All
    right。 Save。 Then let's add in one more here as a look up to the account object
    in Salesforce which。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我想在这里添加几个字段。我将添加的第一个字段是下拉列表字段。我们希望跟踪交付的状态。我可以在这里输入值，比如预定、已交付和已取消。好的，保存。然后让我们再添加一个，作为
    Salesforce 中帐户对象的查找。
- en: is one of the standard objects in Salesforce to use for tracking a company or
    an organization。 And I want to call this supplier。 Again， lots of configuration
    you can do in each of these different fields but we're just。 going to try to create
    something quickly here。 And in addition to the deliveries。 I really want to get
    more value out of this by tracking， the individual items in a delivery。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 是 Salesforce 中用于跟踪公司或组织的标准对象之一。我想称之为供应商。同样，您可以在这些不同字段中进行很多配置，但我们只是想快速创建一些东西。除了交付外，我真的想通过跟踪交付中的单个项目来获得更多价值。
- en: So let's say create an item called delivery item and give it a plural name of
    delivery， items。 Go ahead and change this to an auto number field。 Give it a format
    for the auto number。 We do want to allow reports。 Let's skip over activities on
    this one and we're not going to create a custom tab for。 this because we want
    this to be kind of a related record of the delivery itself。 All right。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们假设创建一个名为交付项的项目，并给予它复数名称交付项。继续将其更改为自动编号字段。为自动编号提供一个格式。我们确实希望允许报告。让我们跳过这个活动，因为我们不打算为此创建自定义标签，因为我们希望它成为交付本身的相关记录。好的。
- en: So then in the fields relationship or fields and relationships， let's just create
    to a long。 text area or description of the item。 And then we also need to build
    the relationship。 And in this case， we'll do a master detail relationship。 That's
    the equivalent of like a foreign key field。 It's a required relationship。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在字段关系或字段和关系中，让我们创建一个长文本区域或项目的描述。然后我们还需要建立关系。在这种情况下，我们将做一个主详细关系。这相当于外键字段。它是一个必需的关系。
- en: And we want a master detail relationship to the delivery。 So no delivery items
    can exist without a delivery that brought them。 Except the defaults there。 Next，
    next and save。 All right。 So we've created these two objects really quickly。 just
    kind of clicks not code in the， Salesforce instance。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望与交付建立主详细关系。因此，没有交付就无法存在交付项。除了默认设置。接下来，接下来，保存。好的，我们真的很快就创建了这两个对象，实际上只是点击而不是编码，在
    Salesforce 实例中。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_7.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_7.png)'
- en: Now let's jump back into Cumulus CI and show how we capture that into version
    control。 So go ahead and collapse that down。 Close this robot test。 Just a little
    bit more room on the command line here。 And to do this。 we're going to use a task
    in Cumulus CI called list_changes。 And actually before I do that。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到 Cumulus CI，看看我们如何将其捕捉到版本控制中。请将其折叠。关闭这个机器人测试。这里在命令行上留出一点空间。为此，我们将使用 Cumulus
    CI 中的一个任务，名为 list_changes。在我这样做之前。
- en: I'm going to go ahead and so that I don't have to keep。 typing minus minus org
    dev on the end of every command that I run。 I'm going to make the dev org into
    my default org for this project。 So now I can just run list_changes。 And this
    will go out and query the org and interact with the source tracking that's in。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续进行操作，这样我就不必在每个命令后面一直输入 minus minus org dev。我将把 dev org 设为此项目的默认 org。现在我只需运行
    list_changes。这将查询 org 并与源跟踪进行交互。
- en: the org to find all the metadata that I changed in the org。 Now sometimes you
    want to exclude down the list。 And that's where the custom task options for this
    come in。 If I want to find those options， I can do CCI task info list_changes。
    This will give me output of all the different task options。 In this case。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: org 用于查找我在 org 中更改的所有元数据。有时你可能想从列表中排除一些项目。这就是自定义任务选项的作用。如果我想找到那些选项，可以执行 CCI
    task info list_changes。这将给我所有不同任务选项的输出。在这种情况下。
- en: I want this exclude option to exclude components from the list。 And this is
    just a regx format。 And I want to leave out those profiles because profiles are
    kind of uniquely difficult to。 package in the Salesforce world。 They're more of
    kind of an individual implementation configuration detail。 So I do want to capture
    the objects in the fields and the layouts for those objects。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这个排除选项能将组件从列表中排除。这只是一个正则表达式格式。我想排除那些配置文件，因为在 Salesforce 的世界中，配置文件是非常独特且难以打包的。它们更像是个别实现的配置细节。所以我确实希望捕捉到这些对象及其字段和布局。
- en: So now all I've got to do is just recall this command and change to use rather
    than list_changes。 the retrieve_changes task。 Which accepts the same options so
    you can kind of prepare the list of options。 And this will go and actually run
    a query through the Salesforce metadata API and pull。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我只需回忆这个命令并改为使用 retrieve_changes 任务，而不是 list_changes。它接受相同的选项，因此你可以准备选项列表。这将通过
    Salesforce 元数据 API 实际运行查询并拉取数据。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_9.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_9.png)'
- en: down the content that was created。 All right， so if I look now in my project
    under this force app directory。 main default， is where my metadata source lives。
    For other objects。 I have folders for each of my objects， a folder for fields，
    the individual， fields in them。 So pretty cool。 I was able to make these changes
    just in the web interface。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 内容的创建。好的，所以如果我现在在我的项目下查看这个 force app 目录，main default 是我的元数据源所在的地方。对于其他对象，我为每个对象都有文件夹，字段的文件夹以及其中的各个字段。所以这很酷。我能够在网络界面中进行这些更改。
- en: capture those changes down， to something that I can put in version control really
    easily。 Now let me just go ahead and do a git add。 As I said earlier on the demo
    intro slide that we were going to create a feature branch。 I forgot to do a commit
    on the master branch。 So we're just going to go ahead and commit this as the initial
    commit。 And do this on the master branch and create the master branch for our
    project。 So that's it。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 捕捉那些更改，将其转换为我可以轻松放入版本控制中的内容。现在让我先执行一个 git add。正如我在演示介绍幻灯片中所说，我们要创建一个功能分支。我忘记在主分支上进行提交。所以我们现在将其作为初始提交进行提交，并在主分支上创建我们的项目的主分支。就这样。
- en: We've kind of started a project。 We can now develop this Salesforce development
    project through feature branches。 If I run the CCI org scratch delete dev command，
    it's going to go wipe out that org where。 I created those changes。 And now if
    I run the dev workflow again。 it will go create a new scratch org， run all， the
    automation。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开始了一个项目。现在我们可以通过功能分支开发这个 Salesforce 开发项目。如果我运行 CCI org scratch delete dev
    命令，它将会删除我创建那些更改的 org。现在如果我再次运行 dev 工作流，它将创建一个新的 scratch org，运行所有自动化。
- en: And this time it's going to deploy everything I just captured into that word
    so I can iteratively。 develop and build out the solution。 Pretty cool。 All right。
    So for the next demo。 I want to show you the web based tools that we built on
    top of cumulus。 CI to make this a little bit more scalable and also a lot more
    approachable to non-developer。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这次它将把我刚刚捕获的所有内容部署到那个单词中，以便我可以逐步开发和构建解决方案。相当酷。好的，接下来的演示中，我想向你展示我们在 cumulus CI
    上构建的基于网页的工具，使其更具可扩展性，也让非开发者更易接触。
- en: types that are kind of thrown off when you try to drop them into the command
    line。 So we're going to take a look at Meteco in order to offer a new feature
    to this application。 Then we're going to look at Metacii， our build system as
    it builds that feature。 And then we'll look at Metadiply and how we can figure
    a new version that we're going。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试将这些类型扔入命令行时，会有一些混乱。因此我们将看看 Meteco，以便为这个应用程序提供一个新功能。然后我们将查看 Metacii，我们的构建系统，它将构建该功能。接着我们将看看
    Metadiply，以及我们如何配置一个新的版本。
- en: to create for our web based installer of this project。 So let's go ahead and
    jump into。 Now this project that I've got already out on GitHub， I've already
    got connected to all。 of these tools。 So we're going to switch over and use this
    for the rest of the demo。 But it's basically the same thing。 You can see under
    the force app main default directory。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个项目的基于网页的安装程序创建的。所以让我们开始吧。现在这个我已经在 GitHub 上的项目，我已经将其连接到所有这些工具。所以我们将切换到这个项目并用它进行剩下的演示。但基本上是同样的事情。你可以看到在主默认目录下的应用程序。
- en: I've got objects。 I've got a delivery and a delivery item。 I think these have
    some additional fields on them。 So they have a scheduled date and a notes field
    that's on them。 But what we want to do for this demo is since in the third demo
    we're going to integrate。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我有对象。我有一个交付和一个交付项。我想这些上面有一些额外的字段。所以它们有一个计划日期和一个备注字段。但在这个演示中，我们想要做的是，因为在第三个演示中，我们将进行集成。
- en: a Django app to sync its data with this one， we want to actually add a new field
    that's。 going to store the external ID from the Django app as an external ID on
    this object。 So to do that。 we could do that using CCI on the command line just
    like we were going， through。 But I want to show you our newest tool that's in
    the works， Metecco， which I think is really。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Django 应用程序与这个应用程序同步数据，我们想要实际添加一个新字段，用来存储来自 Django 应用程序的外部 ID，作为这个对象的外部 ID。为此，我们可以像以前一样，通过命令行使用
    CCI。但我想向你展示我们正在开发的新工具，Metecco，我认为这真的很不错。
- en: really exciting。 So let me quickly log out of here just to show you what it
    looks like from the start。 When I come to Metecco， all that I have to have and
    I really know about GitHub to use。 Metecco is I've got to have a GitHub account，
    which is pretty easy to create。 So I come out and I log in and I've already accepted
    this app。 Normally I would get the。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 非常令人兴奋。所以让我快速注销一下，以便向你展示从头开始的样子。当我来到 Metecco 时，我所需要的和我对 GitHub 的了解是很少的。Metecco
    我必须拥有一个 GitHub 账户，这个账户很容易创建。所以我登出，然后登录，我已经接受了这个应用程序。
- en: do you want to grant this app access to your GitHub profile， OAuth verification
    step。 And what it does is it looks at the list of repositories that I have contributor
    rights。 to and compares that against the repositories that are configured in this
    instance。 So you can kind of pick and choose what repositories this instance is
    supporting contributions， to。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我会看到“你想要授予这个应用程序访问你的 GitHub 个人资料吗？”的 OAuth 验证步骤。它的作用是查看我拥有贡献权的仓库列表，并将其与该实例中配置的仓库进行比较。因此，你可以选择这个实例支持贡献的仓库。
- en: And in this case， I've got the CCI food bank repository here and I also have
    contributor， rights。 So I'm showing the card for that app。 If I click here to
    go into the app， I can。 there's an existing project that I created， earlier。 But
    in this case。 we want to create a new project for our contribution。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我在这里有 CCI 食品银行仓库，我也有贡献权。因此我正在展示该应用程序的卡片。如果我点击这里进入应用程序，我可以看到一个我早些时候创建的现有项目。但在这种情况下，我们想为我们的贡献创建一个新项目。
- en: And the external app is this app called DJ food bank that we're going to look
    at in the， third demo。 So this is really to prepare that。 And we're going to create
    a task to create external ID fields for delivery and delivery。 item。 And if I
    come in and look at this individual task， now this is kind of my workspace for。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 外部应用是我们将在第三个演示中查看的名为DJ食品银行的应用。这实际上是为此做准备。我们将创建一个任务，为交付和交付项目创建外部ID字段。如果我查看这个具体任务，这实际上是我工作的空间。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_11.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_11.png)'
- en: the task。 I've got to assign somebody as a developer。 Right now I'm the only
    active member of this project。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务。我得给某人分配开发者的角色。现在，我是这个项目唯一的活跃成员。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_13.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_13.png)'
- en: And so I'm going to go ahead and click create or。 Now this is doing essentially
    the same thing that the CCI flow run dev org minus minus org。 dev is doing on
    the command line。 So it's tapping into that portable automation。 just providing
    a totally different user experience。 that's a lot more friendly for people that
    are not comfortable in the command line。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我将继续点击创建或。现在，这基本上做的是与命令行上的CCI流运行开发组织相同的事情。因此它利用了可移植的自动化，提供了完全不同的用户体验，对于不熟悉命令行的人来说，这要友好得多。
- en: I started out my career as a Unix admin。 So command line is kind of my bread
    and butter。 But you know， for a lot of people in the Salesforce world。 they're
    very used to these kind of clickable， web interfaces。 And we really want to open
    up these projects to them to be able to contribute。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我职业生涯的开始是作为Unix管理员。所以命令行是我的拿手好戏。但是，对于许多Salesforce世界的人来说，他们很习惯这种可点击的网页界面。我们真的想让这些项目向他们开放，以便能够贡献。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_15.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_15.png)'
- en: And I will also go ahead and assign myself as the tester on this project， just
    so you。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将自己分配为这个项目的测试人员，仅此而已。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_17.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_17.png)'
- en: can see what that looks like。 And the general idea is the developer develops
    things and their scratch org captures them。 creates commits。 The tester then creates
    a new scratch org using the automation from that branch to deploy。 into the org。
    And you can see my org's been created。 So I'm going to go ahead and click view
    org to log into the Salesforce org， the scratch。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看看那是什么样子。开发者的基本思路是开发东西，而他们的临时组织则记录这些。创建提交。然后，测试人员使用来自该分支的自动化创建新的临时组织进行部署。可以看到我的组织已创建。所以我将继续点击查看组织以登录到Salesforce组织，临时的。
- en: org that's been created for me。 And in here， oh， it's really like to launch
    those in the classic UI for some reason。 So I'm going to switch over to the new
    UI because this is much， much nicer。 And in here。 I want to add two new fields，
    one on the delivery object， go to fields and， relationships。 go to new。 And in
    this case， I want to add a number field for the integer ID of the app in Django。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为我创建的组织。在这里，哦，出于某种原因，它真的像在经典用户界面中启动那些。所以我将切换到新的用户界面，因为这好得多。在这里，我想添加两个新字段，一个在交付对象上，转到字段和关系，选择新建。在这种情况下，我想添加一个整数ID的数字字段，表示Django中的应用ID。
- en: And let's call this DJ food bank ID。 And we're going to tell it that we want
    this to be an external ID。 So that'll ensure uniqueness on this field so that
    it can be used essentially as an index。 And save。 And I also want this similar
    field on my delivery item。 So go to fields and relationship for delivery item。
    I'm going to go through and do this quickly。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其命名为DJ食品银行ID。并告诉它我们希望将其设为外部ID。这将确保此字段的唯一性，使其可以用作索引。并保存。我还希望在我的交付项目上有类似的字段。所以去交付项目的字段和关系。我将快速完成这个。
- en: Feel free to pause the video and slow down if you want to see any of this in
    more detail。 of what's happening。 We're going to call this DJ food bank ID and
    also make this an external ID and hit save。 Cool。 So I made the declarative changes。
    Now just like we used the list changes step on the on CCI on the command line
    before。 this， time we're going to use a Moteco which kind of leverages that same
    automation from QMLSCI。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更详细地查看这一切，随时暂停视频并放慢速度。我们将这个称为DJ食品银行ID，同时也将其设为外部ID并点击保存。很棒。因此我做了声明性的更改。就像我们之前在命令行上使用列表更改步骤一样，这次我们将使用Moteco，它利用了来自QMLSCI的相同自动化。
- en: to go out and query the org。 Then it's going to ask me where do I want to store
    this？
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 去查询组织。然后它会问我想把这个存储在哪里？
- en: Do I want to store it in the kind of post install QA configuration that's sort
    of an optional。 configuration or do I want it in the main package directory？ In
    this case。 I want this in the main package because I want it to be something that
    when， people install it。 they get。 So I'm going to go ahead and hit next。 And
    it's again going to show me all the different metadata that it detected has changed。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我想把它存储在某种后安装QA配置中，那是一种可选配置，还是想把它放在主包目录中？在这种情况下。我想把它放在主包中，因为我希望当人们安装时，他们会得到它。所以我将继续点击下一步。它将再次显示我检测到的所有不同的元数据已更改。
- en: in the orgs。 I'm going to leave out the profiles but we are going to select
    the fields and the layouts。 I'll hit next and give it a commit message and tell
    it to go retrieve the selected changes。 So notice， I haven't really had to know
    anything about GitHub here。 And the scenes。 what it's done is created a feature
    branch for the project and then what。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在组织中。我将省略配置文件，但我们将选择字段和布局。我会点击下一步，给出一个提交信息，并告诉它去检索所选的更改。所以请注意，我在这里并不需要了解GitHub的任何内容。而在幕后，它做的是为项目创建了一个功能分支，然后。
- en: we call a child feature branch。 So the project is a parent feature branch。 It's
    feature forward slash the parent project name。 And this new branch that's been
    created for me now that this commit is on。 Let's jump over and look at that in
    GitHub。 All right。 And if I look at this commit。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称之为子功能分支。所以这个项目是父功能分支。它是功能斜杠父项目名称。现在为我创建的这个新分支包含了这个提交。让我们跳过去看看在GitHub上。好的。如果我查看这个提交。
- en: this branch name is feature forward slash sync with DJ or DJ。 food bank underscore
    underscore which separates the parent from the child feature branch。 Add external
    ID fields to delivery and delivery item。 A little bit long as a branch name。 But
    you can see here that it's just some， some， you know， it's pulled down just the
    changes。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分支名称是功能斜杠与DJ或DJ。food bank __，它将父分支与子功能分支分开。为交付和交付项目添加外部ID字段。作为分支名称有点长。但是你可以在这里看到，它只是一些，你知道的，拉下了更改。
- en: that I made in the org， these two custom fields and then adding those fields
    into the page layout。 XML definition for it。 So that looks good。 Now I want to
    go ahead and pass this over to the tester because I think I've captured。 everything
    that I need。 So I'm going to do submit tasks for testing and go ahead and actually
    I'll do this later。 on the project。 So I'll go ahead and just submit the task
    but I can input information that will make。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我在组织中做的这两个自定义字段，然后将这些字段添加到页面布局的XML定义中。所以看起来不错。现在我想把这个交给测试人员，因为我觉得我已经捕获了我需要的所有内容。所以我将提交测试任务，并实际上我稍后会在项目上做这个。所以我将继续提交任务，但我可以输入一些信息来使。
- en: its way into the pull request body。 And this is going to go submit a pull request
    for me。 Now I can jump over into GitHub easily and look at that pull request that's
    been created。 And you'll notice that there's builds that have already kicked off
    on this pull request。 that I created。 Now before we take a look at those builds。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它的方式进入拉取请求的正文。这将为我提交一个拉取请求。现在我可以轻松跳转到GitHub，查看这个已创建的拉取请求。你会注意到，已经在我创建的这个拉取请求上启动了构建。在我们查看这些构建之前。
- en: let me first as the tester now go and create， a new org。 This is going to create
    a new scratch org and deploy this new commit into the org so。 that I can go in
    and test it in a clean environment。 You don't want to test in the development
    org。 right？ And so let's jump over and take a quick look at Metacii and what Metacii
    is doing for me。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我先作为测试人员去创建一个新的组织。这将创建一个新的临时组织，并将这个新提交部署到组织中。这样我就可以在一个干净的环境中测试它。你不想在开发组织中测试，对吧？所以让我们跳过去快速看看Metacii以及Metacii为我做了什么。
- en: here。 So this is Metacii running out on Heroku and it's run the feature test
    plan for this repository。 against my child feature branch on this commit。 And
    it's reusing cumulusii's portable automation again so it's downloading the commit。
    It's calling Salesforce DX to create a new scratch org and then it's running this
    flow。 CI_FETURE that I mentioned earlier as one of the built-in flows for doing
    feature branch， testing。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里。所以这是在Heroku上运行的Metacii，它运行了这个代码库的功能测试计划。针对这个提交的我的子功能分支。它再次重用了cumulusii的便携式自动化，所以它正在下载提交。它调用Salesforce
    DX来创建一个新的临时组织，然后运行这个流程。CI_FETURE，我之前提到过的，作为进行功能分支测试的内置流程之一。
- en: And if I go to the flows tab， you'll notice the output here looks identical
    to what we。 get if we run CCI on the command line。 So we're running this automation
    in a different way with a different user experience around。 it but ultimately
    it's running the same automation in the same way。 If this flow failed and I wanted
    to debug it， I could run it using CCI locally with a。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我去到流选项卡，你会注意到这里的输出与我们在命令行上运行 CCI 时得到的完全相同。因此，我们以不同的方式和不同的用户体验运行这项自动化，但最终以相同的方式运行相同的自动化。如果这个流失败了，我想调试它，我可以使用
    CCI 在本地运行。
- en: '- - debug flag and it would drop into a PDB prompt whenever the flow fails。
    And also because this is a Salesforce specific system， I get some information
    about the target。 environment that''s kind of specific to Salesforce。 Now in addition
    to that。 it''s kicked off and is running my robot tests as well for me。 And since
    that one''s still running。'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '- - 调试标志，流失败时会进入 PDB 提示符。而且由于这是一个特定于 Salesforce 的系统，我获得了一些关于目标环境的信息，这些信息是特定于
    Salesforce 的。除此之外，它还启动并为我运行机器人测试。由于这个测试仍在进行中。'
- en: I'll show you what one of these looks like。 I think this is a really cool feature
    because this is a system for building cumulusii projects。 and we use robot for
    the projects。 I can go in and see。 we built an integration with robot framework
    into this。 So if I want to see the test via the UI。 if you've ever worked with
    robot framework before， you've seen this log format。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我来给你展示一下这些请求的样子。我认为这是一个非常酷的功能，因为这是一个用于构建 cumulusii 项目的系统，我们使用机器人框架进行项目开发。我可以查看，我们与机器人框架集成了这个系统。因此，如果我想通过
    UI 查看测试，如果你之前工作过机器人框架，你就会见过这个日志格式。
- en: we actually integrate those directly into the browser so I can see， exactly
    what's going on。 It'll even capture a screenshot if there's a missing locator
    or locator that doesn't。 find the right thing on its end。 All right， so all checks
    have passed。 Everything looks good here。 Let's go back in here and as the tester，
    I'll go log into the test environment just to。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上将这些直接集成到浏览器中，所以我可以确切地看到发生了什么。如果缺少定位器或定位器未能找到正确的内容，它甚至会捕获屏幕截图。好的，所有检查都通过了。一切看起来不错。让我们回到这里，作为测试人员，我将登录测试环境以展示。
- en: show you that this environment's been created and I can log into it。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 显示这个环境已经创建，我可以登录。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_19.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_19.png)'
- en: Now normally in a non-demo sense， I would go through and actually do testing
    in this environment。 Let's go ahead and jump ahead and submit the review， say
    approve， and it looks great。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在非演示的情况下，我会在这个环境中进行实际测试。我们继续前进并提交审核，表示批准，看起来不错。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_21.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_21.png)'
- en: I'm going to go ahead and add the project review。 Now if I go over on the pull
    request。 that shows up as a comment that was left by me。 And also it shows up
    as a commit status。 So you can set up protected branches to require that as a
    check before it's allowed to merge。 I'm going to go ahead and merge this pull
    request and notice this pull request was just。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我将继续添加项目审核。现在如果我查看拉取请求，这会显示为我留下的评论。它还会显示为一个提交状态。因此，你可以设置受保护的分支，要求在允许合并之前进行此检查。我将继续合并这个拉取请求，并注意这个拉取请求刚刚。
- en: to merge into the parent feature branch。 So now this task is done。 If I go back
    to the project level， I can submit the project for merge。 And here I'll go ahead
    and provide some release notes。 All right。 So now that's created another pull
    request for me。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 合并到父功能分支。因此现在这个任务完成了。如果我回到项目层级，我可以提交项目以进行合并。在这里，我将提供一些发布说明。好了，因此现在为我创建了另一个拉取请求。
- en: And this pull request is requesting to merge this branch into master。 Again，
    normally。 and we do have protected branches set up on this one， I normally don't。
    have it where admins can override。 But for the sake of demo。 I would wait for
    these builds to complete before I do this normally。 But in this case。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此次拉取请求请求将该分支合并到主分支。通常情况下，我们在这个分支上设置了受保护分支，我通常不允许管理员覆盖。但为了演示，我通常会等这些构建完成后再进行合并。但在这种情况下。
- en: I'm just going to go ahead and use my admin rights and merge this pull。 request
    into master so that we can kind of continue along to the next steps in meta-CI。
    All right。 So jumping back into meta-CI， our build system， you'll see that that
    merge to master has queued。 up a build on the upload beta branch。 Now， the way
    that the triggering is set up is through plans。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用我的管理员权限将这个拉取请求合并到主分支，这样我们就可以继续进行 meta-CI 的下一步。 好的。 所以回到 meta-CI，我们的构建系统，你会看到合并到主分支已经排队在上传
    beta 分支上构建。 触发的方式是通过计划设置的。
- en: which are if you're familiar， with Jenkins， these are like jobs in Jenkins。
    except unlike jobs in Jenkins， plans are really， simple and they can apply to
    multiple different repositories because of their simplicity。 because， cumulc。i
    creates this kind of common interface across projects。 So for instance。 the upload
    beta flow， its role is to create a beta release。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Jenkins，这些就像 Jenkins 中的作业。 但与 Jenkins 中的作业不同，计划实际上非常简单，并且由于其简单性，可以适用于多个不同的代码库。
    因为 cumulc.i 在项目间创建了这种通用接口。 举个例子，上传 beta 流程的角色是创建一个 beta 发布。
- en: It's triggered off of commits using a regex match of master。 There's three repositories
    that are using this basic configuration。 It runs against an org named packaging
    and it runs two flows， CI master， that will deploy。 the code into my packaging
    org and then release beta that will upload a release of that and。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它是通过使用与主分支匹配的正则表达式触发的。 有三个代码库使用这个基本配置。 它在名为 packaging 的组织中运行，并且运行两个流程，CI master，将代码部署到我的打包组织中，然后
    release beta 将上传这个发布。
- en: create the release in GitHub。 So let's check back here。 So this system will
    actually auto-scale your Heroku worker dinos。 So it monitors the build queue in
    Redis and automatically will scale up to a certain limit。 that you can set in
    config bars on the Heroku app。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 中创建发布。 所以让我们回过头来检查一下。 这个系统实际上会自动扩展你的 Heroku 工作者 dinos。 它监控 Redis 中的构建队列，并会自动扩展到你可以在
    Heroku 应用的配置中设置的某个限制。
- en: So it's dynamically creating worker dinos and then when the queue goes back
    to zero， it's。 scaling everything back down to zero and shutting them all down。
    You can also set up reserve capacity to keep one or two on at all times。 But the
    nice thing is Heroku is only billing you down to the second for your usage。 All
    right。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 它正在动态创建工作者 dinos，当队列回到零时，它会将所有内容缩减到零并关闭它们。 你还可以设置预留容量，以便始终保留一两个在线。 但好的一点是，Heroku
    仅按秒计费你的使用。 好的。
- en: So those have kicked off and started running。 And if I look at the flows， you
    can see again。 this is just like the command line or output， that I would see
    if I were running this from the command line。 CCI。 And it is almost done with
    its deployment to the packaging org。 And then it's going to run the release beta
    flow in order to cut a release of the package。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些已经启动并开始运行。 如果我查看流程，你会再次看到。 这就像命令行或输出，如果我从命令行运行 CCI。 它几乎完成了对打包组织的部署。 然后它将运行发布
    beta 流程以切割包的发布。
- en: Now while that's running， I'm going to go ahead and queue up a new production
    release， build。 And so again， normally I would wait for the beta to build a complete
    and the beta testing， to pass。 but we're just going to kind of speed things along
    for the purpose of the demo。 So I went through and I picked the upload release
    plan on the CCI food bank repository。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在运行过程中，我将继续排队一个新的生产发布构建。 通常，我会等待 beta 构建完成并且 beta 测试通过。 但为了演示的目的，我们将加快进度。
    所以我选择了 CCI 食品银行代码库中的上传发布计划。
- en: and I'm running this against the master branch。 I hit submit。 And you'll notice
    that this is actually waiting on the other build to complete。 So one of the challenges
    that we ran into because we don't work in virtual machines， you know。 a lot of
    cloud based CI systems presume that if you need more concurrency。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在针对主分支运行这个。 我点击提交。 你会注意到这实际上在等待另一个构建完成。 因为我们不在虚拟机中工作，所以我们遇到的一个挑战是，很多基于云的 CI
    系统假设如果你需要更多的并发。
- en: they'll just give you more virtual machines。 That doesn't really work for us
    because our build environment for the packaging。 we have， a single packaging org
    where the package gets uploaded。 So it should go and unlock here in a minute，
    but I can go ahead and force it。 Go ahead and unlock that org。 And one of the
    other things that you'll notice is at the end of this upload beta build。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 他们会给您更多的虚拟机。这对我们来说并不太有效，因为我们的打包环境。我们有一个单一的打包组织，包在其中上传。因此，它应该在一分钟内解锁，但我可以提前强制执行。去解锁那个组织。您会注意到，在这个上传
    beta 构建结束时的另一个事情。
- en: just， to show you what we do in release automation， it uploads a new version
    of the package， which。 is what it's doing here， then we create a release in GitHub，
    we generate release notes。 automatically by parsing the pull request bodies and
    put those in the release。 And then at the end。 we run this task called GitHub
    master to feature that takes this new。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 只是，为了向您展示我们在发布自动化中所做的事情，它会上传一个新版本的包，这就是它现在所做的，然后我们在 GitHub 中创建一个发布，我们通过解析拉取请求主体自动生成发布说明，并将其放入发布中。最后，我们运行一个名为
    GitHub master 到 feature 的任务，获取这个新的。
- en: tested commit in master and merges it into all open feature branches。 So that's
    actually triggered all these other feature branches to build because they now。
    have new code integrated into them automatically。 All right。 And just kick off
    a rebuild on this and kind of speed it along。 There we go。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在主分支中测试过的提交并将其合并到所有开放的功能分支中。因此，这实际上触发了所有这些其他功能分支的构建，因为它们现在自动集成了新代码。好的，接下来启动一次重建，加速这个过程。来吧。
- en: So now this upload release build is running and it is deploying into the packaging
    org。 but this time rather than a beta version of the package， it's going to create
    a production。 release of the package。 Over in the GitHub repository。 this has
    created under releases a beta release of the package， here。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在这个上传发布构建正在运行，并正在部署到打包组织中。但这次，不是包的 beta 版本，而是将创建一个生产版本的包。在 GitHub 仓库中，这在发布下创建了一个包的
    beta 发布。
- en: And here's the release notes that I entered and a link back to the pull request
    where those。 release notes came from。 So our release notes generator finds all
    the PRs that have emerged a master since the last。 release tag and concatenates
    together the release notes based on the contents of the。 pull request body， which
    we include as part of our code review of new features。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我输入的发布说明，以及一个链接，指向那些发布说明来源的拉取请求。因此，我们的发布说明生成器会找到自上一个发布标签以来，所有从主分支出现的 PR，并根据拉取请求主体的内容，将发布说明串联在一起，我们将其纳入新功能的代码审查中。
- en: And here in a minute， whenever that builds done， there we go， completed。 So
    now I've got the new version of this product version 1。4。 So now let's go over
    and talk about meta deploy。 And meta deploy。 you can see our production instance
    of this that's used by thousands of。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 过一会儿，当构建完成时，完成了。现在我得到了这个产品的新版本 1.4。现在让我们谈谈元部署。您可以看到我们的生产实例，这是成千上万用户使用的。
- en: nonprofit and education customers of ours has all of our main products in it
    available。 for installations。 So for instance， if I wanted to install the NPSP
    or the nonprofit success pack。 I would， come here。 These are all the each one
    of these steps is ultimately a task in key millisci that it's。 available to run
    against an org that I connect it to。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的非营利和教育客户都可以安装我们所有主要产品。因此，例如，如果我想安装 NPSP 或非营利成功包。我会来这里。这些步骤最终都是在我连接的组织上可用的
    key millisci 中的任务。
- en: And then I just click a button and it goes through and runs all of this process
    for me。 automatically。 Now I have this project set up to our staging site。 So。
    Oh， I'm going to deploy STG。 And so I have CCI food bank。 And you can see here
    that right now this is set as version 1。3。 Since I've created the new version，
    I need to actually publish that new version out to， this site。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我只需点击一个按钮，它就会自动执行整个过程。现在我已经将这个项目设置到我们的暂存网站上。所以，哦，我要部署 STG。然后我有 CCI 食品银行。您可以看到，现在这是设置为版本
    1.3。由于我创建了新版本，我实际上需要将这个新版本发布到这个网站上。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_23.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_23.png)'
- en: So now we're going to jump back into the command line。 And I'm going to go into
    the local clone of CCI food bank， pull down the latest master。 And this time I'm
    going to run a task in key millisci called meta deploy underscore publish。 And
    I need to give it a tag。 This is released forward slash one or one dot four。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将回到命令行。我将进入 CCI 食品银行的本地克隆，拉取最新的主分支。这次我将运行一个名为 meta deploy underscore publish
    的任务，并需要给它一个标签。这是版本 forward slash one 或者 one dot four。
- en: And I'm also going to tell it to go ahead and publish the plan that it's going
    to create。 for installing this new version。 So it goes out and it downloads the
    tag。 parses the configuration of the tag。 Now the configuration of the tag came
    from the key millisci yaml。 Show you what that looks like down to the bottom of
    the key millisci yaml here for this， project。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将指示它继续发布将要为安装这个新版本创建的计划。所以它出去下载标签，解析标签的配置。现在标签的配置来自于 key millisci yaml。让我给你展示一下这个项目的
    key millisci yaml 的底部长什么样。
- en: I have plans install。 And notice that the steps for the install are just using
    flows and tasks。 So it's just another configuration of the portable automation
    for the project。 And these plans can get a little bit involved， you know， calling
    a number of different tasks。 and everything depending upon how complex the automation
    that you want to make available。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我有计划安装。请注意，安装步骤只是使用流程和任务。所以这只是项目的可移植自动化的另一种配置。这些计划可能会稍微复杂一些，涉及多个不同的任务，具体取决于你想要提供的自动化的复杂程度。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_25.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_25.png)'
- en: to end users is。 In this case， we're just doing something really simple。 And
    so that published it up。 Now if I go back to the home page for meta deploy and
    go into CCI food bank。 you'll see， that I've got version 1。4。 But click here，
    it's going to install the demo 1。5。 Let's look into that。 Find something new in
    demos every day。 So yeah， that's it。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对最终用户而言。在这种情况下，我们只是做一些非常简单的事情。所以它将其发布上去。现在如果我回到 meta deploy 的主页，并进入 CCI 食品银行。你会看到，我有版本
    1。4。但是点击这里，它将安装演示 1。5。让我们来看看。每天在演示中发现一些新东西。所以就这样。
- en: We made a change through the web， got it into the repository， merged the pull
    request， got。 new releases。 You can see it's a pretty painless process that we
    put together when you have all of。 these web tools and cumulus CI the framework
    kind of working in conjunction with each other。 Really a pretty painless process
    for an open source project to be able to manage something。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过网络进行了更改，将其放入了代码库，合并了拉取请求，并获得了新的发布。你可以看到，当拥有这些网络工具和云层 CI 框架相互配合时，这个过程相当简单。对于一个开源项目来说，能够管理这些内容真的是一个相当无痛的过程。
- en: as complex as building customizations on the Salesforce platform and making
    those available。 to thousands of users。 So let's now switch over and talk about
    integrating this whole thing with a Python Web App。 So over this third demo， I
    built a sample Django application that helps food banks track。 deliveries and
    delivery items。 A very common scenario that we just went through in the first
    two。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 像在 Salesforce 平台上构建自定义功能并使其可用于成千上万的用户一样复杂。那么现在我们来谈谈将整个集成与 Python Web 应用程序结合在一起。在这个第三个演示中，我构建了一个示例
    Django 应用程序，帮助食品银行跟踪交付和交付物品。这是我们在前两个演示中经历的一个非常常见的场景。
- en: And I have gone ahead and done the integration。 What we'll do is walk through
    and I'll show you how I built the integration for that Django。 app and leverage
    some of cumulus CI in that Django app to help my users be able to configure。 the
    application and then we'll go through and show how the integration is actually
    working。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经完成了集成。我们将逐步演示，我会向你展示我如何为这个 Django 应用程序构建集成，并利用一些云层 CI 来帮助我的用户配置应用程序，然后我们会展示集成实际上是如何工作的。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_27.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_27.png)'
- en: All right。 So let's jump back into VS code。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。那么我们回到 VS Code。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_29.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_29.png)'
- en: We'll start talking about this from a code perspective or actually， you know
    what， take， that back。 We're going to go in the browser and we're going to take
    a look at this application。 So go ahead and sign out of this application and come
    back and sign in。 I've created a user for myself in this application。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从代码的角度开始讨论这个，实际上，你知道吗，撤回一下。我们要去浏览器，看看这个应用程序。所以请先退出这个应用程序，然后再回来登录。我在这个应用程序中为自己创建了一个用户。
- en: This is just using the PiDanny cookie cutter template for Django and running
    on Django， three。 It helps to input my password correctly。 And now it's going
    to log me in and take me to my account。 And so we'll come back to my account page
    here in a minute。 I just want to show you how deliveries work。 So I have a basic
    structure for deliveries。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是使用PiDanny的cookie cutter模板进行Django，并在Django 3上运行。这有助于我正确输入密码。现在它将让我登录并带我到我的账户。所以我们稍后再回到我的账户页面。我只想向你展示交付是如何工作的。所以我有一个基本的交付结构。
- en: I can have fields on the individual deliveries。 I can create additional delivery
    items。 So say this is potatoes。 All right。 And I've got my different items created。
    And so， you know。 anybody could use this。 They don't have to be Salesforce users
    or whatever。 But if you built an app like this for food banks， you're probably
    going to wind up starting。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在每个交付上添加字段。我可以创建额外的交付项目。例如，这个是土豆。好吧，我创建了我的不同项目。这样，任何人都可以使用它。他们不必是Salesforce用户。但如果你为食品银行构建了这样的应用，你可能会开始。
- en: getting requests from different food banks because there's a lot of food banks
    that are。 actually using Salesforce for their backend systems。 So you might get
    the question of like。 how do I get this data into my Salesforce instance？
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从不同的食品银行获取请求，因为有很多食品银行实际上在使用Salesforce作为它们的后端系统。所以你可能会问，如何将这些数据导入我的Salesforce实例？
- en: It would really allow me to kind of report on it， to tie it in with all of my
    other records。 and track a lot of this stuff a lot better。 So that's what we're
    going to go through。 That's what I'm going to go through and show you now is how
    I built the integration of this。 application to be able to talk to Salesforce
    instance。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实让我能够报告它，将其与我所有其他记录关联，并更好地跟踪很多信息。所以这就是我们要进行的内容。我将向你展示我如何构建这个应用程序的集成，以便能够与Salesforce实例进行交互。
- en: So the first part of that is you've got to allow your users to be able to connect
    to Salesforce。 instances。 And we're doing this using some open source Python code
    that we've written in a package。 that's called SFDO template helpers。 It's not
    up on PyPy。 but it is out in a public GitHub repository， which is how we've installed，
    it in this one。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 所以第一部分是你必须允许用户连接到Salesforce实例。我们使用一些开源Python代码，这段代码写在一个叫做SFDO模板助手的包里。虽然它没有在PyPy上，但在一个公共的GitHub仓库中可以找到，这就是我们在这个项目中安装它的方法。
- en: And SFDO template helpers has a functionality that extends the OAuth configuration
    for being。 able to interact with some of the unique aspects of doing OAuth in
    Salesforce。 One of those unique aspects is the need for a couple of different
    separate buttons。 So if you want to connect to a production or developer edition
    Salesforce org， you'll。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: SFDO模板助手有一个功能，扩展了OAuth配置，以便能够与Salesforce中进行OAuth的一些独特方面进行交互。其中一个独特的方面是需要几个不同的独立按钮。所以如果你想连接到一个生产或开发版的Salesforce组织，你需要。
- en: notice when I click here it takes me to login。salesforce。com。 If I want to connect
    to a sandbox or a scratch org， when I click here it's going to take。 me to test。salesforce。com。
    So that's one of the main things that our OAuth extension to OAuth for Salesforce
    projects。 does is make it easy to support both those different use cases in a
    way that the default。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我点击这里时，它会把我带到login.salesforce.com。如果我想连接到一个沙箱或临时组织，当我点击这里时，它会把我带到test.salesforce.com。所以这是我们为Salesforce项目的OAuth扩展所做的主要事情之一，便于支持这两种不同的用例。
- en: provider in OAuth doesn't do。 And then the other thing that it's doing is actually
    encrypting the tokens using fernet。 encryption before it writes it into the database。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth中的提供者并没有执行。其次，它实际上是在将令牌使用fernet加密后再写入数据库。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_31.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_31.png)'
- en: So let's take a look at how we wired in the OAuth connection first。 All right。
    And I've got this pulled up in my workspace。 So just to show you how this is structured。
    I've got under config settings。 And then I've also got requirements。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们如何连接OAuth。好的，我在我的工作区中拉起了这个示例。为了展示它是如何结构化的，我在配置设置下有它。同时我还有需求文件。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_33.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_33.png)'
- en: So for the base requirements， I just added in a link out to our GitHub repository，
    SFDO， tooling。 SFDO template helpers， and pegged it at a particular release version
    of that， helper repository。 So then when I pip install off of this file， I get
    that installed into my local environment。 And then in the configuration， there's
    a few things that I've added to my kind of default。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 所以对于基本需求，我只是添加了一个指向我们的 GitHub 仓库、SFDO、工具的链接。我把 SFDO 模板助手固定在那个助手仓库的特定发布版本上。所以当我从这个文件中执行
    `pip install` 时，我就会将其安装到我的本地环境中。然后在配置中，有一些我添加到我的默认配置中的内容。
- en: configuration file here。 I set a default database just to use a same default
    for the database name here for local。 development。 Then all-- oh。 And then I've
    also added in some-- find my third party。 Here we go。 I added in-- I had a deliveries
    app originally， created another app inside of here called SF。 integration that
    has all the logic for the Salesforce integration。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件在这里。我设置了一个默认数据库，以便在本地开发中使用相同的数据库名称作为默认值。然后所有的——哦。我还添加了一些——找到我的第三方。在这里，我添加了——我原本有一个
    deliveries 应用，在这里创建了另一个叫 SF 的集成应用，其中包含与 Salesforce 集成的所有逻辑。
- en: We'll look at that code here in a minute， but I want to focus on the OAuth side
    for now。 And then at the bottom， I've had to create a Salesforce-connected app。
    And I'll show you in a second here what that looks like。 They're really easy to
    create inside of a developer edition org or any other persistent。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会看看那段代码，但我现在想专注于 OAuth 方面。然后在底部，我必须创建一个 Salesforce 连接的应用程序。我马上就会给你展示它的样子。在开发者版组织或任何其他持久的组织中创建它们真的很简单。
- en: Salesforce org。 But this is just the application， like if you create a GitHub
    app to build OAuth integration。 with GitHub。 Same thing。 We're using environment
    variables so that we can run this out on Heroku and set these。 through configuration
    on the app。 We're also using-- or environment variables to get the encryption
    key that we use for。 database encryption。 You'll need a GitHub personal access
    token to do interaction with the GitHub API on behalf。
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Salesforce 组织。但这只是应用程序，就像你创建一个 GitHub 应用来构建与 GitHub 的 OAuth 集成。一样。我们使用环境变量，以便在
    Heroku 上运行这个，并通过应用程序的配置设置这些。我们还使用环境变量来获取用于数据库加密的加密密钥。你需要一个 GitHub 个人访问令牌，以便代表进行与
    GitHub API 的交互。
- en: of the app。 So we get that from an environment variable。 And then here。 we're
    just wiring in the SFDO template helper account adapters and account。 providers
    and setting the appropriate scope for this individual application and wiring。
    in the connected app details to get those from the environment instead of storing
    them。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的。所以我们从环境变量中获取这个。然后在这里，我们只是将 SFDO 模板助手帐户适配器和帐户提供者连接起来，并为这个单独的应用程序设置适当的作用域，并将连接的应用程序详细信息连接到环境中，而不是存储它们。
- en: in the database itself。 So let's take a look at the connected app there for
    this。 Let's go log in again。 And so this is a Salesforce developer edition org
    that I created。 So it's a persistent org， which is good for doing things like--
    if I want to get into the。 app manager。 And the app manager， I can come in and
    create a new connected object。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们看看这个连接的应用程序。让我们再登录一次。这是我创建的 Salesforce 开发者版组织。所以它是一个持久组织，这对于做一些事情非常好——如果我想进入应用管理器。在应用管理器中，我可以创建一个新的连接对象。
- en: You just give it a name， an API name， a contact email， say to enable the OAuth
    settings， give。 it a callback。 And in this case， I want both full and refresh
    token access to be able to get a refresh token。 Like some OAuth providers， the
    access token is not a persistent token。 It will expire and you need the refresh
    token to be able to recreate it。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需给它一个名称、API 名称、联系电子邮件，选择启用 OAuth 设置，给它一个回调。在这种情况下，我希望能够同时获取完整和刷新令牌的访问权限，以便获得刷新令牌。像某些
    OAuth 提供者一样，访问令牌不是一个持久令牌。它会过期，你需要刷新令牌来重新创建它。
- en: So having that access is important for an app like this。 And in this case。 I've
    already created one of these。 So that's the one that I'm using in my app。 Just
    to show you what that looks like when it's fully created is you get the consumer。
    key or the client ID here。 You can click here to reveal the secret and then the
    callback URL for the application。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，拥有这样的访问权限对于像这样的应用程序非常重要。在这种情况下，我已经创建了一个这样的令牌。所以这是我在应用中使用的那个。为了展示它完全创建后的样子，你会得到消费者密钥或客户端
    ID。你可以点击这里查看密钥，然后是应用程序的回调 URL。
- en: One of the things that's nice about these in Salesforce is if it's local host，
    you can， use HTTP。 otherwise HTTPS is required。 But that's really nice for building
    a connected app for your development-- local development。 environments。 All right。
    So with that， I basically have Django all off handling my OAuth login to Salesforce
    for。 me。 And one thing that I'm going to want to do is let's go ahead and create
    a new Scratch， org here。
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Salesforce 中，这些的一个好处是，如果是本地主机，你可以使用 HTTP。否则需要 HTTPS。但这对构建开发环境的连接应用程序非常不错。好的。就这样，我基本上让
    Django 处理我的 OAuth 登录到 Salesforce。接下来我想做的事情是，我们来创建一个新的 Scratch 组织。
- en: So let me just wake up the QA org config。 And this will create a new Scratch
    org that we connect to the app and kind of show how。 that's going to work。 All
    right。 So we looked at the requirements to add in that project。 the changes that
    we made in， the configuration。 And then the next thing that we'll look at is the
    changes that we made in the actual。 Django application code in order to make that
    possible。 But first。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我唤醒 QA 组织配置。这将创建一个新的 Scratch 组织，我们连接到应用程序并展示一下它是如何工作的。好的。我们查看了添加该项目的要求，配置中所做的更改。接下来我们将查看在实际
    Django 应用程序代码中所做的更改，以便实现这一点。但首先。
- en: let's go ahead and get this org connected up。 So I'm going to go back to my
    application。 And I want to connect a new sandbox or Scratch org。 And I can go
    get from the output of CCI org info， the username and password for this Scratch。
    org that it created for me to log into it。 Okay。 Try that again。
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续将这个组织连接上。所以我将回到我的应用程序。我想连接一个新的沙盒或 Scratch 组织。我可以从 CCI org info 的输出中获取这个
    Scratch 组织的用户名和密码，以便登录。好的。再试一次。
- en: I don't know why that's not working。 Of course， I'm doing a demo。 All right。
    Just try。 Maybe it's that character。 I'm going to regenerate that password for
    me real quick。 All right。 Well。 we'll just go ahead and use the existing connection
    that I've got for this that is。 out to another Salesforce org or another Scratch
    org that I created earlier。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道为什么那不工作。当然，我是在演示。好的。再试试。也许是那个字符。我将快速为我重新生成那个密码。好的。那么我们就继续使用我为这个连接的现有连接，它是连接到我之前创建的另一个
    Salesforce 组织或另一个 Scratch 组织。
- en: And just try recreating that Scratch org real quick。 Try one more time and see
    if we can get this to work。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再试一次快速重建那个 Scratch 组织。再试一次，看看我们能否让它工作。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_35.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_35.png)'
- en: If not， we'll just reuse that existing org that I've already connected。 But
    just to show you。 I want to be able to show you the whole process of connecting
    an， org up。 All right。 It's created my org and it's setting a password for it。
    See if we can get this to work now。 One of the nice things about Scratch org is
    it's easy to start from scratch when something。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不行，我们就会重用我已经连接的现有组织。但只是为了给你展示。我想能够向你展示连接一个组织的整个过程。好的。它已经创建了我的组织并为其设置了密码。看看我们能否让这个现在工作。Scratch
    组织的一个好处是，当某些事情出现问题时，可以轻松从头开始。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_37.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_37.png)'
- en: goes wrong。 That looks a lot better。 Okay。 So now it's going to ask me to grant
    access。 The name here is the name that you set in your connected app。 And so I'm
    going to go ahead and do allow。 Now one thing that I didn't do in my demo project
    is have this redirect back to a page。 that's more friendly than this one。 So I'm
    going to go back to this account page。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 出错了。看起来好多了。好的。现在它会让我授权访问。这里的名称是你在连接的应用中设置的名称。所以我将继续允许。现在在我的演示项目中，有一件事我没有做，就是让这个重定向回一个比这个更友好的页面。所以我要回到这个账户页面。
- en: And you'll notice that for this org， the last install status is empty and it's
    showing。 me install configuration。 So what I need to do is actually install the
    new version of that package that I just。 created into my Salesforce org。 And I
    can do that by just clicking install here。 Now in this demo。 I have this just
    kind of running directly in the web process。 In production。
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到对于这个组织，最后的安装状态是空的，并且它显示了我安装配置。所以我需要做的实际上是将我刚刚创建的那个包的新版本安装到我的 Salesforce
    组织中。我可以通过点击这里安装来做到这一点。在这个演示中，我只是直接在网络进程中运行它。在生产环境中。
- en: you would want to use some queuing mechanism， we use Django RQ or something。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你会想使用一些队列机制，我们使用 Django RQ 或其他东西。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_39.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_39.png)'
- en: like Celery to run this in a background worker process。 But I'll show you what
    this looks like in the dev server that's running in the background。 You can see
    that it is actually kicked off。 A little bit hard to see here。 What is that？
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 像**Celery**这样在后台工作进程中运行这个。但我会给你展示在后台运行的开发服务器上这看起来像什么。你可以看到它确实已经启动。这里有点难以看清。这是什么呢？
- en: So it is kicked off and gone out。 And what I've run here is the update dependencies
    task in Cumulus CI and just pointed it at the。 GitHub repository for this project。
    And it goes out and examines how Cumulus CI is configured in their project。 It
    looks at the latest releases in the repository。 And then it finds the latest release
    and goes through and installs that latest release for。
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它已启动并已执行。我在Cumulus CI中运行的是更新依赖任务，并将其指向这个项目的**GitHub**仓库。它会检查Cumulus CI在他们项目中的配置。它查看仓库中的最新版本。然后找到最新的发布并安装该最新发布。
- en: me automatically。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 自动为我完成。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_41.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_41.png)'
- en: So it looks like it's done now。 So that package that we created now just through
    this web app。 I managed to install into the， Salesforce org that I as a user of
    the app just connected to using my permissions in that。 work。 So now let's go
    create a delivery。 And let's say the supplier of this is a local farm。 I'll skip
    doing a scheduled date for now。 But let's say from a notes perspective。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 所以看起来现在完成了。我们创建的这个包现在通过这个网络应用程序安装到了我作为该应用程序用户的Salesforce组织中，使用我在工作中的权限。所以现在让我们来创建一个交付。假设这次的供应商是一个本地农场。暂时我会跳过设定计划日期。但从备注的角度来看。
- en: follow up next month to set a scheduled date。 And I have the option。 I've added
    the option here where I can pick which Salesforce instance do I want to integrate。
    this particular delivery。 So I might have a test environment。 a couple of different
    test environments in my production， environment。
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 下个月跟进以设定一个计划日期。我在这里添加了一个选项，让我可以选择想要集成哪个Salesforce实例来处理这个特定的交付。所以我可能会有一个测试环境，或几个不同的测试环境在我的生产环境中。
- en: This would allow me to pick which one of those。 And this here that is showing
    me is the Salesforce username that I used to log into that Salesforce。 instance。
    So I'm going to pick this second one here which is the new org that I just connected。
    and hit save。 Of course。 Oh， okay。 Quick code correction here。 This is a good
    opportunity to go in and look at the code for the integration anyhow。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让我选择其中一个。这边显示的是我用来登录Salesforce的**用户名**。所以我将选择第二个，这是我刚刚连接的新组织，并点击保存。当然。哦，好吧。这里有个快速代码修正。这正是一个好机会，可以查看一下集成的代码。
- en: So on the integration， I've got a model here or I've got two models， a delivery
    model and。 a delivery item model that have the appropriate objects。 I've overridden
    the save method here supporting a custom keyword for SF sync that can be set。
    to false。 If it's not set to false， then it's going to call this sync delivery
    job that I have。
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在集成中，我有一个模型，或者说我有两个模型，一个是交付模型，另一个是交付项目模型，这些模型包含了适当的对象。我在这里重写了保存方法，支持一个自定义关键字用于SF同步，该关键字可以设置为**false**。如果没有设置为**false**，那么它将调用我已有的同步交付作业。
- en: specified over here in this jobs file。 And the sync delivery job is going to
    receive a delivery ID and whether it's been created。 or not。 It's going to go
    try to look up that delivery by the ID。 If there's not a Salesforce user on that
    delivery， it just exits out because there's。 no Salesforce to sync it to。 And
    then I built this utility method。
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个作业文件中指定的。而同步交付作业将接收一个交付ID，并确认其是否已被创建。它将尝试根据ID查找该交付。如果该交付上没有Salesforce用户，它将直接退出，因为没有Salesforce可以进行同步。然后我构建了这个工具方法。
- en: get simple Salesforce connection that's going to， initialize an instance of
    simple Salesforce using the credentials from all off from the。 all off connection
    to Salesforce。 Then we run a query in Salesforce for the supplier by name。 And
    this query is a format called Sockl。 It's very similar to SQL。 but this is how
    you can query data inside of a Salesforce instance。
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 获取简单的Salesforce连接，这将使用从Salesforce的OAuth连接获取的凭据来初始化一个简单的Salesforce实例。然后我们在Salesforce中按名称查询供应商。这个查询的格式称为**Sockl**，它与**SQL**非常相似，但这就是你如何在Salesforce实例中查询数据。
- en: SF in this case is the instance of simple Salesforce。 So SF。query allows me
    to run a query。 I get back a result set， a result set。 It has keys for total size
    and records。 And it looks like the error was coming from line 23。 This is a dictionary。
    I had tested the other path of updating earlier before this demo， but in a relatively
    easy。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，SF是简单Salesforce的实例。所以SF.query允许我运行查询。我得到了一个结果集，包含总大小和记录的键。看起来错误来自第23行。这是一个字典。在这个演示之前，我测试了更新的其他路径，但相对简单。
- en: change to make there。 And it's either going to retrieve or get an existing account
    for my Salesforce instance。 with that name or it's going to create a new account。
    And then this is how in simple Salesforce you create an instance of a record。
    You give it the object name， just kind of a virtual class that gets created on
    the fly。
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行更改以创建账户。它将检索或获取我Salesforce实例中具有该名称的现有账户，或者会创建一个新账户。这就是在简单Salesforce中创建记录实例的方法。你给出对象名称，类似于实时创建的虚拟类。
- en: through a simple Salesforce。 Call the create method on it。 You pass it to dictionary
    of the values。 And then I'm getting the Salesforce ID of what was synced and saving
    it on this individual， record。 I'm going to go back and rerun that save here。
    Cool。 So I've now got my object created and I've got a link here to go over and
    view that in， Salesforce。
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单Salesforce。调用它的创建方法。你将值的字典传递给它。然后我获取同步的Salesforce ID并将其保存到这个单独的记录中。我将返回并重新运行保存。很好。我现在已经创建了我的对象，并且有一个链接可以查看Salesforce中的内容。
- en: If I click view， this is going to take me over into Salesforce where I can see
    that record。 in the schema that we created over on the Salesforce side。 So I can
    see it's linked out to a supplier， a local farm。 Under related。 I can see it doesn't
    have any delivery items right now。
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我点击查看，这将带我进入Salesforce，在我们创建的架构中查看该记录。所以我可以看到它链接到一个供应商，一个本地农场。在相关项下，我可以看到现在没有任何交付项目。
- en: So I actually have to pause this video and come back because I've got a meeting
    I've got。 to jump into but have time after this that I will finish up the rest
    of the session and。 splice it in。 So be back in just a sec。 All right。 so we're
    going to pick up where we left off in walking through this Django。
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我实际上必须暂停这个视频并回来，因为我有一个会议要参加，但在这之后我会完成剩下的部分并剪辑进去。所以稍等一下。好了，我们将从我们在Django中走过的地方继续。
- en: app that we've now got integrated with Salesforce。 And we just walked through
    the integration of the deliveries。 And let's go ahead and check the delivery items。
    So let's go ahead and create some delivery items。 Let's say we've got carrots。
    Save that。 We've got some frozen peas and those need to be stored as frozen。
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在与Salesforce集成的应用程序。我们刚刚走过了交付的集成。让我们检查交付项目。让我们创建一些交付项目。假设我们有胡萝卜。保存一下。我们有些冷冻豌豆，这些需要存储为冷冻状态。
- en: And we've got some potatoes。 By the fact that I didn't get any errors in saving
    those。 I'm presuming that those， items actually synced over to Salesforce as part
    of the save。 So let's go over and look at that delivery record in Salesforce。
    And this time we'll go to related and I can see those values are now entered into
    the。
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还得到了些土豆。由于我在保存这些时没有收到任何错误，我推测这些项目实际上在保存过程中同步到了Salesforce。让我们去Salesforce查看那条交付记录。这次我们将查看相关内容，我可以看到那些值现在已经输入。
- en: Salesforce app。 Now the thing that's cool about this is for this nonprofit organization。
    they also now， have this a local farm as a supplier。 Now in our application。 all
    that we had was just a name for who supplies the delivery。 But now that this is
    in Salesforce。 they have full capability to maintain a list of， contacts from
    that organization。
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Salesforce应用程序。现在，这对这个非营利组织来说非常酷，因为他们现在有一个本地农场作为供应商。在我们的应用中，我们仅有供应交付的名称。但现在在Salesforce中，他们有完整的能力来维护来自该组织的联系人列表。
- en: different donation opportunities that they might be， getting value from that
    organization。 have all the information about the organization。 And all of these
    are totally customizable by them so that they can build this constituent。 relationship
    management environment to be what they need as an organization to be able。 to
    track their different suppliers， their relationships with their suppliers。
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的捐赠机会，他们可能会从该组织中获得价值。拥有关于组织的所有信息。而且所有这些都是完全可定制的，以便他们能够构建这个客户关系管理环境，满足他们作为组织的需求，以便跟踪他们不同的供应商及其与供应商的关系。
- en: They also have access to chatter so they can come in and have kind of a threaded
    feed of。 discussion related to this particular supplier。 So there's a lot of functionality
    that your application gains that you don't have to build。 into the application
    yourself。 You just kind of need to get the data synchronized with Salesforce and
    you can use all of the。 open source tools that we built and written in Python
    in order to be able to do that。
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 他们还可以访问聊天功能，因此他们可以在这里进行与特定供应商相关的讨论的线程式动态。因此，您的应用程序获得了很多功能，而您无需将其构建到应用程序中。您只需将数据与Salesforce同步，就可以使用我们用Python编写的所有开源工具来实现。
- en: Now let's dig into the code a little bit for this integration so that we can
    kind of see。
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入了解这个集成的代码，以便我们能够大致了解。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_43.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_43.png)'
- en: what it's doing。 So we started walking through this jobs file that has the sync
    delivery function inside。 of it。 And we're querying for the delivery based on
    ID。 Then we're getting a simple Salesforce connection。 We'll take a look at that
    function here in a minute。 But to just continue walking through this one。
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它所做的。所以我们开始查看这个包含同步交付功能的作业文件。我们正在根据ID查询交付。然后我们获取一个简单的Salesforce连接。稍后我们将查看该功能。但为了继续浏览这个文件。
- en: we're running a query against Salesforce， to query for an account whose name
    is the supplier name on the delivery。 Then we're either creating a new account
    or using the first record that we found with， that name。 And then if created is
    true， so if this was a new record that was just created， we go。 ahead and create
    the record inside of the Salesforce instance， get back the Salesforce。
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在对Salesforce运行查询，以查询供应商名称为交付名称的帐户。然后我们要么创建一个新帐户，要么使用找到的第一个记录，如果created为true，即如果这是一个刚刚创建的新记录，我们将继续在Salesforce实例中创建该记录，获取Salesforce。
- en: ID of the record， which is how we're building that link to link out to the record
    in Salesforce。 And then saving that record and telling it don't worry about syncing
    this to Salesforce。 because we're just updating the Salesforce ID。 If it was an
    update to the record。 we do pretty much the same thing。 In this case， we're going
    to query for Salesforce for the record based on the ID that we have。
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的ID，这就是我们如何构建链接以链接到Salesforce中的记录。然后保存该记录，并告诉它不要担心将其同步到Salesforce，因为我们只是更新Salesforce
    ID。如果这是对记录的更新，我们几乎做同样的事情。在这种情况下，我们将根据我们拥有的ID查询Salesforce中的记录。
- en: in the Salesforce ID field。 If we don't find anything though。 it's possible
    that the record got deleted from Salesforce， and you want to recreate that record。
    So we're just going to call Sync Delivery again， but this time tell it that we
    created， it true。 So it will just go ahead and create a new record。 Otherwise。
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在Salesforce ID字段中。如果我们没有找到任何内容，可能是记录已从Salesforce中删除，并且您想要重新创建该记录。因此我们将再次调用Sync
    Delivery，但这次告诉它我们已创建，值为true。这样它将继续创建一个新记录。否则。
- en: it's going to call through simple Salesforce through our object and call the，
    update method。 Now one thing you might notice here is this CCIFB1_ that is the
    namespace prefix that's。 applied to all schema that is inside of a manage package。
    So when you reserve a namespace in Salesforce that's globally unique for your
    manage package。
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 它将通过我们的对象调用简单Salesforce并调用update方法。您可能会注意到这里的CCIFB1_是应用于所有管理包中架构的命名空间前缀。因此，当您在Salesforce中保留一个命名空间时，它是针对您的管理包全球唯一的。
- en: all of your objects get this prefix kind of applied to them。 Also all the fields
    that you create get this prefix applied to them。 It helps avoid collisions。 So
    say you have a common field like SAGUTATION or something like that， it avoids
    multiple。 different packages colliding with each other。 And then for the delivery
    item synchronization。
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您的所有对象都会应用此前缀。您创建的所有字段也会应用此前缀。这有助于避免冲突。因此，如果您有一个常见字段，如SAGUTATION或类似的东西，它可以避免多个不同的包之间的冲突。然后，对于交付项目的同步。
- en: very similar process， we're going to query， for the delivery item。 check to
    make sure that it's delivery has a Salesforce user， get。 an instance of the simple
    Salesforce API， check to see if it's created。 So if it's a new record。 then we're
    going to go ahead and create it in Salesforce and， record back the ID。
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 非常类似的过程，我们将查询交付项目。检查确保它的交付有一个Salesforce用户，并获取一个简单Salesforce API的实例，检查它是否已创建。因此，如果这是一个新记录，我们将继续在Salesforce中创建它，并记录回ID。
- en: And if it's an update to the record， then we will go ahead and query to make
    sure that。 that record still exists in Salesforce if not recreate it。 And if so。
    go ahead and update the record just with the description and the storage requirements，
    field。 So the integration is pretty easy。 Once you have that connection formed
    to Salesforce and once you have the schema installed into。
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是对记录的更新，我们将继续查询以确保该记录在Salesforce中仍然存在，如果不存在则重新创建它。如果存在，则仅用描述和存储要求更新该记录。因此，集成非常简单。一旦建立与Salesforce的连接，并且将架构安装到。
- en: the package on the other end。 So that's how we're actually syncing the data。
    What I want to show you next is how we are， how this package is handling getting
    the package。
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 另一端的包。所以这就是我们实际同步数据的方式。接下来我想向您展示的是，这个包是如何处理获取包的。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_45.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_45.png)'
- en: installed for the user。 Because I think this is where you're really tapping
    into a lot of the value of Cumul C。I。 as a framework。 You're just tapping into
    Cumul C。I。 as portable automation to be able to run an installation。 So I've created
    a basic model here for the package install。
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为用户安装。因为我认为这正是您真正利用Cumul C。I。作为框架的价值所在。您只需利用Cumul C。I。作为可移植的自动化来运行安装。因此，我在这里为包安装创建了一个基本模型。
- en: It has a link out to the all auth social account， which is your Salesforce OAuth
    connection。 And then it has a status field with the statuses here。 It has fields
    to track when it was queued。 when it started， when it ended and a field to， track
    exceptions on it。 Now you could expand this out in a meta deploy。 For instance。
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 它链接到所有认证社交账户，这是您的Salesforce OAuth连接。然后它有一个状态字段和状态信息。它有字段来跟踪何时排队，何时开始，何时结束，以及一个字段来跟踪异常。现在，您可以在元部署中扩展这个。
- en: we capture the full log into a field in the database so that it's easy。 to go
    see on an individual installation if something failed。 And we've wired this up
    into the Django admin panel。 Let me show you what that looks like。 If I come out
    here and go to package installs， I can actually see every one of the installs。
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将完整日志捕获到数据库中的一个字段，以便在个别安装中如果出现故障时容易查看。我们将其集成到Django管理面板中。让我给您展示一下那是什么样子。如果我进入包安装，我实际上可以看到每一个安装。
- en: that's been run of my package。 So that you can go out and keep an eye on， hey。
    if your customers are starting to hit installation， errors。 maybe there's something
    you want to change in the automation and how it's working。
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我包的运行情况。这样您就可以随时关注，如果您的客户开始遇到安装错误，您可能想在自动化和它的工作方式中做一些更改。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_47.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_47.png)'
- en: to address those issues。
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 来解决这些问题。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_49.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_49.png)'
- en: And then we've got these， a couple of utility functions that I built。 The first
    utility function is to escape single quotes。 This is in Sockl queries。 There's
    not support for parameterization or parameterized queries over the REST API。 But
    the biggest risk for injection， because you can't use semicolon in order to have
    another。
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有几个我构建的实用函数。第一个实用函数是转义单引号。这在Sockl查询中非常重要。REST API不支持参数化或参数化查询。但注入的最大风险在于，您不能使用分号来进行另一个。
- en: query or another command afterwards。 So the biggest risk here is single quote
    being inside of the value。 So we go ahead and escape that value in that case。
    Then this simple function to take a social account and parse out the Salesforce
    credentials。 from it。 And this is going to use decryption in order to。
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 查询或之后的另一个命令。因此，最大的风险是值内部的单引号。因此，在这种情况下，我们会转义该值。然后这个简单的函数用于获取社交账户并解析出Salesforce凭证。这将使用解密。
- en: decryption helper that's available through， SFDO template helpers。 And that
    will go decrypt the values that are stored encrypted in the database， get you。
    the token in the secret and return back a quick dictionary。 Now to build a simple
    Salesforce connection， you just pass it a social account。
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 可通过SFDO模板助手获得的解密助手。它将解密存储在数据库中加密的值，为您获取令牌和密钥，并返回一个快速的字典。现在要建立一个简单的Salesforce连接，您只需传递一个社交账户。
- en: And it does a couple of things。 This is kind of common code that we use for
    modifying requests to automatically retry calls。 in the API calls。 You go ahead
    and call get credentials that we just looked at in order to parse out the。 credentials
    from the social account。 And then you just initialize an instance of simple Salesforce。
    You've got to pass it the instance URL of the Salesforce instance that's available
    in。
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 它执行了几项操作。这是一段我们用于修改请求以自动重试API调用的常见代码。你可以调用我们刚刚查看的获取凭证函数，以解析社交账户中的凭证。然后你只需初始化一个简单的Salesforce实例。你需要传递Salesforce实例的实例URL。
- en: extra data and then the key instance URL。 And it needs the token from the credentials。
    We're also going to tell it a Salesforce API version number。 The API in Salesforce
    is versioned。 So you can still， you know， by specifying this as kind of a fixed
    value， you're sort。 of assured that you're going to be interacting with the same
    API even as Salesforce continues。
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 额外数据和key实例URL。它需要凭证中的令牌。我们还将告诉它一个Salesforce API版本号。Salesforce中的API是有版本的。因此，通过将其指定为固定值，你就能确保在Salesforce持续更新时与同一API进行交互。
- en: to update releases。 Then we're going to set some headers on the call in order
    to handle authentication of。 the call and go ahead and mount our adapter for retries
    onto the session and then return。 back that configured API instance。 Now the actual
    installation of that package。 So just to go back and kind of set where this was
    in the UI。 If I come back to my account here。
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 更新发布版本。然后，我们将为调用设置一些头，以便处理身份验证。接下来，将我们的适配器挂载到会话上以进行重试，然后返回配置好的API实例。现在安装该包的实际步骤。为了回顾一下在用户界面中的位置，如果我回到我的账户。
- en: if I click reinstall configuration， it's going to call。 this section of code
    that we're looking at next。 And this section of code is actually going to initialize
    an instance of the key millisci。 runtime and then configure one of the default
    key millisci tasks， update dependencies and。 pass it an option to tell it go install
    this other GitHub repository for your key millisci， project。
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我点击重新安装配置，它将调用我们接下来要查看的这段代码。这段代码实际上将初始化一个key millisci运行时的实例，然后配置一个默认的key millisci任务，更新依赖关系，并传递一个选项，告诉它去安装你key
    millisci项目的其他GitHub存储库。
- en: the CCI food bank repository， go install that repository into this org。
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: CCI食品银行存储库，去将该存储库安装到这个组织中。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_51.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_51.png)'
- en: And so to do that， we've got to do a little bit of boilerplate kind of wiring
    for things。 But that's going to be done in this method deploy repo。 And here we
    need a social account of what's the target Salesforce environment that we want。
    to run this against。 We need to know what we're storing。
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要为某些事物做一些样板式的接线。但这将在deploy repo方法中完成。在这里，我们需要一个社交账户，了解我们想要运行的目标Salesforce环境。我们需要知道我们在存储什么。
- en: what class we're storing the result against。 You could just pass a package install
    but say there's other operations you want to do。 this abstracts it out just a
    little bit。 And so in this case。 we're going to query the result class in order
    to go get the instance。 of the result object where we want to store kind of the
    status and the date updated or。
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们存储结果的类。你可以直接传递包安装，但假设你还有其他操作要做。这稍微抽象了一下。因此在这种情况下，我们将查询结果类，以获取我们想要存储状态和更新时间的结果对象。
- en: the date started and date ended on the operation。 And the next thing we're going
    to do is prepare in key millisci an org configuration or org。 config。 So we've
    got to go get the social account， we're going to call get Salesforce credentials。
    the helper function that we looked at in the utils file earlier and get that credential。
    Then we're going to build an org config by passing it a dictionary of the relevant
    configuration。
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的开始日期和结束日期。接下来，我们将准备一个key millisci的组织配置或org config。我们需要获取社交账户，将调用获取Salesforce凭证的助手函数，之前在utils文件中查看过，并获取该凭证。然后，我们将通过传递相关配置的字典来构建一个组织配置。
- en: that we need it to have。 It needs an instance URL， an access token and a refresh
    token。 Then we're going to give that org a name。 And in this case。 it's not a
    persistent keychain so we're just going to call that org connected， for going
    forward。 The next thing that we need to do is prepare the OAuth connected app
    service。
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要它具备。它需要一个实例 URL，一个访问令牌和一个刷新令牌。然后我们将给这个组织命名。在这种情况下，它不是一个持久的钥匙串，所以我们将把这个组织称为连接的，接下来进行操作。我们需要做的下一件事是准备
    OAuth 连接的应用服务。
- en: And this is actually going to be querying out to the social app from the provider
    in。 OAuth and getting the client ID and the client secret and configuring a service
    configuration。 for the key millisci keychain for the connected app that allows
    us to do OAuth to get home。 or to Salesforce。 Then we also need to configure the
    GitHub service in the key millisci keychain so that。
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这将向提供者的社交应用程序进行查询，以获取 OAuth 的客户端 ID 和客户端密钥，并为 key millisci 钥匙串配置一个服务配置，连接的应用程序允许我们通过
    OAuth 获取 home 或 Salesforce。然后，我们还需要在 key millisci 钥匙串中配置 GitHub 服务。
- en: we can run automation against the GitHub API as part of this task that we're
    going to， run。 To do that， we initialize another service configuration。 In this
    case。 we're just going to have password as the configuration value and pass it
    the。 GitHub token from settings。 And in fact， this should get modified here。
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这个任务中针对 GitHub API 运行自动化。为此，我们初始化另一个服务配置。在这种情况下，我们只会将密码作为配置值，并传递它。来自设置的
    GitHub 令牌。实际上，这里应该进行修改。
- en: That was working because of old records in my database but this should actually
    be connected。 app client ID。 And this should be settings connected app client
    secret。 All right， save that。 And so we've got our org config created stored as
    the variable org。 We've got a connected app service config created， a GitHub service
    config created。
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有效的，因为我的数据库中有旧记录，但这实际上应该是连接的应用客户端 ID。这应该是设置的连接应用客户端密钥。好的，保存这个。所以我们已经创建了我们的组织配置，并将其存储为变量
    org。我们创建了一个连接的应用服务配置，一个 GitHub 服务配置。
- en: Now we need to initialize the key millisci run time。 So I built a slight extension
    of key millisci run time just to kind of take out some of the。 assumptions that
    are made in key millisci that it's running inside of a Git project and。 everything
    so that we don't have to download a GitHub repository。
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要初始化 key millisci 运行时。因此，我构建了一个 key millisci 运行时的小扩展，以便去掉一些假设，即它运行在一个 Git
    项目中，且我们不需要下载 GitHub 仓库。
- en: We just want to be able to run this task as Python code。 So we'll take a look
    at that next。 But for now， we're just initializing the key millisci run time as
    CCI。 That's going to have an attribute on it for the keychain。 We're calling the
    set service method on the keychain to tell it here is the connected app， service。
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只希望能够将这个任务作为 Python 代码运行。因此，我们将接下来看看这个。但现在，我们只是将 key millisci 运行时初始化为 CCI。它将有一个用于钥匙串的属性。我们调用钥匙串上的设置服务方法，告诉它这是连接的应用服务。
- en: And here's the GitHub service。 This last option here is whether you want to
    set the service at a global level or at a。 per project level。 So true sets at
    a global level。 Then we're going to prepare a task configuration that has the
    options that we want to pass into。 the update dependencies task。 And in this case，
    update dependencies accepts an option called dependencies。
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 GitHub 服务。这里的最后一个选项是你想要将服务设置为全局级别还是按项目级别。因此，设置为 true 则是全局级别。接下来，我们将准备一个任务配置，包含我们想要传递给更新依赖项任务的选项。在这种情况下，更新依赖项接受一个名为依赖项的选项。
- en: You pass it a dictionary or you pass it a list of dictionaries for the dependencies。
    And if your dependency has a key GitHub， you can just point it at a GitHub repository，
    URL。 And it will go out and examine that GitHub repository URL and write everything
    out for。 you and kind of handle installing that URL as a cumulaci project。
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你传递一个字典或一个字典列表作为依赖项。如果你的依赖项有一个键 GitHub，你可以直接指向一个 GitHub 仓库 URL。它会访问并检查那个 GitHub
    仓库 URL，并为你写出所有内容，并处理将该 URL 安装为一个 cumulaci 项目。
- en: So next we're going to import from cumulaci tasks Salesforce， the update dependencies
    class。 And then we're going to initialize that class passing it the project config
    from the runtime。 the task configuration from here， and the org configuration
    that we created up above。 So that's what's needed in order to initialize any instance
    of a cumulaci task。
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从cumulaci任务Salesforce导入更新依赖类。然后我们将初始化该类，传入来自运行时的项目配置，从这里的任务配置，以及我们上面创建的组织配置。这是初始化任何cumulaci任务实例所需的。
- en: And then we're going to go ahead and these task classes you basically build
    an instance。 and then the instance itself is runnable。 So we're going to run the
    task here。 And then we're going to record or set the status field to success unless
    there's an exception。 then we'll set the status to failed and record the exception
    as the exception field on the， object。
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将继续构建这些任务类的实例。然后实例本身是可运行的。所以我们将在这里运行任务。然后我们将记录或将状态字段设置为成功，除非出现异常。然后我们将把状态设置为失败，并将异常记录为对象上的异常字段。
- en: And in either scenario， we'll go ahead and set the date end and do result。save。
    So a little bit of code to kind of walk through， but I mean really in， you know，
    73 lines of， code。 you've managed to automate the installation of a package。 And
    really you could tap into doing a lot more automation here if you wanted to by
    leveraging。
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们将设置结束日期并执行结果。保存。所以有一点代码来逐步走过，但我的意思是，实际上在73行代码中，你已经实现了包的自动安装。实际上，如果你想利用这一点，你可以进行更多的自动化。
- en: all of the different automation that's available in cumulaci and any cumulaci
    task or flow。 Now the final thing to show you is in the CCI file， I've created
    an extension of the base。 cumulaci runtime， imported that from cumulaci core runtime。
    And all the only reason I created this extension was so that I can specify a different
    project。
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: cumulaci中所有不同的自动化和任何cumulaci任务或流程。现在最后一件要展示的事情是在CCI文件中，我创建了一个base的扩展。cumulaci运行时，从cumulaci核心运行时导入。创建这个扩展的唯一原因是为了我可以指定一个不同的项目。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_53.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_53.png)'
- en: class。 Now a project assumes that it's going to be running inside of a GitHub
    repo。 So in this case。 I want to go ahead and feed it the repo info as a dictionary。
    And in this case。 I also just went with a blank cumulaci configuration。 The configuration
    that parses yaml is a subclass of base project config。
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 类。现在一个项目假定它将在GitHub repo内部运行。因此，在这种情况下。我想将repo信息作为字典提供。并且在这种情况下。我也只是选择了一个空的cumulaci配置。解析yaml的配置是base
    project config的子类。
- en: And it called yaml project config that will actually parse the yaml file。 But
    in this case。 we don't have a repository that we're working with。 We want to kind
    of point it at a repository over the API。 So I've just provided it the configuration
    that the project is going to need in order。
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 它称为yaml项目配置，实际上会解析yaml文件。但在这种情况下。我们没有正在处理的仓库。我们想通过API指向一个仓库。因此，我只提供了项目所需的配置。
- en: to run what I need it to run。 So it's going to need to know the API version
    that we want to target。 It's going to need to know the description of the services
    that I want to connect to， it。 App service needs to have an attribute client ID
    and client secret。 The GitHub service needs to have a password attribute。 And
    that's pretty much it。
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我需要它运行的内容。所以它需要知道我们想要针对的API版本。它需要知道我想要连接的服务的描述。应用服务需要有属性客户端ID和客户端密钥。GitHub服务需要有一个密码属性。就这些。
- en: So not a whole lot of override of cumulaci， but something that's really easy
    to do just。 in a subclass。 And with the combination of those things， the OAuth
    integration。 this integration of cumulaci， to be able to run a cumulaci task to
    kind of target automation at your user's org。 And with the code in deliveries
    in this job section to actually do the sync of data between。
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 所以并没有太多对cumulaci的覆盖，但只是在子类中做的非常简单。结合这些内容，OAuth集成。这种cumulaci的集成，使得能够运行cumulaci任务，针对用户的组织进行自动化。并且在这个作业部分的代码中实际进行数据同步。
- en: those once the target org has already been configured， really you've got a pretty
    full。 scale integration。 Now just to emphasize again， all of this is actually
    using the--all of this integration。 is running in line in the process。 You do
    not want to do that in production。 You should be tossed into a background worker
    queue， handled asynchronously with retries。
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦目标组织已被配置，你就拥有了一个相当完整的规模集成。现在再强调一下，所有这些实际上都是在过程中运行的集成。你不想在生产环境中这样做。应该将其放入后台工作队列，以异步方式处理，并进行重试。
- en: and kind of error monitoring and things like that。 You'll want to do tweaks
    on the front end user experience for users so that you're showing。 them updates
    on the process as it's running and things like that。 But all those things are
    kind of standard parts of building a Python web application。
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 以及错误监控等事情。你需要在前端用户体验上进行调整，以便在过程运行时向用户显示更新等。但是所有这些都是构建Python Web应用程序的标准部分。
- en: So you can apply your creativity and your approach to user experience on top
    of it。 But cumulaci provides a lot of the plumbing that you would need in order
    to build this。 kind of an integration。 So with that， we're through the demo portion
    of the session。 And I'll leave you with just some resources for additional information。
    First and foremost。
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你可以在此基础上发挥你的创造力和用户体验的方法。但cumulaci提供了构建这种集成所需的很多基础设施。因此，演示环节到此结束，我会为你提供一些额外信息的资源，首先。
- en: if you're interested in cumulaci， is going--I really recommend going， through
    the Trailhead Trail。 It'll probably take you about a day， honestly as a Python
    developer， maybe less than that。 But that cumulaci trail will allow you to do
    a lot of what we did in the first part of， the demo。 but also even more in showing
    you how to sync data sets。
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对cumulaci感兴趣，我真的建议你通过Trailhead学习。作为Python开发者，诚实地说，这可能需要你一天的时间，甚至更少。但这个cumulaci学习路线将让你实现我们在演示第一部分所做的很多事情，甚至更多，教你如何同步数据集。
- en: And it'll also walk through the process of uploading a managed package and even
    building。 another repository that's an extension of that project that has kind
    of customer-specific。 implementation details。 Also the cumulaci documentation
    is available at cumulaci。readthedocs。io。 That is documentation we're in the process
    of reworking， but there's a lot of good reference。
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将指导你上传托管包的过程，甚至构建一个扩展该项目的另一个仓库，具有客户特定的实施细节。此外，cumulaci的文档可以在cumulaci.readthedocs.io找到。那是我们正在重做的文档，但有很多好的参考。
- en: material there about how we manage data sets， about our integration with robot
    framework。 and some individual features of cumulaci that you can look into。 And
    then finally。 the three GitHub organizations that are really great places to dig
    into。 First is Salesforce Foundation， which is where all of our open-source products
    live。
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们如何管理数据集的材料，关于我们与机器人框架的集成，以及一些你可以研究的cumulaci的单独功能。最后，有三个GitHub组织是深入探索的好地方。首先是Salesforce
    Foundation，这是我们所有开源产品所在的地方。
- en: so you can go find the repository for NPSP。 If you really want to understand
    cumulaci and all the different things you can do with。 it， I highly recommend
    going to those open-source project repositories and looking at the cumulaci。yml，
    files in them to see the way all the different types of automation that we've
    implemented。 for our projects using cumulaci。 SFDO tooling is my team's GitHub
    organization。
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以找到NPSP的仓库。如果你真的想了解cumulaci及其所有不同功能，我强烈建议你访问这些开源项目的仓库，并查看其中的cumulaci.yml文件，以了解我们为项目实现的各种自动化方式。SFDO工具是我团队的GitHub组织。
- en: It's where all the open-source tools that we talked about live。 You can go kind
    of see the development process of all of that tooling there。 And then finally。
    SFDO community is the GitHub organization for open-source commons projects。 that
    are community-driven and that we help support and facilitate with all of this
    tooling。
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 所有我们讨论过的开源工具都在这里。你可以看到所有这些工具的开发过程。最后，SFDO社区是开放源代码公共项目的GitHub组织，这些项目由社区驱动，我们帮助支持和促进所有这些工具。
- en: So thank you very much for making it through this rather lengthy session with
    me。 I am super excited to get to share this with the Python community。 I'm incredibly
    grateful to the Python community for everything that's been built that allows。
    me or that has allowed us to be able to create this tooling that really is essential
    to everything。
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢你能够参加这次相当长的会议。我非常兴奋能够与Python社区分享这些。我对Python社区所建立的一切深表感激，这使得我或者我们能够创造出这个对一切至关重要的工具。
- en: that our team does and really helps us maximize the impact that we can create
    in the world。 So thank you。 [BLANK_AUDIO]。
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们团队所做的确实帮助我们最大化在世界上创造的影响力。所以谢谢你。[BLANK_AUDIO]。
- en: '![](img/80d398914e0f602867ed182ef02f1adf_55.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d398914e0f602867ed182ef02f1adf_55.png)'
