# P20：Talk Aly Sivji - If Statements are a Code Smell - 程序员百科书 - BV1rW4y1v7YG

![](img/62a307e40635ec771b228bfe8aa8073b_0.png)

我想感谢蟒蛇的组织者，以及 python软件基金会的所有员工，你们都做得很好，把 pyon从匹兹堡搬到网上，我真的很感激有这个机会和社区分享我的知识，对所有在场观看的人，谢谢收听，听我咆哮，IF语句。我们会有一些乐趣，我叫阿里西吉，你可以在推特上找到我，我在卡亚西巴斯，我是芝加哥蟒蛇用户组织的组织者之一，我们称自己为奇皮，奇皮是世界上最大的蟒蛇群落之一，我们有大约六千名成员。

每个月我们都会举办四到六场活动，通常情况下，我想邀请你们都来芝加哥参加一个活泼的活动，但我们不得不取消所有的面对面会面，直到安全地在大凹槽里见面，但我们一直在通过各种在线平台 让我们的社区参与进来。几个星期前，订阅我们的频道，敲钟，图标以获得我们即将到来的直播流的通知，希望在那里见到你们，这篇演讲的标题是 如果语句是代码气味，有点煽动性，但我想先说我不是来攻击任何人的，我不是来攻击任何人的代码的。

我只是想分享我的经验，使用一种模式来帮助我编写更易读的代码和更可测试的代码，如果陈述是什么，如果语句是编程语言的元素，允许我们控制执行哪些语句，通常当我们运行一个程序时，我们从上到下执行。一行接一行地执行，当我们使用 if语句时 条件为真，我们要执行一段代码 然后继续，但如果那个条件是假的，我们可以跳过那一段代码，继续像什么都没发生过一样，所以让我们把它说得更具体一点，这里有些蟒蛇。

我们的代码在这里检查，如果今天的变量等于用户的生日，如果是这样，我们要印一条生日快乐的信息，如果没有，我们就跳过这一点，继续像什么都没有一样，发生了，因此，如果语句是真的。我们就有能力告诉计算机做我们想做的任何事情，当给定的条件是真的时，通过把一系列的 if语句联系在一起 我们可以完成任何我们能想到的任务，这是一个非常强大的概念，其中一个原因就是，在大多数编程语言中。

语句是一个基本的构建块，但是如果代码中有太多的语句，它使事情难以遵循，甚至更难修改，有难以遵循的代码意味着什么，这可能是意大利面逻辑，在这里我们要上下滚动，多个模块之间的选项卡。试着按照代码的线程来了解发生了什么，很难遵循的代码 也是做许多不同类型事情的长函数，它也可能是没有逻辑地分组在一起的相关功能，如果我们在将解决方案转化为代码方面做得不好，它可能真的很难跟随。

这可能是一些糟糕的变量名或糟糕的函数名，或者我们可以以线性的方式做一些事情，而不是使用更高阶的抽象，当我们进行更改时，有难以修改的代码是什么意思，我们必须去接触我们代码库的许多不同部分。当我们添加新功能时，我们必须修改我们已经写好的代码 来使这个新特性适合，难以修改的代码 可能会在整个代码库中散布重复的逻辑，当我们要去改变的时 候，我们确定我们改变了我们需要的每一个部分。

当我们没有测试的时候，代码真的很难修改，我们怎么知道我们所做的改变是否如预期的那样有效，我们怎么知道我们所做的更改没有破坏现有的功能，我们不知道，我们的代码很难理解，代码很难修改，我们称之为暗号。这是指一个编程模式，它可能表明有什么地方出了问题，我想重申一下 代码气味可能表明出了问题，这并不意味着肯定有问题，如果有些事情很难理解，我们能简化这个逻辑吗，如果改变需要太长时间，我们能修改一下设计吗？

所以我们可以走得更快，展望未来，我们要讨论的第一种代码是化合物，if语句，我们有一个，如果语句或代码，它是相当可读性与复合语句，在解析中，事情变得有点困难，条件中的复杂度就越高，我们的逻辑就越难理解。我想提出的一个建议是将条件重构为布尔变量或布尔函数，回到那个，有两个条件的 if语句，我们可以将条件重构为具有描述性名称的变量，然后我们可以重用这个变量，在我们的，如果条件。

更复杂的条件一遍又一遍地有相同的值，我们可以将其重构为一个函数，使我们的代码更具可读性，另一种使我们的代码难以阅读的模式是嵌套的，如果语句，当我们有一系列嵌套的 if语句，它使我们的代码变成箭头的形状。而且箭头代码也有一些问题，首先，箭头代码具有很高的循环复杂度，这是一个通过代码库代码的不同路径的数量的度量，代码库代码具有很高的循环复杂度，很难理解，而且更难测试，当我们深深筑巢，IF语句。

它确实限制了我们每行可以使用的字符，我们把所有的角色都浪费在空格上了，第二个重构技巧是让箭头代码变平，在芝加哥，我们有一个自行车共享计划与公共应用程序接口，在我的公寓里，我有一个仪表板。让我知道离我最近的车站还有多少辆自行车，让我们遍历生成仪表板的代码，我们将使用请求库来访问应用程序接口，我们会得到回应的，如果反应是200，我们要把空间站的数据，我们要把每个车站都绕进去。

空间站有效载荷，直到我们找到我们在乎的人，如果那个车站的自行车数量小于或等于我们这里的门槛，门槛三，我们要回一条信息，如果大于3，我们会给你一个不同的信息，我们可能会提出一个例外作为回报。就在这里 它应该会引起一些危险信号，它真的离它相关的代码很远，我们有很多方法可以考虑把箭头代码变平，主要的想法是我们希望尽快返回，在我们的例子中，我们要写一个保护条款，这将把我们的正面检查变成负面检查。

所以回到这里的代码，我们要写一个保护条款，这是检查是否响应的状态 代码不是200，如果是这样的话，它将提前退出，这就剩下我们的逻辑了，在我们的模块内没有嵌套，我也想说，我把那个街区的其他东西都拆掉了。因为我真的不需要它，我们将要讨论的第三种也是最后一种代码咒语是当我们有，如果语句遍布整个代码库，当我们讨论前两种代码时，它们很容易识别，也很容易修复这种类型的代码磨坊，容易辨认。

但在我们设计解决方案之前，需要对这个问题有更多的了解，我们以前都见过这样的代码，我们在整个代码库中都有相同的检查，老实说，这真的不是什么大问题，如果我们不需要改变这个代码。但如果我们要修改这个代码 或者至少要读懂这个代码，探索一种不同类型的抽象 可能是有意义的，那么我们应该用什么模式呢？如我所说，我们需要对问题有更深刻的认识，在我们设计解决方案之前，让我们来探索复制。

如果陈述与案例研究在芝加哥 蟒蛇松弛，我们有一个叫做忙碌海狸的社区 参与机器人，忙碌的海狸参与我们社区的方式之一是在指定的渠道为我们的注册用户分享公共 github活动，我们如何生成每日总结，召回。我们可以串联一系列 if语句来完成任何任务，我们可以想到为单个 Github用户生成摘要文本的算法，我们先从应用程序接口抓取数据，接下来我们将按事件类型收集事件，对于这些事件类型中的每一个。

我们要计算一些事件统计数据，最后我们要生成一些摘要文本，对于一个最小可行的产品，我们只需要追踪两种事件类型，我们只关心用户提交的所有内容，除了所有的存储库，用户还可以选择。让我们看看刚才在代码中提到的步骤，我们将从 github api抓取数据开始，这里有这样做的代码，我们将从设置头部开始，我们要去打那个应用程序接口，然后我们要返回我们的 json有效载荷。

请求库的标准使用，接下来我们要从 json有效载荷中提取感兴趣的事件，这是做到这一点的 代码，我们要从我们的有效载荷上遍历每个事件，我们将在字典中按事件类型收集事件，最后我们要把字典还给。这个字典将有一个事件类型的键，这个值就是这个类型的所有事件的列表，最后，我们要为所有我们关心的事件生成一个摘要文本，这个函数为单个用户生成一个 Github摘要，所以我们要从创建我们的头文件开始。

我们将遍历字典中的每个键值 对，然后我们将根据事件类型更新文本，最后我们将返回总结文本，我们刚刚生成了，太完美了，我们创造了我们的最有价值球员，幸运的是我们在芝加哥，大家都喜欢忙碌的海狸。他们想让我们开始追踪更多的事件类型，所以让我们修改我们的代码，所以我们可以开始追踪一个额外的事件 时间，我们将把用户创建的所有新的轮询请求添加到我们的 Github摘要功能中，看一下前面的执行函数。

我们要在 if else的序列中添加另一个条件块，在这里，我们将检查事件类型是否是一个拉出请求事件，事件负载具有打开的操作，请记住，我们只关心向用户发出的新的拉取请求，在事件函数生成的摘要中。我们将添加一些逻辑来生成拉请求摘要信息，就像前面提到的那样，我们只是要在我们的系列中添加另一个街区，这是相当简单的，蟒蛇让事情变得容易，或者是为了生成汇总功能，它已经开始变得很难阅读了，是的。

我知道这是在幻灯片上，我们只用两个空间 而不是四个空间，但事情真的很难遵循，目前我们只追踪了三种事件类型，我们的用户，他们想让我们追踪其他事件类型，你可以开始看到这将如何失控，我们的测试呢。当你看到我们的 mvp测试和我们的 mvp测试之间的区别，有了这个新功能，我们可以看到，我们必须编写一个测试来检查这个pr功能是否如预期的那样工作，但是我们必须回去修改我们已经编写的测试。

以确保这个功能不会被触发，这是因为我们测试的功能，这个函数做了许多不同类型的事情，它试图为许多不同类型的 Github事件生成一个摘要，所以每次我们添加功能的时候，我们在增加望远镜的尺寸。这个函数有更大的表面积，意味着我们有更复杂的测试，所以，如果您发现自己必须修改多个位置的代码来添加一个新功能，或者修改已经编写的测试 以添加新功能，您的存储库中可能有一些代码气味，这就是去年12月的我。

我们刚刚释放了我们的机器人，我们的客户希望我们增加更多额外的功能，但我发现我自己找到了程序设计，我已经在同一时间让这些新功能适应了，我开始读罗伯特马丁的《干净的代码》。他在开发人员社区被亲切地称为鲍勃叔叔，这本书有很多关于如何编写更好的代码的建议，遵循一系列规定的最佳做法，这本书推荐的内容之一是使用多态类重构条件，是啊，我也不太确定。

让我们退一步来讨论 python中的面向对象编程，面向对象编程是一种基于对象的范例，我们试图将现实世界中的事物建模为对象，当我们设计一个解决方案时，它涉及通过发送消息相互通信的协作对象的集合。对象具有数据和行为，面向对象编程允许我们在更高的抽象层次上进行思考，我们可以用集合数据和集合行为创建对象，然后我们可以开始对这些对象执行操作，去完成我们要做的任务，而不是按顺序去做，线性方式。

在面向对象编程中，我们有类和对象，一堂课，它是一个模板，允许它创建对象，我们还可以说，我们从一个类初始化了一个对象，我真的很喜欢这个千篇一律的比喻，我们的饼干切割机，就像上课一样。每个实例或每个 cookie就像一个对象，在面向对象编程中，我们有四个主要原则，有封装，有抽象，有传承，存在多态性，封装将数据和行为捆绑到单个逻辑单元中，我们称之为带有封装的对象。

我们能够隐藏我们对象的内部表示，抽象让我们可以隐藏，我们内部实现的复杂性，在这些物体内部，还建议当对象相互通信时，它们通过使用抽象 调用它们的公共方法来做到这一点，我们能够隐藏复杂性。我们还能够隔离变化的影响，我们希望改变基础 实现，我们不必出门更改呼叫代码，一旦我们改变执行方式，呼叫代码知道该做什么，我们经常有相似的物体，但它们并不完全一样，有传承。

我们能够将公共数据和公共行为提取到我们的基本对象中，然后我们可以使用这个基础对象来创建子对象，这些子对象可以重用来自父对象的所有数据和所有行为，它们还可以覆盖基本方法，以启用与父类或彼此不同的功能。这些子对象也可以实现他们自己的数据和他们自己的行为，这与父对象没有任何关系，有了传承，我们就能消除多余的代码，最后是多态性，我们能够为许多不同类型的对象提供相同的界面，想象一下 我们有一组儿童物品。

我们可以使用我们的父对象，实现我们的接口来运行每个子对象的实现，具有多态性，我们可以将条件块转换成不同的对象，当我们被设定为使用，当我们在编程的时候，使用程序范式。我们必须使用条件来选择性地执行某些代码块，当我们用面向对象的范例编程时，我们将条件逻辑嵌入到程序结构中，我们的物体，当我们运行面向对象的代码时，对象的类型定义了应该运行哪些行为，应该执行哪些代码。

这是我从马丁·福勒的书《重构》中找到的图表，您可以看到如何将条件逻辑转换为类或对象层次结构，让我们用一个具体的例子来深入了解多态性，假设我们有一个叫做动物的家长班，动物类实现了一个接口。该接口定义了一个名为speak的方法，当我们打电话给我们孩子的任何物品时，它根据对象的类型产生不同的行为，所以如果我们做一个猫点说话，它会发出喵喵的叫声，一个狗点说话会产生一只狼。

这就是 python中相同的对象关系，所以我们要从创造一种动物开始，我们可以用一个名字初始化它，我们要用一个叫做speak的函数来实现一个接口，在这里我要定义这个函数，引发未实现的错误。因为我只是想让人们知道这是一个界面，它现在实际上没有被使用，我们要创建一个以动物为基类的猫类，我们要重写这个语音功能 然后返回喵喵，这对猫来说是不同的，我们还将创建一个狗类课程，推翻说话和返回狼。

这是狗的独特功能，现在我们称之为"说话法"，取决于对象的类型，我们说的是一种不同的行为 将以这种方式产生，如果我们想增加一种新的动物，假设我们要加一只鸭子，我们可以创建一个鸭子类，以动物为基地。重写峰值功能，然后返回庸医来产生，呃，独特的功能，回到那个案例研究，我们如何开始用多态性替换条件词呢？当我们第一次破解一个解决方案时 这正是我们所做的，我们花了一个周末的时间设计的，黑客马拉松。

这真的是为了让我们的客户得到一些东西，但现在我们对我们要解决的问题有了一个想法，我们可以专注于真正重要的细节，设计一个更好的解决方案，所以让我们退一步，这个机器人想做什么，一次。我们有一个用户发生的所有事件的列表，我们想开始收集他们的事件类型，然后对于每个事件类型，我们要生成一些摘要文本，听起来像是一个事件类型，或者事件列表可以作为一个很好的基类。

让我们走一遍如何重构副本的过程，如果语句变成多态性类，第一，我想标识我们的复制条件块，接下来它们就在那里 我们可以识别出这些块的作用，功能性方面，在顶部，我们试图将事件与事件类型进行匹配，在底部。我们试图为每一个事件类型生成一个摘要，接下来我们要创建一个基类来建模我们的问题，所以我们要创建一个事件列表，它有一些行为，对于数据，我们要跟踪列表中的所有事件，对于行为，我们将能够得到列表的大小。

我们将能够把项目附加到列表中，我们还有一个返回真或假的函数，如果给定事件与我们所关心的事件类型匹配，还有一个为特定事件类型生成摘要文本的函数，因为这是我们的家长会，它只是定义我们的实现，对不起。它定义了我们的界面，我提出了未实现的错误，就是这样，我喜欢做事，接下来，我们要从条件块中提取功能到子类中，因此，在这里我们将创建一个提交类，它匹配具有类型推送事件的事件。

我们还将生成一个我们期望看到的总结，接下来，我们希望将所有存储库的功能从条件块提取到子类中，一个用户明星，最后，我们将从条件块中提取功能到一个子类中，用于新开的prs，我们还希望创建一个类。它运行为单个用户生成Github摘要的过程，我通常称之为驾驶类，它得到一个事件列表，把它们分类，这个，这些是我代码中唯一有 if语句的地方，当我们对事件进行分类时，我们需要检查我们分类的事件是否匹配。

我们关心的事件，如果是这样，我们将把它添加到事件类型列表中，如果没有，我们会继续像什么都没发生过一样，第二个 if语句仅在用户至少有一个更大的事件时才生成摘要。最后我们要更新之前的执行函数来使用这个新的高阶抽象，上次我们尝试添加新功能的时候，有点疼，我们试着用，让我们尝试使用这个新的面向对象设计，看看在我们的Github摘要中添加一个新的类型是多么痛苦。

这次我们将跟踪用户对 Github汇总输出造成的所有问题，我们首先要创建一个类，这将被称为打开的问题，基类是事件列表，我们要添加一个函数来匹配所有的问题，带有有效载荷的事件，有打开的动作。我们也会有一些代码来生成我们期望看到的文本，最后我们要去，我们得回到驾驶课 更新我们关心的事件列表，通过将这个类型再次添加到列表中，这似乎很简单。

但是它是在观察我们的面向对象解决方案测试和我们的面向对象解决方案测试之间的差异吗，我们可以看到我们必须添加一个测试来检查这个新功能，与以前的设计相比，我们必须修改我们已经编写的测试。以确保这个功能不会被触发，所以是的，我觉得这个设计，但就像编程中的其他东西一样，有一些事情需要我们考虑，首先，我们把程序设计得更复杂一点，每当有人进入这个代码库，他们有更多的概念需要理解。

也许这种额外的设计复杂性是我们在存储库中不想要的，因此，我们的代码改变的频率是非常值得考虑的，如果这东西被修改了很多，或者至少读很多书，花点时间重构可能是值得的，为了更好的抽象。这就是为什么我真的喜欢遵循三的规则，我从马丁·福勒的书中找到了这个，称为重构，当你第一次做某事，只要想办法做好工作，如果这是你第二次做某事，你感到痛苦，只需复制一次代码，现阶段不成问题。

但如果这是你第三次做某事，你感到痛苦，也许值得花一些时间来寻找一个更好的抽象，从泽纳蟒那里回忆，公寓比巢穴好，当我们使用继承时，这意味着我们的代码将是公开的复杂和公开的僵化。而不需要理解几层嵌套的 if语句，我们现在必须了解几个层次的继承 层次结构，所以我们只是用一组问题换了另一组问题，他们总是说 当我们编写面向对象的代码时，我们应该更喜欢组合 而不是有继承的继承。

我们说的是一个物体 是另一个具有组合的物体的类型，我们说一个物体有这些类型的行为，所以这是一个是一个对一个有个人关系，我觉得传承没那么差，只要你不深入太多的继承层次，在很多情况下。通过复制和粘贴来复制代码来解决问题要好得多，比使用错误的抽象，几年前，Ruby Off的Sandy Metz对这个问题进行了一次精彩的讨论，真的建议你们都去看看，我也想向我的测试套件大喊一声。

我可以重构我的程序设计，因为我设置了一个高水平的测试 来确保事情像预期的那样工作，我们可以用 if语句来解决任何问题，我们能想到，但是如果我们的代码太多了，if语句，它使事情难以遵循，甚至更难修改。我们说过一个五步的过程，我们可以用它来重构，副本，如果语句变成多态性类，但记住这不值得浪费，我们重构的时间，除非回报真的值得，现在，您知道如何使用多态性嵌入条件逻辑，所以勇往直前，重构代码。

确保你负责任地做这件事，这些是我在这次演讲中找到的所有资源，如果你有问题，请在下面的评论区询问他们，在接下来的几周到几个月里，我会定期登记回答你的问题，尽我所能。我也想让大家知道我说的这个项目 忙碌的海狸，它是芝加哥蟒蛇社区参与懒散机器人，这是一个开源项目，我们所有的代码都在 github上，如果你是一个社区的组织者，你的工作空间很窄，你想参与，请伸出援手。

我们对多租户开放，并正在寻找测试人员，我还想向芝加哥蟒蛇用户小组发出呼吁，我就不会像现在这样，或者作为一个人，如果没有那个神奇的组织，非常感谢你的时间。
![](img/62a307e40635ec771b228bfe8aa8073b_2.png)