- en: P12：Lightning Talks - Day 1 - VikingDen7 - BV1f8411Y7cP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P12：Lightning Talks - 第一天 - VikingDen7 - BV1f8411Y7cP
- en: Hey， Python。 Hey， everybody。 Welcome to Lightning Talks。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，Python。大家好。欢迎来到Lightning Talks。
- en: '![](img/a47799776e5058416042756da081300f_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_1.png)'
- en: Real quick， we're going to go over how Lightning Talks work， so everyone knows。
    We're going to have a series of speakers。 They're each going to talk for five
    minutes or less。 No more than five minutes。 You're going to talk on any topic
    that they suggested。 And real quick。 this is what we're going to do as they get
    close to their countdown。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快速过一下Lightning Talks是怎么运作的，让大家都知道。我们将有一系列的演讲者。他们每个人将讲五分钟或更少。不超过五分钟。你将谈论他们建议的任何主题。然后，快速地，这就是当他们接近倒计时时我们要做的。
- en: What you'll see is me doing this little one-finger clap。 Let's practice everyone's
    sort of one-finger clap quietly。 You can barely hear it。 And then as they get
    closer， we'll do a two-finger clap。 They'll make a little more noise and they'll
    say， "Oh， I got to wrap up。"。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你们将看到我做这个单指拍手。让我们安静地练习一下每个人的单指拍手。你几乎听不见。当他们靠近时，我们会做一个双指拍手。那会发出更大的声音，他们会说：“哦，我得结束了。”
- en: And then once they get to five， we'll just do a full-on applause。 Thank you。
    Get off the stage。 Next speaker， please。 All right， cool。 We're going to get started
    with Samir。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦他们到了五分钟，我们就会进行热烈的掌声。谢谢。下一个演讲者，请上台。好的，很酷。我们将开始萨米尔的演讲。
- en: '![](img/a47799776e5058416042756da081300f_3.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_3.png)'
- en: who's going to talk to us about data science without data。 Let's give him a
    round of applause。 [applause]， Thank you。 Thank you， Justin。 Okay， good life。
    Hi， I'm Samir。 I'm the head of privacy at Deafron。 Let's take a moment to think
    about what is data science without data。 Like， can we actually do anything when
    we don't have data？ The answer is generally speaking， no。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 谁将和我们谈谈缺乏数据的数据科学。让我们为他热烈鼓掌。[applause]，谢谢。谢谢，贾斯汀。好的，生活真好。嗨，我是萨米尔。我是Deafron的隐私负责人。让我们想一下，缺乏数据的数据科学是什么。像，当我们没有数据时，我们真的能做些什么吗？一般来说，答案是否定的。
- en: Like， that's the start of data science。 Then what does data science without
    data mean？ Like。 does it mean just science？ Well， I'm about to say that there
    is a lot more to this science than that means the eye。 So if you have data access
    problems because of， like。 the emerging data privacy regulations and laws， or
    if your data is split into multiple different trust domains。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 像，这就是数据科学的开始。那么，缺乏数据的数据科学是什么意思呢？像，是不是意味着仅仅是科学？好吧，我要说的是，这门科学远不止眼前所见的那样。如果你因为新兴的数据隐私法规和法律而遇到数据访问问题，或者你的数据分散在多个不同的信任域中。
- en: or if you would like to retain ownership of your data but still like to make
    use of this data。 you would be interested in what we are doing at Deafron。 If
    you are interested in knowing more what we do， like please come visit us at our
    booth in the startup row。 You can， we can show you a demo。 You can also look for
    a demo online。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果你想保留对数据的所有权，但仍然想利用这些数据，你会对我们在Deafron的工作感兴趣。如果你想了解更多我们的工作，像请来我们在初创企业区域的展位。我们可以给你演示。你也可以在线查找演示。
- en: We are also hiring if you speak Python， like we are interested in you。 Thank
    you。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你会说Python，我们也在招聘，我们对你感兴趣。谢谢。
- en: '![](img/a47799776e5058416042756da081300f_5.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_5.png)'
- en: '[applause]。'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[applause]。'
- en: '![](img/a47799776e5058416042756da081300f_7.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_7.png)'
- en: That was a nice quick one。 All right， they're not all going to be that short，
    I promise。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个简短的介绍。好的，他们不会都这么短，我保证。
- en: '![](img/a47799776e5058416042756da081300f_9.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_9.png)'
- en: Chuk， come up on stage。 And Lorena， let's just hang out up here while people
    are talking。 I like it。 And， oh gosh。 I can mask off。 Mask off。 Yeah， go ahead。
    Oh， hello。 So here's Chuk to talk to us about cultural shock at my first Python
    US。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Chuk，快上台。还有Lorena，让我们在这里待着，等人们演讲。我喜欢这样。哦，天哪。我可以摘下口罩。摘下口罩。对，继续。哦，你好。所以这是Chuk来和我们谈谈我第一次参加Python
    US的文化冲击。
- en: '![](img/a47799776e5058416042756da081300f_11.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_11.png)'
- en: Yes， absolutely。 Cultural shock。 I'm already shocked because this room is so
    vague。 It's my first time physically attending Python US， which is。 So， spoiler。
    I was lost in the venue the first day I went to lunch and I got lost。 So， I'm
    shocked。 Hit me up on Twitter if you want to。 I am living in London， UK。 So， this
    is what it。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，绝对是。文化冲击。我已经震惊了，因为这个房间太模糊了。这是我第一次亲自参加Python US，所以，有个剧透。我在去午餐的第一天迷路了，所以，我感到震惊。如果你想，可以在Twitter上联系我。我住在英国伦敦。所以，这就是它。
- en: it's not what it looks like， but it's what people think it looks like。 And also，
    I。 so my company is based in Dublin， so I visit Dublin quite a lot as well。 So。
    I also have some tips about Dublin for you later。 So。 what I think here in the
    US is everything is so vague。 It's， it's perfect。 Like this room is so big。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来并不是它的样子，而是人们认为它的样子。而且，我的公司位于都柏林，所以我也经常去都柏林。所以，我也有一些关于都柏林的建议可以给你。所以，我觉得在美国的一切都很模糊。这是，完美的。就像这个房间太大了。
- en: The venue is so big。 The roads are so big when I cross the road。 I always have
    to run because I feel like I don't have enough time to cross the road。 It's so
    big。 The bed is so big in my hotel room。 This is my hotel room， by the way。 You
    can see that that's my teddy bear there。 It's very small。 So， yeah。 But。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 会议场地非常大。过马路时，路也很宽。我总是得跑，因为我感觉过马路的时间不够。这真是太大了。我的酒店房间的床也很大。顺便说一下，这就是我的酒店房间。你可以看到，那是我的泰迪熊，非常小。所以，是的。但。
- en: but the teddy bear here are so big as well。 So， yeah。 And anybody see this in
    the airport？ Like。 that's really shocked me。 Right？ Wow， the teddy bear is so
    big。 So， yeah。 like it's really shocked me。 Another thing， hotel rooms， they have
    no cat toes。 So， you know， well。 I would say that I'm kind of British。 I live
    in UK for a while， you know， and then like we love tea。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这里的泰迪熊也很大。所以，是的。有人在机场看到这个吗？像。那真的让我震惊。对吧？哇，泰迪熊真大。所以，是的。它真的让我震惊。还有一件事，酒店房间没有猫爪。你知道的，我会说我有点英国化。我在英国住了一段时间，你知道的，我们喜欢喝茶。
- en: We need to have a cup of tea。 So， there's no tea。 No， no， there's tea in the
    hotel room。 but there's no kettle。 I was like， but I was prepared because I was
    told that there's no kettle here。 So， I bring my own kettle。 I forgot to take
    a picture of it。 but I do have a travel kettle that can collapse， which is very
    good。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要喝一杯茶。所以，酒店房间里没有茶。 不，酒店房间里有茶，但没有水壶。我就想，但我已经准备好了，因为我被告知这里没有水壶。所以，我带了自己的水壶。我忘了拍它的照片，但我确实有一个可以折叠的旅行水壶，非常好。
- en: For any of those of you who would love to buy one， talk to me， I can give you
    a tip。 But anyway， so。 also， I was scared。 Luckily， in this city， you don't necessarily
    need to drive because there's a tram。 There are buses， but I was so scared because
    before I came here， I was like， oh my God。 do I have to drive because I'm horrible
    at driving。 I only drive maybe once or twice in my life。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你们中有人想买一个，跟我说，我可以给你一些建议。但无论如何，我感到害怕。幸运的是，在这个城市，你不一定需要开车，因为有电车。有公共汽车，但我真的很害怕，因为在来这里之前，我在想，哦，我的天，我需要开车吗？因为我开车真是糟糕。我一生中可能只开过一两次车。
- en: I'm a city girl， so I am super scared。 So， also， there's something。 there's
    called ice cream sprint that I do in all the pythons in Europe that we'll run
    for ice cream during lunchtime。 So， I was worried that I would become a ice cream
    speeding ticket instead of ice cream sprint。 But luckily， it didn't happen。 So，
    I was shocked。 But I don't want you to be shocked in case you're going to this
    following conferences。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我是个城市女孩，所以我超级害怕。所以，还有一些事情。 在欧洲的所有Python会议上，有一种叫做冰淇淋冲刺的活动，我们会在午餐时间为冰淇淋而跑。所以，我担心我会变成冰淇淋超速罚单，而不是冰淇淋冲刺。但幸运的是，这没有发生。所以，我感到震惊。但我不想让你在参加接下来的会议时感到震惊。
- en: But I did a London in June， a hero of heaven in July， and I'm high in UK in
    September。 I really want to see you there。 I really love seeing people coming
    to my country， my place。 so that would be great。 So， I want to give you some tips。
    So， you won't have cultural shot like me。 So， the weather is going to be a bit
    wet， you know， London， a bit wet。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不过我在六月去了伦敦，七月去了天堂的英雄，九月在英国也很高兴。我真的想在那见到你。我真的很喜欢看到人们来到我的国家，我的地方。所以，这会很棒。所以，我想给你一些建议。这样，你就不会像我一样感到文化冲击。所以，天气会有点湿，你知道的，伦敦，稍微湿一点。
- en: Bring some clothes that are waterproof or water resistant。 Also， getting around。
    you don't need to drive， don't worry。 You can take trains， you can take buses。
    they're very convenient。 The underground train in London is called "Tubes"。 So。
    if anybody telling you to take a trip， that's what you mean， like it's the underground，
    you know。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 带一些防水或防潮的衣物。此外，出行方面，你不需要开车，别担心。你可以乘坐火车，也可以乘坐公交车。它们非常方便。伦敦的地铁叫“Tube”。所以，如果有人告诉你去坐地铁，那就是你所说的，就像地铁，你知道的。
- en: transfer system。 So， eating out， definitely try efficient chips。 And there's
    something called Sunday Rose。 They're only available on Sunday in Pub， so。 but
    usually they're yummy。 So， try that。 Also， tips are optional in Europe。 So。 don't
    worry about the tips。 If you don't want the tips， it's fine。 Also， show show。
    You know。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 转移系统。所以，外出就餐，绝对要尝试高效薯条。还有一种叫做“星期日玫瑰”的东西。它们只有在酒吧的星期日提供。所以，但通常它们很好吃。所以，试试这个。此外，欧洲的小费是可选的。所以，别担心小费。如果你不想给小费，那也没问题。此外，展示展示。你知道的。
- en: the breaks， the breaks， they love drink。 You know， they could be a big shine
    in the conference。 but after a few drinks in the pub， they can talk anything with
    you。 They can introduce their family to you or something like that。 Also， Guinness，
    if you go to Ireland。 go to Dublin， Guinness must drink。 It tastes different there，
    so trust me。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 休息，休息，他们喜欢喝酒。你知道，他们在会议上可能会成为一个大亮点。但在酒吧喝了几杯后，他们可以和你聊任何事情。他们可以向你介绍他们的家人或类似的东西。此外，如果你去爱尔兰，去都柏林，一定要喝健力士。那里的味道不同，所以相信我。
- en: A commendation could be expensive， but， you know， look for something like Airbnb。
    but be careful of the scammers。 Also， you know， student accommodation could be
    an option because somewhere nobody's going to be in this dirt accommodation。 Or
    I have a small room。 So， be my friend。 Maybe host you。 I don't know。 So， people
    are there。 Just very nice， like people here。 So， don't worry about it。 Come to
    visit me。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 赞美可能会很昂贵，但你知道，可以找一些像Airbnb这样的地方。不过，要小心诈骗者。还有，学生宿舍也可以是一个选择，因为在某些地方，没有人会在这样的脏宿舍里。或者我有一个小房间。所以，做我的朋友。也许可以接待你。我不知道。所以，人们在那里。就像这里的人，非常友好。所以，别担心。来拜访我吧。
- en: '![](img/a47799776e5058416042756da081300f_13.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_13.png)'
- en: Come to Pide。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 来Pide吧。
- en: '![](img/a47799776e5058416042756da081300f_15.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_15.png)'
- en: Up next is a gentleman who， I don't think many of us need an introduction for
    Lukas。 Hi there。 We've seen each other already in the morning， so I'm just going
    to quickly make you a typing expert。 This is a concept that many of us struggle
    with because we don't have nice examples。 And the property of nice examples is
    obviously to have cutie animals explaining them。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一位绅士，我想我们大多数人都不需要为卢卡斯做介绍。嗨，我们早上已经见过面了，所以我就快速让你成为打字专家。这是一个很多人都在努力克服的概念，因为我们没有好的例子。而好例子的特性显然是有可爱的动物来解释它们。
- en: And with that is everything is easier。 So， imagine some abstract animal and
    we have some subtypes of that abstract animal。 namely a dog， a cow， a cat， this
    sort of thing。 So， covariance。 contravariance and invariance are concepts that
    explain us whether we can replace one of those with another and what will happen
    in that case。 So， covariance， the most kind of natural and intuitive of those
    means that whenever we have an animal accepted。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，一切都变得更简单了。所以，想象一下某种抽象动物，我们有这种抽象动物的一些子类型，像狗、牛、猫等等。因此，协变、逆变和不变是解释我们是否可以用一个替换另一个，以及那种情况下会发生什么的概念。所以，协变是最自然和直观的意思是，每当我们有一种动物被接受时。
- en: we could put cow and it should work。 Like one example in Python is that if you
    have a function that prints an animal。 if you have a function that prints many
    animals by calling print animal。 what you can do is you can define a function
    called print cats that just uses print animals and everything works fine。 So，
    this is in fact something that does work。 You can do that。 So。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以放牛，应该可行。比如在Python中，如果你有一个打印动物的函数。如果你有一个通过调用打印动物的函数来打印许多动物的函数。你可以定义一个叫做打印猫的函数，它只是使用打印动物，所有的一切都能正常工作。所以，这实际上是可行的。你可以这样做。所以。
- en: the property of the covariance here happens in the sequence of animal that can
    be replaced with sequence of cats。 The opposite happens for contravariance， which
    means in some contexts you can replace a cow with a generic animal。 How does that
    work？ Well， this is the weirdest of the examples， but in fact it deals with callables。
    So， if you have some print with implementation where we want to print a cat， I
    don't know。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的协变性质发生在可以用猫的序列替换的动物序列中。对于反变性来说，恰恰相反，这意味着在某些上下文中，你可以用通用动物替换一头牛。这是如何工作的呢？好吧，这是最奇怪的例子，但事实上它涉及到可调用对象。所以，如果你有某个打印的实现，我们想打印一只猫，我不知道。
- en: as Jason or whatever else， and we want to provide an implementation for it。
    So。 we by default want prints cat because we know that this is something that
    can print cats。 Can we put a function that can print any animal there？ Well， we
    can because it can print any animal。 So， this relationship between those callables，
    prints cat and prints animal is reverse to what you would think about with inheritance
    because you can in fact replace the more concrete thing with a more generic one。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 比如Jason或者其他的，我们希望提供一个实现。因此，我们默认想要打印猫，因为我们知道这是可以打印猫的东西。我们能否在那里放一个可以打印任何动物的函数？当然可以，因为它可以打印任何动物。因此，这些可调用对象之间的关系，打印猫和打印动物，和你在继承中思考的正好相反，因为你实际上可以用一个更通用的东西替换掉一个更具体的东西。
- en: And finally， we have invariance where you cannot replace the cow with a generic
    animal and vice versa。 It's just impossible。 And in fact， this is something that
    very。 very many users of typing fall into faster or later because of an example
    like this。 If you have a function that allows us to add animals to an existing
    list and we have a function that adds a cat。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有不变性，你无法将牛替换为通用动物，反之亦然。这是完全不可能的。事实上，这正是许多类型用户早晚都会遇到的情况，因为有这样的例子。如果你有一个允许我们向现有列表中添加动物的函数，而我们有一个添加猫的函数。
- en: we would think that we should be able to just use this add animal function in
    the implementation of add cat。 And because it's natural， it doesn't do really
    much weirdness， it should work。 But it doesn't because in general， if in the add
    animal function we did something funky。 This is just an example。 But the point
    being we would add an animal which is not a cat。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会认为我们应该能够在添加猫的实现中使用这个添加动物的函数。因为这很自然，它并不会做什么奇怪的事情，应该可以工作。但实际上不行，因为通常情况下，如果在添加动物的函数中我们做了一些奇怪的事情。这只是一个例子。但重点是我们会添加一种不是猫的动物。
- en: then the function below add cat that takes a list of cats would suddenly change
    the type of those cats。 Into cats plus some other animal。 And what type is that？
    Well， we don't really know。 This is something that you might break in Python all
    the time because containers don't really limit you from putting incompatible types
    next to each other。 But with NumPy types or with other programming languages。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么下面的添加猫函数，接受一个猫的列表，突然改变了那些猫的类型。变成猫加上一些其他动物。那么这是什么类型呢？我们并不真的知道。这是你可能在Python中经常会遇到的情况，因为容器并不会真正限制你将不兼容的类型放在一起。但在NumPy类型或其他编程语言中。
- en: the memory layout between different types might be different。 So this becomes
    more important then。 So in this particular case， that would not be possible to
    be done。 And now you understand covariance， contravariance and invariance。 Thank
    you。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型之间的内存布局可能是不同的。所以这变得更加重要。因此，在这个特定的情况下，这是不可能做到的。现在你理解了协变、反变和不变性。谢谢你。
- en: '![](img/a47799776e5058416042756da081300f_17.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_17.png)'
- en: '![](img/a47799776e5058416042756da081300f_18.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_18.png)'
- en: Awesome。 Thanks， Lukas。 Next we have Seth who told me earlier that he never
    met another Pythonista until he came to this conference and met all the Pythonistas。
    So， welcome， Seth。 Seth's going to give us a talk on the future of Trustors in
    Python。 Give it away for Seth。 \>\> Hi， everybody。 So today I'm going to talk
    about Trustors and what that's going to look like in the future hopefully in Python。
    So I'm Seth Larson。 I'm maintainer of your lib3 requests and some other packages。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。谢谢你，Lukas。接下来我们有Seth，他之前告诉我，直到他来到这个会议并遇到所有Pythonista，他从未见过其他Pythonista。所以，欢迎你，Seth。Seth将给我们讲一个关于Python中Trustors未来的演讲。把时间留给Seth。>>
    嗨，大家好。今天我将谈谈Trustors，以及在Python中它将来会是什么样子。所以，我是Seth Larson。我是你的lib3 requests和其他一些包的维护者。
- en: And a lot of the work that's done here is also done by David Glick。 So in the
    audience。 Okay。 show of hands。 Have you seen this error？ I've seen this error
    so many times。 If you've worked at a corporate proxy environment， you've seen
    this error。 Usually you see this when there's no root certificate and you can't
    verify your search chain and you're trying to use TLS。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 而这里的大部分工作也由大卫·格里克（David Glick）完成。那么在观众中，举手。你们见过这个错误吗？我见过这个错误很多次。如果你在企业代理环境中工作过，你一定见过这个错误。通常当没有根证书时，你会看到这个错误，这时无法验证搜索链，而你正在尝试使用
    TLS。
- en: Okay， so first off， what is a Trustor？ Trustor is a collection of certificates
    that your system uses when you're doing TLS handshake。 Server gives you certificates
    back。 You verify them against that Trustor。 And so in Python。 because we're strongly
    tied to open SSL with our SSL APIs。 usually takes the form of a file or a directory
    of certs。 So today in Python。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，首先，什么是信任者（Trustor）？信任者是一组证书，您的系统在进行 TLS 握手时会使用这些证书。服务器会将证书返回给您。您会将它们与信任者进行验证。因此在
    Python 中，由于我们的 SSL API 强烈依赖于 OpenSSL，通常以文件或证书目录的形式存在。因此今天在 Python 中。
- en: Trustors look kind of like this。 Linux distros， they ship things that are compatible
    for open SSL。 But Mac OS and Windows don't do that。 And Python is strongly tied
    to open SSL。 So what do we do on Mac OS and Windows？ We use certify。 So certify
    is a Python package that basically takes the certificates that Mozilla bundles
    in their CA bundle and then repackages it。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 信任者看起来是这样的。Linux 发行版提供与 OpenSSL 兼容的东西。但是 Mac OS 和 Windows 不这样做。而 Python 与 OpenSSL
    紧密相关。那么在 Mac OS 和 Windows 上我们该怎么办呢？我们使用 certify。因此 certify 是一个 Python 包，它基本上采用
    Mozilla 在其 CA 包中捆绑的证书，然后重新打包。
- en: uploads it to the Python package index， and then you can use them。 But there
    are a couple of problems with using open SSL and certify。 especially on Mac OS
    and Windows systems。 So certify。 you only get the certs that are bundled with
    certify。 You don't get to follow some central policy on your system。 For example，
    in a corporate environment。 if your system administrator installs an additional
    certificate into your system trust store。 certify has no idea what that even is。
    And so that means you're going to end up with one trust store per application。
    It's really tough to maintain。 You don't get any auto updates。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将其上传到 Python 包索引，然后您可以使用它们。但使用 OpenSSL 和 certify 存在一些问题，特别是在 Mac OS 和 Windows
    系统上。因此 certify，您只能获得与 certify 一起捆绑的证书。您不能遵循系统上的某些中央政策。例如，在企业环境中，如果您的系统管理员向系统信任库中安装了额外的证书，certify
    根本不知道那是什么。因此这意味着每个应用程序将拥有一个信任库。维护起来非常困难。您不会得到任何自动更新。
- en: And now the Python package index is a CA certificate distribution channel。 which
    is not what it's for。 And so here's why system trust stores are a lot better。
    You get one per system instead of per application。 So that means there's one place
    where all the certificates get updated。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Python 包索引成为了 CA 证书分发渠道，但这并不是它的目的。因此，这就是系统信任库要好得多的原因。您每个系统只需一个，而不是每个应用程序。因此这意味着所有证书都有一个地方进行更新。
- en: The system itself manages and updates everything， and you get a whole bunch
    of fancy features that the operating system usually gives you。 That open SSL wouldn't
    necessarily give you。 Or you'd have to configure additionally。 So this is kind
    of that future that we're envisioning。 So there's this new experimental package
    that me and David have put together called Trust Store。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 系统本身管理和更新所有内容，您会获得操作系统通常提供的许多高级功能，而 OpenSSL 不一定会提供这些功能，或者您需要额外配置。因此，这就是我们设想的未来。所以我们与大卫一起制作了这个新的实验性包，叫做信任库（Trust
    Store）。
- en: This code is very new， so it's experimental。 Don't deploy it。 It's only been
    alive for about four months now。 You can get it on GitHub。 There's the URL there。
    But essentially what it is is it provides an SSL context API。 It works on all
    of the major platforms and does the native system trust store thing to make sure
    everything works。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常新，因此是实验性的。请勿部署。它现在大约活跃了四个月。您可以在 GitHub 上获取，那里有网址。但本质上，它提供了一个 SSL 上下文 API。它在所有主要平台上工作，并执行本地系统信任库功能，以确保一切正常工作。
- en: And we tested against a whole bunch of libraries。 The only kicker is it requires
    Python 310 because it uses some special private APIs that if you really are super
    interested in the system。 I wrote an entire article about it。 So go to the GitHub。
    You'll find it。 Okay。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们针对一堆库进行了测试。唯一的限制是它需要 Python 3.10，因为它使用了一些特殊的私有 API，如果你真的对系统非常感兴趣，我写了一整篇关于它的文章。所以去
    GitHub 查找，你会找到它。好的。
- en: And so then this exists。 What happens now？ Look at the project。 Be interested
    by it。 Like learn about it。 But do not deploy it yet， please。 It's very。 very
    young code to be doing something that's super， super important。 So just wait for
    a little bit in that case。 But I think one of the future directions that this
    is going to go in is we would like to get this functionality added to Python so
    that all applications that use Python can immediately take advantage of it。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后这个存在。现在发生了什么？看看这个项目。对此感兴趣。了解它。但请不要还部署它。这段代码非常、非常年轻，不适合做一些超级重要的事情。因此在这种情况下请稍等一下。但我认为这个项目未来的一个方向是，我们希望将这个功能添加到
    Python 中，以便所有使用 Python 的应用程序都能立即受益。
- en: And I think that there is an avenue for more incremental adoption by some libraries
    and tools of the specific library。 So that's kind of it。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为一些库和工具对特定库的更渐进式采用是一个途径。所以就这些。
- en: '![](img/a47799776e5058416042756da081300f_20.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_20.png)'
- en: '[applause]， Fantastic。 Love hearing that there is a space for you to collaborate。
    but do not yet deploy to prod。 Huge emphasis there。 Up next we have Pablo。'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]，太棒了。听到你有空间进行合作我很高兴，但请不要还部署到生产环境。这里强调很大。接下来我们有 Pablo。'
- en: '![](img/a47799776e5058416042756da081300f_22.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_22.png)'
- en: Hey。 Hello， Python。 So I'm Pablo Calindo。 You may know me from my work on CPython。
    But I'm here today to talk about something that we have released from the company
    that I work for。 That is Bloomberg。 And this is Membray。 So Membray is a memory
    profiler that we have open source two weeks ago。 Many of you may know it because
    apparently it was quite popular on Twitter during a couple of days。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿。你好，Python。我是 Pablo Calindo。你可能知道我在 CPython 的工作。但今天我在这里谈论我们公司（彭博社）发布的一个东西。这就是
    Membray。因此，Membray 是我们在两周前开源的内存分析器。你们中的许多人可能听说过，因为显然它在 Twitter 上非常受欢迎，持续了几天。
- en: But I hope to give you an overview over what it does and why it could be useful
    for you。 So the scope of memory profilers and profilers engineering in Python
    is a fantastic landscape because there's a lot of cool tools。 But let me help
    you cover what memory does that many other profilers may not do or may do a bit
    worse。 So one of the things that happen is that， for example。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但我希望给你一个关于它的概述，以及它为什么对你有用。因此，Python 中的内存分析器和分析器工程的范围是一个令人惊叹的领域，因为有很多很酷的工具。但让我帮助你了解内存分析器所做的事情，而许多其他分析器可能做得不够或做得稍差。所以其中一个发生的事情是，比如说。
- en: in the standard library we sit with some memory profilers。 It's called trace
    malloc。 The problem with for instance， trace malloc and many other profilers is
    that they can see allocations that Python interpreter does。 but not allocations
    that other things underneath do。 For instance， in this case。 we are allocating
    a huge amount of memory。 This is like 90 something megabytes using Memmup。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库中，我们有一些内存分析器。它叫 trace malloc。trace malloc 和许多其他分析器的问题在于，它们可以看到 Python 解释器所做的分配，但不能看到其他底层所做的分配。例如，在这种情况下，我们正在分配大量内存。这大约是
    90 多兆字节，使用 Memmup。
- en: But this could also be done in a C extension or NumPy or things that are not
    communicating with Python interpreter。 And the problem is that for instance， in
    this case。 if you ask trace malloc how much memory was allocated， it tells you
    that it's only 80 bytes。 which is not great， right？ Because there is a huge amount
    of memory here。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但这也可以在 C 扩展、NumPy 或与 Python 解释器没有通信的其他东西中完成。问题是，例如，在这种情况下，如果你询问 trace malloc
    分配了多少内存，它会告诉你仅分配了 80 字节。这并不好，对吧？因为这里有大量的内存。
- en: But if you do the same with memory， this is one of the example outputs that
    you will see。 In this case， it will tell you that we detected one allocation is
    9 megabytes and it's because one allocator happened。 So Membra can see not only
    a location that's happening in Python。 but also a lot of allocations that happen
    in C extensions。 Other profilers can do this。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你对内存做同样的事情，这是你会看到的输出示例。在这种情况下，它会告诉你，我们检测到一个分配是 9 兆字节，这是因为发生了一个分配器。因此，Membra
    不仅可以看到 Python 中发生的分配，还可以看到在 C 扩展中发生的许多分配。其他分析器可以做到这一点。
- en: but something that many other profilers cannot do is that if you have one of
    the outputs of Membra。 which is this flangraff， for instance， in this case some
    memory is allocated in this Python code。 Membra can also tell you what happens
    underneath that Python code。 And it can tell you all the C code that is executed
    underneath and what happened。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但许多其他性能分析器无法做到的是，如果你有 Membra 的输出之一，比如这个 flangraff，在这种情况下，一些内存是在这段 Python 代码中分配的。Membra
    还可以告诉你在那段 Python 代码下发生了什么。它可以告诉你所有执行的 C 代码和发生的事情。
- en: And as you can see， you can go here and see that actually there is some NumPy
    cache that is the actual responsible to allocate the memory for that instruction。
    which is super cool， especially if you are using data science libraries that you
    see extension or Python。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以点击这里，实际上会看到一些 NumPy 缓存，它负责为该指令分配内存。这非常酷，特别是当你使用数据科学库时，你会看到扩展或 Python。
- en: But we have many other things。 For example， we dump all the information that
    we collect to a binary file and then you can produce a ton of reports。 depending
    on what you want。 You can get the statistical reports， you can get three reports。
    flangraffs， tables， and for instance you can even get live reports when you can
    see what your application is doing as it's running and you don't need to generate
    one。 You can see what's happening， which is very cool。 I know people like moving
    things， so here you go。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还有很多其他东西。例如，我们将收集到的所有信息转储到一个二进制文件中，然后你可以根据需求生成大量报告。你可以获得统计报告，三种报告，flangraffs，表格，甚至可以获取实时报告，当你可以看到应用程序在运行时所做的事情时，而不需要生成一个。你可以看到发生了什么，这非常酷。我知道人们喜欢移动事物，所以这里你去吧。
- en: But yeah， the idea is that we also have an API， so you can use the API to track
    just parts of your code。 You don't need to track the entire program because you
    may be using Gunico or other good things that make the whole thing very difficult。
    So you can just say， okay， track only what happens here。 And the cool thing I'll
    mention is that。 as opposed to other memory profiles， is that anything that happens
    outside this context manager has zero overhead because the activity is everything
    in a very special way that makes sure that any code that is known under this context
    manager has zero overhead。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，想法是我们还有一个 API，所以你可以使用 API 仅跟踪代码的某些部分。你不需要跟踪整个程序，因为你可能在使用 Gunico 或其他好的工具，使得整体变得非常困难。所以你可以简单地说，好的，仅跟踪这里发生的事情。我要提到的酷点是，与其他内存分析器相比，在这个上下文管理器之外发生的任何事情都没有额外开销，因为活动以非常特殊的方式进行，确保在这个上下文管理器下的任何代码都没有额外开销。
- en: so it runs at full speed。 We have also a play test plan。 which you can use immediately
    by installing and that does memory to your educational play test。 that after the
    test passes， it will show you a bunch of statistics。 So for instance。 it will
    tell you how much memory was allocated， how many locations happened。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它以全速运行。我们还有一个测试计划，你可以通过安装立即使用，它为你的教育测试添加内存，测试通过后，它会向你展示一堆统计数据。例如，它会告诉你分配了多少内存，发生了多少位置。
- en: meaning the diagram of the locations that happened and the places in your code
    and your test when there were more allocations。 which is quite cool。 But you can
    use also this play test plan to say， okay， I have this test。 but I don't want
    anything under this test to use more than 25 megabytes。 and memory will make sure
    that this test will fail， even if the test itself passes。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着发生的位置图，以及在你的代码和测试中，当有更多分配时的地方。这相当酷。但你也可以使用这个测试计划来设定，比如，我有这个测试，但我不希望这个测试下的任何内容使用超过
    25 兆字节的内存，内存会确保即使测试本身通过，这个测试也会失败。
- en: if it uses more than 25 megabytes。 So you can use that your functions are limited
    by whatever you want。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用超过 25 兆字节。所以你可以使用这个函数被限制在你想要的任何限制内。
- en: '![](img/a47799776e5058416042756da081300f_24.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_24.png)'
- en: So yeah， this is the profiler。 It's just one among many。 There is many， many
    other good profilers。 and this is just complementary to them。 But we think it's
    quite cool。 We put a lot of effort to develop in this team and open source in
    it， and we hope that you like it。 You can check it in。 So give up。com/bloomer-memory。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所以是的，这是性能分析器。它只是众多中的一个。还有许多其他优秀的性能分析器，而它只是对它们的补充。但我们觉得它相当酷。我们在这个团队投入了大量精力来开发并开源它，希望你喜欢。你可以查看它在
    So give up.com/bloomer-memory。
- en: and I hope that you use it for finding why your programs are getting so big。
    Thank you very much。 [applause]， Super cool。 Very excited about that。 Okay， next
    we have Graham， who has no slides。 who's going to talk to us about the grief cycle，
    data security breaches。 and how we could code the future of America and the world。
    Let's give it away for Graham。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能利用它来找出你的程序为何变得如此庞大。非常感谢。[掌声]，超级酷。我对此非常兴奋。好吧，接下来是Graham，他没有幻灯片，将和我们讨论哀伤周期、数据安全漏洞，以及我们如何能够编写美国和世界的未来。让我们为Graham热烈鼓掌。
- en: '[applause]， First of all， I think that title is a little bit grandiose because
    coding the future of the world is a kind of big topic。 But can I get a show of
    hands？ Who here knows someone that has been hacked？ Okay。 now who here has been
    hacked？ Now， raise your hand if you are proud that you got hacked。 I didn''t think
    so。 One of the big things that I encountered when I was doing research in my master''s
    program was a real issue with shame that came with being hacked。'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]，首先，我觉得这个标题有点夸大其词，因为“编写世界的未来”是一个相当大的话题。但我能否请举手？这里谁认识被黑客攻击过的人？好的。现在，谁这里被黑客攻击过？现在，如果你为自己被黑客攻击而感到骄傲，请举手。我想不是。进行研究时，我在硕士项目中遇到的一个重大问题就是与被黑客攻击相关的羞愧感。'
- en: And it kind of built onto this grief cycle concept where you start -- people
    actually are going through a grief cycle because of the shame of the fact that。
    oh， I'm compromised。 My data。 Myself， it's my fault。 And it may be reconsider
    how we as -- I mean。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上与哀伤周期的概念相结合，人们实际上正在经历一种哀伤周期，因为他们感到羞愧。哦，我的数据被泄露了。我自己，我的错。这可能需要重新考虑我们作为——我的意思是。
- en: Python。 This is PyCon。 We should be the people to be helping people with this
    sort of thing。 And in the future， we're going to be building things that will
    shape the minds of everyone that uses the Internet。 That was loud。 And for that
    reason， I think it's really important that we look at it from a holistic perspective
    because I think there are some parts of this grief cycle that people are going
    through in the workplace。 even on our teams or our friends or even our clients。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Python。这是PyCon。我们应该是帮助人们解决这类问题的人。在未来，我们将构建一些塑造所有使用互联网的人的思想的事物。声音太大了。因此，我认为从整体角度来看待这一点非常重要，因为我认为在工作场所，人们正经历着哀伤周期，即使是在我们的团队、朋友或客户中。
- en: That there's lots of people that we don't know they're in the anger phase and
    we try to sell them something。 And while in the anger phase， they're just not
    going to buy something because who would。 And I think that there's a lot of potential
    -- there's a -- I don't think it。 I know there's a lot of potential in machine
    learning and specifically， I think。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多人我们不知道他们处于愤怒阶段，而我们试图向他们推销一些东西。在愤怒阶段，他们是不会买东西的，因为谁会呢。我认为机器学习中有很多潜力——我不是在猜测，我知道其中蕴含着巨大的潜力，特别是我认为。
- en: in reinforcement learning for the advancement of even our understanding of the
    way social dynamics work。 I'm kind of excited to see what the next couple years
    hold in terms of modeling social change。 like figuring out how we can create models
    to maybe do conflict resolution with people that are in a grief cycle with maybe
    a chatbot that helps people to calm down before they talk to a human so that the
    poor customer service people don't have to deal with that。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在强化学习中推动我们对社会动态运作方式的理解。我很兴奋看到未来几年在社会变革建模方面会有什么发展，比如弄清楚我们如何可以创建模型，或许可以用聊天机器人进行冲突解决，帮助那些正在经历哀伤周期的人在与人交谈之前冷静下来，这样可怜的客服人员就不用面对这些情况。
- en: And this really came to my attention whenever I had to do cold calling。 And
    that was one of the hardest jobs I ever did。 It changed my perspective of that
    whole industry and it really made me appreciate those people and what they go
    through。 And I think that's the kind of people that we serve with open source
    software。 And that's the kind of thing I'm excited to work on with all of you
    is this working on making machine learning without bias。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我特别注意到每当我需要进行冷拨电话时。这是我做过的最艰难的工作之一。这改变了我对整个行业的看法，也让我更加欣赏那些人和他们所经历的事情。我认为这就是我们所服务的开源软件背后的那种人。这也是我期待和大家一起努力的事情，那就是在没有偏见的情况下进行机器学习。
- en: working on building things that work and that can actually enact change。 And
    I really。 really appreciate being here this year and for everything that PyCon
    offers。 On that note。 we appreciate all of you being here at the end of a long
    day or for many of you who've been here many days。 But up next we have Mason who's
    going to be talking to us about what is synthetic data。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在致力于构建有效的事物，真正能够推动变化。非常感谢今年能够在这里，以及PyCon提供的一切。感谢大家在漫长的一天结束时，或对许多在这里待了多天的你们的到来。接下来是梅森，他将为我们讲解什么是合成数据。
- en: '![](img/a47799776e5058416042756da081300f_26.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_26.png)'
- en: Can we get the podium？ There it is。 There we go。 Okay， we'll try that again。
    Hello。 my name is Mason。 I will be talking about synthetic data today。 Usually，
    whenever I try to do。 Yeah。 we'll do that。 How you know I speak with my hands。
    Okay， we'll try this for the third time。 Synthetic data。 My name is Mason。 One
    of the first things that I do whenever I learn about a new topic is I usually
    try to find some sort of definition on the Internet that gives it some sort of
    explanation。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得到讲台吗？在那里。好吧，我们再试一次。你好，我的名字是梅森。今天我将讲述合成数据。通常，每当我尝试时。是的，我们会这样做。你知道我说话时会用手。好的，我们再试第三次。合成数据。我的名字是梅森。每当我学习新主题时，我通常会在互联网上找到某种定义，以提供一些解释。
- en: So the definition that I've found is that synthetic data is artificially annotated
    information that is generated by a computer using algorithms or simulations。 And
    it's commonly used as an alternative to real world data。 After I read that definition。
    I was just as confused as I bet some of you are。 Let's look at a little bit a
    couple of examples and some of the problems that synthetic data solves。 So data
    is one of the biggest problems that developers face today。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我所找到的定义是，合成数据是由计算机使用算法或模拟生成的人工注释信息。它通常被用作真实世界数据的替代品。在我读到这个定义后，我和你们中的一些人一样感到困惑。让我们看几个例子以及合成数据解决的一些问题。数据是开发者今天面临的最大问题之一。
- en: Getting access to usable testing data is usually pretty difficult。 The data
    could be in a production database or you don't have some sort of access to it。
    You're not on the right team。 The data may contain private information such as
    social security numbers。 credit card numbers， all of these kind of things where
    it's not safe for a company to allow every developer within the company to have
    access to this data。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 获取可用的测试数据通常非常困难。数据可能在生产数据库中，或者你没有某种访问权限。你可能不在合适的团队中。数据可能包含私人信息，如社会安全号码、信用卡号码等，这些都使公司不安全，不允许每个开发者接触这些数据。
- en: Another problem that developers have with data is the limited data sets。 35%
    of the time that goes into building a new ML model is spent just in the data gathering
    phase and it is the largest phase that happens in the ML thing。 Trying to find
    relevant data that helps us is very difficult。 And also our data is biased。 We
    very often don't have a complete data set。 This can be intentional or unintentional。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者在数据方面面临的另一个问题是有限的数据集。构建新的机器学习模型时，有35%的时间花在数据收集阶段，而这是机器学习中最大的阶段。寻找相关数据以帮助我们非常困难。同时，我们的数据往往存在偏见。我们常常没有完整的数据集，这可能是有意或无意的。
- en: but very often the data has a really slanted view in one way or the other and
    it's a problem that we have to deal with。 Synthetic data comes to the rescue in
    almost all of these situations。 So one thing synthetic data can do is it can make
    private data accessible and shareable。 So what you can do with your production
    data is you can take this production data and run it through a synthetic data
    generator and then generate an entirely new data set that is statistically equivalent
    to the approach of the data。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但数据往往在某种程度上有非常偏斜的视角，这是我们必须面对的问题。合成数据几乎在所有这些情况下都能提供帮助。合成数据可以使私人数据可访问和可共享。你可以将生产数据通过合成数据生成器处理，然后生成一个在统计上等同于原始数据的新数据集。
- en: To the production data set would give you the same things through any sort of
    testing。 any sort of machine learning algorithm， but it has now been completely
    anonymized and you would not be able to know that this came from a production
    data set。 You could then in turn share this data and use it wherever you want
    it。 It also allows us to generate more samples if we have a limited data set。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 生产数据集通过任何形式的测试，任何机器学习算法，都会给出相同的结果，但它现在已经完全匿名化，你将无法知道这些数据来自生产数据集。然后你可以分享这些数据，并在任何你想要的地方使用它。它还允许我们在数据集有限时生成更多样本。
- en: Say we have a data set of only 5，000 elements and we need a much larger data
    set because our model just will perform better if we have more data to train it
    on。 We can generate as much of this synthetic data as possible as we want。 We
    can generate a million records， a trillion records， however much you want。 And
    we can with pretty good accuracy tell you that this data is still statistically
    equivalent to the original data set。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只有5,000个元素的数据集，而我们需要一个更大的数据集，因为如果我们有更多数据进行训练，我们的模型会表现得更好。我们可以生成尽可能多的合成数据。我们可以生成一百万条记录，甚至一万亿条记录，想生成多少都可以。而且我们可以相当准确地告诉你，这些数据在统计上仍然与原始数据集相等。
- en: We can even reduce bias in machine learning data sets through a combination
    of some of these techniques。 So a really good example that is in the slide and
    I'll give these slides and all these links after the presentation is reducing
    AI bias in predicting heart disease with synthetic data。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过结合这些技术来减少机器学习数据集中的偏见。所以一个很好的例子在幻灯片中，我会在演讲结束后提供这些幻灯片和所有链接，就是用合成数据减少预测心脏病的AI偏见。
- en: This slide talks about a case study where they were looking at heart disease
    data from patients。 70% of the data which came from men because that was the data
    that they had 30% was from women and it was very biased towards the men side and
    it didn't perform very well。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这张幻灯片谈到了一个案例研究，他们在研究来自患者的心脏病数据。70%的数据来自男性，因为他们只有这些数据，30%来自女性，这在性别上非常偏向男性，而且表现得很糟糕。
- en: We were able to then take this data set， shrink down the men's size to a 50%
    and then take the 30% that we have for the women set and expand upon it using
    synthetic data。 generate it。 And then the model actually improved in accuracy
    from 88% to 96% because we were able to de-bias the data。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们能够缩减男性数据集的大小到50%，并使用合成数据扩展我们拥有的30%女性数据集。生成它。然后模型的准确性从88%提高到96%，因为我们能够消除数据偏见。
- en: But a lot of you may be going well isn't synthetic data just fake data？ And
    the answer is no。 there's actually a very big difference between synthetic data
    and fake data or mock data if you will。 A lot of people think of fake data， they
    think of faker。 And one of the problems that I've had people tell me is that faker
    sometimes gives two perfect of results like all the data sets are always filled。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但是很多人可能会问，合成数据难道不就是假数据吗？答案是否定的。合成数据和假数据或模拟数据之间实际上有很大的区别。很多人一想到假数据，就会想到“造假”。而我曾经听到的一个问题是，造假有时会给出完美的结果，比如所有数据集总是被填满。
- en: they're always meaningful。 It's not how data comes into the real world and we
    all know that。 So fake or mock data has no accuracy。 It's purely random。 Synthetic
    data on the other hand is nearly as accurate or in some cases as represented by
    this paper as well can be more accurate than the original data set when trained
    on a specific model。 So where can you use synthetic data？ The answer is everywhere。
    Automotives， financial services。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它们总是有意义的。数据是如何进入现实世界的，我们都知道这一点。所以假数据或模拟数据没有准确性，它完全是随机的。而合成数据则几乎与原始数据集一样准确，或在某些情况下，正如这篇论文所述，可以比原始数据集更准确，当在特定模型上进行训练时。那么，你可以在哪里使用合成数据？答案是无处不在，汽车、金融服务。
- en: cybersecurity， healthcare and life sciences with genomics， all sorts of things。
    How can you。 as the audience member， start using synthetic data？ Gretel。 the company
    that I work for has open sourced our synthetic data model。 We have one right now。
    there are more coming。 So if you have a really good GPU or using Google Cloud。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 网络安全、医疗保健和生命科学与基因组学，诸如此类的事情。作为观众，您如何开始使用合成数据？我工作的公司Gretel已经开源了我们的合成数据模型。我们现在有一个，更多正在到来。所以如果你有一个很好的GPU或者使用Google
    Cloud。
- en: you are more than welcome to try to use it。 You can use our cloud offering。
    It has a free tier。 It also gives you all the synthetic data scores to tell you
    how far your data has drifted。 differential privacy， a whole bunch of things。
    You can check out this blog。 I'm doing a open space。 250 AB tomorrow at four on
    Saturday and that's all the time I have。 [applause]。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您非常欢迎尝试使用它。您可以使用我们的云服务。它有一个免费层。它还提供所有合成数据分数，以告诉您数据漂移的程度，差分隐私等等。您可以查看这个博客。我正在做一个开放空间。明天星期六四点在250
    AB，时间不多了。[掌声]。
- en: '![](img/a47799776e5058416042756da081300f_28.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_28.png)'
- en: Thank you， Mason。 [applause]。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢你，梅森。[掌声]。
- en: '![](img/a47799776e5058416042756da081300f_30.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_30.png)'
- en: Love synthetic data。 All right。 Next up we have Sophia， who's going to talk
    to us about holo-vis。 Take it away。 [silence]， [inaudible]， Hello， everyone。 Hi。
    My name is Sophia。 I'm a data scientist from Anaconda。 Today I'd like to talk
    about holo-vis。 Holo-vis is my favorite Python visualization ecosystem， which
    comprises seven libraries， panel。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 喜爱合成数据。好吧，接下来我们有索非亚，她将和我们谈论holo-vis。开始吧。[静音]，[听不清]，大家好。嗨，我叫索非亚。我是Anaconda的数据科学家。今天我想谈谈holo-vis。Holo-vis是我最喜欢的Python可视化生态系统，由七个库组成，包括panel。
- en: HV plot， holo-views， geo-views， data shader， program， and color set。 With more
    than hundreds of thousands of downloads per month。 it is one of the most popular
    Python libraries。 So my data visualization workflow usually starts with HV plot。
    I use HV plot with panel to build dashboards， and I use HV plot with data shader
    to visualize big data。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: HV plot、holo-views、geo-views、数据着色器、程序和颜色集。每月下载超过十万次，是最受欢迎的Python库之一。所以我的数据可视化工作流程通常从HV
    plot开始。我使用HV plot与panel构建仪表板，并使用HV plot与数据着色器可视化大数据。
- en: HV plot， it might be familiar with Pandas。plot， ABI。 HV plot just works and
    looks and feels just like Pandas。plot。 To the left here we have Pandas。plot API，
    plotting x， x and y access with mapplotlib as the back end。 To the right we replace
    dotplot to dot HV plot， so you can see this is a HV plot plotting the same plot
    with bokeh as the back end。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: HV plot，可能和Pandas.plot很相似。HV plot的工作原理和外观感觉与Pandas.plot完全一样。在这里左侧，我们有Pandas.plot
    API，使用mapplotlib作为后端绘制x、y轴。右侧我们将点图替换为点HV plot，因此您可以看到这是一个使用bokeh作为后端绘制的HV plot。
- en: In the holo-vis ecosystem you can actually use different back ends from your
    preferred library like mapplotlib。 bokeh， bokeh， plali， and etc。 Next I want to
    show you an example of how to build a dashboard of using HV plot and panel。 You
    might be familiar with Pandas。 We have a Pandas。peplai， we define Pandas。train
    method。 this is with the car dataset， we define the cylinder in manufacturer。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在holo-vis生态系统中，您实际上可以使用您喜欢的库中的不同后端，比如mapplotlib、bokeh、plali等。接下来，我想向您展示如何使用HV
    plot和panel构建仪表板的示例。您可能对Pandas很熟悉。我们有一个Pandas.peplai，我们定义了Pandas.train方法。这是使用汽车数据集的，我们定义了制造商中的气缸。
- en: and we group by some variables and calculating the horsepower。 What if we want
    to interact with the cylinder manufacturer and all that？
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按一些变量分组并计算马力。如果我们想与气缸、制造商等进行交互呢？
- en: So instead of using those defined values we can actually use panel wedges。 Here
    I define three panel wedges， cylinders， manufacturer and x access to define the
    variables we want to take the min off。 And then the result is the interactive
    table or interactive data frame which you can plot。 interactive plot on。 So here
    is the final result with a few more lines of code。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以实际使用panel wedges，而不是使用那些定义的值。在这里，我定义了三个panel wedges：气缸、制造商和x轴，以定义我们想要取最小值的变量。结果是交互式表格或交互式数据框，您可以进行绘图。交互式绘图在此。因此，这里是最终结果，还有更多的代码行。
- en: If you want to see full example of this full code of this example。 please go
    check out my GitHub page。 It is listening here。 And then finally I want to show
    you a simple example of how to visualize big data using HV plot and data shader。
    To the left here again we have Pandas。plot。api plotting 11 million data points
    of NYC taxi drop off locations。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看这个示例的完整代码，请访问我的GitHub页面。它在这里。最后，我想向您展示如何使用HV plot和数据着色器可视化大数据的简单示例。在左侧，我们再次有Pandas.plot.api，绘制了1100万个NYC出租车的掉落地点数据点。
- en: As you can see in this plot it is a blob and it's very hard to extract meaningful
    information from this。 With HV plot we can use a "restaurize = true" option which
    uses data shader under the hood to plot this data meaningfully and interactively
    really fast。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这个图中所看到的，它是一个模糊的区域，很难从中提取有意义的信息。使用HV图时，我们可以使用“restaurize = true”选项，这在后台使用数据着色器以有意义和交互的方式快速绘制数据。
- en: If you want to learn more about Hallovis， please check out the documentation
    at Hallovis。org and also the documentation of HV plot panel and data shader。 I
    have also written several blog posts， data visualizations and an account on the
    nucleus in account。cloud。 And account on the nucleus is a data science engagement
    content and community platform。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于Hallovis的信息，请查看Hallovis.org上的文档，以及HV图面板和数据着色器的文档。我还写了几篇博客文章，数据可视化，以及关于nucleus的一个账户，在account.cloud上。nucleus是一个数据科学参与内容和社区平台。
- en: Please go check it out。 It's pretty cool。 Thank you。 Please feel free to connect
    me at Twitter and LinkedIn。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请去看看。非常酷。谢谢你。请随时通过Twitter和LinkedIn与我联系。
- en: '![](img/a47799776e5058416042756da081300f_32.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_32.png)'
- en: '[applause]， Thanks Sophia。 Excellent。 Thank you so much Sophia。 Up next we
    have Shavai and I''m really excited about this。 Go ahead without further ado。
    With a little ado because we need to put the dongle on the computer。 A small ado。
    A dongle size to do。 Oh no。 We''re going to do a comedy skit up here。 No， I don''t
    think so we should。'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声] 谢谢Sophia。太棒了。非常感谢你，Sophia。接下来是Shavai，我对此非常兴奋。请继续，没有更多的废话。因为我们需要把接收器连接到电脑。稍微有一点小麻烦。接收器的尺寸正好。哦不。我们将在这里做一个喜剧小品。不，我觉得我们不应该这样。'
- en: '![](img/a47799776e5058416042756da081300f_34.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_34.png)'
- en: '[laughter]， Alright， let''s give him another round of applause。 One moment。
    Hello。 First of all welcome everyone to the lightning talks。 I''m Shavai。 I''m
    a contributor and sponsor for Robin。 Well， Robin is an async Python web framework
    with a Rust front time。 And today I''m going to be telling you all about it。'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[笑声] 好吧，让我们给他再一次热烈的掌声。等一下。你好。首先欢迎大家参加闪电演讲。我是Shavai。我是Robin的贡献者和赞助者。Robin是一个异步Python网络框架，具有Rust的前端。今天我将告诉你们关于它的一切。'
- en: So first of all let's get to know about how Robin actually started。 So well
    it's a pet project from one of my really close friends son， Scott。 who is one
    of the original creators of this project。 So basically back in April of 2021 he
    was in his final year of college and。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解一下Robin是如何开始的。这是我一个非常亲密朋友的儿子Scott的宠物项目。他是这个项目的最初创建者之一。基本上，2021年4月，他正在上大学的最后一年。
- en: he was basically preparing for his final thesis。 Along that same time there
    was a huge wave of build with Rust or basically rewrite in Rust。 A lot of different
    softwares were being rewritten using Rust because Rust is such a popular language
    because of its performance。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 他基本上在为他的最终论文做准备。在那个时候，出现了一股使用Rust构建或重写的巨大浪潮。许多不同的软件正在使用Rust重写，因为Rust因其性能而非常受欢迎。
- en: So at that point of time since Scott was also working on a side project that
    was being built with Flask。 He also was working a lot with Node。js and he wished
    that like you know Flask could actually get async support which it lacked at that
    point of time。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 那时，Scott也在做一个使用Flask构建的副项目。他还在大量使用Node.js，并希望Flask能获得当时所缺乏的异步支持。
- en: So he decided that why not just create another framework that could actually
    become the next async Flask。 Well， I mean he was aware of fast API but he just
    wanted to create his own Rust based framework and that's how Robin actually came
    into play。 Well one of the biggest benefits of Robin over other Python frameworks
    is that everyone should be knowing about the notoriousness of like the global
    interpreter lock that is there in Python which does not allow it for being truly
    concurrent。 And that's where like you know Rust because it natively implements
    like you know multi threading is much faster as compared to other Python frameworks
    that might have been built using Python or C Python。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以他决定，为什么不创建另一个框架，实际上可以成为下一个异步Flask。他知道fast API，但他只是想创建自己的基于Rust的框架，这就是Robin的诞生。Robin相比于其他Python框架的一个最大优势是，大家应该知道Python中有一个著名的全局解释器锁，这使得Python无法真正实现并发。而Rust因为本身实现了多线程，速度比其他可能用Python或C
    Python构建的框架要快得多。
- en: And Robin also comes with a basically with a coupled server。 So that means that
    it does not have to depend on an actual or an external ASGI。 And if we just compare
    it against all the major frameworks as compared like you know sitas your Flask。
    fast API， Django。 So this test that you see in this table was done over 10。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Robin也基本上配备了一个耦合服务器。这意味着它不必依赖实际的或外部的ASGI。如果我们将其与所有主要框架进行比较，比如Flask、FastAPI、Django等。这张表中的测试是在10次基础上进行的。
- en: 000 different requests for a simple HTTP request get request。 And you can see
    that Robin is actually the fastest as compared to all of them across different
    kind of strained workloads。 Now quickly coming to the architecture right so essentially
    since it's a Rust based runtime so we are come like we are basically compiling
    the code of a Python into Rust is getting converted。 Now if you can see the worker
    event cycle this is sending requests to the router which basically contains various
    Python based code objects which basically are there for each and every separate。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 进行简单的HTTP GET请求时有000个不同的请求。你会看到，Robin在不同的高负载下实际上是最快的。现在快速来看架构，由于它是基于Rust的运行时，我们基本上是将Python代码编译成Rust。
- en: Route that is being generated。 Now once this basically the routers sends this
    code directly to a thread pool which then distributes it along the different threads
    based on the workload of the CPU。 And this sort of becomes really great if you
    want to scale it because each of these worker events can be distributed amongst
    various CPU cores。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 路由被生成后，路由器会直接将代码发送到线程池，然后根据CPU的工作负载将其分配到不同的线程。如果你想扩展，这种方式非常好，因为每个工作事件可以在各种CPU核心之间分配。
- en: And if you really want to scale it further you can distribute this workload
    across very CPU cores and that makes it super impressive as you can see from the
    results that you saw from the comparison。 And of course if you want to get used
    to it like you can simply install the Python packets for Robin and you will be
    able to use it very simply as you might actually use something like Flask。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想进一步扩展，可以将这个工作负载分配到多个CPU核心，这让结果非常令人印象深刻。正如你从比较中看到的那样。当然，如果你想习惯它，只需安装Robin的Python包，你就可以像使用Flask一样简单地使用它。
- en: Of course with the added benefit of being async。 And well if you want to get
    involved you can like you know if you like the project you can give it a star
    by going to github。com/sansrops/robin。 And you can also join the getter community
    for the Robin project and you can also follow the Robin project on Twitter。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有异步的额外好处。如果你想参与其中，如果你喜欢这个项目，可以通过访问github.com/sansrops/robin为它加星。你也可以加入Robin项目的getter社区，还可以在Twitter上关注Robin项目。
- en: And of course if you want to connect with me you can connect with me on Twitter
    at the rate hard enough。 But thank you so much for attending today's lightning
    talk。 [Applause]， Alright。 yet another web framework just that we need。 I'm just
    joking。 You can always make them faster right？
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你想和我联系，可以在Twitter上找到我，用户名是hard enough。非常感谢你参加今天的闪电演讲。[掌声] 好吧。又一个我们需要的网络框架。我只是在开玩笑。你总是可以让它们更快，对吧？
- en: I think you need a double check。 Oh you got one oh sorry I'm vamping because
    I thought we were moving one from the other side。 Alright so this is Chris。 Chris
    is going to give us a talk on elegant code in three steps。 Is the first step just
    use Python maybe？ Yeah maybe so。 Okay give it away for Chris。 [Applause]。 I'm
    told in America they make things bigger。 Anyway my name is Chris May。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你需要再检查一下。哦，你得到了一个，哦抱歉，我刚刚以为我们正在从另一边移动。好的，这是Chris。Chris将给我们讲解优雅代码的三个步骤。第一步是不是只用Python？是的，可能是的。好了，把时间留给Chris。[掌声]。我听说在美国他们做得更大。无论如何，我叫Chris
    May。
- en: I'm excited about talking to you how to make code elegant。 To make code elegant
    we need to refactor。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我很高兴能和你讨论如何使代码优雅。要使代码优雅，我们需要重构。
- en: '![](img/a47799776e5058416042756da081300f_36.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_36.png)'
- en: And that is because it is practically impossible to make elegant code that you
    as well documented code that you can understand。 code that you can maintain the
    first go around。 And thankfully since people have been writing code for decades
    we have decades worth of tools that you can use to refactor such as code smells。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为几乎不可能制作优雅且有良好文档的代码，这样的代码你能理解并能在第一次运行时维护。幸运的是，由于人们已经编写代码几十年，我们有数十年的工具可供使用，以进行重构，比如代码异味。
- en: People have categorized specific things they call code smells which are things
    that suggest opportunities for improvement。 In addition there are specific methods
    you can use to refactor code。 Each of these have a list of specific steps you
    can follow to make sure that your code is always going to run and it's going to
    be more elegant when you're finished。 But there are a lot of them right？ How are
    you going to keep them straight especially when you don't have this list there
    or you don't know which one you need to follow？
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 人们对一些被称为代码异味的具体事物进行了分类，这些是暗示改进机会的事物。此外，还有一些特定的方法可以用来重构代码。这些都有一系列特定的步骤，你可以遵循，以确保你的代码总是能运行，而且在完成时会更加优雅。但它们有很多，对吧？你怎么能理清它们，特别是当你没有这份列表或者不知道该遵循哪个时？
- en: Wouldn't it be great if there is a way that you can just follow something simple
    to make a code more elegant？
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一种简单的方法可以让代码更优雅，那不是太棒了吗？
- en: Well thanks to Heinrich telling me about this book 99 bottles of OOP。 I've been
    really impressed with Sandy， Metz and Katrina Owen。 They spent two years trying
    to figure out how do you tell people how do you explain how to refactor。 They
    created this thing called the flocking rules。 These are the three rules。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了海因里希告诉我这本书《99瓶OOP》，我对桑迪、梅茨和卡特里娜·欧文印象深刻。他们花了两年时间试图找出如何告诉人们如何解释重构。他们创建了这个叫做群聚规则的东西。这是三个规则。
- en: If I were to read them to you right now， you're not going to get it。 We need
    a little code to walk through。 In trying to learn the flocking rules I started
    creating code that would recite the 12 days of Christmas song。 Here are two verses
    that I started working。 First thing we need to do is identify the things that
    are most alike。 In this case there are two verses。 That's easy。 We need to find
    the smallest difference between them。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我现在读给你听，你是不会明白的。我们需要一些代码来走一遍。在试图学习群聚规则时，我开始创建可以背诵《圣诞节的12天》歌曲的代码。这里有两个我开始工作的诗句。我们需要做的第一件事是识别最相似的东西。在这种情况下，有两个诗句。这很简单。我们需要找到它们之间最小的差异。
- en: I'm going to focus on the first lines of each of these cases。 The only difference
    is the word first or the word second。 Next we need to make simple changes that
    will remove the differences。 The first and second we need to come up with a concept
    that encapsulates this idea。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我将专注于每个案例的第一行。唯一的区别是“第一”这个词或“第二”这个词。接下来我们需要做一些简单的更改，以消除这些差异。我们需要想出一个概念来概括这个想法。
- en: When verses one this thing will be first。 I'm going to use the word day。 It
    makes sense to me。 We don't have to stick on this。 We can always refactor it later。
    So day。 So what we need to do is create new code that represents day。 With Python
    we just make a function。 Next we need to make this code ready to return the data
    that we want。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当“第一”这个东西将是“日”。我将使用“日”这个词。这对我来说有意义。我们不必固守于此。我们可以稍后重构它。所以“日”。我们需要做的是创建表示“日”的新代码。使用Python，我们只需创建一个函数。接下来我们需要让这段代码准备好返回我们想要的数据。
- en: I should say I made a test for this。 We should be running tests。 We ran the
    test。 The test passed。 That is good because we know we have valid code。 We now
    add what we need to return。 Run our tests。 It passes again。 We know we are ready
    to incorporate it in。 Let's do that。 Pars execute and use the results。 So we insert
    that in into this first opportunity。 Run our tests。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该说我为此做了一个测试。我们应该运行测试。我们进行了测试，测试通过了。这很好，因为我们知道我们的代码有效。现在我们添加我们需要返回的内容。再次运行我们的测试。它再次通过。我们知道我们准备好将其纳入了。我们来做吧。解析并使用结果。因此我们将其插入到第一个机会中。运行我们的测试。
- en: They pass。 We are doing good。 So technically you can say we can go to the next
    one to delete unused code but we have all。 unused code that we can use so we can
    go back through the flocking rules。 Or we can focus in and say let's just stick
    here and refactor this whole through。 Next thing we need to do is incorporate
    the second。 So we can return second。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它们通过了。我们做得很好。因此，从技术上讲，你可以说我们可以进行下一个步骤，删除未使用的代码，但我们有所有未使用的代码可以使用，因此我们可以再次回顾聚集规则。或者我们可以专注于这里，重构整个过程。接下来我们需要做的是整合第二个。这样我们就可以返回第二个。
- en: So day needs information。 Let's give it to it。 We pass in something we know
    we can delete later because we want to make sure it passes at this。 point which
    they do。 So let's do that。 Let's add code to return second。 Let's incorporate
    it into the code。 Now let's make the two pieces of code the same。 Just like that。
    And hey look at that。 They are identical now so we can delete unused code which
    is this little extra code that I。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所以需要信息。我们给它提供信息。我们传入一些我们知道可以后续删除的东西，因为我们想确保它在这一点上能通过测试，它们确实通过了。那我们就这样做。让我们添加代码以返回第二个。让我们把它纳入代码中。现在让我们让这两段代码保持一致。就这样。看看，现在它们是完全相同的，所以我们可以删除未使用的代码，这些就是我多余的小代码。
- en: put in here。 And we now have code that's more elegant。 And at this point you
    can go back through the flocking rules again。 And the thing I love about the flocking
    rules is that it's always kind of fractal in nature。 So no matter where you are
    you can just jump back into them and make your code better。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 放在这里。现在我们有了更优雅的代码。此时，你可以再次回顾聚集规则。我喜欢聚集规则的地方在于，它总是具有某种分形的特性。所以无论你在哪里，你都可以跳回去，使你的代码更好。
- en: If you get pulled away while you're in the middle of refactoring and you don't
    know where。 you are you're going to have working code that works obviously and
    you can always jump。 back in and make it better。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在重构的过程中被拉走了，而你不知道自己在哪里，你将会有明显可工作的代码，当然你可以随时回到这里并让它变得更好。
- en: '![](img/a47799776e5058416042756da081300f_38.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_38.png)'
- en: Well thank you。 If you want more tips like this check me out at everyday superpowers
    at div where I want。 to give you the superpowers you can use every day and on
    twitter at underscore chris may。 Thank you very much。 [applause]， Thank you so
    much chris。 And up next we have chris。 Who's going to be talking to us about getting
    to 100% coverage and why it matters。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢。如果你想要更多这样的技巧，可以在 Everyday Superpowers 的 div 上关注我，我想给你们提供可以每天使用的超能力，还有我的推特帐号是
    underscore chris may。非常感谢。[掌声]，非常感谢你，Chris。接下来是 Chris，他将与我们谈论如何达到 100% 的覆盖率以及为什么这很重要。
- en: Check one check two。 Thank you。 Thank you all for staying for the last lightning
    talk of the day。 So I'm going to talk to you about 100% test coverage。 100% test
    coverage is when we have all lines of our code covered by test。 I want to talk
    about is it worth it is it worth getting to 100% and how can we get there。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一下，一个检查，两个检查。谢谢你们。感谢大家参加今天的最后一场闪电演讲。我将和你们谈谈 100% 的测试覆盖率。100% 的测试覆盖率是指我们所有代码行都被测试覆盖。我想讨论的是，达到
    100% 是否值得，以及我们如何能做到这一点。
- en: So this comes out of my two year journey to achieve 100% test coverage on an
    open source。 project called static frame。 I achieved that goal and I got that
    100% banner there。 It was really hard but I made it and it's very satisfying。
    Initially I was very skeptical about this goal because 100% test coverage does
    not mean。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这来源于我两年的旅程，旨在为一个名为 Static Frame 的开源项目实现 100% 的测试覆盖率。我达到了这个目标，得到了那个 100% 的横幅。过程非常艰难，但我做到了，这非常令人满意。起初，我对这个目标持怀疑态度，因为
    100% 的测试覆盖率并不意味着。
- en: 100% behavior coverage and aren't all those new features you want more important
    than 100%。 test coverage。 I believe 100% test coverage is worth the effort。 At
    least we have exercise all lines of our code and we have 100% test coverage and
    this。 is critical in Python where un-exercise codes will not be evaluated。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 100% 的行为覆盖率，而你想要的所有新特性是否都比 100% 的测试覆盖率更重要。我相信 100% 的测试覆盖率是值得付出努力的。至少我们已经测试了所有代码行，并且达到了
    100% 的测试覆盖率，这在 Python 中至关重要，因为未被测试的代码将不会被评估。
- en: It does not guarantee correctness but it does offer many additional benefits。
    So this is my journey through the code curve timeline of my coverage and you can
    see in。 January of 2020 I set out to get to 100%。 I didn't make it。 I got to about
    98%。 And then you can see my coverage wander and start to slip away。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 它并不保证正确性，但确实提供了许多额外的好处。这是我在覆盖率时间线上的代码旅程，你可以看到，在 2020 年 1 月，我开始追求 100%。我没有做到，我达到了大约
    98%。然后你可以看到我的覆盖率开始波动并逐渐下降。
- en: And then I realized one day my coverage was slipping。 So I tried again and then
    I got distracted and my coverage drifted and you see this pattern。 repeat over
    and over again until finally in January of 2022 I got to 100%。 And it's much easier
    to stay at 100% once you're at 100%。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我意识到有一天我的覆盖率在下降。我又试了一次，但又被分心了，覆盖率又偏离了，你会看到这个模式一遍又一遍地重复，直到最终在2022年1月我达到了100%。一旦你达到了100%，保持在100%会轻松得多。
- en: So that's really one of the important takeaways here。 So what is it in that
    last 2% that was so hard？ Well one of the things is non-trivial unreachable code。
    This is not the unreachable code that Pilent tells you about。 This is the unreachable
    code that is due to a logic problem that you haven't evaluated， correctly。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是这里一个重要的收获。那么，最后的2%到底有什么如此困难的呢？其中一个原因是非平凡的不可达代码。这并不是Pilent告诉你的不可达代码，而是由于你没有正确评估的逻辑问题导致的不可达代码。
- en: So that's one of the things that I found。 But overwhelmingly what you find is
    hard to test code。 There's a reason that's the last 2% is because it's hard and
    that often leads to valuable。 refactoring of your code and improving your designs。
    But is less than 100% good enough if you have like 93 can you say well I tried。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我发现的其中一件事。但你会发现，难以测试的代码占了绝大多数。最后的2%之所以如此困难，是因为它往往会导致你代码的有价值的重构和设计改善。但是如果你有93%的覆盖率，能说“我尽力了”吗？
- en: So many popular open source packages do not make it to 100% and we can see one
    example， here。 So I argue that less than 100% is not good enough。 And there's
    a number of reasons。 So the first is as I said the last 2% of lines is the hardest
    to test code and there。 are probably real bugs in that code。 It's also while you're
    working on your code hard to tell if you are growing or reducing。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 许多流行的开源包并没有达到100%，我们可以看到一个例子。所以我认为不到100%是不够好的。有很多原因。首先，如我所说，最后的2%行是最难测试的代码，可能在这些代码中确实存在真实的bug。在你编写代码的过程中，很难判断你是在增长还是减少。
- en: coverage if you're not at 100%。 I mean you can check your coverage every day
    but it's going to be harder to follow if you're。 not at 100%。 Furthermore without
    100% coverage you have less confidence that any refactoring you do。 is not going
    to break things。 Without 100% coverage it's hard to tell if pull requests are
    adding enough coverage and。 this helps make test expectations really explicit
    for your contributors。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的覆盖率不到100%。我的意思是你可以每天检查覆盖率，但如果没有达到100%，跟进会更困难。此外，如果没有100%的覆盖率，你对任何重构后不会破坏东西的信心就会降低。没有100%的覆盖率，很难判断拉取请求是否添加了足够的覆盖率，这有助于使测试期望对贡献者非常明确。
- en: So for example here in a GitHub PR using the code cover report tool we can see
    that I added。 10 lines of code in this PR and I added 10 lines of test。 And if
    you merge all your code through your PRs and you have code coverage looking at
    your。 coverage with each of these PR you can maintain 100% coverage in your project。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个GitHub PR中，使用代码覆盖报告工具，我们可以看到我在这个PR中添加了10行代码，并添加了10行测试。如果你通过PR合并所有代码，并且在查看每个PR时保持代码覆盖率，你就可以在项目中保持100%的覆盖率。
- en: So how do we get to 100% coverage？ Well the first step is building coverage
    into your continuous integration。 And I've used codecove。io for a number of years。
    I've been very happy with it。 There's probably alternatives out there but it's
    worked very well for me and it's free。 for open source projects。 You'll need a
    couple packages。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何达到100%的覆盖率呢？第一步是将覆盖率构建到你的持续集成中。我已经使用了codecov.io好几年了，我对此非常满意。可能还有其他替代品，但对我来说效果很好，并且对开源项目是免费的。你需要几个包。
- en: The coverage package has been there for a long time and it's a great utility。
    The PyTestCove plugin works with coverage to derive your coverage in your PyTest
    runs。 Now you need to get this in your continuous integration。 So I use GitHub
    Actions。 other continuous integrations you can probably do the same thing。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率包存在了很长时间，是一个很好的工具。PyTestCove插件与覆盖率配合使用，以推导你在PyTest运行中的覆盖率。现在你需要在你的持续集成中引入这个。所以我使用GitHub
    Actions，其他的持续集成也可以做同样的事情。
- en: You can see here I just run PyTest with the Cove plugin and I tell it to give
    me an XML， report。 And then I use the codecove action tool to upload that to codecove
    and that's all we need， to do。 So you can set this up with your continuous integration
    and you'll get constant coverage， updates。 So a couple practical tips。 So not
    every line needs coverage。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我刚用Cove插件运行了PyTest，并告诉它生成一个XML报告。然后我使用codecove的操作工具将其上传到codecove，这就是我们需要做的所有事情。因此，你可以将这个设置在你的持续集成中，你将获得持续的覆盖更新。有几个实用的小贴士，并不是每一行都需要覆盖。
- en: You can use the pragma no cover declaration to skip immaterial lines。 Now you
    don't want to just skip stuff because it's hard。 You want to skip stuff that really
    doesn't need coverage。 And a good example is unimplemented abstract base class
    methods。 Like that's code that should never be called。 We don't want to， we don't
    want to coverage on that。 In addition， while you're studying your coverage， I
    recommend putting comments in your code when。 you identify lines that do not have
    coverage。 It's a good idea to put a comment in your code right away to tell you
    coverage is missing。 there。 So later on when you're not looking at your coverage
    and you're maybe working on your， test。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用pragma no cover声明来跳过无关的行。现在你不想仅仅因为困难就跳过某些东西。你要跳过那些真正不需要覆盖的内容。一个好的例子是未实现的抽象基类方法。那段代码是绝对不该被调用的。我们不想对此进行覆盖。此外，在你研究覆盖时，我建议在你的代码中添加注释，当你识别出没有覆盖的行时。立即在代码中添加注释来提示你那里的覆盖缺失是个好主意。这样等你以后不再查看覆盖时，或许在编写测试时，就能记起这些缺失。
- en: you can find what's missing and work on getting that coverage。 Finally， you
    can debug when you're。 when you're test writing test to get coverage， it's useful。
    to debug on that line because you might think you're getting coverage there but
    you're not。 So I implore all of you， stop adding new features and chase down that
    remaining coverage。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以找出缺失的部分并努力获得覆盖。最后，当你在编写测试以获取覆盖时，调试是有用的，因为你可能认为在那里获得了覆盖，但实际上并没有。因此，我恳请你们停止添加新功能，追寻剩余的覆盖。
- en: '![](img/a47799776e5058416042756da081300f_40.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_40.png)'
- en: Thank you。 [applause]。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢。 [掌声]。
- en: '![](img/a47799776e5058416042756da081300f_42.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_42.png)'
- en: Right down to the wire。 All right。 Next talk is by Indra。 Is your mic working？
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都到了关键时刻。好的，下一个演讲者是Indra。你的麦克风工作正常吗？
- en: I think it's probably on。 Yep。 Thank you。 All right。 Let's give it away for
    Indra。 Hi everyone。 Thank you so much。 Really excited to be here。 My name is Indra。
    I'm a Python developer and I'm a big fan of frameworks。 So I worked extensively
    with Django and GraphQL and SQL alchemy and more recently with Keros。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我想这可能是可以的。好的，谢谢。来，大家为Indra欢呼。大家好，非常感谢。真的很高兴能在这里。我叫Indra。我是一名Python开发者，也是框架的忠实粉丝。因此，我在Django、GraphQL、SQLAlchemy等方面有广泛的工作经验，最近还使用了Keras。
- en: and TensorFlow。 I was part of bank pipers in Bangalore and attended PyCon in
    India but this is my first。 time attending PyCon in the US。 So really excited
    to be here and talking to you all。 Today I wanted to talk to you about a medium
    article that I wrote called Pandas to production。 and as I said I'm a fan of frameworks
    and I'm becoming a fan of frameworks that help。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 还有TensorFlow。我曾是班加罗尔银行的一部分，参加了在印度的PyCon，但这是我第一次参加美国的PyCon。因此，我真的很兴奋能够在这里与你们交谈。今天我想跟你们谈谈我写的一篇中等文章，名为《Pandas到生产》。正如我所说，我是框架的粉丝，我开始喜欢那些提供帮助的框架。
- en: data scientists very quickly take their models from a Jupyter notebook and make
    an API service。 out of it。 There are many sort of frameworks that do this today。
    There's fast API。 There's a cube flow ML flow。 I have used Bento ML which is one
    of the open source projects that also aims to do this。 So what's the problem with
    solving？ Machine learning models are easy to build and prototype iteratively on
    a Jupyter notebook。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学家可以非常快速地将他们的模型从Jupyter笔记本中转化为API服务。现在有很多这样的框架。比如fast API，还有kubeflow和ML flow。我使用过Bento
    ML，它是一个开源项目，也旨在实现这一点。那么解决这个问题的关键是什么呢？机器学习模型在Jupyter笔记本中构建和迭代原型是很简单的。
- en: but then we don't like typically data scientists have to hand this off to a
    DevOps team or a。 MLOps team more likely these days because someone needs to understand
    the machine learning side。 of it， the DevOps side of it， writing APIs and not
    everyone can hire an API engineer and。 a infrastructure engineer to do these things。
    So here's a very quick tutorial on how you can do all of that if you sort of work
    with。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但通常我们不希望数据科学家将其交给DevOps团队或更可能是MLOps团队，因为需要有人理解机器学习和DevOps方面的内容，编写API，并不是每个人都能雇用API工程师和基础设施工程师来做这些事情。所以这里有一个非常快速的教程，教你如何处理这些。
- en: one of these frameworks。 So step one is sort of the easy bit which is the model。
    I guess not easy。 It's the bit that's easy for the data scientists。 So I'll skip
    over this。 I'll just tell you that I'm using a pre-trained sentiment analysis
    model that I pulled from， Kaggle。 And so what step two， step two is defining the
    API service contract。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是其中一个框架。所以第一步是相对简单的部分，模型。我想这并不容易，但对数据科学家来说是简单的部分。所以我将跳过这个。我只是告诉你，我使用的是从Kaggle获取的预训练情感分析模型。那么第二步是什么？第二步是定义API服务合同。
- en: So what does your endpoint take as input？ What does it provide as output？
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你的端点接受什么输入？它提供什么输出？
- en: How does it respond to queries？ And in this example。 I'm going to try and step
    through code live and this may or may。 not work very well but you can see that
    I have imported BentoML and the framework itself。 has ways of interacting with
    model artifacts。 So in my case。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 它如何响应查询？在这个例子中，我将尝试实时演示代码，这可能效果不好，但你可以看到我已经导入了BentoML，框架本身有与模型工件交互的方法。所以在我的案例中。
- en: my model is a SK Learn model so I'm importing that kind of artifact and。 also
    I'm telling Bento that I'm expecting adjacent input。 And really all I'm doing
    is writing a very simple sort of flask API endpoint。 So you can see my class is
    a sentiment analysis class。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我的模型是一个SK Learn模型，所以我导入那种工件，并且我告诉Bento我期望相邻输入。实际上，我所做的只是编写一个非常简单的flask API端点。所以你可以看到我的类是一个情感分析类。
- en: It's a Bento service which means this is going to be exposed at a certain endpoint。
    There's a couple of big packages that I'm declaring I need and this is important
    because。 it gets packaged into the runtime environment and I'm defining that I
    expect a model artifact。 which will be pickled。 So it's going to be loading from
    a pickled file。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Bento服务，这意味着它将在某个端点暴露。我声明了几个我需要的大包，这很重要，因为它将打包到运行时环境中，并且我定义了我期望一个将被序列化的模型工件。所以它将从一个序列化文件加载。
- en: And then I just have to implement a predict function。 All this does is says，
    okay。 I'm expecting some kind of JSON input and then here's all。 the code that
    I have to write to make my model an API。 I'm saying， let me pass the JSON。 let
    me load the model artifact and run predict on that。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我只需实现一个预测函数。这个函数的作用是，好的，我期望某种JSON输入，然后这是我必须编写的所有代码来将我的模型变成API。我在说，让我传递JSON，让我加载模型工件并在其上运行预测。
- en: This is going to load the SK Learn model run predict on my text and then for
    each prediction。 I'm just constructing a JSON response。 I'm saying， here's the
    sentiment score。 Here's the sentiment score name and then here's the text that
    I predicted on。 Seems simple enough。 So from there， the next step is to package
    this model and serve it。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载SK Learn模型，在我的文本上运行预测，然后对于每个预测，我只是构造一个JSON响应。我在说，这是情感分数。这是情感分数名称，然后这是我预测的文本。看起来够简单。所以从这里开始，下一步是打包这个模型并提供服务。
- en: So all I need to do is import that particular model， call Bento service and
    say， hey， this。 is the service I defined。 This is the model that you need to run
    on and then all it's going to do is it's going。 to load those two together， load
    up a Docker environment， install the pip packages and。 declare and ready to serve。
    So that exposes a flask endpoint which you can see right here。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我需要做的就是导入那个特定模型，调用Bento服务并说，嘿，这是我定义的服务。这是你需要运行的模型，然后它将会把这两者加载在一起，启动一个Docker环境，安装pip包，并声明准备提供服务。所以这将暴露一个flask端点，你可以在这里看到。
- en: It comes with a bundled health metrics and other endpoints and I'm able to execute
    and。 get responses from this API。 With a couple of quick changes to that and I'm
    coming up on a minute so I'm going to。 run through this， with a couple of quick
    changes to that we can instrument error tracking and。 performance metrics measurements。
    So I will skip down to the end and show you how I've done that。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含了健康指标和其他端点，我能够执行并从这个API获取响应。稍微改动一下，我快到一分钟了，所以我要快速讲一下，经过几次快速修改，我们可以实施错误跟踪和性能指标测量。所以我会跳到最后，展示我是怎么做到的。
- en: So relying on our good friend's sentry here， so import sentry SDK， set up your
    sentry config。 and you're ready to go。 Sentry will start tracking errors as long
    as there is a try except block and you're doing。 capture exception。 Bento ML comes
    bundled with Prometheus for performance metrics tracking。 So I have two metrics
    that I've defined here。 There's a request time metric which measures latency and
    there is a text length which is。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此依赖于我们好朋友Sentry，在这里导入Sentry SDK，设置你的Sentry配置，然后你就可以开始了。只要有try except块，并且你在进行捕获异常，Sentry就会开始跟踪错误。Bento
    ML随附Prometheus以进行性能指标跟踪。所以我在这里定义了两个指标。有一个请求时间指标，用于测量延迟，还有一个文本长度指标。
- en: more of a custom metric。 So I'm interested in how many queries am I being asked
    at any given time。 And with that you can see some zero division errors that I
    forced here and Prometheus。 logs out of the box。 So this is part one hoping to
    do part two with A/B testing and more。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的是一个自定义指标。因此我对任何给定时间我被询问多少个查询感兴趣。你可以看到一些我在这里强制产生的零除错误，以及Prometheus的默认日志。这是第一部分，希望第二部分能涉及A/B测试和更多内容。
- en: '![](img/a47799776e5058416042756da081300f_44.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_44.png)'
- en: Thank you。 All right。 Thank you， Indra。 And that does it for tonight's lightning
    talks but if you enjoyed these lightning talks。 you might also enjoy lightning
    talks tomorrow morning， tomorrow evening and Sunday morning。 If you want to give
    a lightning talk like these fine folks that just gave talks today。 you can sign
    up for tomorrow evening and Sunday morning lightning talks in the boards。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢大家。好的。谢谢你，Indra。这就是今晚的闪电演讲，但如果你喜欢这些闪电演讲，你可能还会喜欢明天早上、明天晚上和周日早上的闪电演讲。如果你想像今天刚刚演讲的那些优秀朋友一样进行闪电演讲，你可以在公告板上报名参加明天晚上和周日早上的闪电演讲。
- en: directly out that back door right next to the registration booth。 Anyone can
    sign up to give a five minute talk about whatever they want。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 直接从注册摊位旁边的后门出去。任何人都可以报名进行五分钟的演讲，主题不限。
- en: '![](img/a47799776e5058416042756da081300f_46.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a47799776e5058416042756da081300f_46.png)'
- en: And as a point of clarification， if you are selected you will be emailed。 Yeah。
    And you're emailed really nicely on the board because if I can't read your email，
    I can't。 email you to tell you that your talk is been accepted。 Right。 Exactly。
    All right。 Thanks everyone。 Have a great night and see you all tomorrow。 [APPLAUSE]。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清一下，如果你被选中，你会收到邮件。对的。你的邮件会在公告板上非常好地展示，因为如果我看不懂你的邮件，我就无法联系你告诉你你的演讲被接受了。没错。好的。谢谢大家。祝大家晚上愉快，明天见。[掌声]
