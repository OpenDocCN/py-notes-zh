- en: P45：Talk - John Reese_ Open Source on Easy Mode - VikingDen7 - BV1f8411Y7cP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P45：演讲 - John Reese_ 开源简单模式 - VikingDen7 - BV1f8411Y7cP
- en: So the way we'll do that today is by looking at a number of different tools
    and best practices。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，今天我们将通过查看许多不同的工具和最佳实践来实现这一点。
- en: '![](img/2508ea5a8857e89cfeb32a3e593805bc_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2508ea5a8857e89cfeb32a3e593805bc_1.png)'
- en: '![](img/2508ea5a8857e89cfeb32a3e593805bc_2.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2508ea5a8857e89cfeb32a3e593805bc_2.png)'
- en: that together build a cohesive end-to-end developer experience where each individual。
    piece provides value by reducing the overall level of effort needed to maintain
    an open。 source project。 There's a lot to cover and we're going to go fast， but
    I'll have a GitHub link with。 everything that I talk about at the end of the presentation。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些共同构建了一个连贯的端到端开发者体验，其中每个单独的部分通过减少维护开源项目所需的总体努力程度而提供价值。有很多内容需要涵盖，我们将快速进行，但我会在演示结束时提供一个包含我讨论的所有内容的GitHub链接。
- en: So let's jump right in with foundational pieces that every project needs in
    order to function。 within the greater Python ecosystem。 First up is project metadata。
    This is a core requirement to publishing and distributing packages on PIPI and
    accessible。 metadata can also enable developer tooling to better understand our
    project beyond just。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们直接进入每个项目在更大的Python生态系统中运行所需的基础部分。首先是项目元数据。这是发布和分发包到PIP的核心要求，可访问的元数据还可以使开发工具更好地理解我们的项目，超越简单的。
- en: the files on disk。 The best way to do this is with well-structured and standardized
    metadata。 For anyone who's been around the block in the Python world， starting
    a new project means。 writing a new setup。py。 You import setup tools， you open
    the readme file， fetch a long description。 and maybe we'll， just find another
    project and copy paste。 We should stop this。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘上的文件。最好的方法是使用结构良好且标准化的元数据。对于任何在Python世界中历经沧桑的人来说，启动新项目意味着编写新的setup.py。您导入设定工具，打开自述文件，获取长描述，也许我们还会找到另一个项目进行复制粘贴。我们应该停止这种做法。
- en: This is not metadata。 It's arbitrary code that needs to be run every time the
    package is built from source。 Nothing there is standardized beyond what whatever
    setup tools does。 So what we want is a well-defined format that doesn't involve
    executing someone else's， code。 Thankfully， we've approved standards focused on
    a single file at the root of Python projects。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是元数据。这是每次从源代码构建包时都需要运行的任意代码。这里没有任何标准化的内容，除了设定工具所做的事情。因此，我们想要的是一个明确定义的格式，不涉及执行他人的代码。值得庆幸的是，我们已经批准了专注于Python项目根目录下单个文件的标准。
- en: called PIProject。toml。 This file acts as a central location for project metadata
    and configuration for developer tools。 alike。 The original standards for PIProject。toml
    were focused around the selection of build back。 ends， the tools that actually
    transform your Python sources into installable distributions。 Together， pet 517
    and 518 define the build system table， which any package manager can。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 称为PIProject.toml。该文件作为项目元数据和开发工具配置的中心位置。PIProject.toml的原始标准集中在构建后端的选择上，即将Python源代码转换为可安装发行版的工具。一起，PEP
    517和518定义了构建系统表，任何包管理器都可以使用。
- en: use to install your preferred build back end and then actually build and install
    your package。 I'm a fan of FLIT， so here we have the FLIT core package as the
    dependency， and the。 associated build back end。 But these days are PIProject。toml。
    It can also include standardized project metadata thanks to PIP621。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来安装您偏好的构建后端，然后实际构建并安装您的包。我是FLIT的粉丝，所以在这里我们将FLIT核心包作为依赖项，以及相关的构建后端。但这些天是PIProject.toml。它还可以根据PIP621包含标准化的项目元数据。
- en: This new format of metadata is in the top-level project table of our file and
    includes all。 of the basic package information that previously lived in setup。py
    or other back end specific。 configurations。 This unlocks a great potential for
    developer tooling to understand and use package metadata。 without the need to
    support many different formats。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的元数据格式位于我们文件的顶层项目表中，包括所有以前存储在setup.py或其他后端特定配置中的基本包信息。这为开发工具理解和使用包元数据释放了巨大的潜力，而无需支持多种不同的格式。
- en: At the top here we have the basic metadata about the package， as you might expect，
    including。 the minimum Python version requirement。 And here we have our list of
    package dependencies。 But just listing them isn't often enough。 It can cause a
    number of bug reports from users who want to use your project but have。 different
    versions or older versions of those dependencies or on platforms where they're
    not。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里顶部，我们有关于包的基本元数据，正如你所预期的，包括最低Python版本要求。这里是我们的包依赖关系列表。但仅仅列出它们通常是不够的。这可能会导致用户提出许多错误报告，他们想使用你的项目，但有不同版本或较旧版本的这些依赖关系，或者在不支持的平台上。
- en: supported。 So let's look at how we can better define those dependencies and
    how that can help guide。 users and their package managers towards optimal choices。
    So one thing is that things change。 especially in software。 Packages will get
    new features， deprecate functionality。 or just outright make breaking， changes
    at will。 That's why we can set version limits on our dependencies to make sure
    package managers。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的。因此，让我们看看如何更好地定义这些依赖关系，以及这如何帮助引导用户及其包管理器做出最佳选择。有一点是事情会发生变化，尤其是在软件方面。包将获得新功能、弃用功能，或者完全任意地进行破坏性更改。这就是为什么我们可以对依赖关系设置版本限制，以确保包管理器。
- en: install compatible versions。 If we wanted to absolutely guarantee compatibility
    we could pin our dependencies to exact versions。 But that's not convenient for
    users， especially if another package wants to pin to a different。 version。 So
    even if we expand our limits to anything without a major version。 we're still
    potentially， leaving users on old versions open to bugs and security vulnerabilities。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 安装兼容版本。如果我们想绝对保证兼容性，我们可以将依赖项固定为确切的版本。但这对用户来说并不方便，特别是如果另一个包想固定到不同的版本。因此，即使我们将限制扩展到任何没有重大版本的内容，我们仍然可能会让用户使用旧版本，从而暴露于漏洞和安全风险中。
- en: Instead， we can compromise and specify future friendly version limits on our
    dependencies。 With this method， we provide only a lower bound on those dependencies，
    ideally chosen。 based on the features we use from them and what versions support
    those features。 In our metadata。 it could look something like this。 By skipping
    the upper version boundary。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以妥协并为我们的依赖关系指定面向未来的版本限制。通过这种方法，我们只提供这些依赖项的下限，理想情况下基于我们使用的功能以及哪些版本支持这些功能进行选择。在我们的元数据中，它可能看起来像这样。通过跳过上限版本边界。
- en: we're trusting that our dependencies won't suddenly， break compatibility。 That
    might be a leap of faith， but this trade-off allows our users to upgrade and never
    potentially。 get newer and more secure versions。 It also means we don't need to
    release a new version of our own project every time one。 of our dependencies gets
    a major feature。 We can always come back and add an upper limit later if we really
    need to。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相信我们的依赖关系不会突然破坏兼容性。这可能是一次信任的飞跃，但这种权衡使我们的用户能够升级，并且不会潜在地得到更新且更安全的版本。这也意味着我们不需要在每次依赖项获得重大功能时发布我们自己项目的新版本。如果真的需要，我们可以随时回来添加上限。
- en: We can also add environment markers to our dependencies for packages that only
    need to。 be installed on specific platforms or back ports that aren't needed on
    newer Python versions。 But once we set them， how do we know our version limits
    are correct？ Well。 the honest answer is that we need to validate them。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为我们的依赖项添加环境标记，以便那些只需要在特定平台上安装的包或在较新Python版本上不需要的回移植包。但一旦我们设置了它们，我们如何知道我们的版本限制是正确的呢？老实说，我们需要验证它们。
- en: We need to test this on every version we're allowing。 But if we're being generous
    on our limits。 that's a lot of different versions to test， with。 Well。 my coworker
    Tim wrote a tool to help with exactly that problem。 Because the Python packaging
    ecosystem makes him so happy， he called the tool pessimist。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在每个允许的版本上进行测试。但如果我们对限制过于宽松，那就有很多不同的版本需要测试。我的同事Tim为这个问题写了一个工具。因为Python打包生态系统让他非常开心，所以他将这个工具称为“悲观者”。
- en: What it does is quite simple。 It looks at your project dependencies and runs
    whatever tests you prefer on all of the。 matching versions， then generates a report
    on whether your limits are valid。 There's also a fast mode， which limits the testing
    to both the oldest and newest matching， versions。 specifically for use in local
    testing or CI when compute time is otherwise limited。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它的功能非常简单。它查看你的项目依赖关系，并对所有匹配版本运行你选择的测试，然后生成一份关于你的限制是否有效的报告。还有一个快速模式，将测试限制在最旧和最新的匹配版本，专门用于本地测试或在计算时间有限的CI环境中使用。
- en: Here we're running it on a project's test suite and pessimist validates that
    it passes。 with our limits。 Now that we're confident in our metadata and dependencies。
    let's focus on building a， reproducible development workflow。 Not only can this
    simplify the process of developing， testing and validating our changes。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在一个项目的测试套件上运行它，而 pessimist 验证它在我们的限制内通过。现在我们对元数据和依赖项充满信心，让我们专注于构建一个可重现的开发工作流程。这不仅可以简化开发、测试和验证更改的过程。
- en: but it'll also make it that much easier to replicate our development environment
    on new。 machines and VMs， as well as for new developers to pick up our project
    and immediately make。 progress and have confidence that the changes are working。
    But just having a list of commands to run isn't really helpful。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 而且还会使我们在新机器和虚拟机上复制开发环境变得更加容易，对于新开发人员来说，也能立即进行项目进展，并有信心这些更改是有效的。但仅仅拥有一份要运行的命令列表并没有什么帮助。
- en: You need to have a dedicated command runner。 This will combine all of your build
    and testing steps into a single command。 including any， preparation or setup necessary
    to get your project running on a new machine。 At a bare minimum， this can be satisfied
    with make files， and I've personally used them with。 many of my projects for the
    last decade。 But it knows nothing about how Python projects work and requires
    you to re-engineer every。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个专用的命令运行器。这将把所有构建和测试步骤组合成一个单一命令，包括在新机器上运行项目所需的任何准备或设置。至少，这可以通过 make 文件来满足，我在过去十年中已在许多项目中使用过它们。但它对
    Python 项目的工作原理一无所知，需要你重新设计每个。
- en: piece of the puzzle。 Ideally， we want something that can do more of that work
    for us。 especially around setting， up virtual environments and installing dependencies。
    And we would like to do that on multiple Python versions with a single command。
    Tox is one of the most widely used projects for testing， while Nox provides an
    alternative。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望有一些可以为我们完成更多工作的工具，特别是在设置虚拟环境和安装依赖项方面。我们希望通过单个命令在多个 Python 版本上做到这一点。Tox
    是用于测试的最广泛使用的项目之一，而 Nox 提供了一个替代方案。
- en: system that lets you define your workflow with actual Python code。 But today。
    I'd like to introduce a new tool I created， a rapid development assistant that，
    I called Thaxx。 or THX。 It uses many of the same basic concepts， but focuses on
    optimizing the development workflow。 for Python projects。 Thaxx is configured
    entirely in your PyProject。toml。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 允许你使用实际的 Python 代码定义工作流程的系统。但是今天，我想介绍一个我创建的新工具，一个我称之为 Thaxx 或 THX 的快速开发助手。它使用许多相同的基本概念，但专注于优化
    Python 项目的开发工作流程。Thaxx 完全在你的 PyProject.toml 中配置。
- en: and defining simple jobs is straightforward， with a list of job names and associated
    commands。 We can then define a subset of those jobs that should be run by default。
    Now when we run Thaxx。 it executes the default jobs in virtual environments and
    outputs results， to this terminal。 If everything is successful， we see a bunch
    of green OK messages。 But if one of those jobs fails。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 定义简单作业是直接的，列出作业名称和相关命令。然后，我们可以定义一个默认运行的作业子集。现在，当我们运行 Thaxx 时，它会在虚拟环境中执行默认作业，并将结果输出到这个终端。如果一切顺利，我们会看到一堆绿色的
    OK 消息。但是，如果其中一个作业失败。
- en: we get clear error output， along with the exact command， that was run。 By default。
    Thaxx will just run jobs using the same Python version that Thaxx is installed，
    with。 But if we're trying to support our projects on multiple Python versions，
    we want our tools。 to run our development workflow on each of those supportive
    versions。 Well， Thaxx can do this。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会得到清晰的错误输出，以及运行的确切命令。默认情况下，Thaxx 将使用安装时的同一 Python 版本来运行作业。但是，如果我们想在多个 Python
    版本上支持我们的项目，我们希望我们的工具能在每个支持的版本上运行开发工作流程。好吧，Thaxx 可以做到这一点。
- en: and it can do it fast。 We can simply give Thaxx a list of the Python versions
    that we care about。 and Thaxx will， look for these run times when executing jobs。
    Each of their requested jobs will run on each of the Python versions in parallel
    with separate。 virtual environments for each version。 In some cases， though， like
    formatting。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 而且它能做到这一点很快。我们只需给 Thaxx 一份我们关心的 Python 版本列表，Thaxx 会在执行作业时查找这些运行时。每个请求的作业将在每个
    Python 版本上并行运行，并为每个版本提供独立的虚拟环境。在某些情况下，比如格式化。
- en: we might only need to run a job on a single version。 There's no need to format
    our code base four times， so we just mark the job with once equals， true。 For
    more complex jobs， we might want to run multiple steps。 Here。 we define the job
    as a list of steps each with its own command to run。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能只需要在单个版本上运行一个作业。没有必要对我们的代码库格式化四次，因此我们只需将作业标记为一次等于真。对于更复杂的作业，我们可能希望运行多个步骤。在这里，我们将作业定义为每个都有其自己运行命令的步骤列表。
- en: Thaxx will run each of these steps in order， stopping early if a step fails。
    But in this case。 none of these commands depend on the results of the previous
    one。 They could all run in parallel just fine。 So we just mark the job with parallel。
    and Thaxx will run all of them at the same time， and it will run all of these
    in parallel with each and every Python version that we're testing。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**Thaxx**将按顺序运行每一个步骤，如果某个步骤失败，则会提前停止。但在这种情况下，这些命令并不依赖于前一个命令的结果。它们都可以很好地并行运行。因此，我们只需将作业标记为并行，**Thaxx**将同时运行所有这些作业，并与我们测试的每个Python版本并行运行。'
- en: against， taking full advantage of modern multi-core systems and making our iteration
    that much。 faster。 But Thaxx has one more trick up its sleeve。 A watch mode。 where
    it can wait for modifications to our project， and automatically rerun its。 jobs
    every time our files change on disk。 It's perfect for running in an IDE or terminal
    alongside your code and gives us immediate。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 充分利用现代多核系统，让我们的迭代更加快速。但**Thaxx**还有一个独特之处。它有一个监视模式，可以等待项目的修改，并在每次文件在磁盘上更改时自动重新运行其任务。这非常适合在IDE或终端中与代码一起运行，并能立即给我们反馈。
- en: feedback when something has broken our test suite or failed coverage star-solds。
    And its parallel performance provides tremendous leverage for validating our project
    throughout。 development。 If you'd like to know more about Thaxx， please check
    it out at thx。omnilib。dev。 There's more documentation and configuration options
    that you can find there， along with。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当某些事情破坏了我们的测试套件或未通过覆盖率标准时，反馈将会提供。而其并行性能为我们在整个开发过程中验证项目提供了巨大的杠杆。如果你想了解更多关于**Thaxx**的信息，请访问[thx.omnilib.dev](https://thx.omnilib.dev)。那里有更多的文档和配置选项可供你查找。
- en: some recipes for common use cases like code coverage and CI， and how Thaxx can
    help。 So now that we have the tools to build out our workflow， we can begin looking
    at how to。 improve our development experience。 One of the best areas to focus
    on is code quality。 where the side effects of better code， are often as important
    as the code itself。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一些适用于常见用例的配方，比如代码覆盖率和持续集成，以及**Thaxx**如何提供帮助。因此，现在我们有了构建工作流程的工具，我们可以开始考虑如何改善我们的开发体验。一个值得关注的重点是代码质量，其效果往往与代码本身同样重要。
- en: Better code doesn't just mean that our project's faster or more reliable， but
    also that it's。 easier to read， easier to understand， and easier to debug。 Together。
    this means you'll spend less time maintaining and more time building。 So where
    do we start？ Well。 let's pick the lowest hanging fruit first， code style， and
    let's get the flame， wars out of the way。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的代码不仅意味着我们的项目更快或更可靠，还意味着它更易于阅读、更易于理解和更易于调试。综合来看，这意味着你将花更少的时间进行维护，更多的时间进行构建。那么我们从哪里开始呢？好吧，首先让我们解决最简单的任务：代码风格，并把争论抛在一边。
- en: I don't care what your code looks like， as long as it all looks the same。 Consistency
    and predictability are the primary factors to making code easy to read， and the。
    easier code is to read， the easier it is to understand what it's actually doing。
    Just don't make it my problem。 Only once to spend an hour fixing a bug。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我不在乎你的代码长什么样，只要它们看起来一致。一致性和可预测性是让代码易于阅读的主要因素，而代码越容易阅读，就越容易理解它实际在做什么。只要不要让我为此烦恼。仅仅花一个小时修复一个bug。
- en: only to get nitpicky feedback about code style。 Choose a code formatter that
    enforces your preferred style。 and make it an integral part， of the development
    workflow so that nobody， including you。 has to ever think about code， style again。
    The more automated and extensive， the better。 We want to dump code from our brain
    and let the computer worry about making it look right。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 只需针对代码风格获取一些挑剔的反馈。选择一个强制执行你首选风格的代码格式化工具，并将其作为开发工作流程的一个重要组成部分，这样没人，包括你自己，便不必再考虑代码风格。越自动化和广泛越好。我们希望将代码从脑海中抛弃，让计算机来担心如何让它看起来正确。
- en: after the fact。 But really， you should just use black。 It's an excellent tool
    with strong safety guarantees， so you can run it on your whole code。 base without
    worrying about breaking anything。 And for anyone who cares。 it makes your code
    look like this。 But more importantly， its configuration looks like this。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，你应该使用black。这是一个出色的工具，具有强大的安全保证，因此你可以在整个代码库上运行它，而无需担心破坏任何东西。对于在意的人来说，它会让你的代码看起来像这样。但更重要的是，它的配置看起来是这样的。
- en: When you decide to use black， all the opinions come baked in。 There's no more
    debate。 There's only one color you can paint the bike shed。 That's the easiest
    tool you'll ever configure in your life， and everyone will either thank。 you for
    it or be really angry that they have nothing to argue about anymore。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你决定使用black时，所有的观点都是固定的。再也没有争论了。你只能用一种颜色来涂刷自行车棚。这是你一生中最容易配置的工具，大家要么会感谢你，要么会因为他们没有什么可争论的而非常生气。
- en: So black will make your code look consistent， but it won't move your imports。
    I know a lot of folks really like their artisanal， handcrafted imports broken
    down by color。 and size and favorite musician， but that's a lot of work， and I'm
    lazy。 So like code style。 it's an awful lot easier to just let the computer do
    it for you。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用黑色主题会让你的代码看起来一致，但它不会移动你的导入。我知道很多人喜欢把他们的手工导入按颜色、大小和最喜欢的音乐家分类，但那需要很多工作，而我比较懒。所以，像代码风格一样，让计算机为你处理这些要容易得多。
- en: This is where I get to shamelessly self-promote some more and say we should
    all be using， U-sort。 It was built from the ground up by Tim and myself to understand
    and manipulate the syntax。 tree directly so that it can recognize and make intelligent
    choices about when and where。 it's safe to move imports。 So in the best case，
    U-sort will follow the most common patterns and sort something that。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我可以毫无羞耻地自我推广一下，大家都应该使用U-sort。它是由Tim和我从头构建的，旨在直接理解和操作语法树，以便识别并做出智能选择，决定何时何地安全地移动导入。因此，在最好的情况下，U-sort将遵循最常见的模式并对某些内容进行排序。
- en: looks like this into this。 Groups for the standard library， third party， and
    first party imports。 This is the easy part。 Now suppose we want to import a module
    and change our runtime configuration before importing。 something else。 Unlike
    other import sorters， U-sort focuses on making safe changes。 and it treats intervening，
    statements as barriers when sorting blocks of imports。 So the async。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的导入看起来像是这样的。标准库、第三方和第一方导入的分组。这是简单的部分。现在假设我们想要导入一个模块，并在导入其他东西之前改变我们的运行时配置。与其他导入排序工具不同，U-sort专注于安全地进行更改，并在排序导入块时将干预语句视为障碍。
- en: io import would never move above the simple filter call and the warnings import。
    would never move below it。 Maintaining functionality without the need for ugly
    or error-prone comment directives。 This level of safety is what allows us to run
    U-sort as scale inside meta。 Every Python file covered by our formatter gets sorted
    by U-sort without exception， and。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`io`导入永远不会移到简单过滤器调用之上，警告导入也不会移到它之下。保持功能性而无需丑陋或容易出错的注释指令。这种安全级别使我们能够在meta内部按规模运行U-sort。每个被我们的格式化工具覆盖的Python文件都会被U-sort排序，没有例外。'
- en: we automatically apply catch-up formatting for all covered files every morning。
    Now it's great to have these tools， but running multiple formatter separately
    is a recipe。 for minor conflicts， which can cause annoying failures in CI or pre-commit
    hooks。 What you really need is something that can perform both formatting and
    import sorting。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会每天早晨自动为所有覆盖的文件应用补救格式化工具。现在拥有这些工具是很棒的，但单独运行多个格式化工具是造成小冲突的办法，这可能导致CI或预提交钩子中的烦人失败。你真正需要的是一种能够同时执行格式化和导入排序的工具。
- en: in a single atomic step。 And that's where U-format comes in。 U-format is a combined
    code formatter and sorter， built on top of black and U-sort。 Each file is sorted
    and then formatted in memory as a single atomic step， guaranteeing。 consistent
    results in CI and pre-commit hooks。 If any of that sounds interesting。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以单个原子步骤进行处理。这就是U-format的作用。U-format是一个组合代码格式化器和排序器，构建在black和U-sort之上。每个文件在内存中作为单个原子步骤被排序和格式化，保证了在CI和预提交钩子中的一致性结果。如果这些听起来有趣的话。
- en: please check out the project's documentation for more。 details on how they work
    and how you can integrate them in your developer workflow。 So now that we have
    formatting taken care of， let's look at how we can apply tooling。 to actually
    make the code more reliable by finding and pointing out bad practices， subtle，
    bugs。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看项目文档以获取更多关于它们如何工作以及如何将它们集成到你的开发工作流程中的详细信息。现在我们已经处理了格式化问题，让我们看看如何应用工具，实际提高代码的可靠性，通过发现和指出不良实践和微妙的错误。
- en: or edge cases that aren't obvious， no matter how pretty the code looks。 The
    easiest place to start is with a linter。 They can help you find potential bugs
    in your code or even help prevent you from introducing。 bugs in the future by
    steering you away from problematic patterns。 There are a number of good options
    in the space， including pilot and pifelakes， but my。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 或者那些不明显的边缘案例，无论代码看起来多么漂亮。开始的最简单地方是使用linter。它们可以帮助你发现代码中的潜在错误，甚至通过引导你远离有问题的模式来帮助防止未来引入错误。这个领域有许多不错的选择，包括pilot和pifelakes，但我。
- en: personal favorite and the one we use at meta is flake 8。 Provides a nice wrapper
    around pifelakes。 has sensible defaults， easy configuration， and， most importantly
    has a number of excellent plugins available to increase the scope of。 problems
    that flake 8 can help us find。 By default we'll get warnings that range from pointing
    out bad practices like star imports。 to bugs waiting to happen like shadowed imports
    or search with parentheses， or even runtime。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人最喜欢的也是我们在Meta使用的工具是flake 8。它为pifelakes提供了一个很好的包装，具有合理的默认值、易于配置，最重要的是有许多优秀的插件可用，以扩大flake
    8可以帮助我们发现的问题范围。默认情况下，我们会得到各种警告，从指出不良实践（如星号导入）到潜在的错误（如被覆盖的导入或带括号的搜索），甚至是运行时错误。
- en: errors like undefined variables or invalid grammar。 With some extra plugins
    we can also get notified when we accidentally leave debugging breakpoints。 in
    our code or when we use mutable default values for function parameters or help
    guide。 us to better usage of list comprehension or generator expressions in our
    code。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 像未定义的变量或无效语法等错误。通过一些额外的插件，我们还可以在不小心在代码中留下调试断点时，或使用可变默认值作为函数参数时收到通知，或者帮助我们更好地使用列表推导式或生成器表达式。
- en: Finishing bugs before they happen will save future you an uncountable number
    of headaches。 and hours wasted debugging your projects。 But what you don't want
    your learner fighting with is your formatter。 We recommend turning off most if
    not all lint errors related to code style and just let。 the formatter do their
    job。 If it's good enough for the formatter it should be good enough for your linter。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在问题发生之前修复错误将为未来的你节省无数头疼和浪费在调试项目上的时间。但你不希望你的学习者与格式化工具作斗争。我们建议关闭与代码风格相关的大部分甚至全部lint错误，让格式化工具完成它的工作。如果它对格式化工具来说足够好，那么它应该对你的linter来说也足够好。
- en: While linters can look for patterns and individual pieces of your code the real
    meat is in static。 analysis tools especially type checkers which look at your
    code base as a whole and make。 sure everything is correctly passing and using
    values。 And it can do this based on what it knows about not just your code but
    other code as。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然linter可以查找你代码中的模式和个别部分，但真正的核心在于静态分析工具，尤其是类型检查器，它们会将你的代码库作为一个整体进行分析，确保一切都正确传递和使用值。它可以根据对你代码及其他代码的知识来做到这一点。
- en: well including the standard library and any other type annotated libraries used
    by your， project。 So let's look at an example of how types can help us find real
    world bugs that a human。 may never notice。 Let's assume get path is a foreign
    API we don't really know shouldn't really need to care。 about how it works。 Do
    you see the bug？ Do you have an idea of what it could be？
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 包括标准库和项目使用的任何其他类型注释库在内。那么我们来看一个示例，类型如何帮助我们发现人类可能永远注意不到的现实世界中的错误。假设`get path`是一个我们不太了解的外部API，我们实际上不需要关心它是如何工作的。你看到这个错误了吗？你有什么想法呢？
- en: What if we add some type annotations？ We're adding new information here that
    previously we might have needed to read a doc string for。 Well maybe some extra
    in line annotations help。 What if I told you that open raises an exception when
    passed none？
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加一些类型注释呢？我们在这里添加新的信息，而之前可能需要阅读文档字符串。也许一些额外的内联注释会有帮助。如果我告诉你，当传入`none`时，`open`会引发异常呢？
- en: Well， there's some input that can cause get path to return none and then we're
    just passing。 that straight to open and you end up with an angry bug report because
    someone crashed。 their production service。 But our type checker can find and report
    that before we ever release the code let alone run。 it in production。 But beyond
    finding errors there are benefits just adding type annotations to your own modules。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，有些输入会导致get path返回none，然后我们只是将其直接传递给open，结果你会收到一个愤怒的bug报告，因为有人让他们的生产服务崩溃。但我们的类型检查器可以在我们发布代码之前找到并报告这些问题，更不用说在生产中运行它了。除了发现错误，向自己的模块添加类型注解还有其他好处。
- en: Consider it as a form of validated documentation for you and everyone else looking
    at your code。 Given these two definitions for the same functions which one do
    you find more useful？
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将其视为对你和其他查看你代码的人的验证文档。考虑到这两个定义的相同函数，你认为哪个更有用？
- en: Which one could you evaluate faster when looking at a foreign API？
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看外部API时，你能更快地评估哪个？
- en: We don't even need to see a doc string or look at the body of the code in order
    to have。 a good idea of the contract being described。 This is valuable documentation
    for developers and unlike a doc string a good type checker。 will force you and
    everyone else to keep this information up to date。 So again there are multiple
    good choices here for type checkers but I recommend the use of。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至不需要看到文档字符串或查看代码主体，就能对所描述的合同有一个良好的理解。这对开发人员来说是有价值的文档，与文档字符串不同，一个好的类型检查器会强制你和其他人保持这些信息的最新。所以这里有多个优秀的类型检查器选择，但我建议使用。
- en: myPIE for open source projects。 It's by far the most popular type checker available
    and works really well with minimal。 setup or configuration needed。 For many projects
    this is the only option you need just because there are still a large。 number
    of libraries out there that don't have type stubs or aren't appropriately marked。
    as annotated and there's not much we can do about that。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: myPIE用于开源项目。它无疑是最受欢迎的类型检查器，使用起来非常顺畅，几乎不需要设置或配置。对于许多项目来说，这就是你所需的唯一选项，因为仍有大量库没有类型存根或没有适当标注。
- en: You don't even need all of your code to be typed annotated to start seeing an
    impact。 But if you're willing to type annotate everything including your test
    cases I highly recommend。 enabling strict mode。 This will let myPIE get more pedantic。
    find more bugs and also point out anytime you fail， to document I mean annotate
    your code。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至不需要所有代码都经过类型注解就能看到影响。但如果你愿意为所有内容，包括测试用例进行类型注解，我强烈建议启用严格模式。这将使myPIE更加严格，发现更多错误，同时指出任何你未能文档化的地方，也就是未标注的地方。
- en: So speaking of documentation while looking at the code directly is important
    for working。 on your own project the last thing you want to look at is someone
    else's code especially。 when you just need to know what a function is called or
    what various arguments do。 Most importantly there will come a day when your own
    code looks foreign to you and you。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在直接查看代码时讨论文档对你自己项目的工作非常重要。你最不想看到的就是别人的代码，尤其是当你只需知道一个函数的名称或各种参数的功能时。最重要的是，总会有一天，你自己的代码会对你来说显得陌生。
- en: forgotten what all your own APIs look like。 When that happens you can turn to
    your own documentation for help。 But we don't just want to brain dump info in
    a text file tucked away and forgotten cursed。 to never be accurate again。 What
    we need is tooling specifically designed to extract as much information as possible。
    from our code base including docstrings and type information and automatically
    compile。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 忘记了自己所有的API是什么样子。当这种情况发生时，你可以求助于自己的文档。但我们不希望只是将信息大脑倾倒到一个文本文件中，随意放置，注定再也无法准确。我们需要的是专门设计的工具，从我们的代码库中提取尽可能多的信息，包括文档字符串和类型信息，并自动编译。
- en: that documentation into useful formats。 Now there are many different tools that
    can do this but Sphinx is designed specifically。 for Python and used by hundreds
    of open source projects。 Sphinx will compile and transform a set of source documents
    into a full website including。 navigation and text search。 You can add arbitrary
    pages as well allowing you to build a combined project and documentation。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将文档转化为有用的格式。现在，有许多不同的工具可以做到这一点，但Sphinx专门为Python设计，并被数百个开源项目使用。Sphinx将编译并转换一组源文档为一个完整的网站，包括导航和文本搜索。你还可以添加任意页面，使你能够构建一个结合项目和文档的综合体。
- en: site all in one with relatively little time effort required to maintain it。
    Sphinx uses restructured text format similar to markdown but focused on technical
    documentation。 When compiled Sphinx generates well formatted HTML and we can include
    code blocks with syntax。 highlighting links to other sections of the documentation
    and much more that isn't possible。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内容都集中在一个地方，维护所需的时间和精力相对较少。Sphinx使用类似markdown的重构文本格式，但更专注于技术文档。编译后，Sphinx生成格式良好的HTML，我们可以包括带有语法高亮的代码块、链接到文档的其他部分，以及更多无法实现的内容。
- en: in plain markdown。 And we don't need to sacrifice the ability to read and understand
    the source text in an。 editor。 But the real magic of Sphinx comes from the autodock
    extension。 This gives Sphinx the power to look at your project's source code and
    automatically extract， module。 class and function APIs including type annotations，
    docstring， contents and more。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以普通的markdown格式。我们不需要牺牲在编辑器中阅读和理解源文本的能力。但Sphinx的真正魔力来自于自动文档扩展。这使得Sphinx能够查看你项目的源代码并自动提取模块、类和函数的API，包括类型注释、文档字符串内容等。
- en: With this in mind we can actually write our docstrings with Sphinx results in
    mind using。 inline restructured text。 We can include references to other functions。
    inline code blocks and anything else we could， put in a normal documentation page。
    Then we just add the appropriate autodroc directives to our documentation and
    regenerator， site。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们实际上可以使用Sphinx的结果来编写我们的文档字符串，使用内联重构文本。我们可以引用其他函数、内联代码块以及我们可以放入普通文档页面的任何内容。然后，我们只需将适当的自动文档指令添加到我们的文档和生成器网站中。
- en: And now our compiled documentation includes our function prototype， formatted
    contents。 of our docstring as well as type information。 Now you might be asking
    what can you do with this once you have it？
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们编译的文档包括我们的函数原型、格式化的文档字符串内容以及类型信息。现在你可能会问，一旦你拥有这些，你能做什么？
- en: Well maybe you've heard of a little site called Read the Docs。 This is an excellent
    free service for building and hosting your project documentation sites。 and it's
    specifically designed to work with Sphinx。 It also has excellent integrations
    with GitHub including the ability to automatically build。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，也许你听说过一个叫做Read the Docs的小网站。这是一个优秀的免费服务，用于构建和托管你的项目文档网站，特别设计用于与Sphinx配合使用。它还与GitHub有很好的集成，包括自动构建的能力。
- en: every time code is pushed as well as building previous sites for each pull request
    so you。 can easily evaluate any documentation changes for PRs。 So now that we
    have an end developer and documentation workflow let's take a look at how we can。
    streamline the process of community contributions without putting undue burden
    on your own time。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每次代码推送时以及为每个拉取请求构建之前的网站，这样你就可以轻松评估任何文档更改。所以现在我们有了一个最终开发者和文档工作流程，让我们看看如何简化社区贡献的过程，而不对你自己的时间造成不必要的负担。
- en: One of the most important pieces of having positive community interaction starts
    with。 setting clear boundaries on expectations in both directions。 You really
    should have a code of conduct if and when your project gains more attention。 clowns
    will inevitably show up and the easiest way to deal with them is by having code
    of。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 积极的社区互动的一个最重要部分是明确设定双方的期望界限。如果你的项目获得更多关注，确实应该有行为规范。小丑不可避免会出现，处理他们的最简单方法是有行为规范。
- en: conduct with clear set of rules and consequences that you can follow。 I use
    the contributor covenant at the Omelema project and recommend it both for the
    standards。 it includes as well as their guidance on how to enforce it。 Beyond
    that make sure you set clear expectations for what contributions you're willing
    to accept。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 具有明确规则和后果的行为规范，可以让你遵循。我在Omelema项目中使用贡献者公约，并推荐它，因为它包含的标准，以及如何执行它的指导。除此之外，请确保你对愿意接受的贡献设定明确期望。
- en: from the community。 If you only care about bug fixes say that。 If you're happy
    to take feature requests say that。 Let folks know ahead of time if they should
    open an issue or discuss new features before。 they take up their own time and
    yours with pull requests that you would never accept。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 来自社区。如果你只关心错误修复，请说明。如果你乐意接受功能请求，也请说明。提前告知大家是否应该在提交流请求前打开问题或讨论新功能，以免浪费他们和你的时间。
- en: If you can document the level of support you'll give for each project but don't
    over commit。 yourself。 Unless there's a paid support contract you do not owe anyone
    your time you don't owe。 them your energy and you certainly do not owe them your
    sanity。 If someone's being too needy and is taking up your limited time then just
    dump them。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能记录你对每个项目的支持级别，但不要过度承诺。除非有付费支持合同，否则你不欠任何人的时间，不欠他们你的精力，更不欠他们你的理智。如果有人过于需要帮助并占用了你有限的时间，那就直接放弃他们。
- en: If they're being nice apologize and just tell them you can't help them maybe
    point them。 to a different project but if they're being less than nice just don't
    engage and remove。 them from the community。 Don't waste your time on unproductive
    community members。 Unhappy or note let's look at how we can simplify and automate
    as much of their contributor。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们态度不错，向他们道歉并告诉他们你无法帮助，可能可以引导他们到其他项目，但如果他们态度不好，直接不理会并将他们从社区中移除。不要在无效的社区成员身上浪费时间。不愉快或其他，让我们看看如何简化和自动化他们作为贡献者的过程。
- en: workflow as possible。 We want to remove barriers between the community members
    and their ability to ramp up on your。 project because less friction the more likely
    you are to receive high quality contributions。 This starts with you guessed it
    more documentation。 A basic contributors guide starts with the steps to set up
    and build your project from。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能简化工作流程。我们希望消除社区成员与他们在你的项目中提升能力之间的障碍，因为减少摩擦会使你更有可能获得高质量的贡献。这从更多的文档开始，你猜到了吧。基本的贡献者指南从设置和构建你的项目的步骤开始。
- en: source as well as how to run the project and test suite。 A better guide also
    includes extra validation steps needed like linters or form matters as。 well as
    general guidance on what to include with changes like documentation test cases
    or。 change load entries。 This is where a reproducible workflow from earlier can
    really help。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码以及如何运行项目和测试套件。更好的指南还包括所需的额外验证步骤，比如代码检查器或格式化程序，以及关于更改时需要包含的内容的总体指导，比如文档、测试用例或变更日志条目。在这里，之前提到的可重复工作流程可以真正发挥作用。
- en: The closer contributors get to the workflow you use the more trust you'll have
    in their。 contributions and the more trust they will have in their own changes
    that they're making。 during development。 You can further help guide contributors
    in the right path by adding detailed issue templates。 and pull request templates
    to your project that will pre-populate the text boxes with。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 贡献者越接近你使用的工作流程，你对他们贡献的信任就越高，他们对自己在开发过程中所做更改的信任也会随之增加。你可以通过向项目中添加详细的问题模板和拉取请求模板来进一步指导贡献者，这些模板会预填充文本框。
- en: whatever you want。 You can have multiple different templates for specific types
    of issues or requests but。 be sure to include any spots for specific information
    that you want to see like steps。 to reproduce the user's environment or whatever
    makes sense for the project。 Once your community members have submitted a pull
    request you want to make sure that you。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你想要什么。你可以为特定类型的问题或请求准备多个不同的模板，但请确保包括你希望看到的任何具体信息，比如步骤。以重现用户的环境或其他对项目有意义的内容。一旦你的社区成员提交了拉取请求，你要确保你。
- en: automate the testing and validation process in a way that not only reduces the
    time you。 spend reviewing their contributions but also gives immediate actual
    feedback to the contributor。 themselves。 Continuous integration systems are one
    of the easiest and most common ways to make this。 happen。 If your project is on
    GitHub then GitHub actions is the easy choice and runs for free on public。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试和验证过程，以减少你在审查他们的贡献上花费的时间，同时也能给贡献者自己提供即时的反馈。持续集成系统是实现这一目标的最简单和最常见的方法之一。如果你的项目在GitHub上，那么GitHub
    Actions是一个简单的选择，并且在公共项目上免费运行。
- en: repos。 The biggest benefit here is the ability to configure CI to test your
    project on a variety。 of operating systems and Python runtime versions and get
    direct feedback in a pull request on。 which of those pass so you can easily see
    if it's OS or version dependent or if it's。 a more basic issue。 Again， we'll beat
    the drum for reproducible workflows。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库。最大的好处在于能够配置CI在各种操作系统和Python运行时版本上测试你的项目，并在拉取请求中直接反馈哪些通过，这样你就可以轻松看到是操作系统或版本相关，还是更基本的问题。再次强调，我们倡导可重复的工作流程。
- en: Whatever CI platform or system you choose it should be configured to use the
    same build。 test and validation workflow that you use locally。 This will help
    minimize surprises and make it that much easier for you to review a pull。 request
    and understand the results of the CI。 Simply be aware that GitHub actions as well
    as integrations to other services are available。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪个 CI 平台或系统，都应该配置为使用与你本地相同的构建、测试和验证工作流程。这将有助于减少意外，并使你更容易审核拉取请求，理解 CI 的结果。请注意，GitHub
    Actions 及其他服务的集成也是可用的。
- en: and can also improve the amount of time that it takes you to actually review
    a pull request。 The last piece of the puzzle is releasing your project。 The easier
    it is to prepare and release a new version the faster we can publish our bug。
    fixes and the more boring each individual releases with targeted fixes or improvements。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以提高你实际审核拉取请求所需的时间。拼图的最后一块是发布你的项目。准备和发布新版本越容易，我们就能更快发布错误修复，而每个单独的版本都能更乏味地针对特定的修复或改进。
- en: the more reliable and trustworthy your project will be perceived。 So let's start
    with the most important part of releasing new versions， picking the right。 version
    numbers。 Ultimately， we want version numbers that convey some amount of meaningful
    information。 How big or how important or how dangerous your change is。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 项目被认为越可靠、可信。那么让我们从发布新版本最重要的部分开始，选择正确的版本号。最终，我们希望版本号传达一些有意义的信息，表明你的更改有多大、多重要或多危险。
- en: One of the most well-known schemes is semver， semantic versioning and I'm here
    to say semver。 is impossible。 The major version number is supposed to tell us
    when breaking changes occur but how do。 we define breaking changes。 So change
    to feature breaking as an API change breaking is a bug fix breaking。 On the other
    end of the scale we can simply base our versions on the year and date of。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的方案之一是语义版本（semver），我在这里要说 semver 是不可能的。主要版本号应该告诉我们何时发生重大变化，但我们如何定义重大变化？因此，将功能更改视为
    API 变更是破坏性的，而修复错误也是破坏性的。在另一个尺度上，我们可以简单地基于年份和日期来制定版本。
- en: each release but beware because once you make your major versions based on the
    calendar year。 you just burn more versions than chrome。 Yes， technically you can
    increment a version epic and start over from zero but literally。 nobody wants
    that and you'd be surprised how many tools will break。 So really just pick something
    be consistent with your versioning and communicate your plan， clearly。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每次发布都要小心，因为一旦你根据日历年份制作主要版本，你就会比 Chrome 产生更多版本。是的，从技术上讲，你可以递增版本号并从零开始，但实际上，没人想要那样，而你会惊讶于有多少工具会崩溃。所以真的只需选择某个版本，保持一致，并清晰地沟通你的计划。
- en: But picking a version number is only the first step。 There's a lot more that
    can go into release than you might expect so we want to automate。 as much of that
    process as we can as well。 Like our development processes earlier we want to have
    reproducible workflows。 You shouldn't have to figure out and piece this all together
    every time you get a new。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但选择版本号只是第一步。发布中可以包含的内容远比你想象的要多，因此我们希望尽可能自动化这个过程。就像我们之前的开发流程一样，我们希望拥有可重复的工作流程。每次获取新版本时，你不应该每次都需要搞清楚并拼凑这些。
- en: laptop at the very least document the necessary tools and steps to publish a
    release so that。 future you can just refer to your documentation。 But we can do
    more。 The key to reproducible releases is based on the off of published tag revisions
    in your。 source control。 Those tags should already include any changes to documentation，
    version numbers。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 至少在笔记本电脑上记录发布所需的工具和步骤，以便将来的你可以参考你的文档。但我们可以做得更多。可重复发布的关键是基于源控制中的已发布标签修订。这些标签应该已经包含对文档、版本号的任何更改。
- en: etc。 Now once it gets to getting that tools can help I specifically wrote a
    tool called attribution。 which automates the process of generating a change log。
    As for building your actual release you want artifacts but we're running out of
    time so。 I'm going to power through this。 Wheels are binary wheels they're only
    on specific platforms and versions。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。现在一旦开始获取工具，具体来说我写了一个叫 Attribution 的工具，自动生成变更日志。至于构建实际的发布，你需要构建工件，但我们快没时间了，所以我会快速推进。轮子是二进制轮子，仅适用于特定平台和版本。
- en: Source distributions are where you can actually rebuild on anything。 The last
    key you want your S-DIS because anybody who's on OS or version where you don't
    have。 a wheel can actually build your project but you want the combination because
    it's faster。 for most users。 If you want help in building all of those the CI
    build wheel project can help automate。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 源分发是你可以在任何地方实际重建的地方。你希望你的S-DIS是最后的关键，因为任何在没有轮子的操作系统或版本上的人都可以实际构建你的项目，但你想要组合，因为这对大多数用户来说更快。如果你想在构建所有这些方面获得帮助，CI构建轮项目可以帮助自动化。
- en: a lot of that in your CI steps。 It helps you support that whole matrix of version
    compatibility。 So we made it。 We've reproduced our workflows。 We've improved our
    code quality。 we've fostered our community， we published our distributions。 Well
    now we take time for ourselves。 Don't forget the golden rule。 It's your life，
    your project and ultimately you're the only one who can choose how to spend。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的CI步骤中，这能帮助你支持整个版本兼容性的矩阵。所以我们做到了。我们重现了我们的工作流程。我们提高了代码质量。我们培育了我们的社区，发布了我们的分发版。现在我们留出时间给自己。不要忘记黄金法则。是你的生活，你的项目，最终只有你能选择如何支配时间。
- en: your time。 I appreciate you spending this time here with me。 You can find links
    to all the projects and resources on my GitHub repo。 Thank you so much。 Have a
    good Python。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你的时间。我感谢你花时间和我在这里。你可以在我的GitHub仓库找到所有项目和资源的链接。非常感谢。祝你有个愉快的Python时光。
- en: '![](img/2508ea5a8857e89cfeb32a3e593805bc_4.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2508ea5a8857e89cfeb32a3e593805bc_4.png)'
- en: Thank you。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢你。
- en: '![](img/2508ea5a8857e89cfeb32a3e593805bc_6.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2508ea5a8857e89cfeb32a3e593805bc_6.png)'
