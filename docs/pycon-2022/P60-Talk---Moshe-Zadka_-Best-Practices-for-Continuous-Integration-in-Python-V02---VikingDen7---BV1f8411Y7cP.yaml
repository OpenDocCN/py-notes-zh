- en: P60：Talk - Moshe Zadka_ Best Practices for Continuous Integration in Python
    V02 - VikingDen7 - BV1f8411Y7cP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So I want to cover what are the steps I'm going to go through in this talk。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b9fcf17d06e5a70dccca14da249704e_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: I'll start by diving into what are the functional bits that make up a continuous
    integration。 system because those are the functional bits that we want to apply
    the best practices to。 Then before we talk about how to apply those best practices
    to， we'll talk about why we're。 going to apply the best practices to。 So what
    actually makes one continuous integration set up good and another bad？
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: So what are the criteria we're going to evaluate？ And finally。 after we've all
    agreed about what bits we can control and what are the targets。 we'll actually
    come to what I promised I'm going to talk about and explain how to make。 your
    continuous integration actually good。 So before you even talk about having a continuous
    integration for a project。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: you usually are， going to have some sort of a local way of building your project。
    So。 basically the interpreted language， we don't have a traditional build step，
    we don't need。 to compile anything， you know， usually。 But we do have steps that
    are pretty traditional to run and I kind of think of them as the build。 We usually
    want some kind of linting process。 Pilate， flakeate， sometimes my pie。 Under linting。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: I cover anything that will look at your code but will not run it。 So anything
    that analyzes your code statically。 Obviously。 the other thing that you can do
    is run your code and the other thing you can， do is test your code。 Test is anything
    that runs your code or pieces of your code and looks at the output and sees。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: if the output is okay。 So， we usually do that when we want CI and before we
    have a CI。 you usually want to already， have some way of running your tests locally。
    And we usually have some sort of packaging。 Now， sometimes you'll package it into
    a wheel or an S-dist but this does not have to be the。 case。 Sometimes you'll
    want to package it into a PEX or maybe a Debian package or an RPM package。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: or very commonly a Docker container image。 But these three things。 they're not
    always present but very frequently you'll find that。 most projects will have all
    of these three。 And before we even run CI。 we want to make sure that the project
    knows how to lint itself。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: to test itself and to package itself。 So let's assume we already have a project
    that does that。 Well， we can start doing CI。 And so， I kind of gave the thing
    away， right？ I said， well， you know。 you run it locally， it's not the CI。 So clearly
    CI should be something that you run remotely on a server。 Well when you run it
    locally， the answer to when you run it was either very simple or。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: very complicated。 The simple answer is when you wanted and the complicated answer
    is human psychology is。 really complicated。 I don't know when you wanted to do
    it。 But at the end of the day， you know。 it's at least obvious。 When you wanted
    to do it， you just did it。 When you run it on a server。 the server has to have
    some sort of well-defined algorithm， when do you run that build。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: And that will have to be defined via code， so that has to be very clear。 In
    the old old data。 like let's say circa 2006， having a nightly build was considered。
    this is where the term continuous integration came for。 You continuously， every
    night。 every night you run the build and teams did that were， like sophisticated。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: They have an automated build process that runs every night on a server。 That
    was like the height of sophistication in 2006。 And then it was good， right？
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Because then in the morning you can come in and say， okay， oh， something broke。
    It was one of the things that were done during the day。 You should remember that
    2006 is a long time ago and most teams were very local and like。 there was a specific
    definition of time， right？ Like the time zone of the local team。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: So the night is like whenever the team is asleep。 And so they would come in
    the morning。 see that something broke。 One of the things that happened during
    the day。 it might be difficult to figure out which， of the things during the day。
    So someone said， hmm。 I have an idea。 What if instead of waiting until it's night
    time。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: as soon as they've emerged to the main， branch， we'll run it。 Then if it's broken。
    we'll know that that's probably whatever that merges。 This is like， let's say
    in 2008。 if you had that， you were like in the top 95th percentile， of development
    sophistication。 People were like， oh， that's a team I want to join。 Clearly they
    take their code seriously， right？
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: But we keep updating our standards。 And nowadays， we usually think of what we
    want to run the contingency regression on or。 something I want to think of as
    suggested patch。 Different systems will have different names for that。 In GitHub，
    it will be called the pull request。 In GitHub， it will be called the merger request。
    If you use review board， it's a review request。 But whatever it is。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: it's the thing that you ask your colleagues to review as people will。 also be
    the thing that you're going to run the CI before you merge。 So if it's broken。
    you don't know that fact after you have merged。 And now you have to fix something
    that's broken for everybody。 But you know， ahead of time， this is let's say， you
    know， started kind of being like kind。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: of standard practice， sometime between 2013 to 2015。 And by now。 every reasonable
    system that you use will have that as a built-in feature。 The situation hasn't
    stopped。 Right？ This is already kind of 10 to 7 years ago。 There's like more things
    that can be done now。 People talk about stuff like merge trains。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: something called not-wacket science， which is， a very weird name for something。
    All kinds of stuff。 I'm not going to dive too much into that。 Another thing I'm
    not going to dive too much into that is continuous delivery and deployment。 That's
    not because these things are not important。 But this talk is limited in time。
    If I try to cover everything， it would take way too long。 So in this talk。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: I'm going to focus on these suggested patch builds。 And the reason I'm going
    to focus on these suggested patch builds is that in a typical， project。 your continuous
    integration system， CPU cycle for CPU cycle， will be spending most。 of its time
    in that flow。 Right？ Sure， this will eventually be merged to main。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: and it will run CI on that merge to main。 But usually a patch takes a few iterations。
    So on average。 most of the flows that go through your CI are going to be on that
    suggested， patch build。 Which means that the main thing you're going to want to
    optimize is that flow。 So I'm going to focus the entire talk on just how to optimize
    that specific patch build。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: And to come back to like， why are we doing that， we usually run it as an automated
    gate。 Right？
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: We have a human gate。 Why is the human approval process that will usually mark
    off as approved。 Why is it this code looks good to me？ And the goal of the CI
    is usually to look for regressions。 Right？ It can't really say if the patch is
    like accomplishing its goal in the abstract。 Right？
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: That's not something you can really implement in a computerized manner。 Right？
    What a CI system。 the goal of it in a， one of the suggested patch build is， is
    this making。 any of our things worse than they were before？ And so this is useful
    because this means that like anything that has passed this gate will。 at least
    not make things worse off。 So this is a goal of this suggested system。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: So now we know what it's supposed to do and we know what we're talking about。
    So this is what we're going to focus about。 How do you make your CI system be
    a better automated gate for patch being not regressions？
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: So how does it do that？ Well， your CI system is usually made of a coordinator
    that look at suggested patches。 and decides， okay， that suggested patch has now，
    I should really do like these ones on， it。 And then the CI runners will actually
    go through the flow， run your tests， run your linters。 and send the output。 And
    in most modern frameworks， again， regardless of which ones you use。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: that output will be， consumable via two ways and both of these are important
    and it's going to be really relevant。 in the， you know， press of the talk。 One
    is that they're going to be collected live from the runners。 So as the build is
    running， you can see the output， which means if there's a test failure。 you can
    see it immediately， but it's not just live， it's also documented。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: It's also retained forever。 Now forever is obviously like somewhat of a nebulous
    concept exactly when it's backed。 up， what's going to be paid。 But it's usually
    considered in most systems a reasonably long term place。 right？ You can have a
    permalink in it that you can link in a discussion and say this build shows。 you
    that this test did something， right？ So this is kind of an important thing to
    kind of remember about the build logs in the continuous。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: integration system。 So now that we understand what the continuous integration
    system is made of and what it's。 supposed to do， let's figure out what we can
    do to， what kind of continuous integration。 systems are better than others， right？
    What do we make it good， right？
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Even if we don't know how to make it good， what we make people say this is a
    good system。 you have improved the situation。 Well， there's a few different pretty
    orthogonal criteria that you can apply。 So one criterion that you can apply is
    accuracy， right？
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: We said that its goal is to say does the patch introduce a regression？
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: So accuracy means that the answer is correct。 If it says that the patch introduces
    a regression。 it introduces a regression and if it says that， the patch does not
    introduce a regression。 the patch does not introduce a regression。 Any time that
    it gives the wrong answer。 that's an accurate answer， that's an incorrect answer。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Clearly the perfect continuous integration system is 100% accurate。 A system
    that is more accurate is better than a system that is less accurate。 So this is
    a criteria。 right？ This is something that is good to have。 But another orthogonal
    criterion is actionability。 Again， CPU cycle for CPU cycle most of the time when
    you run a CI system， it will say。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: that most of the patches are bad。 That's reasonable， right？ Otherwise。 why would
    you have a CI system？ If most of the time it would approve。 then you should probably
    run it less， right？ It's probably doing a lot of redundant work。 So in general，
    a lot of times patches are bad。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b9fcf17d06e5a70dccca14da249704e_3.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: That's okay， right？ This is why we have this automated system to give us feedback。
    But this means that when the patch is not good， it's really useful if that system
    gave。 you good information about how to fix it。 Now， the optimum here is something
    like black。 which actually generates a diff for you。 But that's probably unattainable。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: So what kind of an attainable criterion we can have here？ Well。 the best of
    all system tells you exactly how to reproduce it locally。 Once you can reproduce
    it locally， the CI system is not in the picture anymore。 Right now。 how actionable
    it is is kind of up to your local development environment。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: You can use local debuggers， you can put in print statements。 Whatever used
    to debug your local code is up to you， right？
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: That's already like a language stack issue or a development stack issue， not
    a CI issue。 So best of all， if a CI system tells you how to reproduce it locally，
    if for some reason。 it's very hard to reproduce locally， it should probably give
    you a lot of useful information。 Another， again， orthogonal criterion is how long
    does it take towards answer， promptness， right？
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you had a system that is perfectly accurate and perfectly actionable，
    meaning。 that it always gives you the correct answer。 And when the answer tells
    you like this is a bad patch。 like you can either reproduce， it locally， but it
    takes the whole day to run。 That's not a good system， right？ Even though it's
    perfect on the first two criteria， right。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: that's not a good system because you， wouldn't be able to develop effectively
    with it。 So promptness is an orthogonal criterion here。 And the final criterion
    I'm going to talk about is costs。 Right？ Again， imagine that you had a system
    that is perfect on all the other three， but costs。 a lot of money。 Well， we live
    in a capitalist society， right？ We have to pay money for these things。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Basically， the most money you spend in kind of a modern， kind of flexible， cloudish
    environment。 is the one-on-the-compute cost。 If you're spending more money than
    your product brings in。 then this becomes an affordable， system， right？ And that's
    kind of like the limit case。 Clearly。 in an ideal case， you want to minimize the
    cost because this is your profit margin。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: on whatever product DCI system supports。 So now that we know what our goals
    are， finally。 we can talk about how to actually， improve them。 So well， you can
    improve the accuracy。 You can improve the actionability。 You can improve the promptness。
    And you can improve the cost。 So one of the biggest things you can do to improve
    the accuracy is to use containers。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: And the reason is because remember that we said that CI， the goal here in the
    gate function。 is to tell you the regression。 Now if you update to a new Python
    version， right。 even if it exposes a hidden problem， with your code， right。 even
    if it's a new Python build that uses wider characters and。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: it exposes like some problematic stuff with your code， it's not a regression
    in your patch。 That patch should not be not allowed to come in。 So you want to
    use container image that has a specific version of Python and a specific。 build
    of Python。 And any other non-Python dependencies。 And then you want to pin the
    image tag。 right？ If you do all of that and then pin to latest， you've undone
    all the work， the hard work。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: you've done。 Because as soon as a new image is released， you've upgraded to
    the new image。 And again， you might fail perfectly valid patches。 Now a typical
    Python program has dependencies。 Even pretty small things can have like 10， in
    like their recursively closed dependencies。 Medium ones can have 100s。 I've seen
    definitely ones with like thousands。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: If any of those versions update and that somehow causes a problem， again， it
    doesn't。 matter if the problem is in the library or in your code。 This is not
    a problem with a patch。 You should test against the pin dependencies because otherwise
    you will be giving the wrong， answer。 You will be saying that the patch is wrong
    but the patch is absolutely fine。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些版本中的任何一个更新，并且因此导致问题，问题不论是在库中还是在你的代码中，都无关紧要。这不是补丁的问题。你应该针对固定的依赖项进行测试，否则你会得出错误的结论。你可能会说补丁是错误的，但实际上补丁是完全正确的。
- en: So you should always test in your CI flow with patch versions against pin dependencies。
    Now you don't want to upgrade the pins and you want to upgrade them in a dedicated
    patch。 And if that patch fails， the CI system has done its job。 That patch will
    not be allowed to merge。 That patch does indeed introduce a regression and until
    you fix it， you should not merge， it。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你应该始终在 CI 流程中使用固定依赖项的补丁版本进行测试。现在你不想升级这些固定依赖项，而是希望在专门的补丁中进行升级。如果该补丁失败，CI 系统就完成了它的工作。该补丁将不被允许合并。确实，该补丁引入了回归，直到你修复它为止，你都不应该合并。
- en: You should probably fix that at some point but you should follow the usual flow
    about how。 to fix problematic patches。 There are services that will help you。
    The only thing that will help you is to produce your PRs。 That's not nothing but
    you are still responsible for looking at the failures deciding when to。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在某个时刻需要修复这个问题，但你应该遵循关于如何修复问题补丁的通常流程。有些服务会帮助你。唯一能帮助你的是生成你的 PR。这并非毫无意义，但你仍然负责查看故障，决定何时进行调整。
- en: merge and so on。 So whether you use a service or not， you should still go with
    this flow。 Test quality matters a lot for the CI accuracy。 If you have bad tests。
    they're going to reduce your CI quality。 But test quality is its own not half
    hour talk but at least 10 hour tutorial。 From the CI perspective， what you want
    to do is make sure that you monitor and improve。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 合并等等。因此，无论你是否使用服务，你仍然应该遵循这个流程。测试质量对 CI 的准确性非常重要。如果你的测试很糟糕，它们将降低你的 CI 质量。但测试质量本身不是半小时的讨论，而至少是一个
    10 小时的教程。从 CI 的角度来看，你要做的是确保你监控并改进。
- en: the test quality。 The CI is in a unique position to look at the test and see
    the historical data and see。 which tests are good and which aren't。 You want to
    make sure that you do that。 Again。 I'm not going to cover exactly how to optimize
    that。 For improving actionability。 the biggest thing you can do is set the verbosity
    to the highest， level it will go。 Any test runner。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 测试质量。CI 在查看测试时处于独特的位置，可以查看历史数据，了解哪些测试是好的，哪些不是。你想确保做到这一点。再次强调，我不会详细讲解如何优化这一点。为了提高可操作性，最大的事情是将详细程度设置为最高水平。任何测试运行程序。
- en: linked runner that has verbosity options， set them to the maximum it can go。
    Because you can filter out stuff but you cannot filter in stuff。 Which means if
    you had a failure。 especially if it's hard to reproduce failure， you really， want
    to know what was the problem。 So the higher the verbosity， the better。 You can
    filter the logs if you really need to。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 链接的运行程序具有详细程度选项，请将其设置为最大值。因为你可以过滤掉某些内容，但无法过滤进来。这意味着如果出现故障，尤其是如果故障难以重现，你真的想知道问题出在哪里。因此，详细程度越高越好。如果真的需要，你可以过滤日志。
- en: A lot of the time failures will be in tests。 Now frameworks like PyTests or
    Hamcrest will help you to make sure that the assertions。 are more verbose。 But
    they are there to help you。 They are not there to do your job for you。 You can
    still use PyTests assertions or Hamcrest assertions and not get verbose test outputs。
    if you use them badly。 Make sure you cause your test to fail locally。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，故障会出现在测试中。现在像 PyTests 或 Hamcrest 这样的框架会帮助你确保断言更具详细性。但它们是来帮助你的，并不是替你完成工作。如果你使用不当，你仍然可以使用
    PyTests 断言或 Hamcrest 断言，而不会得到详细的测试输出。确保你的测试在本地失败。
- en: Like the assertion failure actually has enough verbosity if not to fix that。
    That is extremely useful。 That is time well spent when you write a test。 One thing
    that PyTests or any of these frameworks will not help you with is when tests fail
    not。 because of an assertion failure but because of an exception。 Which means
    make sure in your code。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，断言失败实际上具有足够的详细性，如果不能修复那就极为有用。当你编写测试时，这样的时间花得非常值得。PyTests 或任何这些框架无法帮助你的是，当测试失败并不是因为断言失败，而是因为异常。这意味着确保在你的代码中处理好这些情况。
- en: When you raise an exception add a lot of details。 Because those details those
    frameworks will show you。 But if you don't put those details in they will not
    be able to show you those details。 So this is really important。 And we talked
    about how a lot of actionability comes to local reproducibility。 Spue as many
    details of the environment to the logs。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你抛出异常时，添加大量细节。因为这些细节那些框架会展示给你。但是如果你没有放入这些细节，他们将无法显示这些细节。因此，这非常重要。我们讨论了如何许多可操作性归结于本地可复现性。尽可能多地将环境的细节输出到日志中。
- en: You can do it in the beginning of the test one so they will scroll off the live
    one and。 won't bother anyone。 But when you have a failure and whoever is trying
    to reproduce it locally is having problems。 they will scroll to the beginning
    and read carefully about what is different between their。 environment and the
    CI environment and you don't know which line is going to save them。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在测试开始时进行处理，这样它们就会滚动到实时日志中，不会打扰任何人。但当你发生故障，而试图在本地重现的人员遇到问题时，他们会滚动到开头，仔细阅读他们的环境和CI环境之间的不同之处，而你不知道哪一行会拯救他们。
- en: So of course environment variables are really crucial because you don't know
    which environment。 variable is going to make some library deep deep deep in your
    code behave slightly differently。 Any details about the platform version of libc
    version of operating system and so on。 And anything else you can think of just
    spew your heart out。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，环境变量是非常重要的，因为你不知道哪个环境变量会让某个库在你的代码中表现得稍有不同。任何关于libc版本、操作系统版本等的细节，以及你能想到的其他任何事情，都可以尽情表达。
- en: As a corollary you're spewing all these environment variables。 If you put secrets
    in them you're going to have a bad time with your secret licking。 The solution
    is not to do all kinds of fancy masking。 The solution is don't put your secret
    in environment variables。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个推论，你泄漏了所有这些环境变量。如果你把秘密放在其中，处理秘密的时间会很糟糕。解决方案不是做各种花哨的掩盖，而是不要把你的秘密放在环境变量中。
- en: The better place to put your secrets every reasonable CI system will give you
    better place。 to put those secrets in。 Environment variables are really scary
    because there are other things that will spew environment。 variables so you're
    not actually helping yourself。 You're just delaying the inevitable secret。 One
    way to improve partners is to cache aggressively。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个合理的CI系统都会给你提供更好的地方来存放秘密。环境变量真的很可怕，因为还有其他东西会泄漏环境变量，所以你实际上并没有帮助自己。你只是在延迟不可避免的秘密。改善合作伙伴的一种方式是积极缓存。
- en: A lot of CI systems will have primitives to cache all kinds of downloads in
    a local file。 systems that will help you figure those out and start using those。
    If you build containers it's kind of annoying to set container layer caching against
    the， registry。 But if you go through that flow it's going to save you a lot of
    time because unlike when。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 很多CI系统会有原语来缓存各种下载到本地文件系统，这将帮助你找出并开始使用它们。如果你构建容器，将容器层缓存设置为注册表是有点麻烦的。但是如果你经过这个流程，将节省很多时间，因为这与当。
- en: you build it locally those CI runners are often very similar so they will not
    have those layers。 cached in。 But very commonly people order their container build
    files to have the least changing and。 most time consuming layers at top。 So if
    you do go through this flow you can improve your container build speed a lot。
    And have local PyPI container caching proxies that are network wise close to the
    CI system。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在本地构建时，这些CI运行器通常非常相似，因此它们不会缓存这些层。但人们通常会将他们的容器构建文件排序，以使最少变化和最耗时的层在顶部。因此，如果你经过这个流程，可以大大提高你的容器构建速度，并拥有与CI系统网络接近的本地PyPI容器缓存代理。
- en: Another thing you can improve on this is pooling。 Aggressively we use connections，
    downloads， etc。 Think carefully about how to break up tests that actually improve
    things。 You can fail fast。 If you use all kinds of libraries to order tests based
    on likelihood to fails， a couple。 of open solutions I will mention them in my
    talk notes。 You can also parallelize ones aggressively。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以改进的另一个方面是池化。积极使用连接、下载等。仔细考虑如何拆分测试以真正改善情况。你可以快速失败。如果你使用各种库根据失败的可能性排序测试，我会在我的演讲笔记中提到几种开放解决方案。你还可以积极并行化测试。
- en: You can use CI primitives for that or you can use tester primitives for that。
    Again。 some configuration may be needed。 It's often worthwhile。 You can mock out
    those things especially like databases。 You can get something that smokes out
    the database and doesn't run to a file system。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为此使用CI原语，也可以使用测试者原语。再说一次，可能需要一些配置。这通常是值得的。你可以模拟那些东西，尤其是数据库。你可以得到一些模拟数据库而不连接到文件系统。
- en: You can mock out a file system by mounting something like Tempeface which won't
    write， to disk。 All kinds of tricks like that。 You can also kill useless ones
    to improve the cost。 If a committee is added to a patch nobody is going to care
    about any ones that are in。 the previous patch。 It's annoying to find those ones
    and kill them but that can improve your cost a lot。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过挂载像Tempeface这样的文件系统来模拟文件系统，它不会写入磁盘。各种这样的技巧。你还可以杀死无用的部分以降低成本。如果一个补丁添加了一个委员会，没人会关心之前补丁中的任何内容。找到这些并杀死它们很烦人，但这可以大大改善你的成本。
- en: You can stop runs early。 That's a bit of a trade-off because sometimes you don't
    get all the failures and you'll。 get to a flow where people do more patches。 You
    should monitor that and see if it actually improves things。 Even if you do better
    stabbing and mocking that will take less resources from the environment。 But you'll
    notice that a lot of these things come with trade-offs。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以提前停止运行。这有点折衷，因为有时你不会得到所有的失败，你会进入一个人们做更多补丁的流程。你应该监控这一点，看看它是否真的改善了事情。即使你做得更好，模拟也会减少环境的资源消耗。但你会注意到，很多事情都是有折衷的。
- en: You can have better accuracy by writing more tests or making sure that they're
    really good。 You can focus a lot of actionability but you might lose on promptness。
    You can focus a lot on promptness but you might lose out on cost。 You can focus
    on all of them but you're going to put it out of effort。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写更多的测试或确保它们真的很优秀，你可以提高准确性。你可以非常注重可操作性，但可能会失去及时性。你可以非常关注及时性，但可能会在成本上失去。你可以关注所有这些，但你会付出更多的努力。
- en: You have to make a decision what you value。 If you don't make a decision you're
    still making a decision by your actions but it's。 going to be re-litigated every
    spring。 You're much better off actually deciding what are your values。 Once you
    have your values in hand， once you know what you care about you can measure。 what
    you have and now that you know what you value you can see whether your measurement。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须决定你重视什么。如果你不做决定，你的行为仍然在做决定，但这会在每个春天被重新审议。你最好真正决定你的价值观。一旦你掌握了自己的价值观，一旦你知道你在乎什么，你就可以衡量你所拥有的，现在你知道了你的价值观，你就可以看到你的衡量标准。
- en: aligns with your values。 And if they don't， now you know what to improve。 The
    thing that least aligns with your values is exactly how much effort to put in。
    So putting that amount of effort and deleting it by how much you want it。 But
    you also want to repeat this process。 You want to keep thinking about whether
    your values should change and you want to see whether。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与你的价值观保持一致。如果不一致，那么你现在知道该改善什么。与你的价值观最不一致的事情正是你要投入的努力。因此，要根据你想要的程度来投入这样的努力。但你也想重复这个过程。你想持续思考你的价值观是否应该改变，并想看看是否。
- en: the situation changes。 Both of these things are likely to change。 That's okay。
    This is talk about best practices。 The only way to do that is to practice them。
    So I hope that you'll apply it to your favorite CIFlow。 I love talking about this。
    I just stood out here and talked to you about this for 30 minutes。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 情况在变化。这两件事情都可能发生变化。没关系。这是讨论最佳实践。做到这一点的唯一方法就是实践它们。因此，我希望你能将其应用到你喜欢的CIFlow中。我喜欢谈论这个。我刚在这里站了30分钟跟你们谈论这个。
- en: If you want to continue the conversation， again my website is COVIDism。com，
    email LinkedIn。 and like 2，000 other ways of reaching out to me out there。 And
    we also have an open space to borrow it at 11am。 Check the board for what room
    it is。 And I would love to talk to you all about more about that。 Thank you all。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想继续对话，我的网站是COVIDism.com，电子邮件、LinkedIn，还有其他2000种联系方式。我们还有一个开放空间，11点借用。查看公告板，看看是什么房间。我很想和大家聊更多关于这个的事情。谢谢大家。
- en: And I hope this was a good talk and I hope you enjoy the rest of your conference。
    [APPLAUSE]。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这次谈话很精彩，也希望你享受会议的其余时间。[掌声]
