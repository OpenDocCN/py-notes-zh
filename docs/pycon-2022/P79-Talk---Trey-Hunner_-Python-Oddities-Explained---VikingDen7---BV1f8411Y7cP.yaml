- en: P79：Talk - Trey Hunner_ Python Oddities Explained - VikingDen7 - BV1f8411Y7cP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P79：演讲 - Trey Hunner_ Python 奇异性解释 - VikingDen7 - BV1f8411Y7cP
- en: All right， so is everyone awake？
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，大家都醒着吗？
- en: '![](img/9addb404724cae11b257bae92a9e8761_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9addb404724cae11b257bae92a9e8761_1.png)'
- en: '![](img/9addb404724cae11b257bae92a9e8761_2.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9addb404724cae11b257bae92a9e8761_2.png)'
- en: Sort of。 Okay。 So my name is Trey and I help folks level up their Python skills
    through onsite and remote。 team training， mostly remote the last couple of years
    for obvious reasons。 And with Python morsels which helps experience programmers
    develop a habit of deepening your。 Python skills every single week through hands-on
    learning because you don't learn by putting。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有点。好的，我的名字是 Trey，我帮助人们通过现场和远程团队培训提升他们的 Python 技能，主要是过去几年由于明显的原因进行远程培训。还有 Python
    morsels，这帮助有经验的程序员每周通过实践学习来培养深化 Python 技能的习惯，因为你不是通过回忆头脑中的信息来学习。
- en: information into your head by trying to retrieve information from your head
    that you actually。 learn。 So when I do team trainings， I often see some very weird
    code because my students are playing。 with Python which is lovely because playing
    is a wonderful way to learn。 Sometimes though when I'm trying to explain something
    that Python is doing， I realize that。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过从脑海中提取信息来将信息输入到脑海中，而实际上是通过这种方式学习。因此，当我进行团队培训时，我常常看到一些非常奇怪的代码，因为我的学生们在玩 Python，这非常好，因为玩是学习的美妙方式。然而，有时候当我试图解释
    Python 在做的事情时，我意识到。
- en: I don't really know what Python is doing or at least I don't understand why
    it's doing。 what it's doing。 So this talk was inspired by all of the individuals
    who asked me weird and confusing questions。 while I was holding a Python workshop
    at your company。 So thank you for your confusion。 This is a Python 3 only talk。
    If this was a Python 2 oddities talk。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不真的知道 Python 在做什么，或者至少我不明白它为什么要做它正在做的事情。所以这次演讲的灵感来自于在你们公司举办 Python 工作坊时，所有问我奇怪和令人困惑问题的人们。所以谢谢你们的困惑。这是一次仅针对
    Python 3 的演讲。如果这是一次关于 Python 2 奇异性的演讲。
- en: it would be much longer and much funnier。 Feel free to ask me questions about
    Python 2 oddities later if you're strangely interested。 Alright let's get started。
    So first I would like to talk about variables。 Let's say we have a variable x
    that is equal to zero and let's say we have a variable numbers。 and that variable
    points to a list of numbers。 If we loop over this list of numbers and assign y
    to the square of each of these numbers。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是的话，会更长更有趣。如果你奇怪地感兴趣，可以随时问我关于 Python 2 奇异性的问题。好的，我们开始吧。首先，我想谈谈变量。假设我们有一个变量
    x 等于零，还有一个变量 numbers。这个变量指向一个数字列表。如果我们遍历这个数字列表，并将 y 赋值为这些数字的平方。
- en: what do you think y will be after this loop？ What's your guess？ Who thinks it
    will be zero？
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为在这个循环后 y 会是什么？你的猜测是什么？谁认为它会是零？
- en: Who thinks it will be eight？ Who thinks it will be 64？ Who thinks it's an error？
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 谁认为结果会是八？谁认为结果会是六十四？谁认为这是一个错误？
- en: We can't see what y is。 So it turns out we can see what y is。 It's 64。 And if
    we access x。 who thinks it's zero？ X is still zero。 Who thinks it's eight？ Who
    thinks it's something else？
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法看到 y 的值。所以结果是我们可以看到 y 的值。它是六十四。如果我们访问 x，谁认为它是零？x 仍然是零。谁认为它是八？谁认为它是其他的东西？
- en: No it's not something else。 I'm not sure what you were thinking it was though。
    It's eight。 And it's eight because inside of a loop variables leak their scope。
    Loops don't have their own separate scope。 So this 4x in numbers。 this is actually
    an assignment that happens during each iteration， of our loop。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这不是其他的东西。我不确定你在想什么。但它是八。它是八，因为在循环中，变量泄漏了它们的作用域。循环没有自己单独的作用域。所以这个 4x 在 numbers
    中，实际上是在我们循环的每次迭代中发生的赋值。
- en: It works the same way that an assignment statement happens with an equal sign。
    The part between the four and the in that x there is the same thing as the left
    hand。 side of an equal sign。 So if we take those same x and the same numbers variables
    and we make a list comprehension。 representing the squares of these numbers and
    we use that x as our looping variable， what。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式与赋值语句使用等号的方式相同。四和那个 x 之间的部分与等号左边的部分是一样的。所以如果我们取这些相同的 x 和相同的数字变量，并且我们制作一个列表推导，表示这些数字的平方，并且我们将
    x 用作我们的循环变量，那么会怎么样。
- en: do you think x will be after we've executed this code？ Who thinks it's zero
    this time？
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为在我们执行这段代码后 x 会是什么？谁认为这次是零？
- en: Wasn't zero before。 Who thinks it's eight this time？ Still eight。 So it was
    eight in Python 2 but it's zero in Python 3 which is kind of nice。 List comprehension
    has their own scope。 That's the last time I'm going to mention Python 2。 It's
    just Python 3 from here on out。 So let's say we have a global variable numbers
    and we want to add more numbers to that by。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 之前是零。这次谁觉得是八？还是八。所以在Python 2中是八，但在Python 3中是零，这其实挺好的。列表推导有自己的作用域。这是我最后一次提到Python
    2。从现在开始只讨论Python 3。假设我们有一个全局变量numbers，我们想通过它添加更多的数字。
- en: using the plus equals operator。 What do you think will happen if we call add
    numbers this function here with the list。 4， 5， 6。 Now it could modify numbers。
    It could just give us an error。 It could make a local variable number。 So who
    thinks it's going to give us an error？
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用加等于操作符。如果我们用列表4，5，6来调用add numbers这个函数，你认为会发生什么？现在它可能会修改numbers。也可能只是给我们一个错误。也可能会创建一个局部变量number。谁认为它会给我们一个错误？
- en: Who thinks it's going to make a local variable numbers？ It won't modify the
    global。 Who thinks it's going to modify that global variable numbers？ So very
    mixed here。 Most of you seem a little bit confused about what it's going to do。
    As you should be。 this is a strange thing to do。 It turns out it gives us an error。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 谁认为它会创建一个局部变量numbers？它不会修改全局变量。谁认为它会修改那个全局变量numbers？这里的意见很分歧。你们大多数人似乎对它的效果有点困惑。你们应该困惑。这是个奇怪的事情。结果是它给我们一个错误。
- en: It gives us an error because this plus equals operator both reads from and assigns
    to the。 variable that's on the left hand side。 So we're trying to read from a
    global variable and assign to a global variable and Python。 doesn't like that
    but it's not because of the plus equals， not in particular。 If instead we used
    an equals with a plus we would still get an error。 When we defined this function。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它给我们一个错误，因为这个加等于操作符同时读取和赋值给左侧的变量。所以我们试图从全局变量读取并赋值给全局变量，Python对此不喜欢，但这并不是因为加等于，尤其不是。如果我们用一个等号加一个加号，我们仍然会得到错误。当我们定义这个函数时，
- en: Python actually parsed all of the assignment operations and。 claimed all of
    those variable names as local variables。 Since numbers is a local variable。 we
    can't read from it before we've written into it。 That doesn't make sense。 So let's
    look at one more example of the same thing。 If you don't believe me yet。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python实际上解析了所有的赋值操作，并将所有这些变量名称声明为局部变量。由于numbers是一个局部变量，我们不能在写入之前读取它。这没道理。所以让我们再看一个类似的例子。如果你还不相信我。
- en: hopefully you'll believe me after this next one。 If we make a similar function
    that prints the global variable numbers and then assigns。 to it right afterward，
    calling that function gives us an error。 Variable names in Python cannot be both
    local and global in the same scope。 So we're allowed to read a global variable
    and we're allowed to write to a local variable。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在接下来的例子中你能相信我。如果我们做一个类似的函数来打印全局变量numbers，然后紧接着为它赋值，调用那个函数会给我们一个错误。Python中的变量名称在同一作用域内不能既是局部又是全局。因此我们可以读取全局变量，也可以写入局部变量。
- en: but not with the same name。 Python doesn't allow that because that would probably
    be a bug in our code。 This really doesn't make sense to do。 We're allowed to read
    from global variables without writing to them but once you assign。 to a variable
    that variable magically becomes local。 So if we swap these two lines of code。
    our function will not give us an error。 This function actually does what's expected
    but our global numbers variable hasn't changed。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但不能使用相同的名称。Python不允许这样，因为那可能会导致我们代码中的错误。这样做真的没有意义。我们可以读取全局变量，但不能写入。一旦你对变量进行赋值，它就神奇地变成了局部变量。所以如果我们交换这两行代码，我们的函数就不会给我们错误。这个函数实际上做了预期的事情，但我们的全局变量numbers没有改变。
- en: because we're assigning to a local variable here and then we're reading from
    that local， variable。 So the global numbers variable and the local numbers variable
    both have the same name but。 they're different variables pointing to different
    objects。 Assignments in Python only change the local scope。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在这里为一个局部变量赋值，然后读取那个局部变量。所以全局变量numbers和局部变量numbers同名，但它们是指向不同对象的不同变量。Python中的赋值只会改变局部作用域。
- en: You can't change the global scope with an assignment。 Actually you can。 there's
    an escape hatch to do so I'm not going to mention it though。 because you shouldn't
    change the global scope with Python。 You could only change the local scope with
    Python。 All variable assignments are local。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法通过赋值来改变全局作用域。实际上你可以，但我不会提及逃生通道，因为你不应该用 Python 改变全局作用域。你只能用 Python 改变局部作用域。所有变量赋值都是局部的。
- en: So this will always assign to a local variable here inside of a function。 Now
    what if instead of doing an assignment in this add numbers function we use the
    extend。 method on this list。 How is this any different？ So when we call this function。
    Python might print out 123456 or it could give us an error， or it could do something
    else。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这将在函数内部始终赋值给局部变量。现在如果我们在这个添加数字的函数中使用extend方法而不是进行赋值，这有什么不同？当我们调用这个函数时，Python
    可能打印出123456，或者可能给我们一个错误，或者做其他事情。
- en: So who thinks this will give us an error？ Who thinks this will print out 123456？
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那么谁认为这会产生错误？谁认为这会打印出123456？
- en: Who thinks it's also going to change the global variable numbers？ All right。
    so a lot of you got this one right。 You're right。 This prints out 123456 and it
    changes numbers。 Now what's going on here？ The reason this works and a lot of
    you had some intuition about this is that the word。 change is tricky in Python。
    It's an ambiguous term。 What are you changing？
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 谁认为这也会改变全局变量numbers？好吧，很多人猜对了。你们是对的。这打印出123456，并且改变了numbers。那么这里发生了什么？之所以这样有效，很多人对此有直觉，是因为在
    Python 中“改变”这个词很棘手，是一个模糊的术语。你在改变什么？
- en: You can change a variable or you can change an object。 So assignment statements
    change a variable that is which object a variable is pointing， to。 That's what
    we talk about when we talk about scope。 That's what we've been talking about。
    This isn't an assignment though。 This is changing an object。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以改变变量或改变对象。赋值语句改变的是一个变量，即变量指向的对象。这就是我们谈论作用域时所讲的内容。这不是赋值，而是改变对象。
- en: We're not changing which object a variable is pointing to with an assignment。
    We're doing a mutation which changes the object itself。 So we can't assign to
    a global variable but we can mutate any object that we can get our。 hands on as
    long as it's a mutable object。 So you're allowed to read from global variables
    in Python but you can only write to local variables。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不是通过赋值来改变变量指向的对象，而是在进行一种改变，即改变对象本身。所以我们不能赋值给全局变量，但可以对任何可变对象进行变更。你可以在 Python
    中读取全局变量，但只能写入局部变量。
- en: every assignment statement assigns to a local variable。 There are some escape
    hatches in Python to get around that limitation but you shouldn't， use them。 List
    comprehensions have their own scope but for loops do not because Python is function。
    level scoped。 It's function scoped not block scoped。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个赋值语句都是赋值给局部变量。Python中有一些逃生通道可以绕过这个限制，但你不应该使用它们。列表推导有自己的作用域，但for循环没有，因为 Python
    是基于函数的作用域。它是基于函数的，而不是基于块的。
- en: We don't really have blocks in Python and Python scope rules are entirely about
    assignments。 not about mutations。 Speaking of which， that's our next topic， mutability
    and mutations。 Number two is about changing variables which object those variables
    point to。 Mutability is about changing objects。 So let's say we have a list of
    numbers and we assign numbers to numbers。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Python 中并没有真正的块，Python 的作用域规则完全关于赋值，而不是关于变更。说到这，我们的下一个主题是可变性和变更。第二点是关于改变变量所指向的对象。可变性是关于改变对象。
- en: If we append to numbers to how many elements will numbers to contain？ So who
    thinks three？
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向数字追加元素，数字会包含多少个元素？那么谁认为是三个？
- en: Who thinks four elements？ I think something else。 There's a couple something
    else。 There's always a couple something else。 I'm curious what those would be。
    It's four elements。 There's numbers。 What is numbers at this point？ We append
    it to numbers two。 Who thinks it's three still at this point？ Who thinks it's
    four at this point？ You're right。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 谁认为是四个元素？我认为是其他几个。总有其他几个。我很好奇那些会是什么。是四个元素。numbers现在是什么？我们向numbers两个追加了元素。谁在这个时候仍然认为是三个？谁在这个时候认为是四个？你们是对的。
- en: It is four and it's four because these two variables are referencing the same
    object。 So we have two variable names that are referencing the same object。 These
    are not two different objects。 Mutating one of these lists mutates the other because
    they're the exact same list。 Using objects and changing variables are distinct
    things。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是四，因为这两个变量引用了同一个对象。因此，我们有两个变量名引用同一个对象。这并不是两个不同的对象。改变其中一个列表会改变另一个，因为它们是完全相同的列表。使用对象和改变变量是不同的事情。
- en: Assignment statements change which object a variable is pointing to。 But mutations
    change the object itself。 And that will change or seem to change any number of
    variables that might be pointing to。 that object。 So can we make a tuple with
    a list inside it in Python？ It's a weird thing to do。 Is it possible？ Who thinks
    you can do this？ Python will allow it even though it's weird。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值语句改变了变量所指向的对象。但突变改变了对象本身。这将改变或看似改变任何可能指向该对象的变量。那么，我们可以在 Python 中创建一个包含列表的元组吗？这是一件奇怪的事情。可能吗？谁认为你可以做到这一点？尽管这很奇怪，Python
    会允许它。
- en: Who thinks this is an error because it doesn't really make sense？ So Python
    does allow this。 We can do it。 What if we call the append method on the first
    item in this list？ Well。 Python will allow this。 Who thinks it will allow it？
    Who thinks this is not possible？
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 谁认为这是一个错误，因为这实际上没有意义？所以 Python 确实允许这样。我们可以做到。如果我们对这个列表中的第一个项目调用 append 方法呢？好吧，Python
    会允许这个。谁认为它会允许？谁认为这是不可能的？
- en: Shouldn't be possible。 So Python allows this。 It does allow us to append to
    this list。 It doesn't give us an error at least。 The first item in this list has
    now changed。 Now tuples are immutable， meaning we can't change them。 It seems
    like we've changed this tuple though。 But we haven't。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不应该是可能的。因此，Python 允许这种情况。它确实允许我们将内容附加到这个列表上。至少它不会给我们错误。现在这个列表中的第一个项目已被改变。元组是不可变的，意味着我们不能改变它们。尽管我们似乎改变了这个元组，但我们并没有。
- en: We haven't actually changed the tuple， not technically， not from the tuples
    perspective， at least。 If we take the first thing in this list and we assign a
    variable to it and then we append。 to that variable， we've changed the list that
    that variable is pointing to but we've。 also changed every other reference to
    that variable because we changed an object。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们并没有真正改变元组，至少从元组的角度来看。如果我们取出这个列表中的第一个元素，并为其赋值一个变量，然后附加到这个变量上，我们改变了那个变量所指向的列表，但我们也改变了对那个变量的其他引用，因为我们改变了一个对象。
- en: And not a variable。 Variables don't store objects。 They're not like this bottle
    here that stores liquid。 They don't contain a thing。 They refer to something。
    They point to something。 So variables are more like pointers or references。 They
    don't actually contain objects。 Now what would happen if we make a new list and
    then we try to append the list to itself？
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是一个变量。变量并不存储对象。它们不像这个瓶子，存储液体。它们并不包含某样东西。它们指向某样东西。因此，变量更像是指针或引用。它们并不真正包含对象。那么，如果我们创建一个新列表，然后试图将列表附加到自身，会发生什么呢？
- en: Who thinks this is possible to do in Python？ You think some weird things are
    possible in Python。 I like you people。 This works。 You can append the list to
    itself。 Now this makes an infinitely recursive data structure with Python represents
    a bit strangely。 at the REPL。 It does this to not break our machine。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 谁认为在 Python 中这样做是可能的？你们认为一些奇怪的事情在 Python 中是可能的。我喜欢你们。这是可以的。你可以将列表附加到自身。这会创建一个无限递归的数据结构，Python
    在 REPL 中的表现有点奇怪。这样做是为了不破坏我们的机器。
- en: Otherwise it would be an infinite amount of square brackets。 So Python represents
    this strangely but it is possible to do。 And this really demonstrates that analogy
    of a variable being a bucket that contains an。 object doesn't make sense because
    a bucket can't contain itself。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 否则它将变成无限数量的方括号。因此，Python 的表现很奇怪，但这是可能的。这真的展示了变量作为一个包含对象的桶的类比没有意义，因为一个桶不能包含它自己。
- en: A bucket can have a piece of paper in it though that refers back to itself。
    So lists are not buckets which contain objects。 Instead they're look up tables
    that reference the memory locations of an object。 Data structures， lists， dictionaries，
    tuples， anything else that might contain something。 They don't actually contain
    objects。 They contain references to objects。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个桶里可以有一张纸，指向它自己。因此，列表并不是包含对象的桶。相反，它们是查找表，引用对象的内存位置。数据结构、列表、字典、元组，以及其他可能包含内容的东西。它们并不真正包含对象，而是包含对对象的引用。
- en: Variables also don't contain objects。 They just refer to or point to objects
    which means that change is an ambiguous term in Python。 We can change which object
    a variable is pointing to with an assignment statement or we can。 mutate an object
    which actually changes the object itself regardless of what variables。 or data
    structures might be pointing to that object。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 变量也不包含对象。它们只是引用或指向对象，这意味着在Python中“改变”是一个模糊的术语。我们可以通过赋值语句改变变量所指向的对象，或者我们可以改变一个对象，这实际上改变了对象本身，而不管什么变量或数据结构可能指向那个对象。
- en: Now if you feel rusty on this topic I wrote an article on it recently called
    Overlooked。 Facts and About Variables and Objects in Python。 It's all about pointers。
    And I highly recommend Ned Batchilder's talk from years ago at Python called Facts
    and。 Mists about Python names and values and Brandon Rhodes' talk from quite a
    while ago called， Names。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你觉得对这个主题有些生疏，我最近写了一篇文章，标题是《被忽视的事实与Python中的变量和对象》。这篇文章全部都是关于指针的。我强烈推荐Ned
    Batchilder几年前在Python大会上的演讲，标题是《关于Python名称和值的事实与迷雾》，还有Brandon Rhodes很久以前的演讲，标题是《名称》。
- en: Objects and Plumbing from the Clif which actually goes into quite a bit more
    than。 just this topic here。 Alright let's talk about ducks。 Let's say we have
    a list called Duck List。 What do you think would happen if we used the plus equals
    operator to add a tuple of two。 values to this list？ Well Python let us do this。
    Who thinks this will work？ It'll do something。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 《来自Clif的对象与管道》，实际上涉及的内容比这里的主题要多得多。好吧，让我们谈谈鸭子。假设我们有一个叫做Duck List的列表。如果我们使用加等于操作符将一个包含两个值的元组添加到这个列表中，你认为会发生什么？好吧，Python允许我们这样做。谁认为这会成功？它会有某种效果。
- en: Who thinks this will give us an error？ Doesn't make sense to do。 So Python actually
    allows this。 It allows us to do this and what happens is Python loops over the
    tuple and adds each。 of the values to our list。 Let's make a tuple called Duck
    tuple that has two strings in it。 Will Python allow us to use plus equals to do
    the same thing but with a list to a tuple？
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 谁认为这会给我们带来错误？这样做没有意义。所以Python实际上允许这样做。它允许我们这样做，结果是Python遍历元组并将每个值添加到我们的列表中。我们来创建一个叫做Duck
    tuple的元组，它包含两个字符串。Python会允许我们使用加等于将列表与元组进行同样的操作吗？
- en: So we're trying to add these two items in our list to the tuple。 So who thinks
    this will work？
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们试图将这两个列表中的项目添加到元组中。谁认为这会成功？
- en: Still works。 Who thinks we get an error at this point？
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有效。谁认为此时我们会遇到错误？
- en: We do get an error at this point but the error isn't because we can't use plus
    equals。 with a list or rather plus equals with a tuple。 Plus equals works with
    tuples。 We're allowed to use plus equals on tuples as long as it's with another
    tuple。 So plus equals on tuples only works with other tuples。 It doesn't work
    with lists。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此时我们确实遇到了错误，但这个错误并不是因为我们不能在列表上使用加等于。或者说，在元组上使用加等于。加等于在元组上是有效的。只要与另一个元组一起使用，我们就可以在元组上使用加等于。所以元组上的加等于仅在与其他元组一起使用时有效。它不适用于列表。
- en: That's the weird thing。 And in fact tuples aren't actually the odd one here。
    Lists are the odd one。 Let's take an empty list and try to use a plus equals operator
    with a string。 Who thinks this will work？ It'll do something。 Who thinks this
    is an error？
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是奇怪的地方。实际上，元组在这里并不是奇怪的存在。列表才是奇怪的。让我们取一个空列表，尝试用字符串使用加等于操作符。谁认为这会有效？它会有某种效果。谁认为这是一个错误？
- en: So this does actually work but it might not do what you think it does。 It loops
    over the string and adds each of the characters to the list because the plus equals。
    operator on a list accepts any iterable of strings。 As long as it can loop over
    it。 it will loop over it and as long as it gets strings it。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这实际上是可行的，但它可能不会像你想的那样工作。它遍历字符串，并将每个字符添加到列表中，因为列表上的加等于操作符接受任何可迭代的字符串。只要它可以遍历，就会遍历，只要得到的是字符串，它就会。
- en: will add those strings to the list individually。 So plus equals on lists does
    the same thing as the extend method on a list。 The extend method accepts any iterable
    and it loops over it and it pins each of the items。 to the list from that iterable。
    So plus equals on lists is consistent but not with plus equals on tuples it's
    consistent。 with the extend method on lists。 The list extend method and this plus
    equals operator on lists。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些字符串逐个添加到列表中。所以列表上的加等于与列表的extend方法做的是同样的事情。extend方法接受任何可迭代对象，并遍历它，将可迭代对象中的每个项目添加到列表中。因此，列表上的加等于是连贯的，但与元组上的加等于不一致，而是与列表的extend方法一致。列表的extend方法与列表上的加等于操作符。
- en: they're not an isolated， issue。 Many other operations in Python accept any iterable。
    For example。 the string join method accepts a list but it also accepts a tuple
    and even， accepts strings。 But again it might not do what you expect it to do。
    What happens when you loop over strings？
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个孤立的问题。Python中的许多其他操作也接受任何可迭代对象。例如，字符串的连接方法接受一个列表，但它也接受一个元组，甚至接受字符串。但再次强调，它可能不会按照你期望的那样工作。当你遍历字符串时会发生什么？
- en: What do you get？ It's technically strings that represent characters because
    strings are infinitely recursive data。 structures。 That's a whole other oddity
    though。 So when we loop over strings we get substrings and that's what we're doing。
    We're joining together each of the characters in this string with space which
    is a strange。 thing to do。 So if we give the dictionary constructor in Python
    an iterable of two item iterables it。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到什么？实际上是表示字符的字符串，因为字符串是无限递归的数据结构。这又是另一个奇异之处。所以当我们遍历字符串时，我们得到子字符串，这就是我们在做的。我们把这个字符串中的每个字符与空格连接在一起，这是一件奇怪的事情。因此，如果我们给Python的字典构造函数一个包含两个项目的可迭代对象，它。
- en: will accept whatever we give to it as long as there are two item iterables and
    make the。 first thing a key and the second thing a value。 Lots of things in Python
    accept any iterable as long as it fits the shape and the style。 they're looking
    for。 They don't really care what you give to it。 What's the word for this？
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 会接受我们给予的任何内容，只要有两个项目的可迭代对象，并且将第一个东西作为键，第二个东西作为值。Python中的许多东西只要符合它们所寻找的形状和风格，就会接受任何可迭代对象。它们并不真的在乎你给予它什么。这个词是什么？
- en: What's the animal that we use to describe this？ I'm sure someone knows。 A duck。
    Right。 We're practicing duck typing。 Rather， Python is practicing duck typing。
    So the idea behind duck typing is when we're trying to identify an animal we don't
    check。 its DNA to see whether it's a duck。 Instead we observe it。 We observe it
    and say， you know。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用什么动物来描述这个？我相信有人知道。一只鸭子。对。我们在实践鸭子类型。实际上，Python在实践鸭子类型。因此，鸭子类型的背后思想是，当我们试图识别一种动物时，我们并不检查它的DNA来看看它是否是一只鸭子。相反，我们观察它。我们观察它并说，你知道的。
- en: if it looks like a duck， it walks like a duck， maybe it， sounds kind of like
    a duck。 then it's a duck。 That means that checking the behavior of an object instead
    of checking what the actual。 class of that object is。 We don't check its type，
    its class， we check its behavior。 So we don't usually care whether something is
    a list。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它看起来像一只鸭子，走起来像一只鸭子，也许听起来也像一只鸭子，那么它就是一只鸭子。这意味着要检查对象的行为，而不是检查该对象的实际类。我们不检查它的类型，它的类，我们检查它的行为。因此，我们通常不关心某个东西是否是一个列表。
- en: We care whether it's a sequence or maybe whether it's an iterable。 And we don't
    care whether something is a function， we care whether it's a callable。 We tend
    to use generic words for describing behaviors of objects instead of discussing。
    the types of those objects。 All right。 So the list extend method accepts any iterable
    and the plus equals operator on lists works。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关心的是它是否是一个序列，或者可能它是否是一个可迭代对象。我们不关心某个东西是否是一个函数，我们关心的是它是否是一个可调用对象。我们倾向于使用通用词汇来描述对象的行为，而不是讨论这些对象的类型。好吧。所以列表的扩展方法接受任何可迭代对象，而列表上的加等号运算符有效。
- en: the same way as the extend method。 It's consistent with extend。 But the plus
    equals operator works differently on tuples and in fact on most types of objects。
    And in many cases， Python doesn't do type checking at all。 Because it's practicing
    duck typing。 It's checking the behavior， it's trying something out and hoping
    for the best。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与扩展方法的方式相同。它与扩展是一致的。但加等号运算符在元组上工作得不同，实际上在大多数对象类型上都是如此。而且在许多情况下，Python根本不进行类型检查。因为它在实践鸭子类型。它检查行为，尝试一些东西并希望得到最佳结果。
- en: So if you embrace duck typing in your own code by thinking in terms of behaviors
    like。 an iterable instead of a type like a list， you'll better understand what
    Python is doing。 But you'll also probably write better Python code。 Your code
    will fit in better in the Python ecosystem。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你在自己的代码中接受鸭子类型，考虑行为，比如可迭代对象，而不是像列表这样的类型，你将更好地理解Python的运作。但你也可能会写出更好的Python代码。你的代码会更适合Python生态系统。
- en: So familiarize yourself with terms like iterable and callable and hashable sequence
    mapping these。 generic terms that describe behavior instead of the type of something。
    And if you're interested in specifically how iterables work in Python， I gave
    a talk on。 this some while back called loop better a deeper look at iteration。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所以要熟悉像可迭代（iterable）、可调用（callable）和可哈希序列（hashable sequence）这些术语。它们是描述行为的通用术语，而不是某种类型的术语。如果你特别感兴趣于Python中可迭代对象的工作原理，我之前做过一个演讲，叫做“更好的循环：深入了解迭代”。
- en: Though it really dives into how iterables work deeply。 You don't really need
    to understand it。 But it's nice to embrace these generic terms when you're talking
    about types。 Because in Python we think in terms of behavior not in terms of concrete
    types。 Okay so we're going to take a very quick mental break before an accession。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它真的深入探讨了可迭代对象的工作原理。你不需要完全理解它。但在谈论类型时，拥抱这些通用术语是很好的。因为在Python中，我们关注的是行为，而不是具体类型。好了，在进入下一部分之前，我们先稍微休息一下。
- en: Here is a dog in a mailbox。 A chip monk enjoying some tea。 And a cat debugging
    its code。 Alright that's a long enough break。 Let's look at the plus equals operator
    again。 Let's take two variables and assign them to the same tuple。 Then let's
    try to use the plus equals operator to modify one of these tuples。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一只在邮箱里的狗。一只享受茶水的松鼠。一只调试代码的猫。好吧，这个休息够长了。让我们再看看`plus equals`运算符。我们来取两个变量并将它们赋值给同一个元组。然后我们尝试使用`plus
    equals`运算符来修改其中一个元组。
- en: Does Python allow plus equals on tuples？ Who thinks Python allows plus equals
    on tuples？ Okay good。 You should know that by now Python allows plus equals on
    tuples。 We just saw it。 So Python does allow plus equals on tuples。 And we can
    use it with another tuple。 So A at this point has four things in it。 How many
    things does B have？ Two or four。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许在元组上使用`plus equals`吗？谁认为Python允许在元组上使用`plus equals`？好吧，不错。你应该知道，现在Python允许在元组上使用`plus
    equals`。我们刚刚看到的。所以Python确实允许在元组上使用`plus equals`。我们可以用另一个元组来使用它。因此此时A里有四个东西。B有多少个东西？两个还是四个？
- en: what do you think？ Two things， four things。 So it turns out it has two things。
    So A has four things。 B has two things because we changed A， we didn't change
    B。 So plus equals on tuples is really the same as a plus operator followed by
    an equal sign。 We're not mutating the tuple。 We're just making a new tuple and
    then reassigning our variable to it。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你觉得怎么样？两个东西，四个东西。所以结果是它有两个东西。所以A有四个东西。B有两个东西，因为我们改变了A，而没有改变B。因此，`plus equals`在元组上的操作实际上与加法运算符后面跟一个等号是一样的。我们并没有改变元组，而只是创建了一个新的元组，然后将变量重新赋值给它。
- en: So X plus equals something is the same as X plus something followed by an equal
    sign afterward。 Both of these statements make a new object and then afterward
    point our variable to that。 new object。 Alright let's take two variables and do
    the same thing。 We'll assign them to the same list。 Now let's use the plus equals
    operator to modify the first list。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所以`X plus equals something`与`X plus something`后面跟一个等号是一样的。这两个语句都创建一个新对象，然后之后将我们的变量指向那个新对象。好吧，让我们取两个变量，做同样的事情。我们将它们赋值给同一个列表。现在让我们使用`plus
    equals`运算符来修改第一个列表。
- en: So our first list now has four things in it。 How many things does our second
    list have？
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们第一个列表现在有四个东西。我们的第二个列表有多少东西？
- en: Two or four at this point。 Yeah， this point our list has four things different
    from the tuple。 So the plus equals operator doesn't mutate tuples but it does
    mutate lists。 Now I find this interesting because that means that on lists A plus
    equals something does。 a mutation but A equals A plus something creates a new
    object and then reassigns the。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此时是两个还是四个？是的，此时我们的列表有四个东西，与元组不同。所以`plus equals`运算符并不会改变元组，但它会改变列表。我发现这很有趣，因为这意味着在列表上，`A
    plus equals something`会导致变异，而`A equals A plus something`则创建一个新对象，然后重新赋值。
- en: variable to that new object。 So in Python A plus equals B is not always the
    same as A equals A plus B。 It is sometimes， but not always。 These two things are
    the same on strings。 on numbers and on tuples but they do different， things on
    lists。 Now this seems a little bit inconsistent but from Python's perspective
    it's perfectly， consistent。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 变量指向那个新对象。因此，在Python中，`A plus equals B`并不总是等于`A equals A plus B`。有时是，但并不总是。这两者在字符串、数字和元组上是一样的，但在列表上却是不同的操作。这似乎有点不一致，但从Python的角度来看，这是完全一致的。
- en: So this is because lists are mutable and plus equals is an in place addition
    operation which。 means it performs a plus operation in place。 So you're supposed
    to do a plus operation in place on mutable objects。 It's actually supposed to
    mutate in place if it can but it's convenient to use plus equals。 on immutable
    types like tuples and strings and numbers。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为列表是可变的，而加等于是一个原地加法操作，这意味着它在原地执行加法操作。所以你应该在可变对象上进行原地加法操作。如果可以的话，它实际上应该在原地改变，但在不可变类型如元组、字符串和数字上使用加等于是方便的。
- en: This is a convenience for us because we don't want to have to type plus and
    then equals all。 the time in our code。 So on immutable types in place assignments
    they just fall back to returning a new object。 instead。 So on mutable types in
    place assignments mutate the object and on immutable types they return。 a new
    object to us。 Now if we take a tuple with a list inside it who thinks we can put
    a list inside of a。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们来说是个便利，因为我们不想在代码中总是输入加号和等号。所以在不可变类型中，原地赋值将回退到返回一个新对象。而在可变类型中，原地赋值则会改变对象。在不可变类型中，它们会返回一个新对象给我们。现在如果我们取一个包含列表的元组，谁认为我们可以在元组中放一个列表？
- en: tuple。 Okay so we've stuck a list inside of a tuple you remember that we've
    already seen this。 It's possible to do but what happens if we say x sub zero plus
    equals a list three four。 Now we've got a list in this tuple who thinks it will
    mutate this list。 It's actually going to mutate the list。 Okay who thinks that
    this won't work we're going to get an error。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们已经把一个列表放进了元组中，你还记得我们已经看过这个吗？这是可以做到的，但如果我们说`x[0] += [3, 4]`会发生什么？现在我们在这个元组中有一个列表，谁认为它会改变这个列表？实际上，它会改变这个列表。好吧，谁认为这不会成功，我们会得到一个错误。
- en: Who doesn't know what this is going to do？ Okay so that was most of you here。
    Now it turns out that the first two of you here you have an interesting situation
    going， on。 It actually does give us an error but it also mutates the list。 So
    everyone's happy at this point right。 Now this is probably the most obscure Python
    oddity I've seen and it's never going to。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 谁不知道这将会发生什么？好吧，大部分人都不知道。结果发现，你们中的前两位遇到了一个有趣的情况。它实际上给我们带来了一个错误，但它也改变了列表。所以到此为止，每个人都很高兴，对吧？现在这可能是我见过的最晦涩的Python怪癖，它不会再出现了。
- en: bite you in real code because why are you trying to mutate a list that's inside
    of a。 tuple by subscripting the tuple nothing seems like it's a good idea here
    but we're going。 to take a look at what's going on anyway。 So whenever we use
    the plus equals operator in Python Python will try to call the dunder。 iad method
    on the object that we're pointing to and in that case it's our list。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实代码中，这会让你感到困惑，因为为什么你要通过下标访问元组中的列表来改变它呢？这里似乎没有什么好的主意，但我们还是要看看发生了什么。所以每当我们在Python中使用加等于运算符时，Python会尝试调用我们指向的对象的魔法方法`__iadd__`，在这种情况下，它是我们的列表。
- en: After that it will do an assignment。 So the exception happened because the assignment
    failed but that was after dunder iad successfully。 mutated our list so the list
    dunder iad method mutates our list and then returns itself back。 for the sake
    of that assignment statement but we're not allowed to assign into a tuple。 so
    we get an error at this point。 Now this isn't ever going to bite you in real code
    because again why are you doing this。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 之后它会进行赋值。所以异常发生是因为赋值失败，但在那之前，魔法方法`__iadd__`成功地改变了我们的列表，所以列表的魔法方法`__iadd__`改变了我们的列表，然后为了那个赋值语句返回了自身，但我们不允许对元组进行赋值，因此此时我们会得到一个错误。现在这在真实代码中不会让你困扰，因为再说一遍，你为什么要这样做。
- en: in your code。 What's the situation with this makes sense but this is an implementation
    detail that we。 found an interesting excuse to learn about here。 So some takeaways。
    The plus equals operator always performs an assignment but plus equals and other
    augmented。 assignment operators or in place operators as they're all also called
    are also allowed。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中。这种情况是合理的，但这是一个实现细节，我们在这里找到一个有趣的借口来学习。所以一些要点。加等于运算符总是执行赋值，但加等于和其他增强赋值运算符，或者说它们都是原地运算符，也都是允许的。
- en: to mutate the object that they're called with if that object chooses to mutate
    itself。 if it's a mutable object list mutate themselves with plus equals but tuples
    don't。 Now this might seem inconsistent but consistency is really about your frame
    of reference。 According to the Python documentation in place additions are supposed
    to do their operation。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象选择自我改变，调用它们的函数可以对该对象进行变更。如果它是一个可变对象，列表会用加等号进行自我改变，但元组则不会。现在这看起来可能不一致，但一致性实际上与您的参考框架有关。根据
    Python 文档，就地添加应该执行它们的操作。
- en: in place whenever possible and lists just happen to be the most common data
    structure。 where it's actually possible to do that。 So if Python doesn't do what
    you expect it to do that doesn't necessarily mean you found。 a bug in Python。
    It does mean that what Python's doing doesn't match up with your own sense of
    reality the。 way Python sees the world isn't the way you see the world。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下使用就地操作，而列表恰好是最常见的数据结构，在那里实际上可以做到这一点。因此，如果 Python 的行为与预期不符，并不一定意味着你发现了
    Python 中的 bug。这确实意味着 Python 的行为与您自己的现实感受不匹配，Python 看世界的方式并不等同于你看世界的方式。
- en: So I'd like to leave you with a few closing thoughts。 Regardless of what programming
    language you're in it's important to understand how the fundamentals。 of your
    programming language are different from other languages。 How do function calls
    work？
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我想给你留下几个结束思考。不管你使用什么编程语言，理解你的编程语言的基本原理与其他语言有何不同是很重要的。函数调用是如何工作的？
- en: How do variables work at a fundamental level？ And how do objects work？
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在基本层面上是如何工作的？对象又是如何工作的？
- en: Also what is an object in your language？ It's important to understand the way
    that your programming language thinks about the world。 and more importantly thinks
    about itself。 What does the world look like through the eyes of the Python interpreter？
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，在你的语言中对象是什么？理解你的编程语言如何看待世界以及更重要的是如何看待自身是很重要的。从 Python 解释器的角度看，世界是什么样子的？
- en: And if you think you found a bug in Python it might just be that you're misunderstanding。
    what trade-offs the Python core developers were taking when they were implementing
    the。 particular bit of functionality that you're using。 So if you see something
    odd going on in your code before you fix that bug poke around and。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为在 Python 中发现了一个 bug，可能只是你误解了 Python 核心开发人员在实现你正在使用的特定功能时所做的权衡。因此，如果你在代码中发现了奇怪的现象，在修复那个
    bug 之前，先探究一下。
- en: see what there is to learn from it because breaking things is one of the best
    ways to， learn。 Also if you find a Python audio of your own use the Python audio
    hashtag if you're going。 to tweet it or put it on social media。 Over the last
    many years I've probably put out over a hundred of these because there's。 lots
    of little weird things hiding in every programming language。 So join me。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 看看从中可以学到什么，因为打破事物是学习的最佳方式之一。如果你找到自己的 Python 音频，使用 Python 音频标签，如果你要在推特或社交媒体上发布的话。在过去的很多年里，我可能已经发布了超过一百个这样的内容，因为每种编程语言中都有许多小奇怪的东西隐藏着。所以加入我吧。
- en: Tweet out a Python audio if you find one。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现一个 Python 音频，请发推特分享。
- en: '![](img/9addb404724cae11b257bae92a9e8761_4.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9addb404724cae11b257bae92a9e8761_4.png)'
- en: Also if you would like Python morsel stickers because my logo is adorable find
    me in the。 hallway afterward。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果你想要 Python 的小贴纸，因为我的标志非常可爱，可以在会后找到我。
- en: '![](img/9addb404724cae11b257bae92a9e8761_6.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9addb404724cae11b257bae92a9e8761_6.png)'
- en: Thank you。 Thank you。 [APPLAUSE]。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢。谢谢。[掌声]。
