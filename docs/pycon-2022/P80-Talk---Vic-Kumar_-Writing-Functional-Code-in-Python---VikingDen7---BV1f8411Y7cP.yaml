- en: P80：Talk - Vic Kumar_ Writing Functional Code in Python - VikingDen7 - BV1f8411Y7cP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P80：演讲 - Vic Kumar_ 用Python编写函数式代码 - VikingDen7 - BV1f8411Y7cP
- en: Welcome everybody。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎大家。
- en: '![](img/74053c9ae9782a56d9156bf3f73c215e_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74053c9ae9782a56d9156bf3f73c215e_1.png)'
- en: '![](img/74053c9ae9782a56d9156bf3f73c215e_2.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74053c9ae9782a56d9156bf3f73c215e_2.png)'
- en: Hopefully everyone can hear me。 Welcome to the afternoon session of PyCon 2022
    in Salt Lake City。 Before I begin this entire presentation， it's on my GitHub。
    If you're running a Jupyter notebook。 you can run a Jupyter notebook。 The PDF
    slides are up there。 My GitHub is Vic Kumar， 1981。 All right。 So a little bit
    about me。 I work for Excela。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 希望大家都能听见我。 欢迎来到2022年盐湖城PyCon的下午会议。 在我开始整个演示之前，所有内容都在我的GitHub上。 如果你在运行Jupyter
    notebook，你可以运行一个Jupyter notebook。 PDF幻灯片也在上面。 我的GitHub是Vic Kumar，1981。 好吧，关于我的一点点介绍。我在Excela工作。
- en: We are a technology consulting firm based out of Arlington， Virginia。 We do
    three things that people sort of give us money for， modern software delivery。
    AI and analytics， as well as agile transformation。 The website， excela。com is
    up there。 We have openings right now for data engineers and data scientists。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是一家位于弗吉尼亚州阿灵顿的技术咨询公司。 我们做三件人们愿意付钱的事情：现代软件交付、人工智能和分析以及敏捷转型。 网站excela.com就在那。
    我们目前有数据工程师和数据科学家的职位空缺。
- en: So feel free to go to the website or reach out to me afterwards。 Right。 And
    some projects that I'm currently involved in go to code。io。 It's sort of like
    a leak code meets remote interview。 Again。 we have Jupyter notebook integration
    in several languages。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所以请随意访问网站或之后联系我。对吧。 我目前参与的一些项目可以访问code.io。 这有点像是泄漏代码和远程面试的结合。再次提到，我们在多种语言中都有Jupyter
    notebook集成。
- en: So if you ever want to play around with like Rust in a Jupyter kernel， go ahead
    and check。 out that site。 If you use the registration code， PyCon 2022 or lowercase。
    you can get a free extended subscription。 Yeah。 And I'm also working on HBCU Digital。
    which is an ESPN sort of app for historically black， colleges and universities。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你想在Jupyter内核中尝试Rust，欢迎查看那个网站。 如果你使用注册代码PyCon 2022（小写），你可以获得免费的延长订阅。 是的。
    我还在HBCU Digital上工作，这是一个为历史悠久的黑人大学和大学提供的ESPN应用程序。
- en: We're trying to add a lot of live content there。 We have on Roku， Apple TV，
    as well as mobile apps。 All right。 Enough jibber-jabber about me。 Let's talk a
    little bit about functional programming。 So in the last five， six years， I'm sure
    all of us have sort of heard of， played around， with。 experimented with some of
    these。 Let's call them like the new kids on the block。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在努力增加许多实时内容。 我们在Roku、Apple TV以及移动应用上都有。 好吧，关于我的闲聊够了。 让我们聊聊函数式编程。 在过去的五、六年里，我相信我们都听说过、玩过、尝试过这些新的技术。我们就称它们为“新来的孩子”吧。
- en: These newer languages， we have React。js out there in JavaScript。 There's F#
    for all the 。NET folks。 There is obviously Scala and Kotlin are still going strong
    in the JVM。 And for iOS development。 we now have Swift。 So you don't have to write
    Objective C。 And as well as there are more traditional functional。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些较新的语言中，我们有React.js和JavaScript。 针对所有.NET开发者，有F#。 显然，Scala和Kotlin在JVM中依然强劲。
    对于iOS开发，我们现在有Swift。 所以你不必再写Objective C。 还有更多传统的函数式编程语言。
- en: programming languages still out there like Haskell or OCaml。 So the idea behind
    functional programming is a pretty straightforward idea， but one that。 has far-reaching
    consequences， which is why I think I like it。 So the idea behind functional programming
    is that we are going to impose a restraint or。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 仍有编程语言，如Haskell或OCaml。因此，函数式编程背后的理念是相当简单的理念，但却有深远的影响，这也是我喜欢它的原因。 函数式编程的理念是我们将施加一个限制或约束。
- en: we're going to try to sort of constrain our code， put a restriction whereby
    we write our。 code only using pure functions。 So what exactly is a pure function？
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试限制我们的代码，设定一个条件，只用纯函数编写代码。 那么什么是纯函数呢？
- en: A pure function is one that does not have side effects。 So the next logical
    question， well then。 what is a side effect？ So side effect， it turns out， is anything
    that isn't a pure computation。 If you mutate the state of a variable， if you modify
    a data structure in place， if you。 throw an exception within your code， if you
    deal with any sort of IO， the console， networking。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是指没有副作用的函数。 所以下一个逻辑问题就是，副作用是什么呢？ 所以副作用是指任何不是纯计算的内容。 如果你改变变量的状态，如果你就地修改数据结构，如果你在代码中抛出异常，或者处理任何类型的IO、控制台、网络。
- en: these are side effects。 Another way of looking at or thinking about this is
    that a function has inputs and it has。 outputs。 In this sort of ubiquitous， not
    just a Python， but just programming in general。 function has， inputs and it has
    outputs。 If we do anything inside that function that doesn't explicitly deal with
    the inputs or。 outputs of that function， then that is by definition a side effect。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是副作用。另一种看待或思考这个问题的方式是，一个函数有输入和输出。在这种普遍存在的情况下，不仅仅是 Python，而是编程的一般原则，函数有输入和输出。如果我们在这个函数内部做任何与输入或输出没有明确关系的事情，那么根据定义这就是副作用。
- en: It's not explicit in the signature of the function that it's doing this thing。
    So that's kind of the idea behind the side effecting。 Right。 Okay。 A pure function
    has the property of referential transparency。 So when we talk about side effects
    and what are pure functions， it's sort of like something。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的签名中并没有明确说明它正在做的事情。所以这就是副作用背后的想法。对吧？好的。一个纯函数具有引用透明性的特性。因此，当我们谈论副作用和什么是纯函数时，这有点像某种东西。
- en: we can prove。 It's like mathematical。 We can go through and I couldn't pace
    the definition there of what referential transparency actually。 is。 But there
    is an easier sort of way to think about this。 So yeah。 let's get to some coding
    examples so that we can actually understand this a little， bit better。 So I have
    a function here。 It just adds a list of numbers。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以证明。这就像数学一样。我们可以一步一步地分析我无法在这里阐述引用透明性的定义。但有一种更简单的方式来思考这个问题。所以，是的。让我们来一些编码示例，以便更好地理解这个问题。所以我这里有一个函数。它只是在添加一组数字。
- en: So we're going to start by creating a variable sum。 We're going to assign it
    to zero。 We'll go through every item in our list and we will add the numbers and
    we can see that。 it gets the sort of the right output when we add those numbers。
    But if I think back to algebra class or math class and I know that's why everyone
    is here。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将开始创建一个变量 sum。我们将其赋值为零。我们会遍历列表中的每一项，并将数字相加，我们可以看到。当我们相加这些数字时，得到了正确的输出。但如果我回想起代数课或数学课，我知道这就是为什么每个人都在这里。
- en: because they wanted to go back to algebra class。 When I say something like x
    equals one。 y equals two， what is x plus y？ I would tell you that it's three because
    in my head I took x and I replaced it with the。 value one and I took y and replaced
    with the value two and one plus two equals three。 So on this first block of code
    I said sum is equal to zero and when you tell me that sum。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因为他们想回到代数课。当我说像 x 等于一，y 等于二，x 加 y 等于多少？我会告诉你是三，因为在我脑海中我把 x 替换为值一，把 y 替换为值二，1
    加 2 等于 3。所以在这第一段代码中，我说 sum 等于零，当你告诉我 sum 时。
- en: equals zero then mathematically if I use sum on the right hand side of any expression。
    it should yield the same result。 So let's take a look at how that works then。
    So instead of sum equals sum plus n I replaced it with sum equals zero plus n
    because you。 told me that sum is equal to zero。 And as you can see it doesn't
    give the same answer。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 等于零，那么从数学上讲，如果我在任何表达式的右侧使用和，它应该产生相同的结果。所以让我们看看这如何运作。那么，我将 sum 等于 sum 加 n 替换为
    sum 等于零加 n，因为你告诉我 sum 等于零。正如你所看到的，它并没有给出相同的答案。
- en: It actually gives an incorrect answer because it gets to the， it iterates to
    the list。 It gets to the last item in that list and it says okay sum equals eight
    plus zero so。 it's equal to eight。 But that's not the same value we got before。
    And even though this code block is sort of like very innocuous， very， very simple
    we can。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上给出了一个不正确的答案，因为它遍历了列表。它到达了列表中的最后一个项目，然后说好，sum 等于八加零，所以它等于八。但这与我们之前得到的值不同。尽管这段代码看起来非常无害，非常简单，我们仍然可以。
- en: see that perhaps there's some things that we don't like about it。 I could easily
    imagine that the list that we're trying to add up might become very， very large。
    and so now we might think okay let's try to apply some concurrency to it。 Let's
    add some threads and run the same block of code using threads。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 看到或许有一些我们不喜欢的地方。我可以很容易想象我们尝试相加的列表可能会变得非常非常大。因此现在我们可能会想，好吧，让我们尝试应用一些并发。让我们添加一些线程，并使用线程运行相同的代码块。
- en: And obviously we could maybe partition the list so that you know the threads
    are operating。 on different parts of the list。 But if we get to that line sum
    equals sum plus n and we do this mutation we can't have。 two threads mutating
    the variable sum at the same time。 You'd have to do something like a lock。 a metaphor，
    a mutex， some sort of lock or maybe an atomic。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以将列表分区，使得线程在列表的不同部分上操作。但如果我们到达这一行求和等于求和加n，并且我们进行了这种变异，我们不能让两个线程同时修改变量求和。你必须做一些像锁、互斥量的事情，某种锁或也许是原子操作。
- en: operation but in any case we're going to have to deal with this in a concurrent
    sense if。 we ever want to make this multi-threaded。 So the problem really here
    is the mutable state of sum。 We want to sort of get rid of this mutable state
    because as we saw in the previous slide。 mutation is a form of side effect and
    we can see that this function isn't referentially transparent。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但无论如何，如果我们想让这个多线程，我们必须以并发的方式处理这个问题。所以真正的问题是可变状态的求和。我们想要摆脱这种可变状态，因为正如我们在前一张幻灯片中看到的，变异是一种副作用，我们可以看到这个函数不是引用透明的。
- en: And we substituted the value zero for what sum was。 It didn't return the same
    thing。 So all right let's try to then rid ourselves of the mutable state sum。
    And there's some pretty straightforward ways that we can do that。 The first of
    which is just let's use recursion。 So if the list is one item just return that
    otherwise return the first item plus the sum。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用零替代了求和的值。它没有返回相同的结果。那么好吧，让我们尝试摆脱可变状态的求和。有一些相当简单的方法可以做到这一点。第一种方法是使用递归。如果列表只有一个项目，就返回那个项目，否则返回第一个项目加上求和。
- en: of the rest of the list。 And we can see that that gives us the same value and
    does not have the consequence of。 a mutable state within the function。 Okay。 The
    second way that we could deal with the same problem is by using what we call a
    higher。 order function。 A higher order function is a function that takes in a
    function as a parameter or returns。 a function as its output。 And so here we're
    going to import this cool function called reduce from inner tools。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的其余部分。我们可以看到这给我们带来了相同的值，并且在函数内部没有可变状态的后果。好的。我们可以处理同一问题的第二种方法是使用我们称之为高阶函数。高阶函数是一个将函数作为参数传入或将函数作为输出返回的函数。因此，在这里我们将从内部工具导入一个很酷的函数叫做reduce。
- en: And inner tools is first parameter is obviously it's a lambda。 It takes two
    things from the list and returns one item and then sort of recursively applies。
    it to the list。 And so this concept is going to come back up in a few slides。
    In functional programming we like using higher order functions to abstract around
    things like。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 而内部工具的第一个参数显然是一个lambda。它从列表中获取两个元素并返回一个项目，然后递归地将其应用到列表中。因此，这个概念将在接下来的几张幻灯片中再次出现。在函数式编程中，我们喜欢使用高阶函数来抽象化诸如。
- en: having to mutate state。 So we see two ways here that we can get rid of that
    mutable state。 The two examples here add numbers two and add numbers three are
    referentially transparent。 and these are pure functions versus the one up here
    we know that it's not。 We've sort of proven that this is not referentially transparent
    and therefore that function is。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不必变更状态。因此，我们看到这里有两种方法可以摆脱可变状态。这两个例子add numbers two和add numbers three是引用透明的，而上面的那个我们知道它不是。我们已经证明了这不是引用透明的，因此那个函数是。
- en: impure in a functional sense。 It doesn't obey the properties and laws that we
    like in math。 And that's sort of where this premise is going to go with functional
    programming。 All right。 so now that we've sort of accepted the idea that we want
    to use higher order， functions。 I sort of did a thing。 I don't know if it's a
    good thing or a bad thing。 But I added some classes。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能上是不纯的。它不遵循我们在数学中喜欢的属性和规律。这正是这个前提与函数式编程的关系。好了，现在我们基本接受了使用高阶函数的想法。我做了一件事情。我不知道这是好事还是坏事，但我添加了一些类。
- en: So this is a library that you can pip install， pip install pi effects。 And so
    it's like my first attempt at trying to introduce some of the classes that you
    might。 see in a language like Haskell and most certainly in Scala you will see
    these types。 And so the types we're going to discuss today are option， try either。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可以通过pip安装的库，pip install pi effects。这是我首次尝试介绍一些在像Haskell这样的语言中，或者在Scala中绝对会看到的类。因此，今天我们讨论的类型是option，try和either。
- en: Actually we're not going to cover either but we are going to do option， try
    and feature。 either is there in the library but we're not going to cover either
    today。 So yeah。 let's talk about abstracting away certain behaviors， some common
    behaviors。 And the way that we're going to sort of approach this is we're going
    to use classes。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们不会涵盖这两者，但我们将讨论选项，尝试功能。库中确实有这两者，但今天我们不打算覆盖它们。所以，让我们来谈谈抽象某些行为，一些常见的行为。我们将通过使用类来处理这个问题。
- en: So the option class is a parent class or like some sort of interface and it
    has two child。 classes actual implementations。 One of which is called some and
    the other one is called empty。 So if there is a value we encapsulate it in the
    some class and otherwise it's empty。 And as always let's go ahead and create an
    example data model that we can sort of play， around with。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所以选项类是一个父类，或者说是一种接口，它有两个子类的实际实现。其中一个叫做 some，另一个叫做 empty。如果有值，我们将其封装在 some 类中，否则就是
    empty。和往常一样，我们先创建一个示例数据模型，便于进行一些操作。
- en: So the idea here is that we're going to create some classes。 We're going to
    have a person。 a person is going to have a contact and the contact is， going to
    have a name。 And the name has the properties first name and last name。 So this
    is sort of like a nested sort of hierarchical class structure。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是我们将创建一些类。我们将有一个人，一个人将有一个联系人，而联系人将有一个名字。名字具有名和姓的属性。这就像是一个嵌套的层次类结构。
- en: And so let's say given a person I want to go ahead and find the first name of
    contact， number one。 So I use data classes and then I let's not worry about the
    get functions， the get last， name。 the get first name。 Those are just wrappers
    and we're going to use those so that we can see how the option。 class sort of
    works。 But first we're just going to sort of use the attributes directly。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设给定一个人，我想找出联系人号码一的名字。我使用数据类，然后我们不必担心获取函数，获取姓氏、获取名字。这些只是包装器，我们将使用它们，以便看到选项类是如何运作的。但首先我们将直接使用属性。
- en: So our example is we're going to be given a person and we want to go ahead and
    try to。 find the first name of contact number one for that person。 So we create
    this like person object and you can see we're just going to use like if statements。
    So all along the way anything could be empty。 That's really what we're dealing
    with。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例是给定一个人，我们想找出该人的联系人号码一的名字。我们创建一个类似于人对象的东西，你可以看到我们将使用 if 语句。因此，沿途任何东西都有可能是空的。这就是我们所要处理的。
- en: We have this nested hierarchy。 We want to get to this thing in our hierarchy。
    But along the way we have to do these checks because things can be have no value。
    It can be empty and that would cause a problem。 So we have to do the checks that
    if the person is there。 if the person's contact one is there， and if they have
    a name then return this value otherwise return none。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有这个嵌套的层次结构。我们想在层次结构中获取某个东西。但在这个过程中，我们必须进行检查，因为某些东西可能没有值。它可能是空的，这将导致问题。因此，我们必须检查是否有这个人，如果这个人的联系人一存在，以及他们是否有名字，然后返回这个值，否则返回
    none。
- en: Right？ And this can get more complicated。 The more nested and more hierarchical
    structure that we have to our classes。 the more complicated， branching and conditional
    logic that we're going to have to use to get from this class。 to that class。 Okay，
    so let's take a look at how this works with the option class。 So okay。 so this
    is where functional pure sort of what they like。 Okay。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对吗？这可能会变得更加复杂。我们的类结构越是嵌套和层级化，所需的分支和条件逻辑就越复杂，以便从这个类转到那个类。好的，让我们看看选项类是如何工作的。好的，这就是函数式纯粹主义者喜欢的地方。
- en: in the second example we don't really have any the branching logic is abstracted
    away。 for you with an operation called flat map。 And so flat map is a way that
    we chain or combine inputs and you're going to see the。 same techniques with the
    other other classes as well。 So it takes the output of one and puts it as the
    input to the next function。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们实际上没有任何分支逻辑，这些都被抽象化处理，通过一个叫做 flat map 的操作。flat map 是一种将输入链接或组合在一起的方法，你会在其他类中看到相同的技术。它将一个函数的输出作为下一个函数的输入。
- en: And what functional peers would really like about this sort of function is as
    you can。 see the second function below we get an input， we apply a series of functions
    and we're given。 an output to a functional person。 This is how every program should
    always work。 We get an input。 apply a series of functions and get an output。 And
    it does the same thing that the first function does。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性同行真正喜欢这种函数的地方是，如你所见，下面的第二个函数我们获得一个输入，应用一系列函数，并得到一个输出。对一个功能性的人来说，这就是每个程序应该始终工作的方式。我们获取一个输入，应用一系列函数，得到一个输出。它完成的功能与第一个函数相同。
- en: The other sort of observation that we can make between the two functions is
    that the。 first function even though it tells me that it's returning a string，
    it doesn't tell me。 anything in the function signature that this string could
    potentially be empty。 In the lower function I can see that it returns an option
    of string so the caller of this。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对这两个函数进行的另一种观察是，第一个函数尽管告诉我它返回一个字符串，但在函数签名中并没有告诉我这个字符串可能是空的。在下面的函数中，我可以看到它返回一个字符串的选项，因此调用者可以了解这一点。
- en: method now knows that this value that is being returned could be empty and they
    are。 forced to deal with the case of emptiness。 And in the case of an option class
    you have something get or else。 So if there's no value you can supply a value
    there。 And right。 So all the functions there。 the get contact one， contact。get
    name， name。get first name。 If I go up a slide。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 方法现在知道返回的这个值可能是空的，他们被迫处理空值的情况。在选项类的情况下，你有一些获取或其他的功能。因此，如果没有值，你可以在那里提供一个值。所有的函数，如get
    contact，contact.get name，name.get first name。如果我上移一张幻灯片。
- en: those functions are just simple functions that return an option。 And that's
    really what flat map is doing for us。 It's just chaining the options together
    so that we can rewrite this logic in a way that。 reads left to right。 The second
    API is also what we call it's a fluent API。 It reads left to right just like how
    English reads。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数只是简单的返回一个选项的函数。而这正是扁平映射为我们做的事情。它只是将选项连接在一起，这样我们就可以以一种从左到右的方式重写这个逻辑。第二个API也是我们所称的流式API。它的读取方式与英语相同，从左到右。
- en: You don't necessarily read English like inside out with if statements and while
    loops you。 kind of read it just left to right。 So we get the benefit of chaining
    operations and sort of seeing a fluent API style。 Okay。 So that's sort of how
    we can deal with emptiness using the option class。 The second example is going
    to deal with now with exceptions because what we talked about。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你不一定是用if语句和while循环来从内到外地阅读英语，而是从左到右地阅读。因此，我们可以享受到链接操作的好处，并看到流式API风格。这就是我们如何使用选项类处理空值。第二个例子将处理异常，因为我们讨论过。
- en: before is that an exception just like that example that we did with the sums
    and we mutated。 sum that function was impure。 So anytime I raise an exception
    within my code。 I'm also suffering from the same problem that， my code is not
    referential or transparent and the function is not pure。 So the same way that
    we dealt with option where option was a parent class and we had。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子是一个异常，就像我们与求和所做的例子一样，我们改变了那个函数是非纯的。所以每次我在代码中引发异常时，我也面临着同样的问题，我的代码不是引用透明的，函数也不是纯的。因此，我们处理选项的方式类似，选项是一个父类。
- en: two child classes to deal with the behaviors that we wanted。 We have a class
    called try。 And the try class is also a parent class。 The try class has two children
    classes。 the first of which is called success and the other， one is called failure。
    So success encapsulates the successful value of something happening without an
    error and。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 两个子类来处理我们想要的行为。我们有一个类叫做try。这个try类也是一个父类。try类有两个子类，第一个叫做success，另一个叫做failure。所以success封装了没有错误发生的成功值。
- en: failure encapsulates the exception that might be thrown in that event if like
    an accept。 So let's take an example here where something that could potentially
    fail。 It could go wrong。 And so we're going to look at an example of JSON parsing。
    So we have two strings。 The first string is going to be parsable。 It's going to
    parse to our model。 It's correct。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: failure封装了在某个事件中可能被抛出的异常，比如一个接受。因此，让我们在这里举一个可能失败的例子。它可能出错。因此，我们将查看JSON解析的示例。我们有两个字符串，第一个字符串是可以解析的。它会解析成我们的模型。是正确的。
- en: The second string I've deliberately made a mistake。 There's no attribute called
    first name is wrong。 So when I try to sort of parse my JSON and get it into my
    model， it is going to raise， an error。 It's going to raise an exception。 So let's
    take a look at how we might do this in a very straightforward way。 So we have
    like parse person。 We're going to do a JSON loads。 We'll load it into a dictionary。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意在第二个字符串中犯了一个错误。“没有名为 `first name` 的属性”是错误的。所以当我尝试解析我的 JSON 并将其加载到我的模型中时，它将引发一个错误。它将引发一个异常。所以让我们看看如何以非常简单的方式做到这一点。所以我们有
    `parse person`。我们将进行 `JSON loads`。我们将其加载到一个字典中。
- en: We'll check some attributes。 From that person， we'll parse the contact and from
    that contact。 we'll go ahead and parse， the name。 The parse name function there。
    we can see except it raised the type error。 I couldn't deserialize the name。 So
    that function is not pure。 And similarly， like we saw with the option。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查一些属性。从那个人那里，我们将解析联系，并从那个联系中解析名字。那里的 `parse name` 函数，我们可以看到除了它引发了类型错误。我无法反序列化这个名字。因此，这个函数并不纯粹。同样，就像我们在选项中看到的那样。
- en: when I just look at the signature of pars name， it takes the dictionary's input
    and it returns a name。 Nothing in the signature of that function tells me that
    this could potentially throw。 or raise an exception。 Perhaps it's there in the
    docs and stuff like that。 But I think we could make it more explicit。 And so the
    example there， it works。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我只看 `parse name` 的签名时，它接收字典作为输入并返回一个名字。这个函数的签名没有告诉我这可能会抛出或引发一个异常。也许在文档里有这样的说明。但我认为我们可以让它更明确。所以那里的例子是有效的。
- en: It gets the first name of contact one from our JSON string。 And if you go back，
    oh， sorry。 Alice is the correct first name there。 So it works。 But the function
    definitely raises an exception and perhaps is not as explicit as we would。 like
    to make it。 So we'll take an example。 Oh， yes。 I forgot about this。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 它从我们的 JSON 字符串中获取第一个联系人的名字。如果你回去看，哦，抱歉。爱丽丝是正确的名字。所以它有效。但这个函数确实引发了一个异常，可能没有我们想要的那么明确。所以我们会举一个例子。哦，是的。我忘了这一点。
- en: So this is what happens if we sort of parse the second string， which is invalid，
    we'll get。 the error that the first name。 There's no attribute called first name
    is wrong。 So we can see that we get this exception when we try to parse the name
    because the second。 JSON was not a good JSON for our model。 Right。 So let's try
    to rewrite this using the try class。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我们解析第二个字符串（这是无效的），就会发生这种情况，我们会得到一个错误，指出“没有名为 `first name` 的属性”是错误的。因此，当我们尝试解析名字时，可以看到我们得到了这个异常，因为第二个
    JSON 对于我们的模型来说并不是一个好的 JSON。对吧。所以让我们试着用 `try` 类重写这个。
- en: So the parse name function here， we're going to use try。of， which will encapsulate
    like a。 callable object。 And if that callable succeeds， it'll return a success。
    If the callable fails。 it'll return a failure。 And in the signature of the function，
    we can see that， okay。 it takes in the same dictionary， as the input。 But the
    return value is not just a name。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里的 `parse name` 函数，我们将使用 `try.of`，它将封装一个可调用对象。如果那个可调用对象成功，它将返回一个成功。如果可调用对象失败，它将返回一个失败。在函数的签名中，我们可以看到，好的，它接收相同的字典作为输入。但是返回值不仅仅是一个名字。
- en: It's a try of a name。 So someone who sees that code， who reads that code。 can
    see that this function could， fail。 It could succeed or it could fail。 And just
    like we saw with the option class， we're going to have to sort of deal with the。
    case of failure。 Oh， sorry。 Okay。 And so we're going to go ahead and test that
    function。 Oh， yeah。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个名称的尝试。所以看到那段代码的人，阅读那段代码的人可以看到这个函数可能会失败。它可能成功也可能失败。就像我们在选项类中看到的那样，我们将不得不处理失败的情况。哦，抱歉。好的。所以我们将继续测试这个函数。哦，是的。
- en: Sorry。 I forgot one thing on this。 The way that we deal with failure in the
    try class is very similar to how we would deal。 with the failure in the option
    class。 In the option class， when it was empty。 we applied a method called get
    or else。 So when it was empty， we said get or else do this。 And we can do that
    with try also。 But in this case， we're going to use it or else supply。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 抱歉。我在这上面忘了一件事。我们在 `try` 类中处理失败的方式与我们在选项类中处理失败的方式非常相似。在选项类中，当它是空的时候，我们应用了一个叫做
    `get or else` 的方法。因此，当它为空时，我们说 `get or else` 做这个。而我们也可以用 `try` 来做到这一点。但在这种情况下，我们将使用
    `or else supply`。
- en: which is like get or else， but， it takes in a callable as its parameter。 So
    in this case。 we're going to call a function called handle parse error， which
    will create， the contact。 but it'll just warn us that we couldn't parse this。
    So if we have like a lot of JSON that we're parsing， we want to be warned。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 它像**get or else**，但接受一个可调用对象作为其参数。因此在这种情况下。我们将调用一个名为**handle parse error**的函数，该函数将创建联系人。但它只会警告我们无法解析这一点。因此，如果我们有很多JSON要解析，我们希望收到警告。
- en: We want to know that never happened。 We might want to keep continue， you know，
    continue parsing。 even though there was some， kind of mistake or error。 So yeah，
    these are tests。 So person one。 that's the good string there。 And you can see
    it does the exact same thing that we saw before without throwing an exception。
    It gets the first name， Alice。 And then in the second one， it tells us， oh。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想知道从未发生过的事情。我们可能希望继续，你知道，继续解析。即使有一些错误或问题。所以，是的，这些都是测试。那么第一个人。这是一个很好的字符串。你可以看到它确实和我们之前看到的完全一样，没有抛出异常。它得到了第一个名字，**爱丽丝**。然后在第二个中，它告诉我们，哦。
- en: there was an error parsing， you know， the， contact， contact one。 And it gives
    us the second person and it says that the contact name is known。 So that's sort
    of like the same thing that we saw with option。 We're trying to just be more explicit
    with how we deal and handle errors using the try， class。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析时出错，你知道，联系人，联系人一。它给了我们第二个人，并且说联系人名称是已知的。因此，这有点像我们看到的选项。我们尝试更明确地处理和处理错误，使用**try**类。
- en: So we've extracted the behavior of emptiness。 We've abstracted around the behavior
    of try-except blocks。 And the third class that we're going to briefly touch upon
    is how we can use the same concepts。 to deal with concurrency， futures。 I'm sure
    futures are there in a lot of different languages we've seen。 promises。 Future
    works a little differently than option and try。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们提取了空的行为。我们围绕**try-except**块的行为进行了抽象。我们将简要触及的第三类是如何使用相同的概念来处理并发和未来。我相信在许多不同的语言中都有未来。**promise**。未来的工作方式与选项和尝试略有不同。
- en: And that there is no explicit parent class and child class。 What future does
    is future is going to start off and it's going to have no value。 The value is
    not completed。 It's none。 For some period of time。 future will eventually behave
    like the try。 Once the future completes。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 并且没有显式的父类和子类。未来的作用是未来将开始，并且它将没有值。该值尚未完成。对于某些时间段。未来最终将像**try**那样表现。一旦未来完成。
- en: either there's a successful value from the future or there。 is a failure value
    from that same future which encapsulates your throwable， your exception。 that
    you're going to get back。 So let's go ahead and see how this works。 The simplest
    thing that we can do is sort of just run something asynchronously in a new。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要么是来自未来的成功值，要么是来自同一未来的失败值，其中封装了你的可抛出异常。所以让我们看看这个是如何工作的。我们可以做的最简单的事情就是在新的上下文中异步运行某些内容。
- en: thread and that's done with featured outrun。 So we just have a real easy function
    here。 Sleeps for three seconds and it will go ahead and return the value 100。
    So we're going to check some things。 The first thing we're going to do is we're
    going to sort of time the whole thing and。 we're going to， once we get the value，
    we're just going to do a little map statement and。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 线程，这个用**特征超越**完成。因此我们这里有一个非常简单的函数。等待三秒钟，然后返回值100。所以我们将检查一些事情。我们要做的第一件事是对整个过程进行计时。我们将获得值后，只需做一个小的映射语句。
- en: add one to the resulting value。 We're going to check if the future is done immediately。
    It's not going to be done because it just started and there's a three second wait
    and。 then we're going to wait four seconds。 We're going to check again if the
    future is done at which point it's true。 done equals， true。 We'll print out the
    result of that sort of value which is 101 and we got the overall。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果值上加一。我们将立即检查未来是否完成。它不会完成，因为它刚刚开始，并且有三秒钟的等待。然后我们将再等四秒。我们将再次检查未来是否完成，此时为真。完成等于真。我们将打印出那种值的结果，即101，并且我们得到了总体。
- en: execution time which is roughly four seconds。 The time that sleep for in there
    is what's causing it to be about four seconds。 So yeah， pretty simple example。
    We can easily run something in a new thread using future。 Okay。 But what about
    combining two things？ Looks like we saw a flat map to combine our options and
    our tries。 We can do the same sort of higher order function that we saw to combine
    features。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时间大约是四秒。里面的睡眠时间使其大约为四秒。所以是的， pretty simple 的示例。我们可以很容易地使用未来在新线程中运行某些东西。好的。但结合两个东西呢？看起来我们看到扁平映射来组合我们的选项和尝试。我们可以做同样的高阶函数来组合特征。
- en: So here we have two threads。 One is going to sleep for three seconds。 Return
    100。 The other one is going to sleep for five seconds。 Return the value 50 and
    then what we want to do is sort of add up those two results。 right？ So you can
    see result one we call featured out run， result two we call a future， the second。
    function and then we say result one we flat map it into result two and we add
    their two。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里有两个线程。一个将睡眠三秒，返回100。另一个将睡眠五秒，返回值50，然后我们想做的是将这两个结果相加，对吗？所以你可以看到结果一我们称之为特征执行，结果二我们称之为未来，第二个函数，然后我们说结果一我们扁平映射到结果二，并将它们相加。
- en: values and we add a little callback。 So the callback here is doing the same
    thing that we did in the more imperative example where。 we're trying to calculate
    what is the total overall running time like you see。 So in this example one thread
    took three seconds and other thread took five seconds。 Both threads executed in
    parallel。 Once the longer thread was done it combined the results。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一些回调。所以这里的回调做的事情与我们在更具命令性的示例中所做的相同。我们试图计算整体运行时间。所以在这个示例中，一个线程用了三秒，另一个线程用了五秒。两个线程并行执行。一旦较长的线程完成，它就结合了结果。
- en: We got the value 150。 It was roughly more or less five seconds of execution
    time。 So what happens then if something were to go wrong though？
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了150的值。执行时间大约是五秒。那么如果出了什么问题呢？
- en: So in this example we'll deal with an error。 So the first function is actually
    going to just throw an exception which we know is impure。 but for this example
    we'll go ahead and do it anyway just to see what kind of happens。 And now on our
    callback we have the same code to flat map and map but on our callback。 because
    once the feature is complete it sort of behaves like a try。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这个示例中，我们将处理一个错误。第一个函数实际上会抛出一个异常，我们知道这不是纯的。但在这个示例中，我们还是会这样做，看看会发生什么。在我们的回调中，我们有相同的代码来扁平映射和映射，但在我们的回调中。因为一旦特征完成，它的行为就像一个尝试。
- en: It has a success and a failure and we can check that。 So in my callback on this
    example now I simply we can simply check did the result fail or。 did it succeed
    and handle those two use cases separately。 So in this example again it ran both
    things in parallel the three second thread and the。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个成功和一个失败，我们可以检查它。所以在我这个示例的回调中，我简单地检查结果是失败还是成功，并分别处理这两种用例。所以在这个示例中，它再次并行运行了三秒线程和。
- en: five second thread the three second thread failed so it never actually had to
    you know。 the five second thread kept running but for the purpose of the computation
    it actually。 finished in three seconds because it got the error and it error out。
    So we have this sort of callback style on the feature that we can use to check
    if the value。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 五秒的线程，三秒的线程失败了，所以它实际上没有完成。五秒的线程一直在运行，但在计算的目的上，它实际上在三秒内完成了，因为它遇到了错误并报错。因此我们有这种基于特征的回调风格，可以用来检查值。
- en: once it's complete succeeds or fails。 Okay but I'm going to go up a couple slides
    here。 So in this example where we are combining features using flat map and map
    comprehensions。 and stuff like that we could easily see okay so we have two threads
    running here two results。 values asynchronous computations that we care about
    the result but what if there was three。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它完成，无论成功还是失败。好的，但我会跳到几张幻灯片。我们在这个示例中使用扁平映射和映射理解组合特征。我们可以很容易地看到，好吧，所以这里有两个线程在运行，两个结果。我们关心的异步计算的值，但如果有三个呢？
- en: or four or five or more results this could get you know map flat map map flat
    map over。 and over and over again this can get a little complicated and the real
    thing is so when。 I do feature。run I'm getting a feature value back and I get
    another feature value back and。 another feature value back and eventually I'm
    left with a list a list of future values。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 或者四个、五个或更多的结果，这可能会让你知道如何进行扁平映射，反复进行扁平映射，这可能会变得有点复杂。实际上，所以当我运行特性时，我会得到一个特性值，然后又得到另一个特性值，再然后是另一个特性值，最终我会得到一个特性的值列表。
- en: and what I really want to do is I want to sort of invert that instead of having
    a list。 of future values I would like a single feature with a list of values that
    have the combined。 results of all my threats and in like a language like Scala
    that function is called future。trovert。 it inverts the two things so it'll take
    a list of futures and make it a future list a future。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 而我真正想做的是，我想反转这个，而不是拥有一个特性值列表，我希望有一个单一的特性和一个值列表，这些值结合了我所有威胁的结果。在像Scala这样的语言中，这个函数被称为future.trovert。它反转这两个东西，所以它将一个特性列表转化为一个特性列表。
- en: of a list right so let's go ahead and take a look at how that works right and
    so we have。 result one which is the same thing featured out run delay result one
    featured out to result。 to and here we call future。trovert and we supply the list
    of futures and then the same thing。 we just call the on complete handler to get
    the execution time and sort of like our final。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们来看一下它是如何工作的，我们有结果一，它与特性输出运行延迟相同，结果一特性输出到结果二，在这里我们调用future.trovert，并提供特性列表，然后同样的事情，我们只是调用完成处理程序来获取执行时间，类似于我们的最终结果，然后打印出来。
- en: result to print it out right so future。trovert we can see if we're dealing with
    like a lot。 of different sort of computational results we can quickly invert a
    list of futures into。 a future of a single list alright so some of the key takeaways
    here is that when we use。 side effects we can see that sometimes our code is not
    as explicit as we would like it。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所以future.trovert我们可以看到，如果我们处理的是许多不同类型的计算结果，我们可以迅速将一个特性列表反转为一个单一列表的特性。所以这里的一些关键要点是，当我们使用副作用时，我们可以看到有时我们的代码没有我们希望的那么明确。
- en: to be that makes the code a little bit harder to reason about if the functions
    are more referential。 transparent if they're pure then it allows us sort of reason
    about our functions in a。 more localized manner and it opens up us using higher
    order functions and abstractions to。 sort of deal with common behaviors that we
    might have in our code we saw the examples。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数是更具引用透明性的，那么它会使代码更难以推理。如果它们是纯的，那么它使我们能够以更局部的方式推理我们的函数，并且它为我们使用高阶函数和抽象提供了机会，以处理我们代码中可能存在的常见行为，我们看到了这些例子。
- en: dealing with emptiness dealing with concurrency and dealing with exceptions
    and all of these。 examples as you can see they sort of just like English they
    read left to right we're。 no longer sort of writing if statements and things that
    are nested and harder to read everything。 is just reading left to right we get
    an input value we apply some functions and we get a。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 处理空值、并发和异常，所有这些例子正如你所看到的，就像英语一样，从左到右阅读，我们不再编写嵌套的if语句和更难阅读的内容，一切都是从左到右阅读，我们获取输入值，应用一些函数，然后得到一个。
- en: return value and that is sort of how a functional program or thinks about the
    world how they。 think about programs and how they want every program to kind of
    behave and that's really。 all I had thank you guys so much that's my Twitter handle
    vikumar 1981 and that's my， get up page。 Thanks， WIC for that wonderful talk I
    would now like to I would like to open the floor。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值，这就是函数式程序员如何看待世界，如何看待程序，以及他们希望每个程序都以某种方式运行，而这就是我想说的，谢谢大家，这是我的推特账号vikumar1981，这是我的GitHub页面。谢谢WIC带来的精彩演讲，现在我想打开讨论。
- en: for discussion and invite questions from the audience。 Thank you。 Thank you。
    Okay on time。 Any questions for WIC？ Okay。 Thank you。 [Music]， In the future example
    why was it a list of int versus a list of try event？
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 进行讨论并邀请观众提问。谢谢。谢谢。好，准时。有没有关于WIC的问题？好的。谢谢。[音乐]，在未来的例子中，为什么是一个整数列表而不是一个尝试事件列表？
- en: Yes。 Okay so on the callback it's just a single try event so you have actually
    you might be。 right maybe I do I'm going to look at my slides that's a very good
    question you might be。 right because it's optional static typing maybe I did screw
    up the optional annotation。 on that let me actually check my slide real quick。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。好的，所以在回调中，这只是一个单一的尝试事件，所以你实际上可能是对的。也许我会查看我的幻灯片，这个问题很好，你可能是对的，因为它是可选的静态类型，也许我确实搞错了可选注解。让我快速检查一下我的幻灯片。
- en: The reason I asked is the previous example only without the traverse had the
    try in so I was。 wondering。 Okay this example right here right。 Yeah and versus
    the previous example that had just result as a try and。 Oh right right right so
    handle result takes in a list of the here the handle result takes。 in a list of
    in versus this example where it's a try of a single int。 Yes。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我问这个的原因是之前的例子没有遍历，只有尝试，所以我在想。好的，这个例子对吧？嗯？与之前的例子相比，只有结果作为尝试。哦，对，确实如此，所以处理结果接受一个列表，而这里的处理结果接受一个单一的整数的尝试。是的。
- en: Okay no that could be that's error on the slide actually you are right it should
    be a try of。 list event on that because you can check success and failure it is
    the try of list event I。 should have probably corrected that。 And then what would
    there be a list of try and versus a try list and。 Okay so what is the difference
    or。 Yeah so a list of try event is sort of a little harder to because each individual
    try now you。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，不，这可能是幻灯片上的错误，实际上你是对的，它应该是一个列表事件的尝试，因为你可以检查成功和失败，这是列表事件的尝试，我可能应该更正这个。那么尝试列表和列表的尝试之间有什么区别呢？好的，区别是什么？嗯，所以列表尝试事件有点难，因为每个单独的尝试现在。
- en: have to check the success and failure but if you have a try of list event I
    can check the。 success and failure of the whole thing right did this all the succeed
    or did all of it fail。 so inverting it becomes like a little useful because now
    I can just check the whole thing。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 必须检查成功和失败，但如果你尝试列表事件，我可以检查整个事情的成功和失败。到底是全部成功了，还是全部失败了？所以反转过来就变得有点有用，因为现在我可以直接检查整个事情。
- en: '![](img/74053c9ae9782a56d9156bf3f73c215e_4.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74053c9ae9782a56d9156bf3f73c215e_4.png)'
- en: right does that make sense。 Yeah it makes sense thank you。 [BLANK_AUDIO]。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这有意义吗？是的，确实有意义，谢谢。[BLANK_AUDIO]。
- en: '![](img/74053c9ae9782a56d9156bf3f73c215e_6.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74053c9ae9782a56d9156bf3f73c215e_6.png)'
