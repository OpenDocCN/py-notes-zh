- en: P39：Talk - Henry Fredrick Schreiner III_ Building a binary extension - VikingDen7
    - BV1f8411Y7cP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P39：演讲 - 亨利·弗雷德里克·施赖纳三世_ 建立二进制扩展 - VikingDen7 - BV1f8411Y7cP
- en: Good morning everybody。 Thank you so much for being able to join us this morning。
    We have。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大家早上好。非常感谢你们今天早上能参加我们的活动。我们有。
- en: '![](img/738d8639b8493010cb054fb10c6b232c_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/738d8639b8493010cb054fb10c6b232c_1.png)'
- en: '![](img/738d8639b8493010cb054fb10c6b232c_2.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/738d8639b8493010cb054fb10c6b232c_2.png)'
- en: one more talk and then glorious lunch。 I know you're all looking forward to
    it but hang。 tight because this promises to be really， really cool。 So today we're
    going to hear from Henry。 Schreiner building a binary extension。 Henry Schreiner
    is a computational physicist/research。 software engineer in high energy physics
    at Princeton University。 He specializes in the。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 再来一个演讲，然后就可以享受美妙的午餐。我知道你们都很期待，但请耐心等待，因为这将会非常、非常酷。今天我们将听到亨利·施赖纳的演讲，主题是建立二进制扩展。亨利·施赖纳是普林斯顿大学高能物理学的计算物理学家/研究软件工程师。他专注于这个领域。
- en: interface between high performance compiled codes and interactive computation
    in Python。 in software distribution and in interface design。 He's previously worked
    on computational。 cosmic ray tomography for archaeology and high performance GPU
    model fitting。 He's currently。 a member of the IRIS-HEP project developing tools
    for the next era of the Large Hadron。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在高性能编译代码和Python中的交互计算之间的接口。在软件分发和接口设计方面。他之前在考古学的计算宇宙射线断层成像和高性能GPU模型拟合方面工作过。他目前是IRIS-HEP项目的一员，正在开发下一时代大型强子对撞机的工具。
- en: Collider LHC。 Ladies and gentlemen， Henry Schreiner。 Thank you。 So I'm Henry
    Schreiner。 and I'm working with the IRIS-HEP project which is basically trying
    to build a set of。 Python tools to replace and augment the existing C++ that we've
    been using in energy physics。 since the mid-90s。 We actually have a C++ interpreter
    if you probably don't want to know that。 So。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 大型强子对撞机。女士们，先生们，亨利·施赖纳。谢谢。 我是亨利·施赖纳，我正在参与IRIS-HEP项目，基本上是试图建立一套Python工具，以替代和增强我们自90年代中期以来在能量物理学中使用的C++。我们实际上有一个C++解释器，但你可能不想知道这个。
- en: we've been building up these tools and one of the things that was really important
    with。 this is we have very high performance requirements in certain areas。 We
    have the largest academic。 data set in the world for example。 And so with this
    it becomes really， really important。 to be able to do some of the things you'll
    be seeing today。 So I'm going to start with， a question。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在构建这些工具，其中一个非常重要的方面是我们在某些领域有非常高的性能要求。例如，我们拥有世界上最大的学术数据集。因此，这变得非常、非常重要，以便能够完成你今天将看到的一些事情。所以我先来问一个问题。
- en: Is Python fast？ So of course this is a completely ambiguous question。 A good，
    way to start。 But let's just take an example here。 This is an article that came
    out fairly。 recently within the last two years。 And they had this problem where
    they're projecting。 a billion cells and they had this Fortran code， 1500 lines，
    the Fortran code that did this。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Python快吗？当然，这完全是个模糊的问题。这是一个不错的开端。但是让我们举个例子。这是一篇在最近两年内发布的文章。他们面临的问题是投影十亿个单元，他们有一个1500行的Fortran代码来完成这个任务。
- en: in six hours and 30 minutes。 And finally they decided to rewrite this in Python
    and when。 they did that it took four minutes。 And the reason for this was really
    they had this high。 level language。 They had libraries that they could access。
    It allowed them to easily explore。 different algorithms。 If you have a billion
    cells you're doing projections。 You really。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在六个小时30分钟内。最后，他们决定用Python重写这个，当他们这么做时，只花了四分钟。这背后的原因主要是他们使用了这种高级语言，能够访问库，使他们能够轻松探索不同的算法。如果你有十亿个单元在进行投影，你真的。
- en: want to use something like a kd tree。 There's one in scipy so they just use
    that。 And so。 the key behind this is that you have a library and in that library
    you have compiled code。 that does the hard work for you and you're still able
    to stay in Python。 So Python has。 really great performance as long as you can
    find a library that has your desired algorithm。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 想要使用像kd树这样的东西。在scipy中有一个，他们就直接使用那个。因此，关键在于你有一个库，在那个库中你有编译的代码，为你完成繁重的工作，而你仍然可以保持在Python中。所以，只要你能找到一个拥有所需算法的库，Python的性能真的很好。
- en: in it like NumPy or Pandas or something like that。 But what do you do if you
    don't？ What。 do you do if you have some sort of algorithm that's not already coded
    up somewhere？ How。 do you write that yourself？ And that's what we'll be looking
    at。 So first possible solution。 to this would be you could just dump Python。 This
    is the Twitter and random article on。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 像 NumPy 或 Pandas 这样的库。但是如果你没有这些呢？如果你有某种算法还没有被编写出来，你该怎么办？你怎么自己编写它？这就是我们将要研究的内容。所以这个问题的第一个可能解决方案是，你可以直接放弃
    Python。这是 Twitter 上的一篇随机文章。
- en: the internet solution。 And maybe you're enticed by these other languages。 Is
    anybody enticed， by C？
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 是网络解决方案。也许你被其他语言所吸引。有谁会对 C 感兴趣吗？
- en: Yeah。 But they offer native performance。 Well， Python though is really easy
    to learn。 It's very quick to write and it has this massive ecosystem。 I would
    say each of these three。 things are equally important and incredibly important。
    So you'll see and this is where。 we'll get with the final solution。 You might
    already guess that by the title of the talk。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，但它们提供原生性能。不过，Python 确实很容易学习。它非常快速，拥有庞大的生态系统。我认为这三件事情同样重要且极其重要。所以你会看到，这就是我们最终解决方案的所在。你可能已经通过演讲的标题猜到了这一点。
- en: So you can split the driver code and that's the stuff that usually takes the
    most time。 to work on and that's what you're manipulating working with。 That can
    still be in Python and。 then you can just move the performance critical code to
    something else and work together。 Before we go on though， there's a few other
    possible solutions。 One is a number。 This。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以将驱动代码拆分，这通常是耗时最多的部分。那是你正在操作的内容。它仍然可以用 Python 编写，然后你可以将性能关键代码移动到其他地方并一起工作。不过在继续之前，还有其他一些可能的解决方案。一个是数字。这。
- en: is just in time compiler for Python。 If this is just as fast or faster than
    any other solution。 you can come up with most of the time。 But it does have some
    downsides。 You are going。 to have to do the just in time compiling on your on
    the device。 It's a somewhat heavy， dependency。 There's plus sides and downsides。
    But if you just want to make it faster， this。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个针对 Python 的即时编译器。如果这个编译器的速度和其他解决方案一样快或更快，你可以在大多数情况下使用它。但它确实有一些缺点。你需要在设备上进行即时编译。这是一个相对较重的依赖。它有优点和缺点。但如果你只是想让它更快，这就是今天的解决方案。
- en: might be the first thing to try。 This would be the first thing I would try。
    Another solution。 is you can just make Python itself faster。 There's a variety
    of different packages and。 projects that do this。 You have PyPy for quite a while。
    PyCon is a bit newer one。 And then。 there's even forks of CPython to try to make
    it faster。 And CPython itself is actually。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是你要尝试的第一件事。这将是我会尝试的第一件事。另一个解决方案是你可以让 Python 本身更快。有各种不同的包和项目做到这一点。你可以使用 PyPy
    已经有一段时间了。PyCon 是一个相对较新的项目。然后，还有 CPython 的一些分支，试图让它更快。而 CPython 本身实际上是。
- en: interested in getting faster now too。 These sorts of things are in the say 5x
    performance， range。 Maybe five times faster。 At least for CPython。 But they don't
    really make heavy。 numeric code faster because that's already sits in a compiled
    language。 It doesn't need。 to be made faster。 You may need more algorithms。 And
    of course the solution we'll be looking。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在也对加速感兴趣。这些类型的东西在性能上大约是 5 倍的提升。也许快五倍。至少对于 CPython 来说。但它们并没有真正加速重数值代码，因为那部分代码已经用编译语言编写了。它不需要被加速。你可能需要更多算法。当然，我们将要研究的解决方案。
- en: at today is this one。 You can precompile。 So you can write code using the CPython
    API。 or you can have maybe code sitting in an interface somewhere。 And then that
    can be compiled into。 an extension。 And you can then distribute that。 And it turns
    out that a lot of things。 you use every day are actually done for those things。
    And this works very， very well。 So first。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进行预编译。因此，你可以使用 CPython API 编写代码，或者你可以在某个接口中保留代码。然后可以将其编译成扩展。然后你可以分发它。结果是你每天使用的很多东西实际上都是为这些东西完成的。这工作得非常好。所以首先。
- en: let's go into a little bit of what a binary extension is。 If you're using Python
    now， you。 probably think in terms of you have some code you're writing and then
    you're using libraries。 And if you were to write your own library， you probably
    start with this first one， this。 side on the left here。 You put all your library
    code in Python。 Well that code in the library。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨一下什么是二进制扩展。如果你现在正在使用 Python，你可能会认为你有一些代码要编写，然后使用库。如果你要编写自己的库，你可能会从左侧的第一个开始。你把所有库代码放在
    Python 中。好吧，那段库代码。
- en: can also be compiled code。 It can be a binary extension。 And the first one is
    really easy。 But the next one traditionally has been viewed as complex。 The examples
    tend to be rather poor。 Tinn to be things that a really large library like NumPy
    would do。 And there are lots of。 details in building these and distributing them
    that for example you need to compile。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以是编译代码。它可以是一个二进制扩展。第一个实际上很简单。但第二个传统上被视为复杂。示例往往相当糟糕。通常是一些像 NumPy 这样的大型库会做的事情。在构建和分发这些的过程中有很多细节，例如你需要编译。
- en: on every different platform you support that sort of thing。 But you can achieve
    really。 high performance。 And one of my goals in this talk will be to show you
    that this is actually。 not that hard to do。 You can do this yourself。 And the
    tooling around this and all that has。 become very， very good。 And it's really
    not as complex or as hard as it used to be。 Okay。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在你支持的每一个不同平台上都会出现这种情况。但你可以实现非常高的性能。在这次演讲中，我的一个目标是向你展示，这实际上并不难做到。你可以自己做到。围绕这一点的工具及其所有内容变得非常、非常好。实际上，它并没有以前那么复杂或困难。好的。
- en: So here's an example of what of wheels。 So I start my example with wheels for
    showing。 you something that's not a wheel。 That's an S-dist。 And that thing has
    a setup。py or。 a pipe project at Tomo or some collection of tools that allow a
    back end to build that。 Okay。 So that's where your source code sits。 Then you
    have this。 This is a pure Python wheel。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 wheels 的一个示例。我以一个非 wheel 的示例开始。那是一个 S-dist。那个东西有一个 setup.py 或一个 pipe project
    at Tomo，或一些工具的集合，允许后端构建它。好的。这是你的源代码所在的位置。然后你有这个。这是一个纯 Python 的 wheel。
- en: This is something usually that just contains Python。 You'll see the name there。
    It has。 the implementation API and platform。 And that's just Py3。 None。 Okay。
    And this doesn't have。 compiled extensions。 And then you have wheels that look
    like this。 These are the ones that。 have binaries in them。 And you see you have
    the implementation， the API。 Those have actually。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是只包含 Python 的东西。你会看到名称。它有实现 API 和平台。这就是 Py3。None。好的。这没有编译扩展。然后你会看到像这样的 wheels。这些是包含二进制文件的。你会看到你有实现和
    API。这些实际上有。
- en: been same most of the time in modern Python。 And then you have a platform which
    is your。 operating system and your architecture。 Okay。 And Pip will actually do
    the smart thing。 It'll pick the most specific ones。 So in my Py's case， they actually
    have a pure Python。 wheel and they compile。 So that way if you're not on one of
    these systems， it will fall， back。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 Python 中大多数时候都是相同的。然后你会有一个平台，那就是你的操作系统和架构。好的。Pip 实际上会做聪明的事情。它会选择最特定的版本。在我
    Py 的案例中，他们实际上有一个纯 Python 的 wheel，并且会进行编译。这样，如果你不在这些系统之一上，它将会回退。
- en: But most of you will probably be on one of those systems。 There's only a few
    cases。 where you end up falling back。 So things like NumPy are shipped。 There's
    no pure Python。 version of NumPy and they still ship quite well with this。 Okay。
    And we'll be looking。 at how to make this third one today。 So I've already gone
    over one of the two main reasons。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但你们中的大多数人可能会在这些系统之一上。只有少数情况下你才会回退。因此像 NumPy 这样的东西被发布。没有纯 Python 版本的 NumPy，它们仍然能很好地发布。好的。今天我们将看看如何制作第三个。因此我已经讨论了两个主要原因之一。
- en: to compile。 You can get performance。 It's also useful for code reuse。 You can，
    there's。 already great libraries out in these other languages。 You can just use
    those in your compile extensions。 You don't have to rewrite them。 Or maybe you
    want to write something that works in both， languages。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后你可以获得性能。这对于代码重用也很有用。你可以，这里已经有出色的库在其他语言中。你可以直接在你的编译扩展中使用它们。你不必重写它们。或者也许你想编写一个在两种语言中都能工作的东西。
- en: So this is just a collection of some different libraries that support or that，
    ship binary wheels。 Things like PyTorch and MyPy， Pandas， NumPy。 And you'll see
    non-scientific。 numeric things in there as well。 You see UV loop and twisted。
    Web sockets。 Okay。 So we'll。 start this talk also with a few disclaimers。 This
    will be a bias talk。 I'll be showing。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这只是一些不同库的集合，它们支持或发布二进制 wheels。像 PyTorch、MyPy、Pandas、NumPy 这样的东西。你也会在里面看到非科学的数值内容。你会看到
    UV loop 和 twisted Web sockets。好的。因此我们也会以一些免责声明开始这次演讲。这将是一次有偏见的演讲。我将展示。
- en: you things I work on。 But I like those projects enough to join them。 And those
    are the things。 I know the most about。 And we'll also be looking at good practices。
    Maybe they'll be best practices。 But this is definitely not the only way you do
    things。 Okay。 So you might be now saying， to me。 well， but it's hard。 Compiling，
    compiling code is hard。 It requires that you do a lot。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我所做的事情。但我很喜欢这些项目，愿意加入它们。这些是我最了解的事情。我们也将关注良好的实践。也许它们会是最佳实践。但这绝对不是你做事情的唯一方法。好的。所以你现在可能会对我说，嗯，但这很难。编译代码很难。它要求你做很多。
- en: more than just shipping a Python extension。 That's true。 But let's divide this
    problem。 up into three stages。 You've already sort of seen them。 First you have
    the actual writing。 of whatever you're interested in。 So that could be something
    that's written in C++ or。 it could be something that is in something that's like
    my Pis C。 So you write something。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅是打包一个 Python 扩展。这是对的。但让我们将这个问题分为三个阶段。你已经大致看到了它们。首先，你必须实际写下你感兴趣的东西。所以那可以是用
    C++ 编写的东西，或者它可以是类似于我的 Pi 是 C 的东西。所以你写一些。
- en: that looks like Python and you still want to compile it。 And then once you have
    something。 you want to compile， then -- and notice I'm skipping things like just
    here。 Because those。 are not -- those don't fall into this area。 And then you
    have a build system。 This is something。 that takes that code and produces the
    binaries。 Traditionally， this has been set up tools。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像 Python 的东西，但你仍然想要编译它。然后一旦你有了想要编译的东西——注意我跳过了诸如这里的东西。因为那些——那些不属于这个范围。然后你有一个构建系统。这是一个将代码转化为二进制文件的东西。传统上，这一直是设置工具。
- en: and disutills。 But this is starting to become a more interesting space and a
    little less。 tied to just that one specific view。 You'll see that again in a minute。
    And then you need。 a tool to do the wheel building。 Because once you have these
    things you need to produce。 wheels that are redistributed that can go out to all
    the different platforms。 And we'll。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他的工具。但这个领域开始变得更有趣，并且与仅仅那一种特定视角的联系变得更少。你稍后会再看到这一点。然后你需要一个工具来进行轮子的构建。因为一旦你拥有这些东西，你需要生产可以在所有不同平台上分发的轮子。我们将会。
- en: be focusing primarily on these -- this path through here。 There's lots of different
    paths。 we could take。 But this is the one I'll be focusing on today。 But it's
    -- I like this。 because it's a mix and match。 You may find some other binding
    tool or coding tool better， for you。 but you might still want to build wheels。
    That sort of thing。 Okay。 So starting。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我将主要关注这些——这里的这条路径。这里有许多不同的路径我们可以选择。但今天我将专注于这一条。我喜欢这个，因为它是混合搭配的。你可能会发现其他的绑定工具或编码工具更适合你，但你可能仍然想要构建轮子。就是这样的事情。好了，开始吧。
- en: with this bindings and coatings， there's sort of two choices here。 You can access
    existing。 compiled code。 So some of the tools sort of focus on that。 How do you
    get C++ or Go or。 Rust or something out？ And there's also from scratch code which
    is code you want to write。 and you want to make it faster。 You're not trying to
    reuse an existing algorithm。 And。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些绑定和编码，这里有两种选择。你可以访问现有的编译代码。所以一些工具专注于这一点。你如何将 C++、Go 或 Rust 之类的代码提取出来？还有从头开始的代码，这是你想要编写的代码。你希望让它更快。你并不想重用现有的算法。
- en: you probably want something that looks like Python。 So， Python and my Pis C，
    things like。 that tend to be in this sort of this category。 And you might even
    be able to make your extension。 optional a bit easier with this one because it
    may be even the same code。 So starting。 with this idea of interfacing the existing
    library where you're not actually writing， the binding。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要一些看起来像 Python 的东西。所以，Python 和我的 Pi 是 C 的东西。像这样的东西往往属于这一类。你甚至可能能够通过这个让你的扩展更容易选择，因为它可能甚至是相同的代码。所以开始。与现有库的接口想法，你实际上并不是在编写绑定。
- en: you have this sort of this side。 That's how you would load a library from C，
    types。 And then you have to build that shared object library somewhere and you
    have to do。 all of the work yourself。 And then Python also provides -- C Python
    provides this way。 to write your own extensions。 And that would be writing this。
    Now， most of the time you。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你有这一类的东西。这就是如何从 C 加载库，类型。然后你必须在某个地方构建那个共享对象库，而且你必须自己完成所有的工作。然后 Python 还提供——C
    Python 提供了一种写自己扩展的方法。这就是编写这个。现在，大部分时间你。
- en: should probably should not be writing this by hand。 But I'm just sort of illustrating。
    what you would need， what all these binding tools are actually doing behind the
    scenes。 They're writing stuff that looks like this。 And there's only sort of two
    important things， here。 And it's this -- the fact that you have this name that's
    dependent on the name。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 应该不应该手动编写这个。但我只是简单说明一下。你需要的是什么，这些绑定工具实际上在后台做了什么。它们写的东西看起来像这样。这里有两个重要的事情。就是这一点——你有一个依赖于名称的名称。
- en: of your module and that's how it knows to look up what it has and then you list
    what， you have。 Staying on the C interface side， let's just briefly mention a
    couple options， there。 C types is built in。 It's very simple， but you're really
    -- it's up to you to get。 everything right yourself。 So it's probably a good idea
    to try to wrap this in something。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你的模块，这就是它知道查找它拥有什么的方式，然后你列出你所拥有的。在 C 接口方面，让我们简单提一下几个选项。C types 是内置的。它非常简单，但你真的——要自己确保一切正确。所以尝试把它包装在某种东西中可能是个好主意。
- en: so that you have some sort of nice interface for your users。 And -- because
    it's not going。 to protect you if you do anything wrong。 This is a good way to
    get SEGFOLTS in C Python。 If you make a mistake here。 And CFFI is a tool heavily
    for that -- I think came out。 of the PIPI there。 They built sort of this tool
    that reads in the C headers。 It's a library。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你就有了一些很好的用户界面。并且——因为它不会保护你，如果你做错了什么。这是一个在 C Python 中获得 SEGFOLTS 的好方法。如果你在这里犯了错误。而
    CFFI 是一个专门用于此的工具——我认为它来自 PIPI。他们构建了这样一个工具，读取 C 头文件。这是一个库。
- en: you get on -- on PIPI。 PIPI。 You know I do that。 And you can sort of generate
    some of。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 PIPI 上找到。PIPI。你知道我这样做。你可以生成一些。
- en: '![](img/738d8639b8493010cb054fb10c6b232c_4.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/738d8639b8493010cb054fb10c6b232c_4.png)'
- en: this automatically and get some extra safety there。 Going back to the sort of
    traditional。 ways to do this， Numba actually also has the ability， besides being
    a jet。 I remember I。 said it would not be in this area， but it also has a head
    of time compile which looks， like this。 Where you can take a little function。
    You can put a export on the out and you have。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这样自动化并获得一些额外的安全性。回到传统的方式，Numba 实际上也有能力，除了作为 JET。我记得我说过它不会在这个领域，但它也有一个看起来像这样的提前编译。你可以取一个小函数。你可以在输出上放一个导出，然后你有。
- en: to tell it what the module name is。 Remember it has to get that module name
    in order to。 produce a extension because that's part of the interface。 And you
    could compile it。 They。 have this extension for just utils that you can just stick
    in there。 And then you could。 actually just run this and compile this ahead of
    time。 Ship it as a wheel。 It would not require。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 来告诉它模块名称是什么。记住，它必须获取模块名称才能。生成扩展，因为这是接口的一部分。你可以编译它。他们有这个仅用于 utils 的扩展，你可以直接放进去。然后你可以。实际上只是运行这个并提前编译它。将其作为
    wheel 进行打包。这不需要。
- en: Numba。 This is very limited， but it's an option。 And I've seen it used at least
    once in a。 real situation。 Another option is my pi C。 So this really piggybacks
    on top of modern。 Python typing。 So for example， you see this on the left。 You
    see a little piece of code。 It has type hints。 It's valid Python。 I can run this
    with Python。 You see Python fib。py。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Numba。这非常有限，但这是一个选项。我至少在一个真实场景中见过它被使用。另一个选项是我的 pi C。所以这实际上是基于现代 Python 类型的。例如，你在左边看到这个。你看到一小段代码。它有类型提示。这是有效的
    Python。我可以用 Python 运行这个。你看到 Python fib.py。
- en: Or I can compile it with my pi C。 And then I can run it and it will be 10 times
    faster。 Because it's actually compiling the function in the middle。 For comparison，
    if you did this。 with the JET， this would be 35 times faster。 You can't do it
    with the head of time compile。 because recursive is not supported in that head
    of time。 Compile that you saw。 Another。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我可以用我的 pi C 来编译它。然后我可以运行它，它会快10倍。因为它实际上是在中间编译这个函数。相比之下，如果你这样做。使用 JET，这将快35倍。你不能用提前编译来实现这一点，因为递归在那种提前编译中不被支持。你看到的那个编译。另一个。
- en: popular option is fast not quite Python。 And that's Python。 This has been around
    for a very。 long time。 It's a very good tool for doing this。 You can see some
    code over on the right。 This is not probably what you weren't used to seeing with
    the Python code， but this is。 actually valid Python and Python code。 There is
    an interface to do that。 There's also sort。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的选项是快速但并不完全是Python。这就是Python。它已经存在很长时间了。它是执行此操作的一个非常好的工具。你可以在右侧看到一些代码。这可能不是你习惯看到的Python代码，但这实际上是有效的Python代码。这里有一个接口来实现这一点。还有其他类型。
- en: of this weird hybrid between C and Python that they provide。 So it also has
    a custom， language。 That's what you see a bit more often。 And there's the code
    for running it， at the bottom。 And that's nine times faster。 So it's a little
    bit slower than the my pi。 C example for this little piece。 And it does have --
    Python does have some downsides。 It。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它们提供的C和Python之间的奇怪混合体。因此，它还具有一种自定义语言。这是你更常看到的。底部是运行它的代码。这比九倍快。因此，在这个小片段中，它比我的Pi
    C示例稍慢一些。而且Python确实有一些缺点。
- en: can actually bind C and C++， but it wasn't really built for that。 It will be
    very verbose。 if you try to do that。 And it's got a few caveats and drawbacks。
    But it's really good。 It was really designed sort of to allow you to write Python
    and then make it much faster。 and compile it。 It works well for that。 Okay。 And
    then pi by 11 is a header only P or C++。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上可以绑定C和C++，但它并不是为了这个目的而构建的。如果你尝试这样做，它会非常冗长。而且有一些注意事项和缺点。但它确实很好。它的设计初衷是让你能编写Python代码，然后使其速度更快，并进行编译。这在这方面效果很好。好的。然后Pi
    by 11是一个仅包含头文件的P或C++。
- en: interface。 And just to unpack that a bit， it means that it's really trivial
    to add it。 to a C++ project。 There are no special build requirements。 It's just
    C++ 11 or newer。 And。 there's no precompile phase。 You don't have to siphonize
    or use one of these other sort。 of tools to prepare it。 It's just straight C++。
    And you can kind of think of it as if。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接口。简单来说，这意味着将其添加到C++项目是非常简单的。没有特殊的构建要求。只需C++ 11或更高版本。而且，没有预编译阶段。你不必使用siphon或其他准备工具。这就是纯C++。你可以把它想象成。
- en: it was a C++ API for Python itself。 And it was really designed just to do the
    binding。 It was not designed to do these other things。 So here's a little example
    of what it looks。 like to use。 Pi by 11。 You include it。 You have your C or C++
    code that you're interested。 in binding。 And then you create a module。 Remember，
    it has to get the name of that module， somehow。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个针对Python本身的C++ API。它的设计目的是仅进行绑定。并不是为了执行其他功能。因此，下面是使用Pi by 11的一个小示例。你需要包含它。你有你感兴趣的C或C++代码进行绑定。然后你创建一个模块。记住，它必须以某种方式获取该模块的名称。
- en: So this is how you're telling it what the name of the module is so it can generate。
    the correct entry point。 And then you just take your--the M is the module object
    in Pi， by 11。 And you just can define an add。 And it will actually infer the signature
    and things。 like that from the thing that you pass in。 And you can actually compile
    this yourself， if you want。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你告诉它模块名称的方法，以便生成正确的入口点。然后你只需获取你的——M是Pi by 11中的模块对象。你可以定义一个add。它实际上会根据你传入的内容推断出签名等信息。如果你愿意，你实际上可以自己编译它。
- en: And this would just work as is。 There's lots of great features of Pi by 11。
    And I list a few of them here。 I won't go into them in extensive detail。 But it's
    quite powerful。 And it does--even supports WebAssembly with PiDye now。 And it
    has a variety of different。 things that it does。 There is one more I want to go
    into before we sort of dive in a little。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按原样工作。Pi by 11有很多出色的功能。我在这里列出了一些。我不会详细介绍它们。但它相当强大。甚至现在还支持使用PiDye的WebAssembly。它做了多种不同的事情。在我们深入之前，我想再讲一个。
- en: bit deeper。 And there is a sort of sequel to Pi by 11 called NanoBind， written
    by the， same author。 And this is C++ 17 only。 And it's Python 3。8 only。 It's built
    on top of， the fast call API。 Very similar API to Pi by 11 intentionally meant
    to be more limited。 And some of these ideas are being backported to Pi by 11 as
    well。 And I have some plots。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 更深入一点。还有一个名为NanoBind的Pi by 11的续集，由同一作者编写。这是仅支持C++ 17和Python 3.8的。它构建在快速调用API之上。API与Pi
    by 11非常相似，故意设计得更有限。其中一些想法也正在反向移植到Pi by 11。我有一些图表。
- en: here that show that it is much quicker to compile。 It was sort of designed with
    compilation。 time in mind because header only C++ libraries are really slow to
    compile。 The binaries are。 smaller。 Do keep in mind this is for a very basic example
    basically like a class and a， class。 So if your binary size is dominated by your
    binding tool， then you're probably。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了编译速度更快。它的设计是考虑到编译时间，因为仅包含头文件的C++库编译速度非常慢。二进制文件更小。请记住，这只是一个非常基本的示例，基本上就像一个类和一个类。因此，如果你的二进制大小被绑定工具主导，那么你可能。
- en: not compiling very much。 But smaller binary size and the runtime performance
    is faster。 Say if you're looping over something， Pi by 11 is a bit slow because
    it has a overload。 dispatch mechanism built in。 Which is very powerful and you
    shouldn't be looping over。 and calling a function over and over and over in Python
    probably。 You should try to find。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不太编译。但是较小的二进制大小和更快的运行时性能。如果你正在循环某个东西，Pi by 11会有点慢，因为它内置了一个重载调度机制。这非常强大，你不应该在Python中反复循环并调用一个函数。你应该尝试找到。
- en: some way to wrap the entire thing。 So this is an exciting new project。 It's
    only， a few months。 a couple months old now I think。 So we're going to dive into
    an example project。 I'm going to show you every single line of， code you need
    to create a compile extension for all platforms。 everything。 So I'll have， a reasonable
    amount of code。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有某种方式包装整个内容。因此，这是一个令人兴奋的新项目。它只是一两个月大。我想我们将深入一个示例项目。我将向你展示创建所有平台编译扩展所需的每一行代码。一切。因此，我将有一个合理的代码量。
- en: The sort of point of this is to show you how much code， and maybe point out
    a few things。 I'm not going to walk through every single line。 And。 I'm going
    to try to do something that's not completely trivial。 I'm going to try to take。
    CLI 11 which is a command line parser library。 My favorite command line parser
    library。 I also。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是为了展示你需要多少代码，也许指出一些东西。我不会逐行演示。我会尽量做一些不完全简单的事情。我将尝试使用CLI 11，它是一个命令行解析库。我最喜欢的命令行解析库。我也。
- en: wrote it so my UI。 But my stuff terminal uses it so。 So we're going to make
    a little wrapped。 version of this from Python。 That's not necessarily a good idea
    but it's a library I happen to。 know。 It's a good idea to know the library you're
    trying to wrap so you know how it works so。 you know how to expose it。 And we're
    just going to do sort of this minimal bit here。 So we。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我为我的UI写了它。但我的终端使用它。因此，我们将从Python制作一个小的封装版本。这不一定是个好主意，但这是我恰好了解的一个库。了解你试图封装的库是个好主意，这样你就知道它是如何工作的，以及如何暴露它。我们将做一些最小的工作。
- en: want to be able to create an app。 We want to add a flag。 We want to be able
    to check。 and see if that flag exists。 And we want to make sure that sort of basic
    nice cities are， there。 So we want to make sure that we can print the app and
    something nice will print。 out and that we get a keyer or something that depends
    or will check as a keyer out if we。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 想要能够创建一个应用程序。我们想添加一个标志。我们希望能够检查并查看该标志是否存在。我们想确保一些基本的漂亮城市在那里。因此，我们想确保能够打印应用程序，打印出的东西很不错。
- en: make a mistake。 So this is the entire binding code。 We're going to import pibind
    11 and it also has some wrappers， for the standard library things。 And a little
    bit of setup there。 Here we're creating a， new exception。 That exception is going
    to be， it's going to come from a keyer。 It'll， make a new armodule。option。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 犯了一个错误。这是整个绑定代码。我们将导入pibind 11，它也有一些标准库的封装，以及一些设置。在这里，我们创建一个新的异常。该异常将来自一个键控器。它将创建一个新的armodule.option。
- en: found for us。 And that will automatically wrap the exception。 so we don't need
    to bother with it down here。 We could。 We could throw a py colon colon。 keyer
    if we want to do。 But this is more declarative which is nice。 And then we create
    our app。 And。 then in the app we're going to define a few methods。 And so we're
    defining each one。 Notice。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 并且我们得到一个键控器或其他依赖于此的东西，如果我们为我们找到的。它会自动包装异常，因此我们不需要在这里处理。我们可以。如果我们想，可以抛出一个py colon
    colon。键控器。但这种方式更具声明性，这很好。然后我们创建我们的应用程序。在应用程序中，我们将定义几个方法。因此，我们正在定义每一个。注意。
- en: we even have some dunder methods there。 We set define get item and stir。 And
    then the。 thing on the other side can just be a lambda function。 Sometimes， like
    there in the middle。 you see that overload cast。 There it's actually -- it's binding
    to the function itself and it's。 overloaded so you have to pick which one。 Or
    you can just use a lambda function in C++。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至有一些 dunder 方法。我们定义了 get item 和 stir。然后另一边的东西可以只是一个 lambda 函数。有时，比如在中间，你会看到那个重载转换。那里实际上是——它绑定到函数本身，并且是重载的，所以你必须选择哪个。或者你可以在
    C++ 中直接使用一个 lambda 函数。
- en: and just throw that in there and let the compiler figure out which overloaded
    one you're after。 Or you can do more work if you want。 So it's really quite nice
    to be able to just use the。 lambda functions there。 And that's the binding code。
    Okay。 I said I'd show you every line。 of code so there's the init。py。 And also
    tests。 You should always test anything。 So let's at。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后把它放进去，让编译器弄清楚你想要哪个重载的函数。或者如果你愿意，可以做更多的工作。所以能够直接使用 lambda 函数真的很不错。这就是绑定代码。好的。我说我会给你展示每一行代码，所以这里是
    init.py。还有测试。你应该始终测试任何东西。所以让我们。
- en: least write some tests。 So this is basically the same thing I just showed you。
    But in test， form。 Okay。 All right。 We're going to leave that for a minute。 When
    you go back to the。 yellow slides we'll be back in our example。 Let's talk about
    build systems。 So there are。 some great examples of pure Python build systems
    that are now using PEP 6。21。 Things。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 至少写一些测试。这基本上和我刚刚给你展示的内容是一样的，但以测试形式。好的。我们先暂时放一放。当你回到黄色幻灯片时，我们会回到我们的例子。让我们谈谈构建系统。所以，有一些很棒的纯
    Python 构建系统的例子现在正在使用 PEP 6.21。
- en: like flit and hatch and others， including actually setup tools now。 But building
    binary。 your binaries your choices are somewhat limited。 So setup tools and disk
    utils has a lot of。 drawbacks。 It doesn't it is capable of building a file from
    C or C++。 But it really wasn't。 extended and doesn't add a lot of things just
    sort of basic things that most build systems。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 像 flit 和 hatch 以及其他工具，包括实际上现在的设置工具。但是构建二进制文件，你的选择有些有限。所以设置工具和磁盘工具有很多缺点。它可以从
    C 或 C++ 构建文件，但实际上并没有扩展，也没有增加很多东西，只是大多数构建系统会有的基本功能。
- en: would have like multi threaded builds or partial rebuilds and features of your
    compiler and。 just all these things that are built into tools like CMake and mason
    and stuff。 You can't even。 tell it what C++ standard you want to target。 It does
    actually have native Python support， though。 So this then has been extended by
    a lot of different packages。 So my PIC extends， this。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 比如多线程构建或部分重建和编译器的功能，以及像 CMake 和 mason 之类的工具中内置的所有这些东西。你甚至不能告诉它你想要针对哪个 C++ 标准。虽然它实际上有原生
    Python 支持。但这已经被很多不同的包扩展了。所以我的 PIC 扩展了这个。
- en: NumPy disk utils。 There's lots of examples of things that then write extensions
    and work。 with this even though it's you're kind of delving into the internals
    quite a bit。 And then there。 are a few from scratch。 I don't think actually in
    scans I'm not sure if that fully counts。 because that's also using at least a
    little bit of disk utils。 I saw disk utils showing。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 磁盘工具。有很多例子写扩展并与此工作，尽管你在某种程度上深入了内部。而且还有一些从头开始的。我不认为实际上在扫描中，这是否完全算作，因为那也至少使用了一点磁盘工具。我看到磁盘工具展示了。
- en: up inside its code base。 But I do want to point it out just because it was one
    of the。 earliest adopters of PEP 517 that supported compiled builds。 But mason
    py is out now and。 Motrin is one for Rust。 So we're starting to see some of those。
    There's also scikit build。 which is sort of what we'll focus on today。 Right now
    unfortunately it just wraps set。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在它的代码库内部。但我想指出这一点，因为它是最早支持编译构建的 PEP 517 的采用者之一。但现在 mason py 出来了，Motrin 是 Rust
    的一个。因此，我们开始看到一些这样的东西。还有 scikit build，这是我们今天要关注的。现在不幸的是，它只是包装了 set。
- en: of tools but there is a plan to move and I'll talk a little bit about the plans
    to try to。 get it over into this sort of， onto that side of the screen。 Python
    11 actually has this。 nice extension as well for setup tools。 So you can just
    grab this set of helpers and then。 you can add the， do a pipeline extension， you
    can tell it what C++ standard you want。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具，但有一个计划要转移，我会稍微谈谈计划，尝试把它转移到这个屏幕的另一侧。Python 11 实际上也为设置工具提供了这个很好的扩展。所以你可以抓取这一组助手，然后你可以添加，做一个管道扩展，你可以告诉它你想要什么
    C++ 标准。
- en: and just go with that。 If you have something that's simple you can do that。
    So scikit build is a tool from the makers of CMake to allow you to use CMake from
    Python。 And this started back in 2014。 It was announced at scipy。 It was originally
    PyCMake and then。 it was renamed a bit later。 And two of our most popular packages
    are the CMake package， for Python。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有简单的东西，可以做到这一点。因此，scikit build 是 CMake 制作的一个工具，允许你从 Python 中使用 CMake。这一切始于
    2014 年，在 scipy 上宣布。最初叫 PyCMake，后来稍后改名。我们两个最受欢迎的包是 CMake 包，适用于 Python。
- en: So if you do PEP install CMake you get CMake for pretty much all the binary。
    and all these different areas。 It has some really nice tooling。 I helped sort
    of update。 some of that。 And you can do the same thing with Ninja。 You can PEP
    install Ninja as well。 And that comes from the scikit build project。 And this
    is really exciting because it would。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你执行 PEP install CMake，你将获得几乎所有二进制文件的 CMake，以及这些不同的领域。它有一些非常不错的工具。我帮助更新了一些工具。你也可以使用
    Ninja。你也可以 PEP install Ninja。这来自 scikit build 项目。这非常令人兴奋，因为它会。
- en: allow you to use a very powerful existing build system， the most popular C++，
    C， et cetera。 build system directly from Python。 It has a couple new maintainers
    that joined in the。 last six months or so。 And it's definitely an exciting example
    there。 And just also if。 you need a refresher on CMake I wrote a book on CMake
    so you can go check that out。 Years。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 允许你直接从 Python 使用一个非常强大的现有构建系统，最流行的 C++、C 等构建系统。最近六个月左右，有几位新维护者加入了它。这无疑是一个令人兴奋的例子。如果你需要
    CMake 的复习，我写过一本关于 CMake 的书，所以你可以去查看一下。
- en: before this。 Okay。 As long as you use modern CMake it's actually quite nice
    and you'll， see that。 So there are some plans。 The idea is that we'll try to develop
    a scikit build。 core that will be a 517 builder avoiding setup tools and distuetills。
    That will give us hopefully。 we can sort of give a compatibility layer so the
    existing users will still work。 We'll。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前。好的。只要你使用现代 CMake，实际上会非常不错，你会看到的。因此，有一些计划。我们的想法是，我们将尝试开发一个 scikit build
    核心，成为一个 517 构建器，避免使用 setup tools 和 distutils。希望这样能为我们提供一些兼容层，使现有用户仍然可以使用。
- en: also have a way to do a direct build。 And then hopefully a proper setup tools
    extension。 because currently that's still sort of how you put these things together。
    But there might。 actually be some generalization that's happening in the， we're
    going to talk about this a bit。 in the packaging summit later。 So it might be
    nice if we could sort of generalize and。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种直接构建的方法。然后希望有一个合适的 setup tools 扩展，因为目前这仍然是将这些东西组合在一起的方式。但可能实际上会有一些概括，我们将在后面的打包峰会上稍微讨论一下。如果我们能概括一下，那会很好。
- en: not write an extension for every single system out there like Hatch， Poetry，
    etc。 And then。 also we need an extension discovery mechanism。 We might be working
    with CMake itself to do。 this because it would be really nice if we could just
    stick this in our Python requires。 Say I want to buy by eleven and then just immediately
    find it。 Right now you have to。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会为每个系统编写扩展，比如 Hatch、Poetry 等。此外，我们还需要一个扩展发现机制。我们可能会与 CMake 本身合作来实现这一点，因为如果我们可以将其直接放入
    Python 的需求中，那会非常好。比如，我想购买 by eleven，然后立即找到它。现在，你必须这样做。
- en: do a little bit more work to do that and you'll see in the next page that I
    just avoid this。 entirely in the example we'll be showing。 And you can read more
    about that proposal there。 Alright。 so going back to our project。 This is our
    CMake list。 This is the whole thing。 We're actually just grabbing both PyBind
    11 and CLI 11 from GitHub because that way we。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 需要做一点额外的工作，你会在下一页看到我在示例中完全避免了这一点。你可以在那里阅读更多关于该提案的信息。好吧，回到我们的项目。这是我们的 CMake 列表。这是整个内容。我们实际上只是从
    GitHub 抓取 PyBind 11 和 CLI 11，因为这样我们。
- en: don't have to deal with the fact that we don't have a nice way to grab where
    PyBind 11 is。 And we have to do this with CLI 11 anyway because it's not a Python
    package。 So we're。 just grabbing those。 Then we add a module。 This is added by
    PyBind 11。 We link them。 We。 tell it we need C++ 14 because we use C++ 14 feature
    and then there's an install。 And。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 就不必处理找不到 PyBind 11 的问题。我们必须以同样的方式处理 CLI 11，因为它不是一个 Python 包。所以我们只是抓取这些。然后我们添加一个模块。这是由
    PyBind 11 添加的。我们链接它们。我们告诉它我们需要 C++ 14，因为我们使用 C++ 14 特性，然后进行安装。
- en: that's the CMake list。 Right now you have to write this setup。py as well。 And
    this is。 what I mentioned about the wrapper for the regular setup。 And we have
    to stick this in。 Some of this does actually have to be inside the setup。py and
    can't be pulled out to set。 up by config。 Not all of it but some of it does。 Okay，
    so those are really the almost the entire。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 CMake 列表。现在你还需要写这个 setup.py。这就是我提到的常规设置的包装器。我们必须将其放入。有些内容实际上必须放在 setup.py
    内，不能提取到 set up 配置中。并不是所有内容都这样，但有些确实如此。好的，所以这些几乎是整个构建系统。
- en: build system。 The only remaining thing is we need to also request a psychic
    build and。 our build system requires。 Okay。 And we'll actually fill out some more
    of the Py project， at Tomo。 We're not done with that yet。 But we'll leave it there
    for now。 The next thing。 we need to do is to redistribute。 So we need to build
    wheels。 So you could distribute on。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的事情是我们还需要请求一个心理构建，而我们的构建系统需要。好的。我们实际上还会填写一些 Py 项目，Tomo。我们还没有完成。但我们先停在这里。接下来，我们需要重新分发。因此，我们需要构建轮子。这样你就可以在
    Python.org 上分发你想要的目标。
- en: Conda Forge。 I'm not going to go into that in detail just because it's really
    mostly automated。 You just have to go out and write a recipe and their CI will
    build that for you。 And you， know。 a lot of the stuff that we do we really want
    to make sure we distribute on both。 But。 we'll be focusing on PyPI。 And there
    we have a variety of different things that we have。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Conda Forge。我不打算详细说明，因为它主要是自动化的。你只需写一个配方，他们的 CI 就会为你构建。而且，你知道，我们做的大部分事情，我们真的想确保在两者之间分发。但我们将专注于
    PyPI。在那里，我们有各种不同的内容。
- en: to deal with。 So on Linux we need to build inside of a controlled Docker image
    to make。 sure that we're not using something that's not allowed in the mini Linux
    specification。 You don't want to pull something in that or use the version of
    Glib C that's too new or。 something like that。 So there's Mini Linux and Mucil
    Linux images。 And you know， there's。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这一问题，因此在 Linux 上，我们需要在受控的 Docker 镜像内构建，以确保不使用不符合 Mini Linux 规范的内容。你不想拉取或使用过于新版本的
    Glib C 或其他类似内容。所以有 Mini Linux 和 Mucil Linux 镜像。而且，你知道，这些都有多种架构。
- en: also multiple architectures for all of these。 And you really should be running
    audit wheel。 afterwards to make sure that this is packaged up into a nice mini
    Linux image。 Alright。 mini Linux wheel。 Back OS you now have to worry about the
    target version。 You have to。 pick what version you target。 It's really a nice
    feature of Mac but you also have to。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些，你真的应该在之后运行 audit wheel，以确保这被打包成一个漂亮的 Mini Linux 镜像。好的，Mini Linux wheel。现在你需要关注目标版本。你必须选择你想要的版本。这是
    Mac 的一个不错的功能，但你也必须考虑这一点。
- en: think about it。 And you also need to make sure your Python was compiled with
    whatever that。 target was。 So you really want to use the Python。org Python。 You
    don't want to grab the。 CI or whatever because that was probably targeting the
    thing it built on which is probably Mac OS。 10。15 or something like that。 But
    you really want to use the 10。9 when the target's 10。9。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要确保你的 Python 是使用那个目标编译的。所以你真的想使用 Python.org 的 Python。你不想抓取 CI 或其他东西，因为那可能是针对它构建时的版本，可能是
    Mac OS 10.15 或其他版本。但当目标是 10.9 时，你真的想使用 10.9。
- en: from Python。org so that you have your choice of what you want to target。 And
    then you have。 to worry about cross compiling for universal。 And there's a separate
    tool there。 Same thing。 again for Windows。 Windows is actually the easiest of
    these because you can pretty much。 grab Python from anywhere and it'll work。 Please
    make sure you still distribute 32-bit。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要担心通用的交叉编译。那里有一个单独的工具。Windows 的情况也是如此。Windows 实际上是这些中最简单的，因为你几乎可以从任何地方抓取
    Python，它都能工作。请确保你仍然分发 32 位，因为你仍然会看到一些 32 位的 Python 在流动。甚至我的笔记本上也有一个。
- en: because you still see some 32-bit pythons floating around。 And even laptop I
    have one。 And then there's beginning to be ARM support on Windows as well。 And
    then there's also。 there's beginning to be a there's a very fairly young tool
    called the VEL wheel that's appearing。 here that also helps you sort of package
    and make sure anything that you use is bundled。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 Windows 上也开始有 ARM 支持了。此外，还有一个相当年轻的工具叫 VEL wheel，它正在出现，也有助于你打包并确保你使用的任何东西都被捆绑在一起。
- en: into your wheel for you。 So I want to go straight into CI build wheel。 This
    is a tool to do this。 all of this for you。 It supports all the major CI providers
    and it runs locally。 It ran locally。 for Linux for a long time but it actually
    supports Windows and Mac OS locally now too。 And this tool has really taken off
    in the last couple years。 I joined it I think in 2020。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 直接进入 CI build wheel。这是一个为你做所有这些事情的工具。它支持所有主要 CI 提供者，并且在本地运行。它在 Linux 上本地运行了很长时间，但现在也支持
    Windows 和 Mac OS。本工具在过去几年里迅速发展。我在 2020 年加入了它。
- en: And then pushed to get this into the PIPA。 It joined and we have over at least
    I think we。 have at least 600 users now which include almost everything you saw
    in that first slide。 like my pie and numpies just has just started has just moved
    to it。 And so this supports。 sort of all the different possible wheels that you're
    likely to want。 So you can target。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后推动将其加入 PIPA。它已加入，我们现在至少有 600 名用户，包括你在第一张幻灯片中看到的几乎所有内容。像 my pie 和 numpies 刚开始并刚刚转移到它。因此，这支持你可能想要的所有不同的
    wheels。所以你可以进行目标。
- en: any version of Mac OS。 You can do Apple Silicon for all the Python versions
    that support it。 which is 3。8 and newer。 All the variants of many Linux including
    the ones that you might。 have to emulate or some CI providers have native runners。
    Mucil Linux was added fairly recently。 PIPA supported。 And this will also go through
    do the repair step I showed you。 It will test。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 任何版本的 Mac OS。你可以对支持 Apple Silicon 的所有 Python 版本进行操作，即 3.8 及更新版本。包括你可能需要模拟的许多
    Linux 变种，或者一些 CI 提供者拥有原生运行器。Mucil Linux 最近被添加。PIPA 也支持。它还会执行我给你展示的修复步骤。它将进行测试。
- en: your wheels if you tell it what command you need to test it。 It will install
    it in a brand。 new environment and make sure that your wheel actually does what
    it says it does and passes。 your tests pulled directly from the wheel you built。
    And the defaults are all pinned。 You。 can't unpin those but they're all pinned
    and updated regularly。 And then there's some new。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你告诉它你需要测试的命令，它会在全新的环境中安装它，并确保你的 wheel 实际上按所说的那样工作并通过测试。这些测试直接从你构建的 wheel 中提取。默认值都是固定的。你不能取消固定，但它们都是固定的并定期更新。然后还有一些新的。
- en: features that have come out recently right after we joined the PIPA。 We had
    CI Build Wheel， 2。 That include our PIPrygetic。tonal support which you'll be seeing
    in a minute which I'm。 quite happy about。 And then over the last few months we've
    been adding even more things like。 the overrides which is powerful but I won't
    be showing you today。 And as I mentioned the。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最近发布的一些功能是在我们加入 PIPA 后立即推出的。我们有 CI Build Wheel 2。这包括我们的 PIPrygetic。tonal 支持，你马上就会看到，我对此非常高兴。过去几个月，我们还增加了更多功能，例如强大的覆盖功能，但今天我不会向你展示。正如我提到的。
- en: local runs experimental windows arm support and though we don't have any runners
    for that。 yet in CI。 That is。 And in 2。5 which was released this morning we also
    have a support。 for the stable ABI。 So you can do a limited API stable ABI build
    and it will build the。 first wheel and then just test all the rest and not try
    to build it again because it's。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本地运行实验窗口的 ARM 支持，尽管我们还没有为 CI 提供任何运行器。这就是。并且在今晨发布的 2.5 中，我们也有了对稳定 ABI 的支持。因此，你可以进行有限
    API 稳定 ABI 构建，它将构建第一个 wheel，然后测试其余部分，而不再尝试重新构建，因为它已经构建好了。
- en: already built。 And you can also build directly from an S-test。 You can just
    grab an S-test， off。 PIPI and then run CI build wheel on it and you can produce
    your wheels。 And we are。 supporting Tomalib now。 A few tips。 This is how you'd
    run it locally。 When you do it locally。 you just have to and I'm just using PIPX
    run there but any way you like to run it I would。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以直接从 S-test 构建。你可以直接从 PIPI 获取一个 S-test，然后在其上运行 CI 构建 wheel，你可以生成你的 wheels。我们现在支持
    Tomalib。几个提示。这就是你如何在本地运行它。当你在本地运行时，你只需， 我只是使用 PIPX 运行，但你可以选择任何你喜欢的方式。
- en: recommend that way。 You just tell it what platform you want to target。 That
    uses Docker。 for Linux so that works on your Mac or Windows or whatever you are
    as long as you can run， Docker。 You can build， you can target Linux but you always
    have to tell it the platform。 and that way it knows that you intentionally are
    trying to build wheels because it may take。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议这样做。你只需告诉它你想要针对的平台。这使用 Docker 进行 Linux，因此在你的 Mac、Windows 或其他任何地方都可以工作，只要你能运行
    Docker。你可以构建，目标是 Linux，但你始终需要告诉它平台。这样它就知道你是有意尝试构建 wheels，因为这可能需要。
- en: a while。 And then this is a really good tip for keeping it up to date。 We do
    provide an。 action and this will keep your action up to date。 So going back to
    our PyProject。Tomalib。 I can now finish showing it to you。 Here we tell CI build
    what command to run for testing。 That will turn on the testing feature。 And then
    we also tell it that I need to install。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间。然后，这个保持更新的技巧非常好。我们确实提供了一个操作，这将使你的操作保持最新。所以回到我们的 PyProject.Tomalib，我现在可以完成展示给你。在这里，我们告诉
    CI Build 运行什么命令进行测试。那将开启测试功能。然后我们还告诉它我需要安装。
- en: with the bracket test when I install the wheel because that's where I put the
    dependencies。 And then this is how you would do this for adding Apple Silicon。
    You have to pick for。 Apple Silicon if you want to use universal wheels which
    have both architectures put into。 one place or if you just want a native wheel。
    And so you just opt in for whichever way you， want。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我安装 wheel 时，我会带上括号测试，因为那里放了依赖项。然后，这就是如何为添加 Apple Silicon 进行操作。如果你想使用包含两种架构的通用
    wheels，你必须选择 Apple Silicon，或者如果你只想要一个原生的 wheel。所以你可以选择你想要的方式。
- en: And that's really the configuration。 There's a lot more options here。 You can。
    customize that however you like。 And you can do it through everything can be done
    through。 environment variables but this is a lot cleaner and nicer。 And lets you
    run it locally without。 having to redo all your environment variables。 And there's
    the PyTest stuff。 Okay， so now。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是配置。这里有更多选项。你可以根据需要自定义。所有操作都可以通过环境变量完成，但这样更清晰、更好，并允许你在本地运行而无需重新设置所有环境变量。还有
    PyTest 的内容。好的，现在。
- en: I'm going to show you the workflows。 This is the longest piece but I think you'll
    see。 it's not too bad。 First thing here and I'm doing this in GitHub。 You could
    do it some。 other system if you wanted。 First we're going to do this whenever
    we click publish or do。 publish from the GitHub command line whatever way you
    like to do that or if you want to。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示给你工作流程。这是最长的一部分，但我认为你会看到，实际上并不算太复杂。首先，我在 GitHub 中执行这个。如果你愿意，也可以在其他系统中执行。首先，每当我们点击发布或者从
    GitHub 命令行执行发布时，不管你喜欢哪种方式。
- en: manually trigger it。 And then because this will probably take a while you're
    going to。 be building a lot of wheels。 Then we're going to build an Estisk。 So
    that's you can just use。 build for that。 So we have a tool that can build wheels
    and Estisk and you can just use。 that to build the Estisk。 And PipEx is built
    into GitHub actions which is really nice and， Azure。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 手动触发它。因为这可能会花费一些时间，你将会构建很多 wheels。接着我们将构建一个 Estisk。所以你可以直接使用 build 来实现。我们有一个工具可以构建
    wheels 和 Estisk，你只需使用它来构建 Estisk。而 PipEx 已集成到 GitHub actions 中，这真不错，还有 Azure。
- en: So you can just do that one line。 You don't even have to get a version of Python。
    You can just use PipEx。 It's a supported platform which is fantastic。 It's actually
    used internally。 inside CI Build Wheels action。 The action is only about a page
    long。 All right。 And we。 just added something to Knox that does that too。 Okay。
    And then you know when to build， your wheels。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你只需执行那一行代码。你甚至不需要获取 Python 的版本。你可以直接使用 PipEx。这是一个受支持的平台，真是太棒了。它实际上在内部的 CI
    Build Wheels 操作中被使用。这个操作只有一页长。好吧。我们刚刚在 Knox 中也添加了一些功能。好的，然后你知道何时构建你的 wheels。
- en: I assume that you would think this one would be the most complex one and。 it
    might technically be but it's not too bad。 You mostly just do pipac。 I build wheel
    and。 then that's a good idea to use an exact version there and then use Dependabout
    to do that update。 for you。 So every time we release it it will then ask you to
    update and that way your wheels。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你会认为这是最复杂的部分，虽然技术上可能是，但其实没那么糟糕。你主要只需执行 pipac。我构建 wheel，然后在这里使用精确版本是个好主意，接着使用
    Dependabout 来为你更新。所以每次我们发布时，它会提示你更新，这样你的 wheels。
- en: don't crash because maybe we change something。 And that's about it。 We're running
    on all。 the platforms。 Okay。 And then finally we， you know， assuming you want
    to upload this， to PyPI。 you could also just download it from the interface and
    manually upload it yourself。 But you can。 because it's an artifact， but here's
    how you would upload it and you want。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不会崩溃，因为我们可能更改了一些内容。就是这样。我们在所有平台上运行。好的，最后，我们假设你想将其上传到 PyPI。你也可以直接从界面下载并手动上传。但你可以，因为它是一个工件，这里是你上传的方法。
- en: to make sure your wheels and your Estisk are finished before you do that。 And
    we're done。 This is what comes out。 This is what that produces。 This is every
    wheel and we put a minimum。 version of 3。7。 So this is every wheel。 It supports
    3。6 in New York。 And that's it。 That's。 you can see the Mac OS wheels there。 There's
    the universal。 There's the one for the， for。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的轮子和Estisk在你做那之前完成。我们完成了。这就是结果。这就是产生的东西。这是每个轮子，我们设置了一个最小版本3.7。所以这是每个轮子。它支持在纽约的3.6。就这样。你可以看到那里的Mac
    OS轮子。还有通用版本。还有针对英特尔架构的。
- en: the Intel architecture。 There's Mini Linux， Miesle Linux。 The two different
    windows ones。 The PyPI for 3。7， 3。8 and 3。9 over there。 They're all there。 If
    you're in the back， just the。 biggest point is there's a lot of things here。 And
    you saw how much work had to go into that。 Not that much。 And this scales。 This
    is something you can do on a very small little project。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有Mini Linux和Miesle Linux。两个不同的Windows版本。那边是3.7、3.8和3.9的PyPI。它们都在这里。如果你在后面，最大的问题是这里有很多东西。你看到了需要投入多少工作。其实不多。这是可以扩展的。这是你可以在一个非常小的项目上做到的事情。
- en: If you look at the CI build wheel examples page， you'll see small little projects。
    You'll。 see medium sized projects and you'll see giant ones。 So this， this scales
    really， really， well。 Simple enough for small projects and powerful enough for
    complex ones。 Also， maybe。 now that I've given you this sort of intern to what's
    possible， maybe you could think。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看CI构建轮子示例页面，你会看到小项目。你会看到中型项目，也会看到巨型项目。所以这个，真的可以很好地扩展。对小项目来说简单，对复杂项目来说强大。也许，既然我给了你这个关于可能性的介绍，也许你可以考虑一下。
- en: outside the box and mix and match these things in unusual ways。 So here's an
    example of clang。 format wheel。 And so that uses a scikit build which actually
    triggers LLVM's build。 It uses。 the CI build wheel to then build Python independent
    binary wheels。 You only need one。 So it just。 picks like 3。8 or something。 And
    then it makes sure that the final names don't have the 3。8。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 超越框架并以不同寻常的方式混合和匹配这些东西。这是一个clang格式轮子的例子。所以它使用scikit构建，实际上触发了LLVM的构建。它使用CI构建轮子来构建与Python无关的二进制轮子。你只需一个。所以它只选择像3.8这样的版本。然后确保最终的名称不包含3.8。
- en: part because it doesn't depend on CPython。 But it does depend on your platform。
    And then。 these are like one or two megabyte binaries that sit on PyPI。 There's
    no binding here。 This is only an entry point。 But this means you can just do PIPX
    run clang format and。 you can get clang format in a second or two on pretty much
    any system that you can run， on。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 部分原因是它不依赖于CPython。但它确实依赖于你的平台。这些就像是放在PyPI上的一到两兆字节的二进制文件。这里没有绑定。这仅仅是一个入口点。这意味着你可以快速运行PIPX
    run clang format，并且你几乎可以在任何可以运行的系统上在一两秒内得到clang格式。
- en: There's even a pre-commit wheel。 You can run this on pre-commit CI yourself。
    Before。 this project came out， I've been fighting Conda Forge to try to get this
    thing under， I。 think it was 500 megabytes to fit into the， to try to get a Conda
    environment that would。 fit in under 500 megabytes with clang format in it so
    that it could run it in pre-commit。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至还有一个pre-commit轮子。你可以在pre-commit CI上自己运行这个。在这个项目出现之前，我一直在与Conda Forge斗争，试图将这个东西压缩到500兆字节以下，以便能够在pre-commit中运行clang格式。
- en: dot CI because there was a limit。 Maybe it's 250。 I don't know。 And you know
    this was one。 to two megabytes per wheel。 So this is a really fantastic use I
    think of some of these things。 we've been seeing。 If you want to just quickly
    jump in and start working on this， I just want。 to do a little plug for something
    that I work on。 One of the scikit-hep pages， or products。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: dot CI因为有一个限制。也许是250。我不知道。而且你知道每个轮子大约是一到两兆字节。所以我认为这是一些我们一直在看到的东西的一个非常出色的使用。如果你想快速跳进去并开始工作，我只是想为我参与的一个项目做一个小宣传。一个scikit-hep的页面，或者产品。
- en: from scikit-hep is this developer pages。 I want to try to do a lightning talk
    on this。 too because I really like it。 And you can quickly make a package using
    even our， their。 cookie cutter。 So you can just say PIPX run cookie cutter。 Give
    it there。 PyBind 11 and。 as of yesterday now， CICIT build are back in choice。
    PyBind 11 has been there for， you， know。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 来自scikit-hep的开发者页面。我想尝试做一个关于这个的闪电演讲，因为我真的很喜欢它。你甚至可以使用他们的cookie cutter快速创建一个包。所以你只需说PIPX
    run cookie cutter。给它PyBind 11，而截至昨天，CICIT构建已回归选择。PyBind 11已经在那儿很久了。
- en: pure PyBind 11 setup tools has been there forever。 But scikit build just was
    added， yesterday。 So we now have 11 different backends。 A lot of pure Python backends，
    hatch， poetry， whatever。 you know， whatever you'd like， setup tools， two different
    setup tools， one for PIP， 6。0 anyway。 But。 and then for compiled ones， we also
    have a multi-in for Rust。 So if you。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 纯 PyBind 11 设置工具一直存在。但 scikit build 昨天刚刚添加。所以我们现在有 11 个不同的后端。许多纯 Python 后端，hatch，poetry，等等。你知道，无论你想要什么，设置工具，有两个不同的设置工具，一个用于
    PIP，6.0 不管怎样。但是。然后对于编译的，我们也有一个 Rust 的多合一后端。所以如果你。
- en: wanted to start a Rust package， this can get you started too。 And all this is，
    is tested。 with Knox and GitHub actions。 And we even have this also very new repo
    review page。 So。 you can just type in the name of a repository and you can type
    in a branch name， click the。 button and then Piedide will run Python 3。10 in your
    browser and it will then spit out the。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想开始一个 Rust 包，这也可以帮助你入门。所有这些都是经过测试的，使用 Knox 和 GitHub Actions。我们甚至还有这个非常新的仓库审查页面。所以，你只需输入一个仓库名称和分支名称，点击按钮，Piedide
    将在你的浏览器中运行 Python 3.10，然后输出结果。
- en: what guidelines you're following and what you're not from the， from the developer
    guidelines。 So that's quite， quite fantastic。 I would highly recommend taking
    a look at the second， app。org developer page。 So key takeaways here。 The code
    you just saw is， I've just put that。 into the repository。 If you want to look
    at it and that's， you can just see exactly， you。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你遵循了哪些指南，以及哪些没有遵循，来自开发者指南。所以这相当，相当棒。我强烈建议查看第二个，app.org 开发者页面。所以这里的关键要点。你刚刚看到的代码，我已经放入了仓库。如果你想查看，那你可以准确地看到。
- en: can see it work because it's there and they get to have actions。 Logs and things
    are there。 And then if you want to sort of find out a little bit more about this，
    my blog is at， isinempi。dev。 That includes links to the most important things
    I think that are here as， well。 There's a link to the， to the， to the， to the，
    to the， to the developer pages。 And。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它工作，因为它在那里，他们能够有操作。日志等都在那。如果你想了解更多关于这个的内容，我的博客在 isinempi.dev。那里包括了我认为最重要的内容的链接，以及开发者页面的链接。
- en: there's links to the Piedide 11 examples and to the scikit build examples。 And
    Piedide。 Piedide 11 has some very nice examples including just using setup tools，
    using scikit build。 or wrapping， see， make yourself using setup tools。 And then
    finally to end with a little。 bit about me， these are some of the things that
    I work on。 These are， these are the projects。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有指向 Piedide 11 示例和 scikit build 示例的链接。Piedide 11 有一些非常不错的示例，包括使用设置工具，使用 scikit
    build，或者包裹，看看，使用设置工具自己制作。最后，关于我，这些是我工作的内容。这些是，这些是项目。
- en: that I'm involved with and a member in some， in some form or， or some form or
    way。 If you， go to。 but most importantly again， my blog link which is actually
    old there， that will， take you there too。 But isinempi。dev or isinempi。gov。io
    will take you to my blog。 Okay。 And I guess。 we don't really have any questions。
    So thanks for your time。 [applause]， Thank you again。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我参与的一些项目，以及在某种形式或方式下成为成员。如果你去。但是最重要的是，我的博客链接其实很旧，它也会带你过去。但 isinempi.dev 或 isinempi.gov.io
    会带你到我的博客。好吧。我想。我们实际上没有任何问题。所以感谢你的时间。[掌声]，再次谢谢。
- en: We do not have any Q&A at this year's PyCon。 So if you do have any questions，
    for the speaker。 I encourage you to ask them over here outside of this room。 I
    also just。 want to take a moment before you leave for lunch to give a nice shout
    out to our audio。 team and to our transcriptionist for kicking butt today。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 今年的 PyCon 我们没有任何问答环节。如果你有任何问题，针对发言者。我鼓励你在这个房间外面问他们。在你离开吃午餐之前，我也想花一点时间好好感谢我们的音频团队和记录员，今天做得很棒。
- en: '![](img/738d8639b8493010cb054fb10c6b232c_6.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/738d8639b8493010cb054fb10c6b232c_6.png)'
- en: '[APPLAUSE]。'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]。'
