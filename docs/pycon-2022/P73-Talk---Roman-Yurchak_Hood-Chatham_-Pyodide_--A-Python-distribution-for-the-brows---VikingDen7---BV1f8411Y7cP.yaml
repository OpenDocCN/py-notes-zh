- en: P73：Talk - Roman Yurchak_Hood Chatham_ Pyodide_  A Python distribution for the
    brows - VikingDen7 - BV1f8411Y7cP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P73：演讲 - Roman Yurchak_Hood Chatham_Pyodide_一个用于浏览器的Python发行版 - VikingDen7 -
    BV1f8411Y7cP
- en: Okay， hello everyone。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，大家好。
- en: '![](img/59c5fc8db7748b7687462940bca51cbe_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59c5fc8db7748b7687462940bca51cbe_1.png)'
- en: '![](img/59c5fc8db7748b7687462940bca51cbe_2.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59c5fc8db7748b7687462940bca51cbe_2.png)'
- en: Thanks for coming。 Thanks to all the organizers and all that。 So we are two
    of the PIAIDIDE maintainers and we're here to tell you about PIAIDIDE。 which you
    may have heard about in Peter's talk this morning。 We are a PIAIDIDE distribution
    for the browser。 So a quick about us。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢大家的到来。感谢所有组织者等等。所以我们是PIAIDIDE的两个维护者，我们在这里告诉你们关于PIAIDIDE的事情，可能你在今天早上的Peter演讲中听说过。我们是浏览器中的PIAIDIDE发行版。那么，关于我们的简单介绍。
- en: So I am a UCLA national science foundation assistant adjunct professor， which
    means a， postdoc。 but there's like title inflation。 So yeah， so this work that
    I've done is partially supported by NSF grant。 department of material， science
    number， whatever， mathematical sciences。 Okay， here's Roman。 And I'm Roman， so
    I'm a data scientist working mostly as an independent consultant。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我是加州大学洛杉矶分校的国家科学基金会助理副教授，这意味着我是一名博士后，但这个头衔有点膨胀。所以是的，我所做的工作部分由NSF资助，材料科学部门，编号无所谓，数学科学。好的，接下来是Roman。我是Roman，主要作为独立顾问工作的数据科学家。
- en: And I'm a core developer for at CICET Learn and PIAIDIDE， so mostly projects
    that are。 difficult to pronounce。 Okay， so today we're going to talk about what
    is PIAIDIDE。 We're going to review some of the most common use cases， which include
    interactive computing。 educational use cases and machine learning。 And then we'll
    discuss a bit more in detail like the technical developments that has been。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我是CICET Learn和PIAIDIDE的核心开发人员，所以大多数项目都很难发音。好的，今天我们要讨论的是PIAIDIDE是什么。我们将回顾一些最常见的用例，包括互动计算、教育用例和机器学习。然后我们将更详细地讨论一些技术发展。
- en: going on in the last several years in PIAIDIDE。 Sorry。 So as you all know。 if
    you have a Python code and you want to run it in the browser， and。 this is also
    what we was presented in this morning's keynote， essentially the setup is。 fairly
    complicated because you have to have some front-end code in JavaScript， probably。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，PIAIDIDE发生了很多事情。抱歉。正如大家所知，如果你有Python代码并希望在浏览器中运行，这也是今天早上主题演讲中展示的内容，本质上设置是相当复杂的，因为你可能需要一些JavaScript的前端代码。
- en: some back-end code in Python and some infrastructure that you either need to
    maintain or configure。 if it's a cloud provider。 Right。 And so the idea is fairly
    simple。 What would we just run。 take this Python application and run it directly
    inside the browser？
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Python的后端代码和一些你需要维护或配置的基础设施，如果是云提供商的话。对吧。因此，想法相当简单。我们就直接在浏览器中运行这个Python应用程序如何？
- en: So this is possible with PIAIDIDE， sorry， WebAssembly。 And like the general
    implications of this were really well presented this morning in the。 keynote by
    PIAIDIDE。 So we're going to talk to introduce you， PIAIDIDE。 which is the distribution
    of Python in the， browser and with the focus of not so much just running the interpreter
    or like being able。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这在PIAIDIDE中是可能的，抱歉，是WebAssembly。而且，今天早上的PIAIDIDE主题演讲中很好地展示了这一点。因此，我们将向你介绍PIAIDIDE，它是在浏览器中的Python发行版，重点不仅仅是运行解释器或能够。
- en: to execute Python code but essentially being able to run existing packages and
    existing tools。 in the Python ecosystem。 Okay so first what is WebAssembly？
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 执行Python代码，但本质上能够运行现有的包和工具。在Python生态系统中。那么，WebAssembly究竟是什么呢？
- en: So WebAssembly is the second programming language available in the browser。
    It's a binary instruction format for a stack-based virtual machine。 It's portable。
    It's designed for small code sizes。 It's designed for security。 And so as part
    of that security。 it doesn't come with any sort of standard library that， it always
    has。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly是浏览器中可用的第二种编程语言。它是一种用于基于栈的虚拟机的二进制指令格式。它是可移植的，旨在生成小的代码体积，并且注重安全性。因此，作为安全的一部分，它并不附带任何标准库。
- en: It just defines a set of imports and it has a system for calling a function
    and so it can。 call the imports。 And so the host application has to define what
    gets the import。 It's implemented in all modern browsers， mobile browsers。 You
    can run it in non-web environments like Node。 WebAssembly system interface。 So
    yeah。 Anyway。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 它仅定义了一组导入，并且有一个调用函数的系统，因此可以调用导入。因此，主机应用程序必须定义导入的内容。它在所有现代浏览器和移动浏览器中实现。你可以在非网络环境中运行，如
    Node。WebAssembly 系统接口。所以，是的，总之。
- en: so that's what WebAssembly is。 And so then we have the inscript and build tool
    change。 So as I said。 WebAssembly itself has no standard library。 It can't do
    any input or any output。 It can only do pure computation。 All contact with the
    outside world has to happen through imports。 And so the inscript and build tool
    chain is a compiler tool chain that compiles C and。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 WebAssembly 的定义。接着我们有了 inscript 和构建工具链。正如我所说，WebAssembly 本身没有标准库，无法进行任何输入或输出，只能进行纯计算。与外部世界的所有联系必须通过导入来进行。因此，inscript
    和构建工具链是一个编译器工具链，编译 C 和。
- en: C++ code to WebAssembly。 This uses clang so you can set up a WebAssembly target
    for clang。 But then we also need an environment that supports system calls that
    actually interact。 with the outside world。 And so it also provides JavaScript
    bindings for all the system calls that you need。 It's designed for porting POSIX
    Linux applications。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 代码到 WebAssembly。这使用 clang，因此你可以为 clang 设置 WebAssembly 目标。但我们还需要一个支持与外部世界实际交互的系统调用的环境。因此，它还为你所需的所有系统调用提供
    JavaScript 绑定。它旨在移植 POSIX Linux 应用程序。
- en: So it has Postix Linux system calls implemented in JavaScript。 So then you can
    load this from an HTML page and serve it to a Web browser。 Yeah。 So the main components
    of Py， is really rich。 It allows for very easy usage of one language。 The other
    we'll talk more about this in a bit。 And then we take the C Python interpreter
    and our foreign function interface。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 它在 JavaScript 中实现了 Postix Linux 系统调用。然后你可以从 HTML 页面加载这个并服务于 Web 浏览器。是的，Py 的主要组件真的很丰富。它允许非常轻松地使用一种语言。另一个我们稍后会详细讨论。然后我们使用
    C Python 解释器和我们的外部函数接口。
- en: which is， like a C extension of Python。 We take these two things and we can
    compile them with them scripting into a WebAssembly。 binary with a JavaScript
    host that provides the operating system， all of the standard， library。 We also
    compile most of the popular Python binary extensions， including NumPy， Panda，
    SciPy。 Matplotlib。 Also we can compile cryptography。 So now we have Rust support
    very recently。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像是 Python 的 C 扩展。我们将这两者结合，可以将它们编译成一个 WebAssembly 二进制文件，配合提供操作系统的 JavaScript
    主机，所有标准库都在其中。我们还编译了大多数流行的 Python 二进制扩展，包括 NumPy、Panda、SciPy 和 Matplotlib。此外，我们还可以编译加密库。所以最近我们有了
    Rust 支持。
- en: And then we have a package called MicroPIP， which is for installing pure Python
    wheels from， PyP。 Yeah。 And we want to call out Michael Druhtbaum， who was a Mozilla
    employee who originally made。 Pyadide and did really great work on it。 And we've
    sort of been polishing the stuff that he set up。 Right。 So I mentioned upstream
    in RC Python patches。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有一个叫 MicroPIP 的包，用于从 PyP 安装纯 Python wheel。是的。我们想特别提到迈克尔·德鲁特鲍姆，他是最初创建 Pyadide
    的 Mozilla 员工，并为其做了非常出色的工作。我们一直在完善他设置的内容。对，所以我提到了 RC Python 补丁的上游。
- en: So we used to have to patch all sorts of stuff in order to get Python to run
    because WebAssembly。 and Emscripten is a very different sort of host environment
    than x86 Linux。 And so in order to do signal handling， in order to handle certain
    extensions， we needed。 to patch a bunch of stuff。 And so Christian Himes and Brett
    Cannon and I guess Ethan Smith have been involved in a。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们过去需要修补各种内容才能让 Python 运行，因为 WebAssembly 和 Emscripten 是一种与 x86 Linux 非常不同的主机环境。因此，为了进行信号处理和处理某些扩展，我们需要修补很多内容。所以克里斯蒂安·海梅斯、布雷特·卡农和以太·史密斯参与了一个。
- en: process and many other Python maintainers have been involved in up-streaming
    a lot of。 our patches and a lot of other fixes that they're adding to see Python
    in order to add。 sort of third party support or tier three support for Pyadide
    in Python。 And so this includes upstream in our patches。 The compiler itself does
    a lot of bugs。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 处理和其他许多 Python 维护者参与了很多补丁的上游处理，他们在为 Python 添加第三方支持或第三层支持方面做出了贡献。这包括我们补丁的上游。编译器本身处理了许多错误。
- en: It's fairly new。 There's not a huge number of maintainers for Emscripten。 And
    so we're hitting a lot of edge cases， a lot of bugs， trying to get the C Python
    test。 to beat the pass。 So over time this should make Pyad more sustainable and
    also help the ecosystem so other people。 who are trying to compile Python to WebAssembly
    might hit the same edge cases in the Emscripten。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具相对较新，Emscripten 的维护者数量不多。因此，我们遇到了很多边缘案例和错误，试图让 C Python 测试通过。因此，随着时间的推移，这应该使
    Pyodide 更加可持续，也能帮助生态系统中的其他人，那些尝试将 Python 编译为 WebAssembly 的人可能会遇到相同的边缘案例。
- en: compiler and so it should help them too。 So for context。 Pyadide isn't the first
    project that builds Python for the web。 You have a number of those。 so you have
    for instance， Brighton which is a Python 3 implementation。 in JavaScript which
    implements the interpreter and parts of the standard library。 There's the PyPid。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器，所以这也应该帮助他们。作为背景，Pyodide 不是第一个为 Web 构建 Python 的项目。你有许多这样的项目，比如 Brighton，它是一个
    Python 3 的实现，使用 JavaScript 实现了解释器和部分标准库。还有 PyPid。
- en: js which is essentially fairly similar to what Pyadide does but it was like。
    several years ago and it used a different technology rather than ASMGS rather
    than WebAssembly。 and this project is no longer maintained currently。 And there
    is the Rust Python project that because it's like so it's a re-implementation
    of。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: js 实际上与 Pyodide 的功能相似，但那是几年前的项目，使用的是不同的技术，而不是 ASM.js，而是 WebAssembly。而这个项目目前已经不再维护了。此外，还有
    Rust Python 项目，因为它是一个重新实现的项目。
- en: the Python interpreter in Rust and because Rust has already a pretty nice toolchain
    to。 port things to WebAssembly you can essentially with little effort to run it
    in the browser。 So the difference， let's say what we are focused on is not so
    much having the interpreter in。 the browser but is having the whole ecosystem
    run there like the whole Python ecosystem。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的 Python 解释器因为 Rust 已经有了相当不错的工具链，可以将东西移植到 WebAssembly，所以你可以基本上以很小的努力在浏览器中运行它。因此，我们关注的区别不在于是否在浏览器中有解释器，而是在于整个生态系统能够在那里运行，就像整个
    Python 生态系统一样。
- en: And what matters there is essentially very good compatibility and being able
    to run your。 code with minimal changes and this is for instance difficult if you
    implement your interpreter。 from scratch because then you will have some edge
    cases you'll like for instance in Brighton。 it's difficult to have exactly the
    same behavior as the standard C Python。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是良好的兼容性，以及能够以最小的更改运行你的代码。例如，如果你从头开始实现解释器，这将很困难，因为那样你将会遇到一些边缘案例，比如在 Brighton
    中，难以实现与标准 C Python 完全相同的行为。
- en: So by using the standard C Python we remove a lot of those compatibility issues。
    And so I'm going to present next how we package the library ecosystem。 So we have
    a tool called MicroPip which allows to install pure Python wheels from PIP API。
    So essentially it's like a pip but very simplified so it has very rudimentary
    dependence。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过使用标准 C Python，我们消除了许多兼容性问题。接下来我将介绍我们如何打包库生态系统。我们有一个工具叫做 MicroPip，它允许从 PIP
    API 安装纯 Python wheel。基本上它就像是一个简化版的 pip，具有非常初步的依赖管理功能。
- en: And this resolution it's only allowed to load a pure Python wheels so wheels
    that have the。 file extension as you see below。 On the contrary a lot of packages
    that have binary extensions will not be able to install。 them。 And instead what
    you have to do is use the PyRAD build system to build them specifically。 for WebAssembly。
    So we use a configuration format very highly inspired by Konda so it's a metayamel
    where。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 而这个解析只允许加载纯 Python wheels，因此扩展名如下面所示的文件。而许多具有二进制扩展的包将无法安装。相反，你必须使用 PyRAD 构建系统专门为
    WebAssembly 构建它们。因此，我们使用了一种受到 Konda 强烈启发的配置格式，这是一个元 YAML 格式。
- en: you can configure how you would need to build your package with a binary extension。
    There is cross compilation set up and since recently we're out the output is wheels
    so。 so you get Python wheels。 Those are not still very standardized because in
    particular while for instance the M script。 version doesn't have a stable EBI
    so if you update the script version your wheels are。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以配置如何构建带有二进制扩展的包。已经设置了交叉编译，并且最近我们输出的是 wheels，因此你得到了 Python wheels。由于特别是 M
    script 版本没有稳定的 ABI，所以这些仍然没有得到标准化，如果你更新脚本版本，你的 wheels 就会出现问题。
- en: not going to be compatible with the previous ones so that's still a significant
    problem。 There have also been a lot of improvements in the build system so since
    recently we used。 PyPI build tool to have build desolations and we do also some
    custom post processing steps。 for instance we will unvendor tests so that the
    package that you install is a bit smaller。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们将与之前的版本不兼容，因此这仍然是一个重大问题。构建系统也有很多改进，最近我们使用PyPI构建工具来进行构建和处理，并且我们还做了一些自定义后处理步骤。例如，我们将测试从包中剔除，以便你安装的包会小一些。
- en: because probably you don't need to have tests when you just use NumPy。 However
    you will be able to install NumPy tests as a separate package。 And so all this
    is currently distributed with a JES deliver so we have you probably heard。 like
    the scale of what is involved in distributing Python packages with PyPI。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因为当你仅使用NumPy时，可能不需要进行测试。然而，你将能够作为单独的包安装NumPy测试。因此，所有这些目前都是由JES deliver分发的，所以你可能听说过，涉及通过PyPI分发Python包的规模。
- en: We're clearly not at the same scale so we're much smaller but there are still
    some challenges。 in making sure that if anybody puts a Pyodid import loading Pyodid
    on some high traffic。 web page and everybody is going to download those files
    that we are able to support this。 and we're really grateful to JES deliver who
    are able to do this mostly because they're。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然不是在同一规模上，所以我们小得多，但在确保如果任何人将Pyodide导入到一些高流量网页上，所有人都会下载这些文件时，我们仍然面临一些挑战，我们非常感谢能够做到这一点的JES
    deliver。
- en: supported by a number of CDN providers。 And just to mention there was also some
    related work to have a build system which is more。 closer to Conda which is to
    also build essentially packages， Python packages for Gwasm which is。 done in MScript
    and Forge project。 So to give you an overview of the packages that we currently
    can use while some of them。 were mentioned before so we have all the core scientific
    computing packages NumPy， Pandas， SyPy。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由许多CDN提供商支持。值得一提的是，还有一些相关工作旨在构建一个更接近Conda的构建系统，实质上是为Gwasm构建Python包，这在MScript和Forge项目中完成。因此，让我给你一个关于我们目前可以使用的包的概述，虽然之前提到过一些，我们有所有核心科学计算包NumPy、Pandas、SyPy。
- en: Matlab， and all of that。 So this also means that we can actually build for instance
    packages that you cite on。 For SyPy， SyPy was very challenging， we'll talk about
    this later but SyPy uses forthron。 That's fairly difficult to build。 It requires
    external libraries such as BLAST and LaPac for linear algebra and then with。 this
    we can also build all the downstream packages， scikit-learn， scikit-image and
    stuff， model。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Matlab，以及其他所有相关内容。这也意味着我们实际上可以构建例如你提到的包。对于SyPy，SyPy非常具有挑战性，稍后我们会谈到，但SyPy使用了forthron。这相当难以构建。它需要外部库，例如BLAST和LaPac来进行线性代数，此外，我们还可以构建所有下游包，比如scikit-learn、scikit-image等模型。
- en: So we can load packages from PyP and MicroPip and also we have a number of different
    other。 packages that are not part of the scientific computing so Pyodide is not
    a project for。 scientific computing。 It's just that we have a lot of scientific
    computing packages because those tend to have。 a binary extensions but you for
    instance can use a scale alchemy to set up a SQLite database。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从PyP和MicroPip加载包，同时还有许多不同的其他包并不属于科学计算，因此Pyodide并不是一个科学计算项目。只是我们有很多科学计算包，因为这些包往往具有二进制扩展，但例如你可以使用scale
    alchemy来设置SQLite数据库。
- en: so that's the only type of database that currently works and use it for something
    completely unrelated。 to the scientific computing。 And since recently as we mentioned
    we also are able to compile the latest version of。 cryptography which was re-implemented
    in Rust and uses the Pyotree library to expose。 the Rust code to Python。 So overall
    we have over 120 packages in Pyodide and in addition to those you can install
    from。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是当前唯一能够正常工作的数据库类型，并且用于一些完全与科学计算无关的事情。正如我们提到的，最近我们也能够编译最新版本的cryptography，该版本在Rust中重新实现，并使用Pyotree库将Rust代码暴露给Python。因此，总体来说，我们在Pyodide中有超过120个包，此外你还可以从中安装。
- en: PyP that are just through Python。 Okay， so I'm going to talk about the foreign
    function interface。 So we have Python， the interpreter which you can run in the
    browser but the browser's host。 system is all in JavaScript so if you want to
    directly talk to the DOM you need JavaScript。 functionality。 And so it's important
    that we can sort of interface well with existing software that's。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Python访问PyP。好的，我将讨论外部函数接口。我们有Python解释器，你可以在浏览器中运行，但浏览器的宿主系统都是JavaScript，因此如果你想直接与DOM交互，需要JavaScript功能。因此，能够良好地与现有软件接口是重要的。
- en: already written for the web。 And so we have a very pleasantly designed foreign
    function interface that makes it very。 easy to do this。 So if you want to use
    JavaScript from Python you can import JavaScript objects that are。 in the global
    JavaScript scope directly from this sort of magic JS module。 So for instance set
    time out is a JavaScript function that calls a function at some delay。 You can。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 已经为网络编写好了。因此，我们有一个设计非常友好的外部函数接口，使其非常容易做到这一点。如果你想从Python使用JavaScript，可以直接从这种魔法JS模块导入在全局JavaScript范围内的JavaScript对象。例如，set
    timeout是一个在一定延迟后调用函数的JavaScript函数。你可以。
- en: it's a global in the global scope so you can import it from JS and then you
    can。 call set time out and it will call a function at 100 millisecond delay。 On
    the other hand you can also use Python from JavaScript so like at the start entry
    point。 of your application you want to call into Python to call your main method。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 它是全局范围内的，因此你可以从JS中导入它，然后你可以调用set timeout，它将在100毫秒的延迟后调用一个函数。另一方面，你也可以从JavaScript使用Python，因此在应用程序的起始入口点，你希望调用Python以调用你的主方法。
- en: So a Python object that's in global scope can be accessed from JavaScript so
    here this。 is an example where we load the sum built in method and then we use
    it on a list and you。 know it sums the entry。 So sum accepts any iterable that
    argument is a Python。 is a JavaScript array but we can， make JavaScript arrays
    into Python iterables and so sum accepts it and successfully iterates。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，处于全局范围内的Python对象可以从JavaScript访问，因此这里这是一个示例，我们加载内置的sum方法，然后在一个列表上使用它，你知道它对条目进行求和。因此，sum接受任何可迭代对象，该参数是Python中的一个，是一个JavaScript数组，但我们可以将JavaScript数组转换为Python可迭代对象，因此sum接受并成功迭代。
- en: over it and sums the values。 So we automatically convert simple types so float，
    string， and void。 none， null。 Most other types are proxied so we just make like
    a wrapper object that like allows you。 to make sort of convenient idiomatic calls
    in the current language that go across the。 other language and do operations in
    the other language。 So here's some examples。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对它进行操作并求和这些值。因此，我们自动转换简单类型，比如float、string和void none、null。大多数其他类型是代理，因此我们只是制作一个包装对象，使你能够在当前语言中进行方便的习惯用法调用，跨越其他语言并在其他语言中执行操作。这里有一些示例。
- en: So here's some examples of using Python utilities from JavaScript。 So Python
    has all these great standard library utilities so for instance here is the reduce。
    function。 So the first argument is a lambda。 Now this。 this is the Python fun
    tools package we imported it and returned it so this is。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些从JavaScript使用Python工具的示例。Python有很多优秀的标准库工具，比如这里的reduce函数。第一个参数是一个lambda。这是我们导入的Python
    fun tools包，它返回了这个。
- en: fun tools the Python object is a module object。 So fun tools dot reduce now
    is a method and we can call it its first argument is supposed。 to be a function
    that takes two arguments and returns one。 Now this argument is a JavaScript lambda
    expression， right， multiplies the two arguments。 This is a JavaScript array。 Reduce
    expects its second argument to be an iterable。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: fun tools的Python对象是一个模块对象。因此，fun tools.reduce现在是一个方法，我们可以调用它，第一个参数应该是一个接受两个参数并返回一个的函数。这个参数是一个JavaScript
    lambda表达式，对吧，乘以这两个参数。这是一个JavaScript数组。Reduce期望其第二个参数是一个可迭代的。
- en: It expects its first argument to be a callable。 This is a callable， this is
    an iterable。 It successfully reduces it and gets a ten or something。 So right。
    okay here's the second example so math is like another standard library package，
    we can import it。 it returns the module， the math module and then math has a least
    common。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它期望第一个参数是可调用的。这是一个可调用的，这是一个可迭代的。它成功地减少并得到了十或类似的值。好的，这是第二个示例，math就像另一个标准库包，我们可以导入它。它返回模块，即math模块，然后math具有最小公倍数。
- en: multiple method and this will compute the least common multiple of four， six
    and thirteen。 from JavaScript。 So you know again another example which is a bit
    more complicated so here we import the。 random module and so now random does not
    take an iterable as it's a sort of random dot sample。 is going to sample from
    a list and it does not take an iterable as it's first argument。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: It needs a list。 Now this is a JavaScript array which is different from a Python
    list。 So we need to convert it into a Python list so we have this converter function，
    pi dot。 dot two pi which takes the JavaScript array and converts it into a Python
    list so that。 it's acceptable for random sample。 Then this samples five random
    elements from the pair red and blue so we're going to get。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: like red red blue blue red or something and then but that returns a Python list
    but if。 we want a JavaScript array then we need to convert it back so that's this
    2。js function。 So here so that previous example actually leaks a couple of Python
    objects。 They'll eventually get reclaimed by the browser garbage collector but
    it takes a while whereas。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: like Python garbage collector because it's reference counter tends to get called
    much， faster。 So here's an example that actually doesn't leak these objects where
    this is basically。 a wrapper function which you would use to call it from JavaScript。
    And so in general you might have like some application which does some data processing。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: It receives some data structure from that you collect from the user interface
    and then。 you call into like the main entry point of your Python application it
    does some processing。 and it returns some data back to JavaScript for display。
    And so this shows you how you would do the translations at the boundary of the
    application。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: So here we have like the sample space so this would be red and blue but that
    again we're。 expecting this to be called from JavaScript so we're expecting this
    sample space to be。 a JavaScript array。 Now sample expects again a Python list
    so first we convert space to a Python list using。 the 2Py method。 And then we
    sample from it we get a Python list and then we want to return it to the UI。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: potentially that's going to display it to the user in some way and so we convert
    the。 result list back to JavaScript at the boundary。 So here's another example
    so this is the fetch API so fetch is a way to download you。 know like URLs in
    the browser。 This would fetch example。com we can specify some options and it looks
    very much like normal。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Python code but it's calling into a JavaScript method。 You'll see in some of
    this some of Peter Wang's talk if you went to it too。 So here's another example
    where this shows using low level memory buffers so NumPy has。 a multi-dimensional
    array interface so it makes like fast memory buffers and you can。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: actually make direct memory accesses from JavaScript。 So for instance if you
    want to use a JavaScript image or video processing library you can pass。 it an
    indie array from NumPy and you can access from this buffer the strides and the。
    dimensions and all the stuff and you can hand it to a JavaScript indie array library
    and then。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上可以从JavaScript直接访问内存。例如，如果你想使用JavaScript图像或视频处理库，你可以传递一个来自NumPy的独立数组，并且可以从这个缓冲区访问步幅和维度等所有内容，然后将其交给JavaScript独立数组库。
- en: call into whatever this image processing or AI library you want to use。 So what
    we're doing is essentially we're running our Python code in the in the in the。
    inscription host environment that which we use as a VM。 So it's it's essentially
    as running Python code on any like a bit stranger VM。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用你想使用的图像处理或AI库。因此，我们所做的基本上是在“inscription”主机环境中运行我们的Python代码，这个环境我们用作虚拟机。所以，这实际上就像在任何奇怪的虚拟机上运行Python代码。
- en: So the the the features of this one is that it's a 32-bit architecture so while
    normally。 it works but some Python packages are a bit like less well tested on
    32-bit。 We have in file in memory file system so in inscription provides this
    so you have a file。 system you can you can write files like your Python modules
    are loaded from files but it's。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个架构的特点是它是一个32位架构，尽管通常工作，但某些Python包在32位上测试得不太好。我们在内存文件系统中有文件，因此在“inscription”中提供这个，所以你有一个文件系统，你可以像从文件加载Python模块一样写文件。
- en: in in memory one。 Okay so and the limitation is that you cannot use for instance
    supercesses you cannot use。 threading because those are not not not allowed by
    this VM。 You can also not use sockets and some system calls are implemented but
    not all。 So it's also difficult to use it's also difficult difficult to use some
    of the standard like。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中也是如此。好的，限制是你无法使用超进程，也无法使用线程，因为这些在这个虚拟机中是不允许的。你还不能使用套接字，某些系统调用已经实现，但并非全部。因此，使用某些标准库也是困难的。
- en: IO streams such as SCDR， SDD， SD out because they like if you want to show something
    you。 need to render it on the HTML page not like as you would normally on the
    next。 And next we'll present some of the use cases we have that used by that。
    Right so so I guess our three main use cases that we want to talk about are interactive
    computing。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: IO流如SCDR、SDD、SD输出，因为如果你想展示某些内容，你需要在HTML页面上渲染，而不是像通常那样在下一个页面上。接下来我们将展示一些我们使用的案例。对了，我想我们想讨论的三个主要用例是交互式计算。
- en: as was discussed by Peter Wang and then education and machine learning or sort
    of special cases。 of the interactive computing that were particularly good for
    it。 It's very good for like scientific communication and that sort of stuff。 So
    we want to talk about client only architectures which is what Peter Wang again
    talked about。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如彼得·王讨论的那样，教育和机器学习或某种特殊情况的交互式计算非常适合它。这对科学交流等内容非常有帮助。因此，我们想讨论仅客户端架构，这正是彼得·王再次提到的。
- en: this morning。 So the idea is that if you have a back end server you know so
    then the user is using your。 website your web application it sends data back to
    the server the server does some computations。 with it and then it sends the results
    back to the UI to be displayed。 And so the client only architecture the server's
    only role is to send a set of static files。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 今天早上。想法是，如果你有一个后端服务器，用户在使用你的网站或Web应用程序时，它会将数据发送回服务器，服务器会对其进行一些计算，然后将结果发送回UI以供显示。因此，客户端架构的唯一角色是发送一组静态文件。
- en: to the user。 And then all of the logic all of the computation happens inside
    of the browser。 And you know so this has benefits to privacy it has benefits from
    the right I guess we'll。 talk about it here right okay so so so so so usability
    benefits right so you don't need。 to install Python so if you're like doing scientific
    computation you can share your work。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对用户而言，所有逻辑和计算都在浏览器内进行。这对隐私有好处，我想我们会在这里谈论这个，对吧？好的，关于可用性的好处，你不需要安装Python，所以如果你在进行科学计算，你可以分享你的工作。
- en: with other people they don't need to have Python installed。 Right so there's
    big benefits to scalability so you don't need to have a web server you。 don't
    need or you need to have a static you need to sort of static files you don't need。
    like any containerization you don't need any cloud you don't need to figure out
    how to。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 其他人无需安装Python。因此，在可扩展性方面有很大的好处，你不需要有一个网络服务器，也不需要有静态文件，不需要容器化，也不需要云服务，甚至不需要弄清楚如何做。
- en: organize the compute because it all happens on the client side。 Yeah and generally
    packages only need to be downloaded once and then the browsers will。 cache them
    so so it takes a long time on the first use but if you're using it like every。
    day as part of your like scientific computing workflow then you'll only see that
    time hit。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 组织计算，因为这一切都是在客户端进行的。是的，一般来说，软件包只需要下载一次，然后浏览器会对它们进行缓存。所以在第一次使用时可能会花费较长时间，但如果你每天都把它作为科学计算工作流的一部分使用，那你只会在第一次加载时看到这个时间。
- en: on the first load。 Right so it also has big benefits to privacy so because all
    calculations are run locally。 no data is sent to a remote server which is you
    know good for users because their data。 is private it's good for developers because
    they don't have to fill out as much paperwork。 So for instance there's a talk
    analyzing sensitive data at scale doesn't have to be a headache。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对隐私也有很大好处，因为所有计算都是在本地运行的。没有数据发送到远程服务器，这对用户来说是好的，因为他们的数据是私密的；对开发者来说也是好的，因为他们不需要填写那么多文书工作。例如，分析大规模敏感数据就不必成为一个麻烦事。
- en: which is about analyzing you know children's financial data with Python where
    they have。 a lot of trouble installing software there's a complicated paper they
    have to do to install。 software but they also cannot use software as a service
    because they cannot send out。 that private data。 So what they do is they go to
    a website they download the Python application with Pyadide。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于用Python分析儿童财务数据的内容，他们在安装软件时遇到了很多麻烦，有一篇复杂的论文需要完成以安装软件，但他们也不能使用软件即服务，因为无法发送那些私密数据。因此，他们所做的就是去一个网站，下载带有Pyodide的Python应用程序。
- en: and then they can turn off the internet air gap the computer plug in a flash
    drive with。 the children's sensitive financial data and then do the analysis there。
    And so what's also interesting that lately there has been a growing ecosystem
    of tools。 that allow you to make client only Python applications。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后他们可以关闭互联网，把电脑与含有儿童敏感财务数据的闪存驱动器连接，然后在那里进行分析。有趣的是，最近出现了一种不断增长的工具生态系统，允许你制作仅限客户端的Python应用程序。
- en: So there is PyScred which was introduced in this morning's keynote which allows
    you to。 do to create rich Python applications in the browser using HTML。 There
    is Iridium which is a tool that allows you to make interactive documents and data。
    visualizations like they use a lot of markdown so it's nice to write。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还有在今天早上的主题演讲中介绍的PyScred，它允许你在浏览器中使用HTML创建丰富的Python应用程序。还有Iridium，这是一个允许你制作交互式文档和数据可视化的工具，使用了大量的Markdown，写起来很方便。
- en: There are also attempts to essentially interface react like to use react from
    Python using the。 Pyadide type translation tools and then there is project like
    VC code which runs essentially。 Python snippets as HTML types。 So there is like
    a growing system of tools we can also mention all the projects that allow。 you
    to run notebooks on the client side so one of the most popular ones is Jupyter
    Lite。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 也有尝试将React接口化，利用Pyodide类型的翻译工具从Python使用React，还有像VC Code这样的项目，它基本上运行Python代码片段作为HTML类型。因此，有一个不断发展的工具系统，我们还可以提到所有允许你在客户端运行笔记本的项目，其中最流行的之一是Jupyter
    Lite。
- en: currently which is essentially the code base of Jupyter lab which normally requires
    a kernel。 on the server but in this case the kernel was moved inside the web browser
    and it runs， on Pyadide。 And there is also startboard notebook， there is Bastone
    which is a fork of Jupyter Lite。 with the same idea as Jupyter Lite。 So this allows
    to have interactive computing in your browser without having to stop a server。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的代码库是Jupyter Lab，通常需要一个服务器上的内核，但在这种情况下，内核被移动到了网页浏览器内，并在Pyodide上运行。此外，还有Startboard
    Notebook，还有一个Jupyter Lite的分支Bastone，理念与Jupyter Lite相同。这使得在浏览器中进行交互式计算成为可能，而不需要启动服务器。
- en: essentially。 And for instance if you go， I don't know。 if you go on the NumPy
    page there will be some， examples that use these tools to illustrate NumPy。 Another
    significant topic of applications， Pyadide applications has been education。 So
    to give an example for instance currently Python is mandatory in French high school
    curriculum。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你去NumPy页面，你会看到一些使用这些工具来说明NumPy的例子。Pyodide应用程序的另一个重要主题是教育。例如，目前Python在法国高中课程中是必修的。
- en: And so the problem they face is that teachers are not really Python developers
    so they don't。 have time to install Python on students laptops。 And on the other
    side if you actually want to have some centralized infrastructure that。 allows
    you to execute Python code while this is costly both in terms of servers， compute。
    time and in terms of maintenance。 And so what they did is to essentially run one
    like to develop a notebook solution Bastone。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 他们面临的问题是教师并不是真正的Python开发者，因此没有时间在学生的笔记本电脑上安装Python。另一方面，如果你想拥有一些集中式基础设施来执行Python代码，这在服务器计算时间和维护方面都很昂贵。因此，他们的做法是基本上开发一个笔记本解决方案。
- en: which is backed by Pyadide and they deploy this massively in high schools in
    France。 And so they have like 100，000 weekly users while only having to maintain
    a very small。 like essentially just serving static files。 And generally they have
    been a lot of different projects that try to use some of these ideas。 for either
    for education or for research。 Another use case that I'm personally interested
    in is how do we deploy machine learning models。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务由Pyodide支持，他们在法国的高中大规模部署这个服务。因此，他们每周有大约100,000名用户，而只需维护非常少的，例如仅仅提供静态文件。通常，他们已经有许多不同的项目试图利用这些想法，或用于教育或研究。另一个我个人感兴趣的用例是如何部署机器学习模型。
- en: So the traditional way to do this is you train your model which is often Python
    code so it's。 going to be I don't know， scikit learn or TensorFlow or PyTorch。
    You can use the standard pickle format which is like the standard way to serialize
    Python。 objects or there are some specific serialization formats。 Then you develop
    a web service。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的方法是训练你的模型，通常是Python代码，因此它可能是我不知道的scikit learn、TensorFlow或PyTorch。你可以使用标准的pickle格式，这是一种序列化Python对象的标准方法，或者使用一些特定的序列化格式。然后你开发一个网络服务。
- en: you package probably in a container and then you deploy， it somewhere on some
    server。 So this is again， this is complicated。 And there are tools that actually
    work with this custom serialization formats that allow。 you to do inference in
    the browser。 So that's support to WebAssembly。 However。 they only work for a fairly
    limited set of operations。 So for instance， if you use TensorFlow， yes。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能将包裹放在一个容器中，然后在某个服务器上部署它。因此，这又是复杂的。确实有一些工具可以处理这种自定义序列化格式，允许你在浏览器中进行推断。这支持WebAssembly。然而，它们仅适用于相对有限的操作集。例如，如果你使用TensorFlow，是的。
- en: you will be able to run TensorFlow operators。 But you will not be able to run
    arbitrary Python code that you might need to pre-process your。 data or transform
    it somehow。 And so the idea is that， well。 since you now have Python running in
    the browser， you， can just use pickle。 so pickle is a standard Python serialization
    format。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够运行TensorFlow操作。但你无法运行你可能需要预处理数据或以某种方式转换的数据的任意Python代码。因此，想法是，既然你现在可以在浏览器中运行Python，你可以直接使用pickle。所以pickle是标准的Python序列化格式。
- en: It has some disadvantages because it's a bit unsafe since you're running arbitrary
    Python， code。 It's a bit brittle to environment changes， but it's essentially
    portable and non-apac。 meaning that once you de-sterilize it， you get your original
    Python object and you can， explore it。 And so the steps to now to deploy circular
    models， for instance， with Pyodiode would be。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一些缺点，因为运行任意的Python代码有点不安全。它对环境变化有点脆弱，但它本质上是可移植和非专用的。这意味着一旦你去除其消毒，你就可以得到原始的Python对象并进行探索。因此，现在部署循环模型的步骤，例如使用Pyodide，将是。
- en: just you create the environment which needs to match between the environment
    where you。 train your model and the environment where you predict。 You pickle
    your model。 you unpickle it in the browser， and then you run an inference with，
    your Python object。 So also training can also happen directly in the browser。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的环境需要与训练模型的环境和预测的环境匹配。你将模型序列化，然后在浏览器中反序列化，然后使用你的Python对象运行推断。因此，训练也可以直接在浏览器中进行。
- en: We can illustrate this with the following example。 Okay， that was not it。 Sorry。
    The home key is a bit of a。 Okay， so here we have an example which is a React
    application that's used to display。 a classifier decision boundaries using Matplotlib。
    It uses some example data。 it trains a model in it， and then it displays the decision
    boundary， here。 So you have。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: for instance， you have three classes and you see the decision boundary here
    with。 the logistic regression model and then。 You switch browser tabs。 No， it's
    fine。 Sorry。 Yeah。 so you can see the three boundaries， three classes that are
    categorized with this， model。 And now you can just change that， for instance，
    your model。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: It's going to be retrained live in the browser。 You're going to have it changed
    fairly quickly。 And then even here in this application you can add extra points，
    for instance。 And your model is going to be retrained each time you do this and
    it's going to be adapted。 and fairly very quickly。 Okay， so now I'm going to talk
    about latest developments in Outlook。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: There were a bunch more fancier demos at Peter Wang's talk this morning so you
    can see more。 of the stuff that we can do with this。 Right， so it's what I'm going
    to talk about some of the technical things that have gone。 into making Piedide
    work recently which we think are really fun。 So what issue is packing SciPy and
    Fortran？ So there's not a working Fortran compiler based on LLVM。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Our inscription tool chain is based on LLVM。 And so this is the problem for
    us。 There's three work in progress compilers。 There's L Fortran， there's Flame
    Classic。 and there's Flame。 And then， so I mean you can do even like very desperate
    things。 Like there's a GCC plugin called Dragon Egg which allows you to produce
    LLVM IR。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: And then you can like hand that over to LLVM and like compile it to WebAssembly。
    But this is sort of a desperation move。 So we use FQC which is a program to convert
    Fortran 77 code to C code。 One problem with this is that much of the code in SciPy
    is Fortran that's newer than， Fortran 77。 Fortran 90 even newer ones。 And FQC
    sometimes exceeds on it。 But we have lots of trouble with it。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: So we use a mix， we have an automatic source transformation that we do on the
    Fortran input。 We have automatic source transformations on the C output that we
    do both before and after。 conversion。 And then we also have a lot of sort of manual
    patches。 And this gets most of the SciPy tests passing but it's sort of a big
    effort。 Okay。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: so another big issue for us is function pointer cast。 So Python C extensions
    define C functions and then call them with the wrong number of， arguments。 The
    C standard says this is undefined behavior。 But most C compilers generate code
    that doesn't crash。 So if you define a function that takes two arguments but ignore
    the second one and then。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: you call it with one argument， usually on native architectures this doesn't
    crash。 What other simply however puts the signature of the function into the assembly
    and the。 runtime will validate the function pointer at runtime and check whether
    its signature。 matches the assertive signature。 If it does not it will crash with
    call indirect function pointer mismatch。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: So here's an example。 So here's a C extension like NumPy or something。 So we
    define the function called do something。 Now this function actually just doesn't
    do anything。 it just returns non。 And it takes a single object which is the representation
    of this function as a Python。 object。 And it's going to return non all the time。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: So then you need to tell the Python virtual machine the Python interpreter how
    to invoke， this。 So we say its name is do something。 And we say that here's the
    function point that we're going to call when we want to call。 this。 And then we
    give it the calling convention which is no arcs。 Now people in the back probably
    won't see this at the bottom but in method object。c in。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: the interpreter it will call this function with two arguments。 See this null
    here。 So it's going to put a null in as the second argument。 You know of course
    the reason we didn't take that as an argument is because it's always， null。 It
    doesn't give you useful information so C developers for Python packages forget
    about， it。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: But in WebAssembly this is a crash。 And there's tons of these。 So I mean all
    the solution would be to fix all of them in the packages but we don't have。 the
    maintainer effort to do that because there's so many of them。 So the solution
    that we finally found after much contemplation is that calls from JavaScript。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: into WebAssembly are flexible。 They can be called with the wrong number of arguments
    and it just works。 So we use a trampoline call。 We call from WebAssembly back
    out to JavaScript and we say JavaScript why don't you call back。 into WebAssembly
    with this function these arguments。 And then it calls back into JavaScript and
    that accepts the wrong number of arguments， is fine。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: This solution has been upstreamed into Python 3。11 thanks to the encouragement
    from Christian。 Himes。 You know and so I have a blog post about this you can see
    the pull request if you want。 It's a big thing。 Okay so another issue is for running。
    So another problem that most like a lot of Python users face is that you cannot
    use essentially。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: a stupid client or request or all those libraries that need to interact with
    the network because。 sockets。work。 So what you have to do instead is to use JavaScript
    API such as fetch。 But then there is another problem that those APIs are often
    async and Python expects those。 functions to be sync。 So there is a working progress
    solution which tries to use a web worker。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: So web worker is essentially like a process in classical Python so it's another
    worker you。 can run in your browser to which you can actually send their requests
    to download your。 package async and meanwhile you block your main thread with
    atomics to until that fetch， completes。 So there is a project that's being worked
    by hood called sync link which aims to make。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: this process easier。 And so as an example another thing is for instance because
    you are in the browser sandbox。 you cannot access files on your file system due
    to security reasons。 However there is a Chrome file system API which allows you
    to essentially using this system。 to mount a mount point like a local folder inside
    the M script and file system and then。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: you can directly write into the host's OS file system。 Okay so we have a CTO
    in the browser so each browser process I guess we are going to call。 it comes
    with its own event loop and Python has event loops you can implement and so we。
    have a custom event loop for async IO which basically all it does to do is schedule
    tasks。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: on the browser event loop。 So in a certain limitations like async IO。run until
    complete cannot work as expected because。 it blocks the same process that's actually
    doing the Python computation and so it cannot， block。 And we also have no control
    over the event loop lifecycle。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: But one of the big benefits of this is that you don't need to control the event
    loop lifecycle。 no one wants to do that。 You really just want to run your async
    code setting up the event loop is sort of baggage。 that we have to go through
    to get to the run in the async code。 So another frequent question is how big are
    like packages you download。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: So for instance if you have an application on the right here that loads pandas
    well you。 have to load pandas and all the dependencies of pandas so including
    numpy here and then。 you have to load CPIT on the standard library。 So in this
    example at the very bottom you can see that we in total downloaded 18 megabytes。
    and around 30 megabytes we get around 30 megabytes after it's uncompressed。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: So this is a significant issue because Python ecosystem was never optimized
    for size because。 if you install locally it doesn't really matter。 There are historical
    large packages such as SyPy which has a lot of modules that might。 maybe you're
    not going to use in the given application but they're still there when。 you install
    SyPy。 And also as you mentioned before some packages will include tests。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: So what can we do about this？ Well there are several possible ways。 So we could
    try to break large packages into smaller ones。 The problem is basically it changes
    your dependency graph so you have new packages that are created。 and that's a
    bit difficult to manage。 A different approach is to use a bundler tool so bundler
    tool means that we have some Python。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: code that we need to run。 We know the code in advance。 We're going to run it
    in the Pyodeid and we're going to check at runtime which files are。 actually accessed。
    And then we're going to recreate an archive with just those files which should
    be much。 smaller than all the files that were installed。 And finally the last
    approach is using dynamic imports so essentially fetch the file when。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要运行的代码。我们事先知道代码。我们将在Pyodide中运行它，并在运行时检查哪些文件实际上被访问。然后我们将重新创建一个只包含这些文件的归档，这应该比安装的所有文件小得多。最后一种方法是使用动态导入，因此在需要时获取文件。
- en: you import it。 However there are often like more than 50 modules that a given
    application can import。 so it's a lot of， it's probably a significant performance
    concerns。 And finally the last solution is to， well we can just wait for the average
    webpage size。 to grow larger。 I mean it's a sad situation but it turns out that
    it's a trend that goes in our favor。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你导入它。然而，给定应用程序可以导入的模块往往超过50个。所以这可能是一个重要的性能问题。最后一种解决方案是，我们可以等到平均网页大小变大。我的意思是这是一种悲哀的情况，但结果证明这是一个对我们有利的趋势。
- en: Okay so now we're going to talk about the roadmap。 So you know what we're up
    to in the future。 There's a lot of maintenance work to do so we need to keep up
    with inscription releases。 Currently we're stuck on an old version of inscription
    due to a bug in recent versions。 of Firefox and bind with versions of LLVM。 But
    it's a fair amount of work to keep up with inscription because of very weird bugs。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们要谈谈路线图。这样你就知道我们未来的计划。有很多维护工作要做，所以我们需要跟上版本发布。由于Firefox最近版本的一个错误和LLVM版本的绑定，我们目前被困在旧版本的inscription上。但跟上inscription是相当多的工作，因为有一些非常奇怪的错误。
- en: We need to upstream patches so NumPy has a lot of patches。 We'd like to upstream
    them。 many other packages have like a few patches and it would be nice， to get
    more of those upstream。 Yeah support for Secret is IO and web workers as we talked
    about a couple minutes ago。 It would be nice to re-implement certain standard
    library modules that you use web。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将补丁上游化，所以NumPy有很多补丁。我们希望将它们上游化。许多其他包也有一些补丁，能够将更多这些补丁上游化是很好的。是的，Secret的支持是IO和Web工作者，就像我们几分钟前讨论的那样。重新实现你在Web中使用的某些标准库模块会是不错的选择。
- en: APIs like HTTP client you know could use fetch。 Reducing size packages and proving
    the sustainability of the build system。 maybe some day threading， support。 So
    there's a lot of work to be done both upstream and downstream。 In fact it would
    be very valuable to work on the inscription compiler and improve some。 of these
    weird educations that we had。 And of course to actually get this to users our
    project is very much sort of down the。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 像HTTP客户端这样的API你知道可以使用fetch。减少包的大小并提高构建系统的可持续性。也许某天会支持线程。所以还有很多工作要在上游和下游进行。实际上，致力于inscription编译器并改善我们遇到的一些奇怪问题是非常有价值的。当然，实际上将这一切带给用户，我们的项目在某种程度上处于下游。
- en: trenches of doing like platform compatibility problems that we're trying to
    solve。 But we're also trying to be useful tools like downstream so there's documentation
    work。 there's all sorts of work to be done。 We love anyone that has issues。 please
    write your questions on our issue tracker， please， help with the docs。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在努力解决平台兼容性问题，但我们也希望成为像下游一样有用的工具，所以还有文档工作等各种工作要完成。我们欢迎任何有问题的人，请在我们的issue跟踪器上写下你的问题，拜托，帮助整理文档。
- en: any work on our package or work downstream we're very happy to see exciting，
    projects downstream。 Yeah。 And so just last note is that there's still a lot of
    things to be done and some of those。 things don't require that much work to finish。
    Yeah， yeah。 Very accessible problem。 So we'd also like to thank all the people
    who contributed to Pyodide directly or indirectly。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们包的任何工作或下游工作，我们非常高兴看到令人兴奋的下游项目。是的。最后一点是，还有很多事情需要完成，其中一些事情并不需要太多工作就能完成。是的，确实是个很容易解决的问题。因此，我们也想感谢所有直接或间接为Pyodide做出贡献的人。
- en: So they're directly the Pyodide contributors starting from Michael Dordboom
    who created， Pyodide。 They're like users who report bug issues， our sponsors and
    then the community。 So M-scriptin。 Pyodide wouldn't exist without M-scriptin，
    CPython for the improvements that's。 like for the support of WebAssembly that's
    happening now， all our downstream libraries that。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所以他们直接是 Pyodide 的贡献者，从创造 Pyodide 的 **Michael Dordboom** 开始。他们就像报告错误的用户，我们的赞助商，还有社区。因此
    M-scriptin。没有 M-scriptin，Pyodide 就不存在，CPython 的改进也是如此。支持 WebAssembly 的相关工作现在正在进行，所有下游库也与此相关。
- en: will make creating client-side application with Python in the browser easier。
    So Jupyter Lite。 PyScript， RIDM， et cetera。 The Iodide team， so initially Pyodide
    was created as part of the Iodide project at Mozilla。 and also all the package
    maintainers that help us to review our patches when we try to fix， things。 So
    thank you。 We'll do a sprint at the end of PyCon if you want to work on any of
    those subjects or。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将使在浏览器中使用 Python 创建客户端应用程序变得更容易。因此有 Jupyter Lite、PyScript、RIDM 等等。Iodide 团队，最初
    Pyodide 是作为 Mozilla 的 Iodide 项目的一部分创建的，还有所有的包维护者在我们尝试修复时帮助审查我们的补丁。所以谢谢你。如果你想在
    PyCon 结束时参与任何这些主题的冲刺。
- en: related subjects on HeadState to come。 Thank you。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与 HeadState 相关的主题将会出现。谢谢。
- en: '![](img/59c5fc8db7748b7687462940bca51cbe_4.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59c5fc8db7748b7687462940bca51cbe_4.png)'
- en: '[Applause]， [Applause]， [Applause]， [Applause]， (applause)， (audience applauding)。'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]，[掌声]，[掌声]，[掌声]，（掌声），（观众鼓掌）。'
- en: '![](img/59c5fc8db7748b7687462940bca51cbe_6.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59c5fc8db7748b7687462940bca51cbe_6.png)'
