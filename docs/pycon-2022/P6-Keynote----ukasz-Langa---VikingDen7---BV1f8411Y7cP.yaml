- en: P6：Keynote - Łukasz Langa - VikingDen7 - BV1f8411Y7cP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P6：主旨发言 - **乌卡·兰加** - VikingDen7 - BV1f8411Y7cP
- en: And now I want to welcome Uka Shlanga， our CPython developer in residence， and
    our first。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我想欢迎我们的CPython驻地开发者**乌卡·施兰加**，以及我们的第一位发言人。
- en: '![](img/662eb3bc4641f5e3a0bbb008642ee734_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/662eb3bc4641f5e3a0bbb008642ee734_1.png)'
- en: keynote speaker。 Let's give him a warm welcome。 Hi there。 This is easily the
    biggest crowd I've ever spoken to。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 主旨发言人。让我们热烈欢迎他。嗨！这是我演讲过的最大观众。
- en: '![](img/662eb3bc4641f5e3a0bbb008642ee734_3.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/662eb3bc4641f5e3a0bbb008642ee734_3.png)'
- en: So I'm a little nervous。 My name is Uka Shlanga， I come from the internet。 You
    can find me in all sorts of places online。 But I've been coming to Python for
    a while now。 and I will be here for the entire event， so I'm happy to answer any
    questions you might have about any subject。 I like Python， so we can talk about
    Python。 I also like Robert Maynard Persig's Zen and the art of motorcycle maintenance。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我有点紧张。我叫**乌卡·施兰加**，来自互联网。你可以在网上的各种地方找到我。但我来Python已经有一段时间了。整个活动我都会在这里，所以我很乐意回答你可能对任何主题的问题。我喜欢Python，所以我们可以讨论Python。我也喜欢**罗伯特·梅纳德·佩西格**的《禅与摩托车维修艺术》。
- en: That's a pictogram from the cover of the book。 First read it some ten years
    ago。 and it massively influenced me。 It's like some meditation about technology
    that also is connecting it to how people perceive。 art。 It talks a lot about Quality，
    and it never really left me since。 I just reread it this month。 and it totally
    holds up。 So I highly recommend you looking it up if you haven't read it yet。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是那本书封面的图标。我大约十年前首次阅读过它，对我产生了巨大影响。它像是对技术的一种冥想，同时也将其与人们如何感知**艺术**联系起来。它谈论了很多关于**质量**的内容，自那以后就一直在我心中挥之不去。我这个月刚刚重读了一遍，依然很有价值。如果你还没读过，强烈推荐你去看看。
- en: And in fact， we're going to be talking about Quality here too， but it's going
    to be maybe。 a little bit of a mundane kind of Quality， because we're going to
    be talking about type。 of notations。 The annotations are here to stay。 They've
    been first added to Python 3。5。 and ever since there's been a number of peps，
    that made them easier to use and made them more powerful to express more complex
    and。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们在这里也会讨论**质量**，但可能会是有些平凡的那种质量，因为我们要讨论**类型**的标注。标注是不会消失的。它们首次被添加到Python
    3.5中，从那时起，出现了许多PEP，使它们更易于使用，并更强大地表达更复杂的内容。
- en: complex types。 So if you haven't ever annotated any application yet。 you're
    likely to be in for a treat soon。 And if you did， you might have some experiences
    with it。 Some of us have been annotating Python programs for quite a while now。
    And with this experience。 we have kind of devised some best practices on how to
    do this， how to write code。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂类型。如果你还没有对任何应用程序进行注释，你很快就会享受到这个乐趣。如果你进行了注释，你可能会有一些相关经验。我们中的一些人已经为Python程序注释了相当长的时间。通过这些经验，我们制定了一些最佳实践，告诉我们该如何进行，如何编写代码。
- en: so that it doesn't really fight the type checker。 And this is what we're going
    to be talking about today。 And also about some， what we consider， anti-patterns
    where what you're trying to do works against。 what the type checker will want
    from you。 And finally。 we'll cover some limitations of static typing compared
    to what the runtime。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以便它不会与类型检查器相斗争。这就是我们今天要讨论的内容。此外，还会谈到一些我们认为的反模式，即你所尝试的内容会与类型检查器对你所期望的相悖。最后，我们将讨论静态类型相比于运行时的一些限制。
- en: Python allows you to do and whether they're a ball and chain or more of something
    that。 you should be really kind of grateful to have。 So why do we even have type
    annotations in the first place？
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许你做的事情，无论它们是个负担，还是更像是你应该感激拥有的东西。那么我们为什么要有类型注释呢？
- en: Looking at this very simple code example that pretty much reads like English，
    we can see。 that it's a process all function， accepting one argument， which is
    items。 And for each of those items， it will find a children attribute on them
    and call a process。 method easy。 But even in such a small example， there might
    be a lot of complexity and questions hiding。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个非常简单的代码示例，几乎像英语一样易读，我们可以看到。它是一个处理所有功能的函数，接受一个参数，即**项目**。对于每一个项目，它将查找其上的**子属性**并调用处理方法。然而，即使在这样一个小的示例中，也可能隐藏着很多复杂性和问题。
- en: In this particular case， what is items？ We don't really know。 In Python， items。
    maybe there are pairs， inductionaries， key value pairs。 But here we know that
    this is not the case because those don't have a children attribute。 So it's something
    else。 How do we find out if there's no doc string。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特定情况下，什么是items？我们并不确切知道。在Python中，items可能是对，归纳，键值对。但在这里我们知道这不是情况，因为这些没有children属性。所以它是别的东西。我们如何在没有文档字符串的情况下找出这一点。
- en: we need to grep through our code base to， find out。 But finding items in a big
    code base。 not very easy。 So how about looking for the children attribute？ Again，
    not very easy。 How about we grep for a process method in all likelihood you're
    going to have more than， one。 So you need some form of documentation。 And you
    need it if you're using powerful features of Python like its dynamicism as well。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在代码库中grep，找出。但是在大型代码库中找到items并不是很容易。那么寻找children属性怎么样？同样，不太容易。我们如何grep一个process方法，通常你会有不止一个。所以你需要某种形式的文档。如果你使用Python的强大特性，如动态性，你也需要它。
- en: Because in this case， we have some proxy that has instances which are callable，
    just like。 functions。 And from the signature here， you see that you can call it
    with any arguments。 Anything goes。 It's all good。 Is it-- experience shows that
    there is only one-- or a few cases where it makes sense to。 call this proxy with
    some set of arguments。 So what are they？ Well。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在这种情况下，我们有一些可以调用的代理实例，就像函数一样。从这里的签名可以看出，你可以用任何参数调用它。任何事情都可以。这一切都很好。经验表明，只有一个或少数几个情况下，调用这个代理并使用一些参数才有意义。那么它们是什么呢？
- en: either we need to read the body of the function or we're lucky enough to have
    some。 documentation which is either in a doc string or provided in some Sphinx
    docs on the side。 But I would argue that type annotations are a wonderful form
    of documentation which works。 for you because it will both allow people on board
    it to a new code base to be productive， quicker。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要么我们需要阅读函数的主体，要么我们运气好有一些文档，这些文档可能在文档字符串中，或者提供在旁边的Sphinx文档中。但我认为类型注解是一种极好的文档形式，它对你有用，因为它将使新进人员更快地适应新代码库并提高生产力。
- en: But it also will allow you yourself to remember what you thought about the function
    you were。 writing six months or six years back。 It helps with review。 It helps
    with debugging but also it's machine readable。 Thanks to a type checker。 we can
    validate assumptions about code that you're writing。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但它也将帮助你记住六个月或六年前你写这个函数时的想法。它有助于回顾，有助于调试，但它也是机器可读的。多亏了类型检查器，我们可以验证你正在编写的代码的假设。
- en: right now and keep validating those assumptions into the future。 So if you change
    a function which is very likely to happen， we modify our software， we。 keep maintaining
    it。 The type checker might still be checking whether the API stays sane。 So I
    could finish right now and we could just go to the coffee break sooner because
    I hope。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保持验证这些假设直到未来。因此，如果你更改一个函数，这很可能会发生，我们修改软件，持续维护它。类型检查器可能仍然会检查API是否保持合理。因此我可以现在结束，我们可以更早去喝咖啡，因为我希望。
- en: I convinced you it's all good。 But what if your type annotations look something
    more like this？
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我说服你一切都很好。但如果你的类型注解看起来更像这样呢？
- en: This is a screenshot taken by Ned Batchelder and posted on Twitter last year
    by him。 He said。 "I'm looking through this Python documentation and like， what
    is this？ Is this the future？
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Ned Batchelder拍摄的屏幕截图，去年他在Twitter上发布。他说：“我在查看这个Python文档，像， 这是什么？这是未来吗？”
- en: Are we supposed to be able to read this？"， My response at the time was like，
    "Ah， yeah， no。 Obviously even the biggest fan of typing will tell you that this
    is not optimal。 This is not what we want。"， Fortunately， there is plenty of ways
    in which even without bothering Python developers。 we， can improve the situation
    so we can make this more readable。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能读懂这个吗？当时我的回应是，“啊，是的，不。显然，连最大的类型爱好者也会告诉你这并不是最佳选择。这不是我们想要的。”幸运的是，有很多方法，即使不打扰Python开发者，我们也可以改善这种情况，使其更易读。
- en: So I responded on the Twitter thread but people started piling on with their
    own favorite。 examples where like， "Ah， how about this example？ How about this？"。
    And I came to the conclusion that sometimes ugly type annotations hint at ugly
    code。 It's a controversial thing to say， maybe insulin， but if you're not at least
    a little bit controversial。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我在推特上回复了，但人们开始争相分享他们自己喜欢的例子，比如，“啊，这个例子怎么样？这个呢？”我得出的结论是，有时丑陋的类型注释暗示了丑陋的代码。说这话可能有争议，但如果你在做演讲时不至少有一点争议，那你的人生该怎么过？
- en: doing a keynote， then how are you living your life？ It needs to be memorable。
    But also I'm pretty serious。 Like type annotations don't create additional complexity。
    They expose complexity that was always there。 And hold on， hold on。 I understand
    that eight-year-olds who first double with programming thanks to Python don't。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要令人难忘。但我也很严肃。类型注释并不会创造额外的复杂性。它们揭示了本来就存在的复杂性。等等，我理解那些八岁的小孩，第一次因为 Python 而接触编程的情况。
- en: necessarily need to know all this and it's wonderful that Python allows that。
    I understand we have even in the audience plenty of professionals who wouldn't
    otherwise call。 themselves programmers but they're enabled by Python to be productive
    in their respective， fields。 So I understand all this。 However， with experience
    you're going to be handling increasing amounts of complexity。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不一定需要知道这些，Python 允许这一点真是太棒了。我知道我们在座有很多专业人士，他们可能不会称自己为程序员，但通过 Python，他们在各自的领域中能够高效工作。所以我理解这一切。然而，随着经验的增加，你将处理越来越复杂的内容。
- en: Your five-line long snippets will become 50-line long scripts and then 500 lines
    long。 And soon enough you're going to be looking at half a million lines of code
    that you're， maintaining。 And with that increased complexity your understanding
    of what's going on has to increase as well。 Otherwise you're going to end up with
    a big ball of mud that is not really maintainable。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你五行的代码片段将变成 50 行的脚本，然后是 500 行。不久后，你将面对 50 万行代码的维护。随着复杂性的增加，你对发生的事情的理解也必须增加。否则，你将最终得到一团乱麻，根本无法维护。
- en: and its behavior cannot be easily reasoned about。 So let's talk about how we
    can structure our code such that it actually makes type annotations。 less ugly。
    First let's actually solve this case that Ned Batchelders showed us because it's
    particularly。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其行为也无法轻易推理。因此，让我们谈谈如何结构我们的代码，使类型注释看起来不那么丑陋。首先，我们来解决 Ned Batchelders 向我们展示的这个案例，因为它特别。
- en: egregious。 And luckily we can do this with only a few simple things。 First of
    all。 please use modern typing syntax。 We are working on Python 3。11 right now。
    Python 3。10 was released in October and Python 3。9 will see its final bug fix
    released just。 two weeks from now。 What that means is there is little excuse not
    using Python 3。9 right now。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 令人震惊。幸运的是，我们只需几个简单的步骤就能做到。首先，请使用现代类型语法。我们现在正在使用 Python 3.11。Python 3.10 于十月发布，Python
    3.9 的最终错误修复将在两周内发布。这意味着现在几乎没有理由不使用 Python 3.9。
- en: It's unstable Debian。 Come on。 So using modern typing syntax in Python 3。9 allows
    you to use built in types as generic， collections which is tremendously useful。
    And in Python 3。10 you can use the pipe operator for unions which combined make
    for really。 terse but readable syntax that expresses even pretty complex types。
    Let's see an example。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不稳定的 Debian。得了吧。所以在 Python 3.9 中使用现代类型语法允许你将内置类型作为通用集合使用，这非常有用。在 Python 3.10
    中，你可以使用管道运算符进行联合，这结合起来使得语法简洁而可读，能够表达相当复杂的类型。让我们看一个例子。
- en: We have a match argument to some function which can be either a string or a
    regular expression。 pattern or a none。 This is how you express it。 And the only
    piece of complexity here is that it's a regular expression of string because。
    it could be an irregular expression of bytes。 So I hope that even if this is the
    first time you're seeing type annotations in this form。 you can kind of see why
    it's read like this。 But after a while it becomes second nature just looking at
    those types you know they are。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个匹配参数可以是字符串或正则表达式模式，或者是 None。这就是你如何表达它。唯一的复杂性在于，它是字符串的正则表达式，因为它也可能是字节的非规则表达式。所以我希望即使这是你第一次看到这种形式的类型注释，你也能理解为什么要这样阅读。但过一段时间后，只需查看这些类型，你就会习惯。
- en: Let's look at a more complex example where we don't want an object of a type
    we want。 to be past a class。 So in this case we would say we expect some type
    to be given to us。 Type of E not E itself not an instance of an object a class
    or we want many of those classes。 in a tuple。 So we either accept a type of E
    or a tuple of many of those types。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更复杂的例子，在这里我们不想要一个类型的对象，而是想要一个类。因此，在这种情况下，我们会说我们期望给我们某种类型。是 E 的类型，而不是 E
    本身，也不是一个对象的实例，或者我们想要多个这样的类在一个元组中。因此我们要么接受 E 的类型，要么接受多个这些类型的元组。
- en: And with those two examples combined we end up with a much more readable piece
    of documentation。 that is an equivalent of what we've seen before。 We can really
    read what it does right now which is a context manager that responds to a raised。
    exception and you need to specify what you expect to be raised。 Either one type
    of an exception or multiple in a tuple。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个示例的结合，我们得到了一段更具可读性的文档，相当于我们之前看到的内容。我们现在可以真正理解它的作用，它是一个上下文管理器，响应引发的异常，你需要指定你期望引发的异常。可以是一个异常类型或多个在元组中的异常。
- en: And you can optionally say that we should be matching some piece of message
    in this context。 manager。 So it's either a string or a pattern of a string。 If
    we don't specify anything the default value is none。 Done okay we understand what
    is going on right now。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择性地说，我们应该在这个上下文管理器中匹配某条消息。因此，它可以是一个字符串或一个字符串的模式。如果我们不指定任何内容，默认值是 None。好了，我们现在理解发生了什么。
- en: The context manager actually returns a raised context that is dependent on the
    type of the。 exception that we gave it。 Okay so cool。 But I kind of you know helped
    it be more readable by changing formatting here a bit。 And it's maybe a mundane
    thing to say right now but I do believe that standardizing signature。 formatting
    has a lot of impact on how readable annotations later are。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该上下文管理器实际上返回一个引发的上下文，依赖于我们给它的异常类型。好的，挺不错的。但我通过稍微改变格式帮助提高了可读性。现在说这可能有点平凡，但我确实相信标准化签名格式对后续注释的可读性有很大影响。
- en: Because some pre-existing conventions on how to format them don't really gel
    well with annotations。 especially the ones that try to hang subsequent arguments
    under the opening parenthesis。 It ends up looking something like this。 It's very
    small I don't expect you to be able to read what is there。 I don't even expect
    you to be able to say how many arguments this function accepts。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因为一些预先存在的格式约定与注释不太契合，尤其是那些试图在开括号下对后续参数进行排列的约定。结果看起来像这样。它非常小，我不期望你能读懂那里写的内容。我甚至不期望你能说出这个函数接受多少个参数。
- en: It's not very nice and there's little space for the return annotation as well。
    So how do you fix it？
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是很好，而且返回注释的空间也很小。那么你该如何解决呢？
- en: Well I have one simple suggestion。 It's black in that shit you know。 I'll do
    it for you。 I'll do it automatically。 This will allow you to increase the font
    size over twice。 Now we can actually see what's going on。 We can see the name
    of the function and that it accepts three arguments。 Cool and there's plenty of
    space for the return annotation which is a dictionary of strings。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个简单的建议。它很黑暗，你知道的。我会为你做到这一点。我会自动为你完成。这将允许你将字体大小增加两倍以上。现在我们可以看到发生了什么。我们可以看到函数的名称以及它接受三个参数。不错，还有足够的空间用于返回注释，这是一组字符串的字典。
- en: to a set of strings。 But I'm not particularly happy about this annotation because
    what are those strings？
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一组字符串。但我对这个注释并不特别满意，因为那些字符串是什么？
- en: Remember type annotations are human readable documentation。 They're meant for
    humans first。 So my suggestion to you is to give those types meaningful names。
    It doesn't matter to the type checker and it matters even less to runtime Python
    which。 doesn't do much with type annotations。 But it matters a lot to a human。
    Let's see an example。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，类型注释是人类可读的文档。它们首先是为人类设计的。因此，我的建议是给这些类型赋予有意义的名称。这对类型检查器没有影响，对运行时的 Python
    影响更小，而对人类来说却非常重要。让我们看一个例子。
- en: If we have a show lyrics function that takes some query list of string and takes
    some lyrics。 database which is a dictionary of string to another dictionary of
    string to string。 This is everything that a type checker needs。 But I don't quite
    understand what's going on here。 So let us help ourselves by giving names to all
    those strings。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个显示歌词的函数，它接受一些字符串查询列表，并接受一些歌词数据库，这就是一个字符串到另一个字符串字典的字典。这是类型检查器所需的一切。但我不太明白这里发生了什么。因此，让我们通过给所有这些字符串命名来帮助自己。
- en: For example looking at the inner dictionary we can say that the keys are song
    names and。 the values are lyrics。 Now the mystery of the inner dictionary song
    so we can even give that entire dictionary。 a name song to lyrics and the annotation
    magically becomes less verbose。 We can do this with the external dictionary too
    saying the keys here are actually artist， names。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: So now with all of those annotations we have a much shorter function signature
    and also。 we can reuse those human readable names in other functions。 You can
    expect that if we are being passed a lyrics database in one function there must。
    be some other function that produces it and there might be others that filter
    them， mutate。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: them or what not。 So we're using the same annotations that communicate to humans
    what those things are tremendously。 useful， highly recommended。 So now we are
    moving from visual things from simple modifications to more of like code refactoring。
    area。 So we're going to be making increasing changes to this but this is all still
    about human understanding。 of the code at hand。 So for example I would argue that
    you should be making your functions small and simple and。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: to dispatch early to specialize the tractors of typing love to give you examples
    where。 they would use some super dynamic function the found in Python say the
    max built in and。 they will say hey try to type that and see what happens。 Well
    of course this isn't even a built in that has one signature it's got two and those。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: are plenty dynamic here as well and they allow for some funky stuff like the
    a terrible。 in the first form doesn't have to have the same types as the optional
    default value and。 the arguments given in the second form might be of incompatible
    types too like it's it's。 all good you can all do this and it will work magically
    in Python and are you using functions。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: like these of course you are this is the core of Python the vocabulary that
    we have that。 doesn't matter what kinds of data you're putting in the same verbs
    apply so it's wonderful to。 have this in Python but when was the last time you
    actually constructed a function that was。 this dynamic I would argue that if you're
    raising your hand right now which I can already。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: see like you're an author of some library or framework that needs this sort
    of dynamic。ism and gospel to yes that in this case static typing will be a little
    verbose but for everybody。 else for end user code it's very unlikely for you to
    have to deal with this sort of。 dynamicism so let's just put things in perspective
    well if you do then you will look inside the。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: implementation of a function like this because the documentation doesn't tell
    you that if。 you're implementing something that is tremendously dynamic the implementation
    tends to look sort。 of like this there's some dispatch there there's 20 lines
    here dealing with one form and 10 lines。 there dealing with another form it's
    not the kind of function that you love to read it's hard to。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: test it thoroughly right now you can talk about cyclomatic complexity whether
    you covered。 actually all paths that are possible the max built-in is wonderful
    but Python is powerful also due to。 its maturity like all the edge cases were
    already ironed out you can pretty much you know use it。 without fear that some
    edge case was not covered with functions that you're writing yourself how。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请彻底测试一下，您可以谈论循环复杂度，看看您是否涵盖了所有可能的路径。实际上，最大内置功能非常棒，但Python之所以强大，也因为它的成熟度，像所有边缘案例都已经被解决了，您几乎可以毫无顾虑地使用它。
- en: lucky is it that there is going to be some edge case that slips in well there
    might be a case like。 that so I would recommend you dispatch early replace the
    implementations with smaller functions。 that only respond to a subset of what's
    going on this allows usually for shorter function signatures。 of those sub functions
    let's call them that the external one will still have a horrible big function。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，可能会有一些边缘案例出现，所以我建议您尽早分发，将实现替换为仅响应正在发生的子集的小函数。这通常允许较短的子函数签名，外部函数仍然会有一个庞大的函数。
- en: signature with long type annotations but it is what it is life looks like that
    like that but。 why splitting the function into many sub functions allow us to
    now see the birds I view of what's going。 on and for example to identify the bug
    that was on the screen all along which is that we accept a。 boolean as the function
    signature tells us but boolean happen to be integers so maybe we don't。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 签名中有长类型注释，但生活就是这样。拆分函数成多个子函数允许我们现在看到正在发生的全局视图，例如识别出屏幕上一直存在的错误，即我们接受布尔值，如函数签名所示，但布尔值恰好是整数，所以也许我们不需要。
- en: actually want to parse it as an integer which we are here because this is the
    ordering in which the。 if's an ellipse go so by splitting the functions it's more
    likely for you during testing to identify。 this problem and you know you can assert
    maybe that as parse and does not want to get boolean because。 they're not exactly
    what we want to deal with and if you look at the function signature of the sub。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们想将其解析为一个整数，这是因为if的顺序是这样的。通过拆分函数，您在测试期间更有可能识别这个问题，并且您可以断言，可能解析不想得到布尔值，因为它们并不是我们想处理的。
- en: function it becomes pretty much trivial one argument which is only an end we
    return an item done right。 but I don't want you to only write trivial functions
    like this like this is no way to live and the。 robustness principle tells us that
    we should be flexible in what we accept and strict with what we。 emit when we're
    talking about functions that first part applies to the arguments of the function。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的签名只有一个参数，即end，我们返回一个项目，完成了。但是我不想让您只写这样的简单函数，这样生活就没有意义。稳健性原则告诉我们，在接受的内容上要灵活，而在输出的内容上要严格。
- en: and the other applies to what we return from the function let me give you an
    example from the black。 code base we're looking for configuration so we have a
    bunch of candidates for paths where。 configuration might hide and then we're going
    to be returning a path to a configuration file if we。 find it or none if we don't
    well do we need this argument to be a tuple maybe it's not really that。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另外一部分适用于我们从函数返回的内容。让我举一个来自黑色代码库的例子，我们在寻找配置，所以我们有一堆候选路径，配置可能隐藏在那里，然后如果找到的话，我们将返回配置文件的路径，否则返回空值。我们真的需要这个参数是元组吗，也许并不需要。
- en: important for it to be exactly a tuple all we're doing here is iterating over
    it so maybe saying。 just give me an iterable is a better idea because now the
    color of this function is able to provide。 you a list that they already produced
    so they don't have to convert anything they can just pass this。 data right there
    maybe they have a set and maybe that's also fine so this is what we mean about
    being。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是它不一定是一个元组，我们在这里做的只是对它进行迭代，所以说“给我一个可迭代对象”可能是个更好的主意，因为现在这个函数能够提供您已经生成的列表，因此他们不需要转换任何内容，可以直接传递这个数据。
- en: flexible and what we accept well we're strict in what we emit and are we here
    not really because we。 either give you a path or give you none and this is not
    perfect because it forces the color of the。 function to always check what is it
    that they received is it none sometimes people will forget。 to check sometimes
    they will just pass this responsibility on to further functions making。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: non proliferate in your code base which isn't something that you particularly
    want so how do you。 solve this well you can in fact use exceptions for exceptional
    states it's what python wants you to。 do in this particular case you can use a
    lookup error one of my favorite built-in exception types。 index error and key
    error both inherit from it but it's also useful for our wide array of cases like。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: this where we're finding something and failing so yes you should be using exceptions
    for exceptional。 states but there's another thing that you can do without having
    to modify types there so you can。 use empty values this is especially natural
    when you're dealing with collections for example if you。 have a function that
    lists all the users that are currently logged into our application it's perfectly。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: reasonable to return an empty list if no user happens to be logged in to your
    application at this。 point but this makes also sense depending on context to do
    for scalers so python does allow for。 full c values when we're talking about numbers
    and it allows for four c numbers a full c values。 with bullions and empty strings
    and so on sometimes that's dangerous so what you want is actually an。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: exception to inform the color that you know we actually fail to find something
    and the default。 value would hide this fact but if you ever used a default dict
    you know that there's plenty of。 cases where an empty value makes perfect sense
    none is a particular special example where returning。 it from a function is annoying
    but it's not the only one in fact any kind of type union that you're。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: returning from your function is going to be hurting your users because they
    will be forced to check。 which one did I get and if they do this and they write
    some if lf chain and you later change your。 function we already talked about bullions
    being ints but this only stands in any form of sub-classing。 code that looks like
    it works might not actually do what you want so I always recommend avoiding。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: returning unions from functions as much as you can help it so coming back to
    this robustness。 principle when we say that we want to be flexible in what we
    accept and strict in what we return。 what we're really saying is that we want
    to be vague in what we accept and concrete in what we。 return what I mean by this
    is that in the arguments here we accept a collection we don't really care。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: what it is you might give me a set you might give me a dictionary you might
    give me whatever else。 we only need a collection but when we are returning our
    list of items we should say that to the user。 not an iterable not a sequence let's
    tell them what they received by telling them exactly what。 they're getting they
    can now utilize append methods they can rely on the order of the things that。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能给我一个集合，或者一个字典，或者其他任何东西。我们只需要一个集合，但在返回我们的项目列表时，应该明确告诉用户。不是一个可迭代的对象，也不是一个序列，让我们通过告诉他们确切的内容来说明他们得到了什么。现在他们可以使用添加方法，可以依赖事物的顺序。
- en: they got and so on and so on so that's pretty much the robustness principle
    in hindsight right like。 in I don't know like high level but sometimes it's not
    really that easy to be you know truthful to。 the dot typing like make it overly
    verbose or it might actually be not helpful because you're。 gonna be spending
    a lot of time only to end up with something that's more brittle than what you。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 他们怎么说等等等等。这基本上就是事后诸葛亮的稳健原则，对吧？在我不知道的高层次上，但有时做到如实地类型标注并不容易，可能会过于冗长，或者实际上没有帮助，因为你会花费很多时间，最后得到的东西比你想要的更脆弱。
- en: wanted let me give you two examples of this so the first example is another
    piece of code from black。 where we split a single line into many lines and we're
    generating it because we're efficient so we're。 yielding those lines what that
    is is a generator that generator generates lines it does not accept。 anything
    being sent to it so none and it does not emit anything on stop iteration so another
    none。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你两个例子，第一个例子是来自黑色代码的另一段代码。我们将一行代码拆分成多行，因为我们很高效，所以我们生成这些行。这是一个生成器，生成器生成行，不接受任何发送给它的内容，所以是
    None，并且在停止迭代时不发出任何内容，因此也是 None。
- en: but I'm not really super happy with this annotation because it is super verbose
    so instead what I end。 up using is to say I'm returning an iterator of line is
    that more vague yes a little but what can。 you do with a generator that does not
    accept anything being sent to it and it doesn't do anything special。 on stop iteration
    well you can pretty much only iterate over it so it's pretty truthful to what。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但我对这个注释并不特别满意，因为它非常冗长，所以我最终使用的是返回行的迭代器。这是否更模糊？是的，有一点，但你能对一个不接受任何发送内容的生成器做些什么呢？它在停止迭代时没有任何特别的行为。好吧，你几乎只能对它进行迭代，所以这对于它的描述是非常真实的。
- en: you're wanting and it's also a much simpler annotation to be reading the opposite
    example would be。 in arguments where you're accepting a file argument an open
    file but you're looking at the body of。 your function and you're like I'm not
    really using the entire api of file I'm only using the small。 slice so maybe any
    file like object will be great you know and how do you annotate that well either。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要的，这也是一个更简单的注释。相反的例子是在参数中，你接受一个文件参数，一个打开的文件，但你查看你的函数体，发现自己并没有使用文件的整个 API，我只使用了小部分，所以任何文件类对象都很不错。你知道该如何注释吗？好吧，要么。
- en: you look at your application and see what are the possibilities of types that
    I could put there and。 there's gonna be some big union of those types or you can
    use structural typing so protocols and。 actually define what methods and attributes
    you want people to be to have to implement to。 conform to your file like object
    or you can just say any which is essentially shutting the type。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你查看你的应用程序，看看我可以放置在那里的类型的可能性。有些类型将会有一个大的联合，或者你可以使用结构化类型，也就是协议，实际上定义你希望人们实现的方法和属性，以便符合你的文件类对象，或者你可以直接说任何类型，这基本上是关闭了类型。
- en: checker up saying you know I'm gonna be doing weird things here please don't
    raise type errors。 so you can do those three things and I used to be in the camp
    that actually specified everything。 to the dot so that you know we sliced the
    contract as thinly as possible but I grew to stop doing that。 now when I need
    a file I'll tell you exactly that please just give me IO of text and we're good。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 检查器在说我会在这里做一些奇怪的事情，请不要引发类型错误。所以你可以做这三件事，我过去一直是在那种实际指定所有内容到点的阵营中，以便我们尽可能薄地划分合同，但我逐渐停止这样做。现在，当我需要一个文件时，我会确切告诉你，请给我文本的
    IO，这样就好了。
- en: why because of my previous experiences as a beginner core developer back in
    2010 I was making。 config parser a little better and I deprecated a function that
    had multiple issues with it with。 a better function of course read file and I
    didn't want to have any duplicate application of the。 implementation so I remade
    the read FP the procaded function to actually use the new one internally。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么呢？因为我作为初级核心开发者的早期经验，回到2010年，我在改善配置解析器，我弃用了一个有多个问题的函数，用一个更好的函数，当然是读取文件，而且我不想有任何实现的重复应用，所以我重新制作了读取FP过程函数，使其实际上在内部使用新的函数。
- en: the argument we accept here FP is an open file so it wasn't really a problem
    to me that before we。 were calling read line on this open file but now we were
    iterating over that new in that new。 implementation so obviously it was not a
    problem for me but it was for other people who were passing。 file like objects
    to this function and that stopped working so I had to put this piece of。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里接受的论点FP是一个开放的文件，因此在之前我们调用该开放文件的读取行时对我来说并没有真正的问题，但现在我们在新的实现中迭代这个新的对象，所以显然对我来说这不是问题，但对于将类似文件的对象传递给此函数的其他人来说，这是个问题，这样就停止了工作，所以我不得不加入这一段代码。
- en: documentation that's still there now to shame me forever that I haven't really
    foreseen this problem。 but you know and if you have to rationalize your mistakes
    later in life because you know。 otherwise you're gonna just be a sad sad person
    with plenty of regrets so I tried to realize that。 you know maybe when I wanted
    a file and the documentation never said anything else that。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 文档仍然在那里，现在让我永远感到羞愧，因为我没有预见到这个问题，但你知道，如果你不得不在生活中为自己的错误辩解，因为你知道，否则你会成为一个充满遗憾的可悲的人，所以我尝试意识到，也许当我想要一个文件，而文档从未提到过其他任何事情时。
- en: please give me an open file me changing my requirements as to which part of
    that file I want to use。 isn't really that unreasonable so if you spend your time
    cutting your contract really neatly。 to expose only the minimum of what you want
    that's perfect that's great but in the future you might。 actually want a little
    more for example if your function accepts a file like object but later on。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请给我一个开放文件，我改变对该文件哪个部分的使用要求，这并不算不合理，所以如果你花时间将你的合同修剪得非常整齐，只暴露出你想要的最少部分，那是完美的，很好，但将来你可能会想要更多。例如，如果你的函数接受一个类似文件的对象，但后来。
- en: you realize that you want to log an error case and actually tell people the
    path to you know where。 stuff gets wrong now you have to use the dot name attribute
    on a file like object and you might have。 not required this before this is not
    awesome because existing code especially on papi if this is open。 source might
    give you a lot of grief so in the end I tend to simplify and just you know be
    concrete。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你意识到你想记录一个错误案例，并实际告诉人们错误发生的路径，现在你必须使用类似文件对象的点名称属性，而你之前可能不需要这样做，这并不好，因为现有代码，尤其是在开源的情况下，可能会给你带来很多麻烦，所以最终我倾向于简化，只需具体说明。
- en: about the types that I expect people to be able to put even if something more
    will be in fact。 accepted at runtime I want to be concrete because it's my contract
    from me to you from programmer。 to a programmer so now let's talk about the mismatch
    between static typing and what python allows us。 to do at runtime because it allows
    for a lot so you can perceive some of the limitations of static。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我期望人们能够使用的类型，即使在运行时实际接受其他类型时，我也希望能具体一些，因为这就是我对你、从程序员到程序员的合同。所以现在让我们谈谈静态类型和Python在运行时允许我们做的事情之间的不匹配，因为它允许很多，所以你可以把静态类型的某些限制看作安全带，你只需把它们系上，甚至不去想，或者你可能会把这些限制更多地看作是你所戴的面具，你知道这是一个悲惨的现实，但你更希望不去面对。
- en: typing as like seat belts you just put them on you don't even you know think
    about it or you might。 think about those limitations more like the masks that
    you're wearing you know a sad sad reality。 that we're in but you know you'd rather
    not so let's see let's start with a simple thing one variable。 one type python
    will not complain if you reassign a given name to mean something entirely different。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的事情开始：一个变量，一个类型，如果你将一个给定名称重新分配为完全不同的东西，Python不会抱怨。
- en: to have a different type to have a totally incompatible value later on it's
    all good you know in terms of。 how runtime perceives this a type checker will
    be annoyed at you if you do this so now the question。 is who's right well obviously
    python at runtime is right it will run your code fine but do you need。 this form
    of dynamism all the time if you even have a very simple example that is a little
    jarring。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有不同类型，后面可能会有一个完全不兼容的值，这在运行时的感知上都是好的。如果您这样做，类型检查器会对您感到烦恼。那么问题是，谁是对的？显然，在运行时
    Python 是对的，它会顺利运行您的代码，但您是否需要这种形式的动态性？即使您有一个非常简单的例子，这也会让人感到不安。
- en: because your function signature tells you that argument is one thing whereas
    after this conversion。 to daytime it is suddenly something else no grade especially
    when this conversion doesn't happen。 right there online one but happens online
    20 of this function where it happens only in some。 conditional or better yet if
    this is in an object and under in it creates a bunch of attributes of。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您的函数签名告诉您该参数是一回事，而在转换为白天后，它突然变成了另一个东西，特别是在这种转换并未立即发生，而是在该函数的第 20 行发生，仅在某些条件下，或者更好的是，如果它在一个对象中，并且在其中创建了一堆属性。
- en: one type but then some other method modifies them to mean something else it
    is very confusing very。 quickly and it's hard to say whether this was the intent
    of the programmer so static typing。 errors on the side of caution saying you know
    this used to be a string and now you're trying。 to make it a datum are you sure
    the solution here is obvious and we should just move on just。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一种类型，但其他方法将其修改为表示其他内容，这会非常快地变得困惑，难以说这是否是程序员的意图，因此静态类型在谨慎一侧出错，表明您知道这曾经是一个字符串，而现在您试图将其变为数据，您确定解决方案显而易见，我们应该继续。
- en: use another name right like i know that there's implementers of python interpreters
    in the room。 so they will say hey but like they're not exactly free but for our
    intent and purpose here they're。 pretty much are like just adding just one more
    name is not going to destroy the world in fact。 it's useful because if you ever
    debug this function and you list its locals now you will be able to。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用另一个名称，比如我知道在场有实现 Python 解释器的人。他们可能会说，但实际上他们并不完全自由，但在这里我们的意图和目的上，他们基本上就是这样，添加一个名称不会毁掉这个世界，事实上，它很有用，因为如果您调试这个函数并列出它的局部变量，现在您将能够。
- en: see the value pre-conversion and post-conversion so if the bug is actually in
    the convert to daytime。 function it will be easier for you to identify this faster
    for you to identify this。 this all comes down to the difference between duck typing
    so structural typing and nominal typing。 so us telling that this is an int this
    is a string this is a list of string this difference is highlighted。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 查看转换前后的值，因此如果错误实际上发生在转换为白天的函数中，您将更容易快速识别。这一切归结于鸭子类型与结构类型和命名类型之间的区别。因此，我们声明这是一个整数，这是一个字符串，这是一个字符串列表，这种差异得到了突出显示。
- en: sometimes you know when people talk about type annotations but for me personally
    they aren't。 actually that different so it is true entirely that when we are running
    python code unless you're。 running its instance or its subclass python doesn't
    care about the types all it cares about is if you。 have an object and you look
    up some attribute on it that it finds this attribute or if you're。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您知道当人们谈论类型注解时，但对我个人来说，它们并没有太大不同。因此，确实如此，当我们运行 Python 代码时，除非您运行其实例或其子类，Python
    不关心类型，它只关心您是否有一个对象，并且在该对象上查找某个属性时能否找到这个属性，或者如果您。
- en: calling a method on an object it finds that method and its signature is compatible
    with whatever。 arguments were given during the call as long as that's fine it
    doesn't care right if it quacks like a。 duck it's a duck like as much as we care
    nominal sub-typing means that in-function signatures。 in fun in type annotations
    we don't really specify what we're going to be using we're saying what。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 调用对象上的方法时，它找到该方法，并且其签名与在调用期间提供的任何参数兼容，只要这样就没问题。如果它像鸭子一样呱呱叫，那就是鸭子，正如我们关心命名子类型的意思，函数签名和类型注解中我们并没有真正指定我们将要使用什么，我们在说什么。
- en: this thing should be what it is so we need an integer we need a decimal we need
    a string we need。 a path object this sort of thing but if you look at a program
    even at a at a big one there's always。 only a finite set of which objects actually
    conform to the operations that you're doing on the object。 within your function
    so at worst what you will be dealing with is some union of possible types that。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个东西应该是它应该是的样子，所以我们需要一个整数，我们需要一个小数，我们需要一个字符串，我们需要一个路径对象，这种东西，但如果你看看一个程序，即使是一个大的程序，总是。只有一个有限的对象集合实际上符合你在函数中对对象进行的操作，因此最糟糕的情况是你将处理某种可能类型的并集。
- en: can actually successfully respond to whatever the function is doing without
    a given argument so with。 that in mind nominally listing those either one in the
    happy case or a union of a few isn't really。 that bad there is not really a huge
    disconnect there and better yet nominal typing doesn't mean you。 only have to
    specify concrete classes there's abstract base classes now so you can say it's
    a。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上可以在没有给定参数的情况下成功响应函数的任何操作，因此考虑到这一点，名义上列出那些，无论是在令人满意的情况下还是几个的并集，其实并不是。太糟糕，这并没有真正造成巨大的脱节，更好的是，名义类型并不意味着你。只能指定具体的类，现在有抽象基类，所以你可以说这是一个。
- en: terrible of string just as just as well if you don't mean a particular implementation
    I only care about。 song structure and if you really want a flexible structure
    protocols allow for that too but giving。 nominal types is sometimes helpful for
    us for example when we're dealing with dynamism of python that。 can be sometimes
    dangerous for example in python a string is also a interval of strings if you
    pass。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的可怕之处在于，如果你不特指某个实现，我只关心。歌曲结构，如果你真的想要一个灵活的结构，协议也允许这样，但给出。名义类型有时对我们是有帮助的，例如，当我们处理python的动态性时。这有时可能是危险的，例如在python中，字符串也是字符串的区间，如果你传递。
- en: a single string to a for loop it will happily split the string character per
    character and do the。 iteration with no complaints but if we look at the previous
    example in the actual black code what we。 have is not an interval of path which
    is a happy case but a interval of string where a single string。 is also one so
    do we want this is this a feature for us if we by mistake specify a single string。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单一的字符串到一个for循环，它会高兴地逐字符地拆分字符串，并进行。迭代而没有任何抱怨，但如果我们查看前面的例子，在实际的黑色代码中，我们。所拥有的不是路径的区间，这是一个令人满意的情况，而是字符串的区间，其中一个单一的字符串。也是一个。那么我们想要这个吗？这对我们来说是一个特性吗？如果我们错误地指定了一个单一的字符串。
- en: now the for loop will cut the string into characters and happily try them as
    candidates this is。 meaningless so what we have to do is either to do this dreaded
    is instance where duck type people。 will tell you don't use this instance like
    that's anti duck typing but you have to do it here because。 otherwise you will
    be opening yourself up to this bug what you can also do though is to just say。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在for循环会将字符串切分为字符，并高兴地尝试它们作为候选者，这毫无意义，所以我们必须做的就是进行这个可怕的实例化，鸭子类型的人。会告诉你不要使用这个实例，因为这违背了鸭子类型，但你必须在这里这样做，否则你会。给自己留下这个bug。你也可以说。
- en: we don't want interval of string we want a list of string yes other types will
    be accepted too but。 through this simplification we are dealing with a class of
    errors that people can do。 and this lets us to typing things that are not quite
    clear to how to do。 very often you're be tempted to just put any there so let's
    talk about this for a second。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想要字符串的区间，我们想要字符串的列表，是的，其他类型也会被接受，但。通过这种简化，我们处理的是人们可能犯的错误类别。这样我们就能输入一些不太明确的内容。你会很常被诱惑去简单地放任何东西，所以我们来讨论一下这个。
- en: people who are just beginning with typing often ask me like you know isn't object
    the base class。 of everything in python so why do we need to input any from typing
    like if i say this should be object。 like wasn't will wanted be true as well well
    for the typing use case they're actually opposites。 when you are typing an argument
    to be a string what it tells the type checker is that any operation。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 刚开始接触类型的人经常问我，你知道的，object不就是python中所有东西的基类吗？那么我们为什么还需要从typing中输入any呢？比如我说这应该是object，那不是也应该是真的吧？嗯，在类型使用案例中，它们实际上是相反的。当你将一个参数类型标记为字符串时，它告诉类型检查器的是任何操作。
- en: which is valid on a string so concatenating it to another string or calling
    the upper method。 all those things are fine but if you call say append the type
    checker will now complain because。 that operation is not implemented on strings
    so if you would say object right if you would annotate。 an argument as object
    what that tells the type checker is that any operation that is valid on the。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串上是有效的，因此将其连接到另一个字符串或调用 `upper` 方法都是可以的。但是，如果你调用 `append`，类型检查器将会抱怨，因为该操作在字符串上并未实现。因此，如果你将一个参数标注为对象，这告诉类型检查器任何在字符串上有效的操作。
- en: base object type is accepted and nothing else what operations do objects accept
    well you can check。 it's id you can convert it to a boolean you can see it's wrapper
    not much than that right all the。 upper appends and other attributes are not there
    on the base type so any is the opposite it tells。 the type checker that whatever
    operation the user will do inside that function should be considered。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 基本对象类型被接受，没有其他类型。那么对象接受什么操作呢？你可以检查它的 ID，你可以将其转换为布尔值，你可以查看它的包装器，没有其他更多，对吧？所有的
    `upper`、`append` 和其他属性在基本类型上是不存在的，因此 `any` 则正好相反，它告诉类型检查器，用户在该函数内进行的任何操作都应被考虑。
- en: valid please don't raise exceptions there so any is tempting you might be tempted
    to to use it whenever。 you don't know what you what you should be putting instead
    but it's not that great and the reason why。 it's not is it will again proliferate
    just like Nandas and silence actually valid warnings from the。 type checker because
    now it is instructed by you explicitly to ignore problems that it sees elsewhere。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有效性，请不要在那里引发异常，因此任何类型都很诱人，当你不知道应该放什么时，你可能会想使用它，但这并不是很好，原因在于，它会像 Nandas 一样繁殖，并实际上会使类型检查器的有效警告沉默，因为现在你明确指示它忽略它在其他地方看到的问题。
- en: in your code so Annie should be sort of taken with a grain of salt and used
    with care and let me。 just finish with another controversial thing because you
    know like I only had one so far。 which is that I started considering strings to
    be not much better than Annie because a string can。 be an identifier from a database
    it can be an email address it can be an entire poem or a JSON。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中，Annie 应该被谨慎对待，使用时要小心。让我再谈谈另一个有争议的话题，因为到目前为止我只提到过一个，那就是我开始认为字符串和 Annie
    并没有多大区别，因为字符串可以是数据库中的标识符、电子邮件地址、整个诗歌或 JSON。
- en: encoded image it can be whatever so when you use strings as types everywhere
    what are you getting。 you don't actually know so I'm not saying you should be
    not using strings from now on but whenever you're。 seeing that your function accepts
    a bunch of strings everywhere let's think about like hey maybe。 there is some
    other representation that I can use that will explain my intent better and it'll。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 编码的图像可以是任何东西。因此，当你在各处将字符串用作类型时，你究竟得到了什么？你并不真正知道，所以我并不是说从现在开始你不应该使用字符串，但每当你看到你的函数接受大量字符串时，让我们想想，嘿，也许有其他表示方法可以更好地解释我的意图。
- en: make sure that I'm not swapping a string that is incompatible with one that
    I actually wanted。 so I could still keep talking and keep talking and keep you
    from the nice coffee break that will。 come after but there's only that much of
    typing information a person can reasonably。 get at one point so let me just give
    you some further reading if you're actually dealing with。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我没有交换一个与我实际想要的字符串不兼容的字符串。因此，我可以继续说下去，让你错过之后的美好咖啡时间，但一个人可以合理地处理的信息量是有限的。让我给你一些进一步的阅读材料，如果你实际在处理。
- en: JSON that I just mentioned type dict will allow you to say that if the key is
    named email it's。 going to be a string but if it's named birth year it's going
    to be a number all right so you can。 actually now annotate strongly some you know
    random dictionaries you're getting from the internet。 we already talked about
    giving meaningful names to strings but there's still nothing stopping you from。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚提到的 JSON 类型 `dict` 允许你说，如果键名为 email，它将是一个字符串，但如果名为 birth year，它将是一个数字。因此，你实际上可以对从互联网获取的随机字典进行强标注。我们已经讨论过给字符串赋予有意义的名称，但仍然没有任何事情阻止你。
- en: you know putting an artist name where a son name should go so new type is a
    functionality of typing。 where you can actually semantically differentiate between
    two kinds of strings or numbers or whatever。 else so look up new type it is very
    good for that and finally in the talk you might have gotten the。 impression that
    I'm not really that happy about you know structural typing about ductile no it's。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道的，将艺术家名称放在应该是姓氏的位置，所以new type是一个打字的功能，可以在语义上区分两种字符串或数字或其他东西，所以查一下new type，它在这方面非常好，最后在演讲中你可能会得到这样的印象，即我对结构化类型和灵活性并不是特别满意，其实并不是。
- en: not what I'm saying it's just that you know sometimes it is a little too heavy
    of a tool for what you。 actually need but since my name is on the pep like you
    know please read the protocols pep it's a wonderful。 feature of typing as well
    which gives us a lot of flexibility to actually merge duct typing with。 type checkers
    so go ahead and look it'll likely solve issues that you might be having later
    on in。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不是我想说的，只是你知道，有时候这个工具对你实际需要的功能来说有点过于复杂，但既然我的名字在提案上，你知道的，请阅读协议提案，这真是一个奇妙的功能，打字时给我们带来了很多灵活性，可以将结构化类型与类型检查器结合，所以请去看看，这很可能会解决你以后可能遇到的问题。
- en: the future and a class of errors that you know or like annotations that I like
    to talk about but。 there's no time right now is self-type so whenever a function
    accepts some object and returns another。 one like it or accepts a type and returns
    an instance of it this is a very very popular。 scheme in Python because it's how
    methods and class methods work so reading on self-type and how。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将来，有一类错误，我喜欢讨论的注解是self-type，但现在没有时间，每当一个函数接受某个对象并返回另一个类似的对象，或接受一个类型并返回它的实例时，这在Python中是一个非常流行的模式，因为这就是方法和类方法的工作原理，所以阅读self-type以及如何。
- en: to use type-vars and then newly added self is going to help you actually navigate
    this sort of thing。 especially when sub-classing is involved and finally varance
    is a word where I'm like you know sure to。 lose the audience so instead of talking
    about it right now I'm going to be giving a lightning talk。 later today just in
    five minutes just about variance like you might just laugh at it later but。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型变量，然后新添加的self将帮助你实际处理这些情况，特别是在涉及子类时，最后关于方差是我觉得你知道的术语，可能会让观众失去兴趣，所以我现在不谈它，今天晚些时候我会进行一个快速演讲，仅仅五分钟，关于方差的内容，之后你可能会笑。
- en: you might actually get what contra variance covariance and invariance are and
    the funny thing about。 this is that people hate static typing for variance they're
    like you know those weird terms like why。 are you imposing this on me but this
    is something that you're dealing with in collections even if。 you don't think
    about this same with list of substitution principle you might be breaking it。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会真正理解什么是反变、协变和不变，搞笑的是，人们讨厌因方差而引入的静态类型，他们觉得那些奇怪的术语，为什么要强加给我，但即使你不这样认为，这也是你在集合中处理的事情，与替换原则相同，你可能正在破坏它。
- en: even if you never use the type checker the type checker only exposes those classes
    of issues so。 reading up on all of this is very very useful so you know there
    can be too much of a good thing just。 like with this talk so for example if you
    find yourself you know fighting type annotations if you。 find yourself unable
    to express what is happening you can take a step back they take a step back and。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你从未使用类型检查器，类型检查器只会暴露这些问题的类别，所以阅读这些内容非常有用，你知道的，太多的好东西也是有问题的，就像这个演讲一样，例如，如果你发现自己在与类型注解作斗争，如果你发现自己无法表达正在发生的事情，你可以退一步。
- en: ask yourself hey like Python is dynamic should I be using those features yes
    of course like this is。 why we're on pikon you know come on like a dynamicism
    is great the flexibility that we have from runtime。 introspection is wonderful
    we should be using those things but should you be 100 dynamic 100%。 of the time
    I would argue that you don't have to so whenever you find that your types are
    especially。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 问问自己，嘿，像Python是动态的，我应该使用那些特性吗？当然应该，这就是我们在Python上的原因，动态性真是太棒了，从运行时的内省中获得的灵活性也很奇妙，我们应该利用这些，但你真的要一直100%动态吗？我认为其实不必，所以每当你发现你的类型特别。
- en: ugly just consider refactoring maybe you can simplify and if you cannot maybe
    you can shove the complexity。 somewhere else so divide and conquer this doesn't
    fundamentally change the amount of complexity in。 the system but it will let you
    deal with a smaller amount at a time which even in the Zen of Python。 is a good
    thing so with that in mind I'm not sure if we have time for questions right now
    if we do。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 丑陋的话，考虑重构，也许你可以简化，如果不能，可能就把复杂性推到其他地方去。所以分而治之，这并不会从根本上改变系统中的复杂性，但它会让你一次处理更小的量，这在Python的Zen中也是一件好事。所以考虑到这一点，我不确定我们现在是否有时间回答问题，如果有的话。
- en: that's great if not I'm happy to answer any questions you might be having if
    you find me at。 the conference I'm gonna be masked so it's gonna be a challenge
    for you but I'm here for you thank you。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有问题，那太好了，我很乐意回答你可能有的任何问题。如果你在会议上找到我，我会戴上口罩，这对你来说会是一个挑战，但我会在这里为你服务，谢谢。
- en: '![](img/662eb3bc4641f5e3a0bbb008642ee734_5.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/662eb3bc4641f5e3a0bbb008642ee734_5.png)'
- en: for your attention。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢你的关注。
