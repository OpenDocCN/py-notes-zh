- en: P74：Talk - Sam Scott_ Why Authorization is Hard - VikingDen7 - BV1f8411Y7cP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P74：演讲 - Sam Scott_ 为什么授权很困难 - VikingDen7 - BV1f8411Y7cP
- en: \>\> Our next talk is about to start。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: \>\> 我们的下一场演讲即将开始。
- en: '![](img/7d2460332f12e9adc53684e71c4115a7_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d2460332f12e9adc53684e71c4115a7_1.png)'
- en: Sam Scott， the co-founder and CTO of OSO will talk about why authorization is
    hard。 \>\> Thank you。 Sam。 \>\> Well， thanks very much， everyone。 So to start
    with。 I actually have an announcement which is I will not be giving that talk。
    Sorry about that。 When I sat down to write this， I decided it felt a little bit
    too negative。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: OSO的联合创始人兼首席技术官Sam Scott将谈论为什么授权是困难的。\>\> 谢谢你，Sam。\>\> 嗯，非常感谢大家。那么，首先，我实际上有一个公告，那就是我不会做那个演讲。很抱歉。当我坐下来写这个时，我觉得这有点太消极了。
- en: Everyone just had a big lunch。 You don't want to come in here and hear me whine
    about authorization for half an hour。 So instead， I will be talking about why
    authorization is fun。 There we go。 So this talk is for。 I'd say， two types of
    people。 This is your chance to run away if you're not one of those two。 Either
    you have never heard about authorization before， and I'm basically going to give
    you。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 大家刚刚吃过一顿丰盛的午餐。你不想在这里听我抱怨授权半个小时。所以，我将讨论为什么授权是有趣的。好了，这个演讲是针对两类人的。如果你不是其中之一，现在就是你逃跑的机会。要么你之前从未听说过授权，而我基本上会给你一个。
- en: a crash course in all the different ins and outs and what makes it fun。 Or you've
    experienced authorization before， you have felt the pain， and you are incredibly。
    skeptical about how it could possibly be fun。 Who am I to talk about this topic？
    Well， first of all。 I did a PhD in cryptography， so I definitely not fun is。 But
    since then。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 关于各种细节的速成课程，以及是什么让它变得有趣。或者你之前经历过授权，你感受到过痛苦，并且你非常怀疑它究竟怎么可能有趣。我有什么资格谈论这个话题？首先，我在密码学方面做过博士研究，所以我绝对知道什么是不有趣的。但是自那以后。
- en: since then I've been spending my time trying to make security less terrible，
    for developers。 And in the course of that， I've met with hundreds of companies
    speaking about how they're trying。 to do authorization and what's been fun about
    it。 So just put some terms out there。 So I'm talking about authorization， not
    authentication。 So authentication is about identity。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，我一直在花时间努力让安全性对开发者来说不那么糟糕。在这个过程中，我与数百家公司交流，谈论他们如何尝试进行授权，以及这其中的乐趣。所以我就先说一些术语。我所讨论的是授权，而不是身份验证。身份验证是关于身份的。
- en: Who is the user？ User name， password， multi-factor or single sign on that kind
    of thing。 I'm not talking about that。 I'm not talking about OAuth。 I'm not talking
    about access to infrastructure， getting access to your S3 buckets。 I'm talking
    about authorization inside an application。 So once the user is logged in。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 谁是用户？用户名、密码、多因素或单点登录这类的东西。我不是在谈论这些。我不是在谈论OAuth。我也不是在谈论访问基础设施，获取你的S3桶的访问权限。我是在谈论应用程序内部的授权。因此，一旦用户登录。
- en: what can they do inside that app？ For some examples， I assume most people are
    familiar with GitHub。 I think GitHub is a pretty unobtrusive authorization model。
    Honestly， most of the time。 I don't even think about it when I'm inside GitHub。
    I can just kind of go about my business and contribute to repositories。 On the
    other hand。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 他们在那个应用程序内可以做什么？举个例子，我假设大多数人都熟悉GitHub。我认为GitHub是一个相当不引人注目的授权模型。老实说，大多数时候，我在GitHub内时甚至不会想到它。我可以顺其自然地做我的事情并为库做贡献。另一方面。
- en: AWS has a product called IAM。 Super powerful， flexible， complex。 can let you
    do really anything you want。 And probably most people who have interacted with
    it wish they spent less time with it。 There's a trade-off there。 I think Summer
    in the Middle is products like Notion。 They can give you a large degree of granularity
    on a per-page basis。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: AWS有一个名为IAM的产品。非常强大、灵活且复杂。可以让你做任何你想做的事情。而且，可能与之互动的大多数人都希望自己能花更少的时间在上面。这其中有一个权衡。我认为中间的夏季产品像Notion。它们可以在每页基础上提供很大的粒度。
- en: I can specify groups of people who can read or edit that page。 And they actually
    have some really nice UI to help you inform you of exactly what you， can do。 So
    you can see this document， you belong to this group， so on。 On the flip side of
    that， though。 Notion has historically had some performance problems， victim of
    their own success。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以指定可以查看或编辑该页面的人员组。实际上，他们有一些非常好的用户界面来帮助你了解你可以做什么。因此，你可以看到这份文档，你属于这个组，等等。不过，值得注意的是，Notion在性能上历来存在一些问题，这是他们成功的代价。
- en: And allegedly a lot of that is because of the complexity of their permission
    system。 So there's really no free lunch here。 It's like you can do a lot of work
    and then you're going to have a big engineering effort。 So what is it about authorization
    that makes it important？ Well， from the examples you just saw。 it's a core part
    of the product。 People need to get access to things。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 而据说，这很大程度上是因为他们权限系统的复杂性。所以这里没有免费的午餐。就像你可以做很多工作，然后你会面临巨大的工程压力。那么，授权的重要性在于什么呢？好吧，从你刚刚看到的例子来看，它是产品的核心部分。人们需要获得访问权限。
- en: If you had a product without authorization， it would be entirely anarchy。 Like
    everyone could just see and do absolutely everything。 So it's a cool part of the
    product。 But equally， if it fails， your entire app probably goes down。 If your
    authorization breaks。 no one could do anything in your app。 Or again， I don't
    like to hop on the security piece。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的产品没有授权，那将完全是无序的。每个人都可以看到和做任何事情。因此，这是产品中一个很酷的部分。但是同样，如果它失败了，你的整个应用程序可能会崩溃。如果你的授权出现问题，没有人能在你的应用程序中做任何事情。或者，我不想总是强调安全性的问题。
- en: but if you get authorization wrong， people might get access to data they're
    not supposed to。 data breaches， things like that。 So the stakes are pretty high
    for authorization。 And I think because of this， it's why people cannot some be
    a little bit scared to touch it。 It can be a piece of the code base that people
    stay away from。 And that's not fun。 So in this talk。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你搞错了授权，人们可能会获得他们不该访问的数据。数据泄露，诸如此类。因此，授权的风险相当高。我认为正因为如此，人们有时会对接触它感到有些害怕。这可能是代码库中的一个人们避而远之的部分。这可不好。所以在这次演讲中。
- en: I'll be talking about three distinct areas of authorization。 The modeling， the
    enforcement。 and the architecture。 And these all are intertwined and relate to
    each other。 So modeling。 this is about basically figuring out what you want your
    application to do and。 then going and implementing it。 So this is things like。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我将讨论三个不同的授权领域：建模、执行和架构。这些都是相互交织并相互关联的。建模，这基本上是关于确定你希望你的应用程序做什么，然后去实现它。这包括这样的事情。
- en: do you want your app to have sharing or roles or administrators？ Or what does
    that look like？
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望你的应用程序拥有共享、角色或管理员吗？或者这是什么样的？
- en: And then how do you go and build it？ As I mentioned at the beginning。 I've spoken
    to hundreds of companies at this point。 And typically， when I ask them。 what kinds
    of things does the app do， they all， about， half of them will say， oh。 we have
    something super bespoke custom that you probably haven't， heard before。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你如何去构建它？正如我一开始提到的，我到目前为止已经和数百家公司交谈过。通常，当我问他们应用程序能做什么时，他们大约一半的人会说，哦，我们有一些超级定制的东西，你可能没听过。
- en: I'll kind of like smile and nod knowingly as they list something that's on my
    sort of。 like list of different authorization patterns and I'll kind of go along
    and tick them off。 But every now and then， I do hear something new。 And so that
    list kind of keeps growing。 It's now 22 different authorization models that we've
    sort of seen out there that different。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们列出我心目中不同授权模式的某个项目时，我会微笑着点头。但时不时我确实会听到一些新的东西。因此，这个列表不断增长。现在我们已经看到22种不同的授权模型，不同的公司拥有这些模型。
- en: companies have。 And so most companies will have some combination of these 22
    different models。 So the question is， what do we do？ How do we implement this？
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所以大多数公司会有这22种不同模型的某种组合。那么问题是，我们该怎么办？我们如何实现这一点？
- en: A lot of authorization comes down to this core interface。 It has three inputs，
    a user， an action。 and a resource。 And the thing we're trying to do is basically
    answer the question。 can the user perform this， action on this resource？ All right。
    And the thing you get back is normally， you know， a yes/no。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 许多授权都归结于这个核心接口。它有三个输入：用户、操作和资源。我们要做的基本上是回答这个问题：用户能否对这个资源执行这个操作？好吧。你得到的结果通常是“是/否”。
- en: So as an example of a really simple authorization model， we might say that admins
    can do anything。 All right。 This answer is always true when they're an admin。
    There's two core pieces of this model that I want to call out。 One is the logic。
    It's kind of the abstract piece of this that says admins can do anything。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 举个简单的授权模型例子，我们可以说管理员可以做任何事情。好的。当他们是管理员时，这个答案总是正确的。这个模型中有两个核心部分我想提到。一是逻辑。这是一个抽象的部分，说明管理员可以做任何事情。
- en: And the second is the data that drives that。 In this case。 I'm just representing
    it as like an attribute pulled off of my Python class。 So you know。 this is admin
    field。 But equally， that data could come from the database。 So in this case。 the
    logic is the same。 I'm still saying admins can do anything。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是驱动这个的数据信息。在这种情况下，我只是将其表示为从我的Python类中提取的一个属性。所以你知道，这是管理员字段。但同样，这些数据也可以来自数据库。所以在这种情况下，逻辑是相同的。我仍然说管理员可以做任何事情。
- en: But the data is coming from a database， maybe an admins table or something like
    that。 So those are two core pieces。 I'll come back to it a lot。 So this is a very
    simple model， right？
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但是数据来自于一个数据库，可能是一个管理员表或类似的东西。所以这两部分是核心内容。我会多次提到这一点。所以这是一个非常简单的模型，对吧？
- en: It's just as admins can do everything。 We don't speak about non-admins。 And
    typically in products。 people want more granularity than this。 You know， I wouldn't
    be able to invite members to the organization。 maybe， but they can't change， the
    billing info。 You can read， but not write， and so on。 And so in a product like
    GitHub， you have this concept of role-based access control。 It's a very。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是管理员可以做一切。我们不讨论非管理员。而通常在产品中，人们希望比这更细致。你知道，我可能无法邀请成员加入组织，但他们无法更改账单信息。你可以读取，但不能写入，等等。在像GitHub这样的产品中，你有基于角色的访问控制的概念。这是非常常见的。
- en: very common thing that people reach for。 The general idea is that you sort of
    group the kinds of things people can do by this thing。 called a role。 And it kind
    of describes who you are or what you can do inside the app。 So in GitHub。 you
    can have one of five roles on a repository。 These range from things like reads。
    which means you can read the repository， to triage。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常用的一个很常见的东西。一般来说，你可以通过这种称为角色的东西将人们可以做的事情分组。这种角色描述了你是谁或你在应用程序中可以做什么。因此在GitHub中，你可以在一个代码库中拥有五种角色之一。这些角色包括读取，这意味着你可以读取代码库，到分类。
- en: which means you can go and close issues all the way down to an admin that can
    basically。 do anything。 So in Python， you might represent this role-based access
    control model by sort of mapping this。 to maybe like a dictionary or something。
    So here， we're saying for each role。 we're basically creating a dictionary or
    this is， kind of a matrix from that role name to the kinds of things they can
    do。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以关闭问题，一直到管理员，基本上可以做任何事情。因此在Python中，你可以通过将其映射到字典或类似的东西来表示这种基于角色的访问控制模型。因此在这里，我们说对于每个角色，我们基本上创建一个字典，或者说这是一个从角色名称到他们可以做的事情的矩阵。
- en: So read can read repository， clone repository， things like that。 So given that
    we have that dictionary back in our logic， we can write this sort of a simple。
    role-based access control model like this。 So basically。 the check becomes a user
    can do an action on a resource if they have a role。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所以读取可以读取代码库，克隆代码库，类似的事情。因此，考虑到我们在逻辑中有这个字典，我们可以编写这种简单的基于角色的访问控制模型。基本上，检查变成用户是否可以在资源上执行某个操作，如果他们拥有一个角色。
- en: and the role has that permission on that kind of resource。 And this is a really
    common thing that people reach for。 This is a really good starting point to add
    a certain amount of granularities to your， app。 But it's still not enough。 It's
    not enough because in， think about something like GitHub。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 并且该角色在这种资源上拥有该权限。这是人们非常常用的一个东西。这是为你的应用程序添加一定程度细粒度的一个很好的起点。但这仍然不够。因为想想像GitHub这样的东西。
- en: you don't just have， one repository role， you have it on a per-repository basis。
    And so in reality。 most applications look more like this。 Most models rather look
    more like this。 You have multiple tiers of resources that are related to each
    other。 Users can have roles for the organization。 They can have a role in the
    repository。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅仅有一个代码库角色，而是按每个代码库为基础的角色。因此实际上，大多数应用程序看起来更像这样。大多数模型看起来确实更像这样。你有多个层级的资源，它们彼此相关。用户可以拥有组织的角色。他们可以在代码库中拥有一个角色。
- en: They create issues and stuff like that。 And so the logic and the data that backs
    this is similarly a lot more complex。 So what I have here is a sort of kind of
    pseudo-code but pretty realistic example of that more complex。 authorization model。
    Now this is just for saying whether a user can do something on an issue inside
    GitHub。 and we're doing things like checking the all roles， the repository roles，
    checking if。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 他们创建问题和类似的东西。因此支撑这一切的逻辑和数据也复杂得多。所以我在这里有一种伪代码，但却是一个比较现实的复杂授权模型示例。现在这只是为了说明一个用户是否可以在GitHub中对某个问题执行某个操作，我们正在做的事情包括检查所有角色、代码库角色，检查是否。
- en: they're an admin， checking if they created the issue。 And this is not a， you
    know。 this is not like an odd use case by any， by any search， of the imagination。
    This is very common both in terms of the complexity of the model and also the
    implementation。 honestly。 Like you'll probably see equivalent code to this in
    many code bases。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 他们是管理员，检查他们是否创建了问题。这并不是一个奇怪的用例，绝对不是。这在模型的复杂性和实现上都非常常见，坦白说。你可能会在许多代码库中看到与此等效的代码。
- en: And so this is what tends to happen is that as your authorization model grows，
    so the。 code grows and it kind of becomes this big ball of mud kind of sticking
    together different。 conditions。 And like it's really sort of flaky， it's hard
    to maintain。 People don't want to touch it because remember again， authorization，
    it's like it's on the。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常发生的情况是，随着你的授权模型的增长，代码也会增长，最终形成一个庞大的“泥球”，不同的条件彼此粘连。而且，这样的结构非常脆弱，维护起来很困难。人们不愿意碰它，因为要记住，授权是一个。
- en: critical path。 It needs to be fast。 You've got， you know， performance hacks
    like thrown in there。 And that's， that stuff is not fun。 And I promise you fun。
    So how do we make this fun？
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 关键路径。需要快速。你知道，这里需要一些性能优化。这些东西都不有趣。我向你保证，乐趣在于。那么，我们如何让这一切变得有趣呢？
- en: So I think the solution is basically to turn to purpose-built languages for
    authorization。 And there's quite a lot of good examples out there because authorization
    maps really。 nicely to like either declarative languages or logic-based languages。
    It's just a paradigm that's really well suited for the problem space。 So why is
    this fun？ Well。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我认为解决方案基本上是转向为授权而设计的专用语言。市面上有很多不错的例子，因为授权与声明式语言或基于逻辑的语言非常契合。这是一个非常适合这个问题领域的范式。那么，为什么这很有趣？好吧。
- en: first of all， building a language is a lot of fun。 Spoilers， aloe。 so we build
    a language for authorization。 That part is a lot of fun。 But you'll probably struggle
    to make the case to your boss that you should go and implement。 a language for
    your authorization problems。 It's not unheard of and if you want to。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，构建一种语言非常有趣。剧透，芦荟。所以我们为授权构建了一种语言。那部分确实很有趣。但你可能很难说服你的老板，你应该去实现一种解决授权问题的语言。这并不罕见，如果你想要的话。
- en: I will help you make that pitch。 But I think the thing that's really fun is
    once you have something like an expressive。 language for authorization， it kind
    of helps you get this， get authorization。 like the implementation， details out
    of the way。 Right？
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我会帮助你提出这个建议。但我认为真正有趣的事情是，一旦你有了像表达性强的授权语言，它可以帮助你将授权的实现细节摆脱困扰，对吧？
- en: So instead of focusing on like the how do you want to make it all work， you
    get to focus。 on the sort of what do you want your product to do。 And that is
    honestly that that's the piece that I find really fun。 Right？
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，与其关注如何让它运作，你更应该关注你希望你的产品做什么。这 honestly 是我觉得非常有趣的部分，对吧？
- en: Going back to those 22 models， like which ones do I want？ How do I get them
    working？
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 回到那22个模型，我想要哪些？我该如何让它们运作？
- en: What do I want the users to be able to do？ So takeaways from modeling。 Remember
    it's all about logic and data。 We're answering that question。 can the user perform
    an action on a resource？ And it very commonly starts out simple but over time
    gets more and more complex。 And that's just something to be aware of。 And so it's
    often a time where something like a language can be a good approach。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望用户能够做什么？因此，从建模中可以得出的要点是，记住这关乎逻辑和数据。我们在回答这个问题：用户能否对资源执行某个操作？这通常开始得很简单，但随着时间推移会变得越来越复杂。这是需要意识到的事情。因此，通常这是一个语言可以很好解决的问题时刻。
- en: Okay， so next I want to talk about enforcement。 So enforcement is all about
    taking that model that we just built and working out how to enforce。 it or carry
    it out。 So many ways it's sort of the flip side of the authorized method that
    I just showed you。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，接下来我想谈谈执行。执行就是将我们刚刚构建的模型落实到位或执行的过程。从某种意义上说，这就是我刚刚向你展示的授权方法的反面。
- en: Right？ So this is a pretty common example。 A typical example。 imagine we have
    a flask route that takes in a document ID and returns， the document to the user。
    We want to make sure that the user can only read documents that are allowed to。
    So we add our enforcement there that checks， okay， can the user do this thing。
    And if not。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: we return an exception or an error。 And this is your bread and butter typical
    enforcement。 But it's not sufficient。 It's not enough。 And the reason is because
    if you just do this。 then typically what will happen is your， user will stumble
    across some page and they get some big horrible error。 And that is not fun for
    anybody。 And I'm claiming that this is our responsibility as developers to avoid
    people from hitting big。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: horrible error messages。 And so the way we do that is we want to basically inform
    our users early on what they can and。 can't do inside the app。 You can sort of
    think of this like Minority Report if you've seen the film。 It's like a pre-crime
    decision where they can sort of anticipate that someone is going。 to do something
    wrong so they get there early and then they， I'm pretty sure they just educate。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: them and send them on their way， right？ That's what we're trying to do here。
    So in an example of this in the wild， I have a little game here。 It's going to
    be the spot the difference。 I have the same page in GitHub。 It's the OSO organization。
    At the top， I'm logged out and at the bottom， I'm logged in。 So there's a bunch
    of differences。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The one I want to call out in particular is this account of how many repositories
    OSO supposedly。 has。 So at the top， if you can't read that， it's pretty small。
    At the top。 it's saying there are 35 repositories and at the bottom， there are
    70。 And basically。 what's happening here is GitHub is filtering out and hiding
    from me the repositories。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: that I don't have access to when I'm logged out。 So these are private repositories
    inside the organization。 GitHub doesn't let me try and open this page and then
    give me big error that says you don't。 have access。 They just hide it from me
    entirely。 So I'm unlikely to stumble into an error page saying I don't have access
    because I can't。 even try to get there in the first place。 So the way we might
    try to achieve this。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: let's say in a Django app， is by taking that authorization， model from before。
    taking our logic and trying to push it down into the database。 The core idea here
    is by taking your logic and turning them to something like a query， filter。 so
    that when we make a query to the database， let's say using Django's RM， it already。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: has those conditions applied。 So what I'm showing here is a specific Django
    technique that kind of lets you expose an。 objects manager that has already had
    that authorization applied。 And now anywhere in my app that I try and reference
    an object， I go and get a specific， document。 I get a list of documents， it's
    always going to have that authorization logic， applied。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: And so my app kind of almost behaves like if you don't have access to it， it
    doesn't exist。 There's other ways you can achieve this as well。 So some databases
    like Postgres have a concept called like row level security where you can。 achieve
    the same thing but directly writing SQL filters in the database。 Okay。 so you
    do this and then you get this， you know， if you don't have access， you don't，
    see it applies。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我的应用几乎就像是，如果你没有访问权限，它就不存在。有其他方法也可以实现这一点。因此，一些数据库如Postgres有一个叫行级安全性的概念，你可以通过直接在数据库中编写SQL过滤器来实现相同的效果。好的。你这样做后，如果你没有权限，你就看不到，它适用。
- en: But that's not the end， right？ It's not just about read or not read。 So I have
    another game。 another spot the difference。 This one's going to be a bit harder。
    The difference here is that at the top， you can see this close issue button but
    not at， the bottom。 And this is because I'm looking at an issue inside and also
    repository versus in a Python。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是结束，对吧？这不仅仅是关于读或不读。我还有另一个游戏，另一个找不同。这次会有点难。区别在于顶部，你可以看到这个关闭问题按钮，但在底部看不到。这是因为我正在查看一个内部仓库中的问题，而不是在Python中。
- en: repository。 So again， GitHub's not going to let me attempt to close the issue
    and then tell me you don't。 have access so you're not allowed to do that。 That'll
    just hide it from me entirely。 And I can try and bypass this， right？ This is purely
    a cosmetic thing on the front end。 I could still go make the raw API request and
    GitHub will still enforce it。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库。因此，再次，GitHub不会让我尝试关闭这个问题，然后告诉我你没有权限，所以不允许这样做。它会完全把它隐藏起来。我可以尝试绕过这个，对吧？这纯粹是前端的一个视觉效果。我仍然可以发起原始API请求，GitHub仍然会强制执行它。
- en: But what they're doing here is providing a really nice user experience that，
    again。 it's kind of informing me what I can do just by the UI。 And you can get
    some sort of maybe breadcrumbs of how they might implement this by interacting。
    with their APIs directly。 So you can call the GitHub API for a specific repository
    and there will be a field on the。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但他们在这里所做的是提供一种非常好的用户体验，再次。这在一定程度上通过UI告知我我可以做什么。通过直接与他们的API交互，你可以获取他们可能如何实现这些的某种线索。因此，你可以调用特定仓库的GitHub
    API，并且会有一个字段在。
- en: data you get back called permissions。 It kind of contains these five different
    permissions which honestly a bit blurry with。 roles and permissions here but that's
    fine。 And so basically you can see the difference here。 When I query this API
    for an OSO repository， I have the triage true permission。 On the other hand。 if
    I do this for the Python， I'm not a contributor to Python so I get。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到的返回数据叫权限。它包含这五种不同的权限，老实说，在角色和权限之间有些模糊，但没关系。因此，基本上你可以看到这里的区别。当我查询这个API时，对于一个OSO仓库，我有triage
    true权限。另一方面，如果我查询Python，我不是Python的贡献者，所以我得到。
- en: full spag from that permission。 And so with this small amount of data。 you can
    see it would be pretty easy as a UI developer， to just implement the logic that
    says。 you know， if you don't have the triage permission， hide the close issue
    button。 So in a nutshell。 that's enforcement， right？ It's about taking that authorization
    model that we had previously。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从那个权限中完全提取。所以，凭借这少量数据，你可以看到，作为UI开发者，实现逻辑会非常简单，就是说，如果你没有triage权限，就隐藏关闭问题按钮。所以简而言之，这就是强制执行，对吧？这涉及到我们之前所拥有的授权模型。
- en: The logic， the data， all of that。 And then figuring out how to apply it across
    these like three different parts of your app。 It's like on both， you know， enforcement
    on a specific thing。 There's pushing it down into the database。 You can filter
    objects。 And then there's also like pushing it all the way to the front end so
    you can provide these。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑、数据，所有这些。然后弄清楚如何在你应用的这三部分之间应用它。就像在两个方面，你知道，在特定事情上的强制执行。有将其推入数据库的过程。你可以过滤对象。还有就是将所有内容推送到前端，以便提供这些。
- en: like rich UIs that let's your users have a really fun experience。 And imagining
    at this point you're all having an epiphany like， ah， this is why every company。
    reimplements authorization from scratch and get it again。 Clearly they're having
    such fun with this problem that they don't want to like let someone。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 像丰富的用户界面让你的用户体验真的很有趣。此时想象一下你们都像是突然领悟了，哦，这就是为什么每家公司从头开始重新实现授权并再次进行的原因。显然，他们在这个问题上乐在其中，不想让其他人。
- en: else do this。 On a more serious note， you know， there is， you know。 because
    of the kind of two dimensions， of modeling and enforcement。 there is like a high
    degree of customization that every product， kind of builds。 And so I think until
    this point， many people just didn't really think it was possible to。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 更严肃地说，由于建模和执行的两个维度，每个产品都有很高的定制化。因此，我认为直到现在，许多人都没有真正认为这是可能的。
- en: build this in a way that was sort of generic enough that any app could use。
    But my claim is that like with better frameworks we can really make this a lot
    of fun。 So as an example， we had an engineer at a company that was actually， you
    know， working。 with us to integrate OSO in their application。 And they actually
    had so much fun working with us and making all this stuff work that。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以一种足够通用的方式构建这个，使得任何应用程序都可以使用。但我认为，通过更好的框架，我们确实可以让这个过程变得更加有趣。例如，我们曾经有一位工程师在一家公司，他实际上在与我们合作将
    OSO 集成到他们的应用程序中。他们在与我们合作并使所有这些东西正常工作时，玩得非常开心。
- en: they， after finishing the project， they then went and applied for a job and
    joined us as。 an engineer so they could work in that full time。 So I have a warning
    which is this stuff is so fun you might not want to do anything else。 with your
    life afterwards。 So the final area I want to talk about is about architecture
    and what makes this fun。 So again， I'm going to be talking a lot about logic and
    data。 Remember logic being， you know。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成项目后，他们申请了工作并作为工程师加入我们，以便全职工作。所以我有一个警告，这些东西太有趣了，你可能不想在此之后做其他任何事。
- en: things like admins can do anything or you can do a thing， if you have a role
    and so on and so on。 The data is the piece that's back in it。 You know， you have
    a specific role in organization or。 you know， this user created this issue。 For
    the following diagrams。 I'll just use these icons to represent them。 Okay。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，管理员可以做任何事，或者如果你有某个角色，你可以做某件事，等等。数据是后端的部分。你在组织中有特定的角色，或者这个用户创建了这个问题。对于以下图表，我将使用这些图标来表示它们。好的。
- en: so when we start out with our monolithic application， so this purple hexagon
    here is。 representing our service， life is pretty okay。 We have our authorization
    logic that's happily integrated inside our app。 Our app talks to the database
    so anytime it needs to get that data it can just call the， database。 Life is good。
    And then we go and implement a new service。 We have some new application。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从单体应用程序开始时，这里紫色六边形代表我们的服务，生活还不错。我们的授权逻辑快乐地集成在应用程序内部。我们的应用程序与数据库对话，所以每当需要获取数据时，它可以直接调用数据库。生活是美好的。然后我们去实现一个新服务，创建一些新应用程序。
- en: product feature， whatever it is。 So we have a new service and that has its own
    database。 Now that service is probably going to want to do some authorization
    itself and it's very。 likely that it's going to want to do the same kinds of things
    the first app was doing。 For example。 suppose you were building GitHub actions，
    right， the sort of it's the CI pipeline。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不管是什么产品特性。我们有一个新服务，它有自己的数据库。现在这个服务可能会想要自己进行一些授权，而且它很可能会想做与第一个应用程序相同的事情。例如，假设你正在构建
    GitHub Actions，对吧，那是 CI 管道。
- en: thing to sort of run your test suite， stuff like that。 You're building GitHub
    actions。 The kinds of things you need to authorize is， you know， who can read
    running workflows。 who can cancel jobs and restart them。 All of that is going
    to depend on the permissions you have in the repository。 And that's the kind of
    thing that I was talking about that was implemented previously。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有些东西需要运行你的测试套件，像这样的东西。你正在构建 GitHub Actions。需要授权的事情是，谁可以读取正在运行的工作流，谁可以取消作业并重新启动它们。这一切都将依赖于你在存储库中的权限。这就是我之前提到的已经实现的内容。
- en: And so what ends up happening is that you have multiple applications and multiple
    services。 but they have a lot of shared logic and shared data to kind of make
    them all work consistently。 And so what ends up happening is you sort of have
    this problem of like， well， how do I。 make sure the right things have the right
    bits in the right places？ And this part gets fun。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所以最终的结果是你有多个应用程序和多个服务，但它们有很多共享的逻辑和共享的数据来确保它们一致地工作。因此，你会遇到一个问题，如何确保正确的事物在正确的地方具有正确的部分？这一部分变得有趣了。
- en: So the option space is kind of falls on like a two by two。 On one hand you have
    the logic and the data that's spoken about a bunch。 And on the other dimension
    we have， to what extent can you centralize those two pieces？
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所以选择空间有点像一个二维框架。一方面，你有关于逻辑和数据的讨论；另一方面，我们要问，在多大程度上可以中心化这两部分？
- en: So to start out with， decentralize logic。 There's not really much to say here。
    This is kind of the sort of the default that you would just do by continuing to
    do what。 you were doing previously。 You keep writing your code in your apps。 If
    you need to， you know。 if you need to duplicate stuff， you go ahead and write
    that， code multiple times。 Very simple。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所以首先，要去中心化逻辑。这里没什么好说的。这基本上是你继续做之前所做事情的默认选择。你继续在应用中编写代码。如果需要，知道吗？如果需要复制某些内容，你就去写代码，多写几次。非常简单。
- en: Your sort of model of working on services doesn't change。 But it can be kind
    of hard to keep things consistent。 Like if you want to make a change across everything，
    you need every team to go and make that change。 So instead we might try and centralize
    some of that logic。 So again。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你在服务上的工作模型并没有改变。但保持一致性可能会有点困难。如果你想在所有地方进行更改，你需要每个团队去做这个更改。所以我们可能会尝试中心化一些逻辑。
- en: so take my example from before about the roles model。 We had that like dictionary
    and Python of like what roles can be what。 Imagine we were to just take that piece
    of data and put it into some central place。 And we put it into an S3 bucket。 And
    now essentially every application on startup periodically。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所以以我之前关于角色模型的例子为例。我们有一个像字典一样的Python代码，说明什么角色可以是什么。想象一下，我们把那部分数据放到某个中央位置。我们把它放到一个S3桶中。现在基本上每个应用在启动时都会定期进行这个操作。
- en: I don't know what， can download， that sort of blob dictionary and use that to
    drive its authorization logic。 What's nice about this is we now have that central
    place to define roles。 If I want to extend an existing one and say， you know，
    repository readers can read GitHub。 workflows， actions workflows， I can do that
    in one place。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道，能否下载那种“blob”字典，并用它来驱动授权逻辑。好的一点是我们现在有一个中央位置来定义角色。如果我想扩展现有的角色，假设，代码库的读取者可以读取GitHub工作流，我可以在一个地方做到这一点。
- en: Now the challenge is we've obviously introduced this new external dependency，
    external piece。 of state that's like shared between all of our services。 So what
    we might do alternatively is kind of take that logic and wrap it inside a service。
    So again。 maybe all the service does is tells you can this role do this action
    on this resource， type。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的挑战是，我们显然引入了这个新的外部依赖，外部状态，在我们的所有服务之间是共享的。所以我们可能会选择将逻辑封装在一个服务中。所以可能这个服务只会告诉你这个角色是否可以在这个资源类型上执行某个动作。
- en: What's nice about this is now we're making that decision dynamically。 We don't
    need to worry about。 like cache invalidation and things like that。 But we've introduced
    that external service dependency to like every single request。 This is going to
    keep coming up again and again in this world is you have this piece of shared。
    logic that needs to be used across your entire architecture。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这点好在于我们现在可以动态做出决定。我们不需要担心缓存失效之类的事情。但我们已经在每一个请求中引入了外部服务依赖。在这个世界中，这个共享逻辑需要在整个架构中使用的情况将会一再出现。
- en: There's just like no good way around this。 But in this case， this is a pretty
    simple set up。 You can even add things like caching if you want to， you know，
    locally if you want to， sort of。 you know， increase the robustness to the network
    going down and stuff like that。 But that's going to introduce complexity。 Okay。
    So what about the data？
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有好的解决办法。但在这种情况下，这是一个相当简单的设置。如果你想的话，甚至可以添加一些本地缓存，以提高对网络故障的鲁棒性。但这会引入复杂性。好的，那么数据呢？
- en: So in terms of having your data decentralized， so things like， you know， what
    roles do people， have？
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据去中心化，像是，知道吗，什么角色是人们拥有的？
- en: If you have a very small amount of shared data， so let's say that in your application，
    users。 only really have like one role on an organization and that's it。 Then what
    you can do is distribute that data on something like a cryptographic token。 So
    maybe something like a JWT， you kind of encode it into that token that， you know，
    the。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: user has a specific role。 What's nice about this is now for an individual services
    standpoint。 when a request comes， in， you know， you do your JWT validation and
    now you have that data as if it already was。 local and you can just read straight
    off of that like， okay， you know， what roles the user。 have and the rest of your
    app kind of continues as it was。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: That's a great option when your data is kind of small。 But think， you know。
    if you had to encode in that token， all of the orgs you have， all， the repositories
    you have。 all the issues you created， all the PRs you submitted in GitHub， that
    token is going to be huge。 So this is not， you can't really do this once data
    gets past the certain size。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: So one option for still keeping that data decentralized is you just leave the
    data where， it is。 You say， look， I have my microservices or my services。 They，
    you know。 have good service boundaries of what data they manage。 So every time
    I need that data。 I'm just going to do what microservices do and I'm just， going
    to query that service。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Maybe I have a role service that just manages roles。 Anytime I need to check
    that。 I'll go query that service。 I think this is， this is like a good approach
    if you already have a very robust mechanism。 for querying other services。 You've，
    I know you've gone all in on microservices and you've got a phenomenal。 I know，
    GRPC method， for doing this because it really needs to be good because this will
    make your app incredibly。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: chatty。 Right？ Anytime you do authorization， pretty much every request。 you're
    potentially going and reaching， out to another service and asking what roles does
    user have。 So that brings me to the final option， centralizing the data。 I'm going
    to claim that if you're centralizing data， you might as well centralize the logic。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: as well。 Like instead of just having it as be like a， a dumb store of， of data，
    extend it with。 some logic。 And so in this world， what happens is you're almost
    back to the simplicity of that initial。 monolithic API where an individual service
    can just ask， authorize， can this user read。 this document。 And that， you know，
    that's just going to be a network。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: network request that goes in queries， that central service that has all the
    data。 has all the logic and it can make that decision， and return that true or
    false。 So from a downstream app standpoint， incredibly， incredibly clean and simple，
    there's like no。 work to do。 The challenge here is building that central service。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: And it's kind of hard to understate just how challenging that is。 So companies
    who've gone down this path talking Google， Airbnb， Carter， just across the road。
    Carter， when they did this， they had， you know， full team of engineers， six， eight
    engineers。 you know， initial upfront work， multiple years， and then ongoing forever
    maintenance work on。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 很难低估这个问题的挑战性。因此，走上这条道路的公司，比如Google、Airbnb和隔壁的Carter，当Carter做这个时，他们有一整支工程师团队，六到八名工程师。最初的前期工作耗时多年，之后的维护工作几乎是永久性的。
- en: keeping those services running。 And so like， for example， here's。 here's what
    the Google's Antibar architecture looks like。 Here's the architecture powering
    Google's authorization。 Because remember。 we're talking about this is on every
    single request， you're making this， authorization query。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 保持这些服务的运行。因此，例如，这是Google的Antibar架构的样子。这是支持Google授权的架构。因为要记住，我们谈论的是每一个请求，你都在进行这个授权查询。
- en: Any latency you add there is added basically to all of your applications。 So
    it needs to be incredibly fast， needs to be incredibly high availability。 So you
    know。 some numbers from Google， they do something like 10 million queries to the，
    service per second。 They have like trillions and trillions of rows in that database。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你增加的任何延迟基本上都会影响到你所有的应用程序。因此，它需要非常快速，并且可用性要非常高。据Google的数据，他们每秒处理大约1000万次查询。那个数据库中有数万亿行数据。
- en: They have something like five or six， nine of availability。 It's a hugely challenging
    problem。 So very， very high benefit to doing this， right？ You sort of， if you
    do this。 your application stay simple， but the， I guess I'd say the fun。 part
    here is in building out this distributed systems problem。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的可用性大约在五到六个九之间。这是一个非常具有挑战性的问题。因此，做这件事的收益非常高，对吧？如果你这样做，你的应用程序保持简单，但我想说的有趣部分在于构建这个分布式系统的问题。
- en: And that's kind of my takeaway from this whole architecture piece is fundamentally
    distributed。 systems are pretty hard。 It's a really fun engineering challenge。
    but you sort of can't quite get away from that， fact that it's going to be。 it's
    going to be a question of what trade off do you want， to make。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我从这个整个架构的部分得到的结论是，根本上分布式系统是相当困难的。这是一个非常有趣的工程挑战，但你无法完全逃避这个事实：这将是一个关于你想做什么权衡的问题。
- en: It's a question of how much time do you want to invest。 It's a question of like，
    do you want this。 do you want to balance ease of individual people， collaborating
    on a service versus having something more abstracted。 So it's summarised everything
    I just said， right？ I spoke about modelling。 where you need something super flexible
    to handle those 22 different， models。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个你想要投入多少时间的问题。你是否想要这种平衡，个人之间的协作与更抽象的东西之间的权衡。这样总结一下我刚才所说的，对吧？我谈到了建模，你需要一些超级灵活的东西来处理那22种不同的模型。
- en: You then take enforcement， which requires you to take those models and put them
    across。 everything from the front end back to the database。 And then for those
    lucky few who are working across multiple services， you take that already。 challenging
    problem and then figure out how to distribute it across a whole architecture。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要进行执行，这要求你将这些模型应用于从前端到数据库的所有内容。对于那些幸运的在多个服务之间工作的人，你需要将这个已经具有挑战性的问题分配到整个架构中。
- en: It's a lot of fun。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有趣。
- en: '![](img/7d2460332f12e9adc53684e71c4115a7_3.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d2460332f12e9adc53684e71c4115a7_3.png)'
- en: It's a lot of fun。 On a serious note， I don't want to just like leave you there
    with this hugely challenging。 problem that with all these kind of trade offs。
    The reason I want to give this talk and the reason that my company exists is to
    try and。 make authorisation easier for developers。 And so to that end， there's
    a couple of resources we have。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有趣。不过说正经的，我不想让你们面对这个巨大而具有挑战性的问题，以及所有这些权衡。我想进行这个演讲的原因，以及我公司存在的原因，是为了帮助开发者简化授权过程。为此，我们有几个资源。
- en: '![](img/7d2460332f12e9adc53684e71c4115a7_5.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d2460332f12e9adc53684e71c4115a7_5.png)'
- en: So number one， we put together a series of technical guides called Authorisation
    Academy。 This is basically long form content of the kinds of things I spoke about
    today。 What are the trade offs？ What are the things you need to do？
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们组建了一系列技术指南，称为授权学院。这基本上是我今天所谈论内容的长篇内容。权衡是什么？你需要做些什么？
- en: When should you use different patterns and why？ This is like fully vendor neutral。
    This isn't about OSO。 This is purely like go read this as a developer if you want
    to understand authorisation deeper。 On the other hand， we do have a product that
    is basically our take on the best way to solve。 for these kinds of problems。 So
    my sort of closing recommendations are sort of two things。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Number one， if you listen to this talk and you thought， wow， this really does
    sound like。 a lot of fun。 I totally buy everything Sam just said。 You should come
    and work with us on it and have fun。 Come build the language and distribute the
    system。 It's great。 On the other hand。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: you're listening and you're like， that sounds terrible。 I really want to focus
    on making my app。 my product work really well for my customers。 This isn't the
    kind of thing we should be spending time on。 Then you should check out our product
    because our mission as a company is basically to get。 people to spend a tenth
    of the time on this problem that you currently do。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: So that concludes my talk。 Thank you everyone for listening。 I will be hanging
    around to answer any questions。 We're also doing an open space at three in room
    251D。 I believe。 So I hope to see you out there at the conference and I will happily
    talk about this topic for。 forever basically。 So yeah， thank you everyone。 [Applause]。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d2460332f12e9adc53684e71c4115a7_7.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
