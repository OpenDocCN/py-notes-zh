- en: P64：Talk - Pablo Alcain_ Software Development for Machine Learning in Python
    - VikingDen7 - BV1f8411Y7cP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P64：演讲 - Pablo Alcain_ Python中的机器学习软件开发 - VikingDen7 - BV1f8411Y7cP
- en: Hello everyone， welcome back。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大家好，欢迎回来。
- en: '![](img/da90557b6b750703f3d8676bdc5d1ce1_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da90557b6b750703f3d8676bdc5d1ce1_1.png)'
- en: '![](img/da90557b6b750703f3d8676bdc5d1ce1_2.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da90557b6b750703f3d8676bdc5d1ce1_2.png)'
- en: We have an next talk by Paolo Alkain on software development for machine learning
    in Python。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来由Paolo Alkain进行关于Python中机器学习软件开发的讲座。
- en: '![](img/da90557b6b750703f3d8676bdc5d1ce1_4.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da90557b6b750703f3d8676bdc5d1ce1_4.png)'
- en: Over to you Paolo。 Now it's better right， you will have a constraint to my hands
    a lot。 Let's hope that it works。 First of all， welcome everyone。 Thank you very
    much for attending。 I'm very happy to be here and thank you also to all the crew
    that made this possible and。 make this possible every day for this amazing conference
    we're having。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在交给你，Paolo。现在这样更好，对吧，你将受到我的限制。希望一切顺利。首先，欢迎大家。非常感谢你的到来。我很高兴能在这里，也感谢所有让这一切成为可能的团队，每天都为我们这场精彩的会议而努力。
- en: I'd like for us to have the following minutes discussing a little bit about
    something that。 is very interesting for not only for me but also in the latest
    developments that we've。 been having in the machine learning industry as a whole
    and it's trying to discuss a little。 bit what kind of software development we
    need in machine learning。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望我们接下来的几分钟能讨论一些非常有趣的内容，不仅对我来说有意义，而且与我们在机器学习行业的最新发展有关，我们试图探讨一下在机器学习中需要什么样的软件开发。
- en: So let's begin by taking a very simple problem。 This is a very well-known problem
    that happens everywhere if you go to a tutorial of scikit。 learn or many pages
    that try to ease you into the classification problem you probably。 are aware of
    the ideas classification。 Here we have the ideas flowers in which the idea is
    for us to be able to classify them。 all by four of the features。 The petal length，
    the petal width。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们先从一个非常简单的问题开始。这是一个非常著名的问题，无论你去哪里找scikit-learn的教程，或者许多试图让你入门分类问题的页面，你可能都听说过分类的概念。在这里，我们有鸢尾花的想法，其目的是让我们能够通过四个特征对它们进行分类：花瓣长度、花瓣宽度。
- en: the sepal length and the sepal width。 And from these four features we have to
    figure out which of the variety it belongs to。 If it's a cetosa， what's the color
    of the vinegar？
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 花萼长度和花萼宽度。从这四个特征中，我们必须弄清楚它属于哪个品种。如果是cetosa，醋的颜色是什么？
- en: Just like first disclaimer first of all since these are going to be a slice
    you will see。 like the strings of the columns being way too shortened。 This is
    not something that I encourage。 It's better to have the best column names as possible
    but we are saving real estate in the。 slides in this case。 I want to say that's
    not in favor of naming columns like this in production code。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要说明的是，由于这些内容将会被截取，你会看到列字符串被大幅缩短。这并不是我所鼓励的。最好能尽量使用最好的列名，但在这种情况下我们需要节省幻灯片的空间。我想说，在生产代码中不应该这样命名列。
- en: Now the first thing that you can do when you take a look at this problem and
    how to solve。 it usually you spin up an old book or a Python interpreter or whatever
    and you start working。 with it as a playground。 Like trying new ideas and figuring
    out how to solve this problem。 So a very simple solution to this problem can be
    this one here。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看这个问题以及如何解决它时，第一件事就是通常你会翻开一本旧书或打开一个Python解释器，然后开始将其作为一个游乐场。尝试新想法，找出如何解决这个问题。因此，解决这个问题的一个非常简单的方法可以是这样的。
- en: Very simple solution to this problem in which we are using the technical stack
    that is very。 usual for machine learning developers or data scientists that is
    basically using pandas。 and side idler。 So you can see the bunch of imports in
    the beginning and then we are basically loading。 a data set。 From the data set
    that we've loaded as the CSV we recognize the features and the target。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的简单解决方案使用了对于机器学习开发者或数据科学家来说非常常见的技术栈，基本上是使用pandas和side idler。你可以看到开头有一堆导入，然后我们基本上加载了一个数据集。从我们加载的CSV数据集中，我们识别了特征和目标。
- en: And then we will classify it with the pipeline object that we have from scikit
    learn。 In this case this pipeline object consists of two steps。 In the first one
    we select the two best of the features according to a specific criteria。 even
    we can choose it。 We want to。 And from those features we classify them with a
    elastic regression directly to see to。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将用来自scikit-learn的管道对象对其进行分类。在这种情况下，这个管道对象包含两个步骤。在第一个步骤中，我们根据特定标准选择两个最佳特征。我们甚至可以选择我们想要的特征。从这些特征中，我们直接使用弹性回归进行分类，以便查看结果。
- en: figure out which variety they belong to。 This is like the declaration of the
    classifier。 In the next step we actually do the fitting of the model。 What we
    normally know as training of the model of machine learning。 And then we compute
    the accuracy score that we have over the training set。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 找出它们属于哪种类型。这就像是分类器的声明。在下一步中，我们实际上会对模型进行拟合。这就是我们通常所说的机器学习模型的训练。然后我们计算训练集上的准确率得分。
- en: This is only just to show one of the things we can do。 Again I'm not saying
    that you should figure out the accuracy of your model on the training， set。 But
    after we calculate the accuracy we simply inform and realize what's the accuracy
    score。 that we got。 Whoa I didn't expect that。 There's something strange going
    on with the slides。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是为了展示我们可以做的事情之一。再说一遍，我并不是说你应该在训练集上计算模型的准确率。但在计算出准确率后，我们只是告知并了解我们得到的准确率得分。哇，我没想到会这样。幻灯片上发生了一些奇怪的事情。
- en: It's like I'm having a subslide under my slide。 This is not being shown here。
    Let me just try to quickly sort this out。 Okay。 So this is like live settings。
    Oh my。 Okay。 Wow。 Okay so yeah it looks like some machine learning model understood
    what I was trying to。 Okay。 Let's get it from here now。 Okay。 It might happen
    again。 I don't know how I solved it。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我在幻灯片下有一个子幻灯片。这里没有显示出来。让我尝试快速解决这个问题。好的。这就像是实时设置。哦，我的天。好的，哇。看起来是某个机器学习模型理解了我想要的内容。好的。现在我们从这里开始。好的。可能会再次发生。我不知道我是怎么解决的。
- en: So probably I have to troubleshoot it again if it happens。 Now this is what
    we have as the play done。 Usually actually this pipeline that we are seeing here
    is what I took almost verbatim from。 the tutorial that you have inside it learned
    when you try to implement the pipeline。 Now when we have to put this into production
    there are like several hurdles that appear。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果再次发生，我可能需要重新排查一下。现在，这是我们所完成的演示。实际上，我们在这里看到的这个管道几乎是我从你们学习教程中逐字提取的。当我们需要将其投入生产时，会出现几个障碍。
- en: when we try to put this tiny source of code in production。 This is a very well
    known image from a paper known as hidden technical depth in machine。 learning
    systems。 I recommend every data scientist machine learning developer or machine
    learning engineer。 that hasn't read this yet to take a look at it because it will
    allow you to see what's。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试将这段小代码投入生产时。这是一张非常知名的图像，来自一篇名为“机器学习系统中的隐性技术债务”的论文。我建议每位尚未阅读此论文的数据科学家、机器学习开发者或机器学习工程师去看看，因为它能让你看到在思考这个问题时我们作为数据科学家所忽视的地方。
- en: on the other side of your scope。 If you're a machine learning engineer you'll
    realize what are the problems that typically。 data science have when taking a
    look at when working with production code and vice versa。 Taking things into production
    implies a lot of different challenges。 I won't name all of them but basically
    I think that the ones that we usually don't consider。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在你视野的另一边。如果你是一个机器学习工程师，你会意识到数据科学在查看和处理生产代码时通常面临的问题，反之亦然。将事物投入生产意味着面临许多不同的挑战。我不会列出所有的挑战，但基本上我认为我们通常不考虑的那些。
- en: when thinking about this are the least we as data scientists。 Sometimes we don't
    consider the continuous training in the deployment， the provisioning。 of infrastructure
    to actually do the training of the models， the model tracking and then。 how to
    serve it。 This is only like a subset of the multitude of problems you can see。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们没有考虑到在部署中的持续训练、基础设施的提供，以便实际进行模型训练、模型跟踪，以及如何服务于模型。这仅仅是你可以看到的众多问题中的一个子集。
- en: not problems but challenges， you can see when you have to put this into production。
    One of the key elements of the paper that we're seeing here is that the machine
    learning。 code that we've just built is only like a small part of this whole structure。
    I'm going to discuss today how we can make this small but very fundamental part
    of the， code。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: how we can make it work so it can serve the purpose of going into production
    and also。 having an easy exploration for the scientist mission。 Why do we say
    that it's important for the data scientist or the machine learning developers。
    to know how the codes are going into production？ What we say is that the developer
    experience of the data scientist is very tightly coupled。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: to what production looks like。 In the first example。 let's suppose that we have
    a scientist that does a couple of changes。 maybe on this way it's more than we've
    just seen and deploys it to production directly。 By saying deploy to production，
    what we're saying is that he or she is the one in charge。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: of actually writing what we call production code。 What is going to belong to
    this structure we've seen before。 In this case it's clear that the data scientist
    or machine learning developer has a lot of。 coupling with how production code
    looks like。 But it's also relevant to notice that if the next data scientist comes
    and they try to。 do some changes on top of this， they have to be able to understand
    what the production， code was。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The coupling between the experience is both for the first writing of the code
    but also。 for understanding the code to actually do changes afterwards。 Now there's
    another extreme solution that we can think about it that's put like a barrier，
    there。 We put the machine learning engineering team between the data scientist
    and the production。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: code and we say hey， you're not going to be the one writing the production code。
    Don't worry about it。 You just think about the model， think how it works。 do it
    all in your play down and I， will be in charge of writing this into production
    code。 And while these looks like can't decouple the data scientist from production
    code itself。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: the problem remains when the next data scientist comes and try to understand
    what's happening。 They have to get the latest code that we have in production
    and they have to understand。 what it means and how to work with it。 Now this can
    be solved in many different ways。 One possibility is to say that the machine learning
    engineer is the one that's going to。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: explain the production go to each of the data scientist。 Another possibility
    to say that the data scientist has to talk among each other and these are。 all
    like very usual solutions that work well in many different aspects。 But today
    I want to discuss with you a software design solution for the productionization
    of。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: machine learning code。 What if we can learn how to write this code so that it
    works according to the following。 four pillars？ The first one is that the goal
    has to have fast and easy exploration。 We know that the solutions that we have
    for these problems are very speculative and the。 models change way too often。
    So we have to allow the data scientist to work with new ideas on top of the production。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习代码。如果我们能学会如何编写这段代码，以便它符合以下四个支柱，那会怎么样？第一个是目标必须具备快速和简单的探索。我们知道，针对这些问题的解决方案非常具备猜测性，模型变化得太快。因此，我们必须让数据科学家能够在生产的基础上探索新的想法。
- en: code。 But we also wanted to be declarative and intentional revealing。 Martin
    Fowler put it much better than I probably can do and one of the things that he
    said。 was that the goal is the only artifact that we have that is sufficiently
    detailed and。 precise to act as documentation。 This doesn't mean that we don't
    have to write any documentation apart from the goal。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 代码。但我们也希望它具有声明性和意图性。马丁·福勒表达得比我可能更好，他说的其中一件事情是，目标是我们唯一的文档，它足够详细和精确，可以作为文档使用。这并不意味着除了目标之外，我们就不需要编写任何文档。
- en: Of course that's not what I'm saying。 What I'm saying is that we have to seize
    the opportunity of this production code here。 We have to be able to take advantage
    of the code that we have in production。 We have to make it as declarative as possible。
    Another important thing that we need is to have what we will call sensible checkpoints。
    We will then try to define better what I mean by this。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我并不是这么说。我所说的是，我们必须抓住这里的生产代码的机会。我们必须能够利用我们在生产中拥有的代码。我们必须尽可能地使其具有声明性。另一个重要的事情是，我们需要设立我们所称之为合理的检查点。接下来我们将更好地定义我所指的内容。
- en: But the main goal that we have here is that if we have a pipeline in which we
    are doing。 many different stuff in the whole production code， we want to be able
    to hook into a problem。 with our own solution that we have before and simply reuse
    one of the steps。 We also want to be able to hook out of the problem and use the
    previous steps as things。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们在这里的主要目标是，如果我们有一个管道，在整个生产代码中做许多不同的事情，我们希望能够用我们之前的解决方案来解决问题，并简单地重用其中的一个步骤。我们还希望能够跳出问题，并将之前的步骤作为参考。
- en: for our exploration and so on。 The reusing of these steps is very important。
    Keep in mind that sometimes it's even like a necessity because some of these steps
    can。 take way too long to run and if you have to wait like four or five hours
    for a step to， run。 you won't be able to fasten this exploration。 And another
    very important thing is that we need to have seamless tracking and monitoring。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 供我们的探索等。重用这些步骤非常重要。请记住，有时这甚至是必要的，因为某些步骤可能运行时间过长，如果你必须等待四到五个小时才能运行一个步骤，你就无法加快这个探索过程。还有另一个非常重要的事情是，我们需要无缝的跟踪和监控。
- en: of the code that's working in production。 And by this。 I mean that we have to
    track the code but we cannot track it in a way that。 pollutes the declarative
    and intention code that we've just described。 Suppose the case in which we are
    seeing the same play-run code that we have but we have。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在生产中运行的代码。我的意思是，我们必须跟踪代码，但不能以污染我们刚才描述的声明性和意图代码的方式来进行跟踪。假设我们看到的是同样的运行代码，但我们有。
- en: '![](img/da90557b6b750703f3d8676bdc5d1ce1_6.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da90557b6b750703f3d8676bdc5d1ce1_6.png)'
- en: like 30 or 40 calls to lock this， lock that and so on。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 大约30或40个调用来锁定这个、锁定那个等等。
- en: '![](img/da90557b6b750703f3d8676bdc5d1ce1_8.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da90557b6b750703f3d8676bdc5d1ce1_8.png)'
- en: This is a solution that while it does lock the model， it pollutes a lot the
    development， space。 So we want to avoid it。 Now with these four pillars that I've
    just discussed。 we're going to do like a caution， detail on the productionizing
    of the model that we have just seen。 Now this is the training file that we've
    just written down。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个解决方案，虽然它锁定了模型，但却严重污染了开发空间。因此，我们想要避免这种情况。现在，结合我刚才讨论的这四个支柱，我们将对刚刚看到的模型进行生产化的详细说明。现在这是我们刚写下的训练文件。
- en: The imports are now collapsed and they will probably collapse for some part
    of the talk。 Let's just keep in mind what important whatever it takes for it to
    work。 So this is the code that we've just had。 And one of the things that we realized
    from the code we were seeing here is that there's。 no way that this is going to
    go into production。 Why？
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在导入的内容已经折叠，可能在演讲的某些部分会折叠。我们要记住，重要的是无论如何都能正常工作。这是我们刚刚写的代码。我们从这里看到的代码中意识到，这不可能投入生产。为什么？
- en: Because the model that we've just trained in the classifier。fit line only lives
    inside。 the scope of this Python file。 We need to find a way to persist this model
    somewhere for us to be able to load it later。 on to do whatever we need to do，
    for example， I don't know， like an online serving of the。 model and things like。
    So the first thing we realized is that instead of checking the accuracy code。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们刚刚在分类器中训练的模型。fit 行仅存在于这个 Python 文件的作用域内。我们需要找到一种方式将这个模型持久化，以便稍后能够加载它，做我们需要做的事情，例如，我不知道，像在线服务模型之类的。因此，我们意识到的第一件事是，不是检查准确性代码。
- en: what we actually， want to do is to save the model as a pickle file， for example。
    You know that pickle is a library that's very useful for this。 We can load it
    directly with this very simple two sentence here， thanks to the with statement。
    Now when we do this， then the prediction part of the file that we have， we'll
    actually load。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上想要做的是将模型保存为一个 pickle 文件，例如。你知道 pickle 是一个非常有用的库。我们可以用这句非常简单的两句话直接加载它，这要归功于
    with 语句。现在，当我们这样做时，文件中的预测部分将会被加载。
- en: the model file that we have。 And on an unseen data set， this unseen i is that
    we're seeing here。 we will predict and， naturally checking the accuracy score
    here， right？
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有的模型文件。在一个未见的数据集上，这个我们正在查看的未见的 i。我们将进行预测，并自然地检查准确性评分，对吧？
- en: Now keep in mind that this is just one of the possible implementation of the
    prediction。 Of course we can do it this way from the moment we decouple the training
    from the serving， we。 can actually serve with， I don't know， through a rest endpoint
    or through fast API or however。 we want， we are free to do it in any way。 So consider
    this file as a token for all the possible ways in which we can serve the model。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请记住，这只是预测的可能实现之一。当然，我们可以以这种方式进行，从我们将训练与服务解耦的那一刻起。我们实际上可以通过，我不知道，通过 REST 端点或通过
    FastAPI 或其他方式来服务。我们可以自由地以任何方式进行。所以把这个文件视为我们可以服务模型的所有可能方式的代币。
- en: once it's persisted。 Now the first thing we realized in the goal that we've
    just written is that we are exposing。 implementation details， right？ When we take
    a look at these two things， we're saying， hey。 maybe we don't want to tell in，
    the goal that we are seeing how we are saving the model。 if we're saving it with
    people and， however it's something and we want to abstract， right？
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它被持久化。我们刚刚写的目标中，我们意识到的第一件事是我们正在暴露实现细节，对吧？当我们查看这两件事时，我们在说，嘿。也许我们不想在目标中告诉人们我们是如何保存模型的。如果我们与他人一起保存，它是某种东西，我们想要抽象，对吧？
- en: We want to abstract it away。 We know how to do it， right？ We abstract this into
    functions。 We create the save model function and the load model function that
    is in charge of actually。 doing this under the hood。 The moment I do this， two
    things。 two very important things start to happen。 The first one is that you can
    see in the train。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要将其抽象化。我们知道如何做到，对吧？我们将其抽象为函数。我们创建了保存模型函数和加载模型函数，负责实际在底层执行这项工作。做这件事的那一刻，有两件事。两件非常重要的事情开始发生。第一个是你可以在训练中看到。
- en: py file that we've just removed this with statement。 that was maybe two of our
    rows and put it in a declarative fashion， right？
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚删除了 with 语句的 py 文件。那可能是我们两行代码的一部分，以声明式的方式放置，对吧？
- en: Now we know that we are actually saving the model somewhere。 But another thing
    that starts to happen is that we've now split the whole goalbase， well。 the whole
    goalbase， just three files， right？ Anyway。 we split the whole goalbase in two
    different semantic spaces。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们实际上是把模型保存在某处。但另一个事情开始发生的是，我们现在将整个目标库进行了拆分，整个目标库，只有三个文件，对吧？无论如何。我们将整个目标库拆分为两个不同的语义空间。
- en: One is the one that we are seeing on the top。 That's what we're going to call
    the library space。 right？ These are the things in which we're going to develop
    all the tools that are going to。 be using the application space that are the things
    in the bottom， right？
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个是我们在顶部看到的。这就是我们要称之为库空间的东西，对吧？这些是我们要开发的所有工具，将在底部的应用空间中使用，对吧？
- en: So what we are going to do now is work on the library space to see how we simplify
    the。 application code that is what we expect the data scientist or the machine
    learning developer。 to iterate on top。 Now after we do this， right after we build
    the save model function， yeah。 and the low model， function， this is now what the
    train。py file looks like。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们现在要做的是在库空间中工作，看看我们如何简化应用代码，这正是我们希望数据科学家或机器学习开发人员进行迭代的。现在在我们完成这个之后，构建保存模型功能，以及加载模型功能，train.py
    文件现在的样子是这样的。
- en: See that this is important， that's why I left the imports here， that now we
    are not。 importing people directly， we are importing from our own library the
    save model function。 And now we take a look at this that we have and we say， hey，
    there's something similar。 to what we've just seen going on here， right？ What's
    going on with this classifier that we have？
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，这很重要，这就是我把导入留在这里的原因，现在我们不是直接导入人员，而是从我们自己的库中导入保存模型功能。现在我们看看我们所拥有的，嘿，有些东西与我们刚刚看到的相似，对吧？我们这个分类器发生了什么？
- en: Kind of with something similar to what we've done with the load model and the
    save model。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有点类似于我们所做的加载模型和保存模型的事情。
- en: '![](img/da90557b6b750703f3d8676bdc5d1ce1_10.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da90557b6b750703f3d8676bdc5d1ce1_10.png)'
- en: We have this idea， right？ We need to abstract them into functions。 And with
    this idea。 I will give you a little spoiler。 This is where like the fall of our
    approach begins。 So I want to make it very， very clear。 I didn't know how to make
    it clear enough that this is how we start to go down a slippery。 slope that we
    will see what kind of thing it goes beyond， right？
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有这个想法，对吧？我们需要将它们抽象成函数。关于这个想法，我要给你一个小剧透。这就是我们方法开始衰退的地方。所以我想非常清楚地说明，我不知道如何足够清晰地表述，这是我们开始滑向一个危险坡度的方式，我们将看到它超越了什么，对吧？
- en: '![](img/da90557b6b750703f3d8676bdc5d1ce1_12.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da90557b6b750703f3d8676bdc5d1ce1_12.png)'
- en: So it doesn't matter， right？ We don't know the spoiler yet。 we're very happy
    and we're like building this fit model。 function that what it's doing actually
    is loading the classifier and doing the fitting， itself。 right？ So this is the
    part of the fitting of the model。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这没关系，对吧？我们还不知道剧透。我们很开心，正在构建这个拟合模型。它实际做的事情是加载分类器并进行拟合，对吧？所以这是模型拟合的一部分。
- en: Now one of the things that we know and Sandi Metz put it in an awesome fashion
    in a talk。 that is called， I think， all the little things。 If you haven't seen
    it。 I recommend you go and see it， that when you're seeing this kind。 of pattern
    in which you have like a repeated prefix or a repeated suffix in your code。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道的一件事是，桑迪·梅茨在一次演讲中以很棒的方式提到这一点，演讲的主题我想是《所有的小事》。如果你还没看过，我建议你去看看，当你在代码中看到这种模式时，比如有重复的前缀或后缀。
- en: what you're seeing is actually an object in there being tortured， screaming
    to it out， right？
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的实际上是里面一个对象在被折磨，尖叫着，对吧？
- en: There's an object here that we have to find out its name。 And it's very clear
    here that the object that we are seeing is the model object， right？
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个对象，我们必须找出它的名字。很明显，我们所看到的对象是模型对象，对吧？
- en: So we do a small refactor and we change the function that we have into methods
    of these。 model objects。 See， now it looks even prettier， right？
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们进行小的重构，把我们拥有的函数改成这些模型对象的方法。看，现在它看起来更漂亮了，对吧？
- en: Because the classifier now belongs to the init part and the fit only that's
    the fitting。 And the train。py file still looks very declarative， very intentional
    revealing and now more in。 this like object-oriented fashion， right？ Now we're
    not only content with this。 this path we've gone through。 We also say， hey， there's
    something similar going on with that asset。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因为分类器现在属于初始化部分，而拟合只是拟合。而train.py 文件仍然看起来非常声明性，非常有意图地揭示，现在更多地呈现出这种面向对象的方式，对吧？我们不仅满足于此，我们还说，嘿，有什么相似的事情发生在那个资产上。
- en: right？ Kind of I do something with that asset similar to what I've done with
    the model。 And again。 I'm not going to start like putting these into functions
    and so on。 We already know like the end of this tail， we will build the data set
    object， right？
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧？我对这个资产的处理方式有点像我对模型所做的那样。再说一次，我不会开始把这些放入函数中。我们已经知道，尾部的最终结果是我们将构建数据集对象，对吧？
- en: So the next step we do is to say， hey， maybe like the features and the target
    that we're。 seeing here are part of an abstraction that is called the data set
    object。 And we want to give you the name， right？ We have the data set。 That is
    what we're going to do and the features we have written down there inside the
    constructor。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所以下一步我们要说的是，嘿，也许我们在这里看到的特征和目标是一个称为数据集对象的抽象的一部分。我们想给你这个名称，对吧？我们有了数据集。这就是我们要做的，特征已经在构造函数中写下来了。
- en: what the features and the target mean。 And now we take a look at the train。py
    file that we've seen。 And man， doesn't this look like much cleaner than what we
    have before， right？
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 特征和目标意味着什么。现在我们来看一下之前看到的 `train.py` 文件。哇，这看起来比我们之前的清晰多了，对吧？
- en: We have a much more concise code and we even got the chance to put our abstractions
    in here， right？
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了更简洁的代码，甚至还可以在这里添加我们的抽象，对吧？
- en: So the model。fit doesn't take like the features on the target like it used to
    before。 We now take the data set that we just build right now with an abstraction。
    Now we're very happy with this， but as I told you， this is not how the story ends
    well， right？
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所以模型的 `.fit` 不再像以前那样直接使用特征和目标。我们现在使用的是刚刚构建的数据集，具有一个抽象。我们对此非常满意，但正如我告诉你的，这并不是故事的结束，对吧？
- en: Because now all of a sudden someone tells us， hey， we don't want to pick the，
    we don't。 want to pick always the best two of these features。 Sometimes you want
    to pick three。 sometimes you want to pick one。 When you work your code。 someone
    that is just trying to know how it's just trying to do， an exploration of this
    data set。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因为突然有人告诉我们，嘿，我们不想总是选择这两个最佳特征。有时你想选择三个，有时你想选择一个。当你编写代码时，有人只是想了解如何探索这个数据集。
- en: right？ They just want to see how it would perform if we didn't have to pick
    the best two features。 And we say， okay， we know how to do it， right？ Let's keep
    calm， keep calm。 We know how to do this。 We， instead of half-golden the two they
    are， we pass the number of selected features， the。 parameter， right？ And now we
    are very happy because we've saved the day， right？
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧？他们只是想看看如果我们不必选择最好的两个特征，会表现得如何。我们说，好吧，我们知道怎么做，对吧？保持冷静，保持冷静。我们知道怎么做。我们不再半心半意地选择那两个，而是传递选定特征的数量作为参数，对吧？现在我们非常高兴，因为我们拯救了这一天，对吧？
- en: Now you can pick the number of selected that you want， right？ The， the required。
    the requirement is fulfilled。 And all of a sudden they say， hey， well。 sometimes
    we don't actually want to pick， we， want to lose。 you do the little situation
    on all of the numbers that we have， on all of， the features。 And we say。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以选择想要的选定数量，对吧？那么，要求就满足了。突然他们说，嘿，有时我们其实不想选择，我们想要放弃。你在我们拥有的所有数字和所有特征上做一点小处理。然后我们说。
- en: okay， we can make this work， right？ Because I'm going to put a。 a contract with
    you in which if the number of selected that， you're sending is none。 then I will
    completely disregard the， the selection step， right？
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们可以让这个工作，对吧？因为我将和你签订一个合同，如果你发送的选定数量为零，那么我将完全忽略选择步骤，对吧？
- en: And now this is like feeling kind of weird， right？ I mean。 having this comparison
    with na and it's not something that we， we enjoy a lot。 But also。 we are like
    in， in the drift of， of making all these changes that people ask， for us。 And
    all of a sudden someone tells， well， actually we don't always want to do a 60
    regression。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在感觉有点奇怪，对吧？我意思是，与 Na 进行比较并不是我们很享受的事情。但我们也正在进行人们要求的所有这些变化。突然有人说，实际上我们并不总是想做
    60 次回归。
- en: We want to try out like a multi-layer perceptron。 And we are like so deep in
    this train of thought that we've just shackled us into that the。 only thing we
    can think of is just adding another if to this construct， right？
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想尝试多层感知机。我们已经深陷于这个思维过程中，唯一能想到的就是在这个构造中再加一个 if，对吧？
- en: This is something that happens a lot while you're trying to give to your library
    the。 flexibility that it's needed， right？ So now if the， the， the previous part
    was a bit， uh， uh， uh。 e-de。 Now this is like completely terrifying， right？ We
    have the comparison with the string。 We have， we have to raise a narrower if someone
    like， even did， I don't know， like a small。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这在你试图为你的库提供所需的灵活性时经常发生，对吧？所以现在，如果之前的部分有点，呃，呃，呃。e-de。现在这简直是令人恐惧的，对吧？我们有与字符串的比较。我们必须提高更窄的，如果有人，比如，甚至做，我不知道，像是一个小。
- en: typo when passing the classifier type， we， this doesn't make any sense at all，
    right？ I mean。 we're not going through the， through the right path here。 There
    has to be a better way to do this。 And then we realize that the problem is that
    we don't actually know what， what is the model。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在传递分类器类型时出现了错误，这完全没有任何意义，对吧？我的意思是。我们没有走在正确的路径上。必须有更好的方法来做到这一点。然后我们意识到问题在于我们实际上不知道，模型是什么。
- en: '![](img/da90557b6b750703f3d8676bdc5d1ce1_14.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da90557b6b750703f3d8676bdc5d1ce1_14.png)'
- en: that we want， right？ All the things that have been changing。 What I actually
    explaining is that the model， as we said， is very speculative and we will。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的，对吧？所有正在变化的事物。我实际上在解释的是，这个模型，正如我们所说，是非常推测性的，我们将会。
- en: '![](img/da90557b6b750703f3d8676bdc5d1ce1_16.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da90557b6b750703f3d8676bdc5d1ce1_16.png)'
- en: never know what the model looks like。 So the main problem that we're having
    from the beginning is to say that the model has。 to be instantiated in here， right？
    That the classifier has to be in here。 What if instead of instantiating the model
    here， we simply pass it as a parameter， right？
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不知道模型是什么样子的。所以我们从一开始面临的主要问题是说模型必须在这里实例化，对吧？分类器必须在这里。如果我们不在这里实例化模型，而是简单地将其作为参数传递，会怎么样，对吧？
- en: In the constructor， instead of doing， of doing like all those weird stuff that
    we've done。 with the strings and with the number of selective with none and so
    on， we simply say that the。 backend model and I mean backend in terms of the，
    the one that is actually going to be。 doing the computing of the fit can be passed
    as a parameter in the constructor。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们不再做那些奇怪的事情，比如处理字符串和选择性的数字等，而是简单地说，后端模型，我的意思是指实际上要进行拟合计算的那个，可以作为构造函数中的参数传递。
- en: Now this is what the model looks like when we start doing this and what we just
    figured。 out here isn't anything new， right？ We haven't like discovered anything。
    It's like a very well-known design pattern of a object oriented design that is
    called。 dependence injection， right？ Actually if you're familiar with the solid
    acronym。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们开始这样做时，这就是模型的样子，而我们在这里刚刚发现的并没有什么新鲜事，对吧？我们并没有发现任何东西。这就像一个众所周知的面向对象设计模式，称为**依赖注入**，对吧？如果你熟悉**SOLID**这个缩写。
- en: dependence injection is the D in the， solid acronym， right？ That's how important
    it is。 For us in Python， usually dependence injection just means parameterizing
    something in the。 constructor， right？ And as typical in this dependence injection
    and composition mechanisms。 what we end up， coming is the delegation of the methods，
    right？
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**是**SOLID**缩写中的D，对吧？这就是它的重要性。对我们来说，在Python中，通常**依赖注入**仅意味着在构造函数中参数化某些东西，对吧？而在这种**依赖注入**和组合机制中，通常我们最终会得到方法的委托，对吧？'
- en: So the fit that we're calling from our model class actually delegates the call
    to a fit。 of the backend classifier， right？ This is a， like a figure that you're
    going to see happening a lot when you start doing。 dependence injection and composition。
    Now this is what the model looks like and see that what we have done is removing
    the。 coupling from the model that we've just built。 We've removed the coupling
    from it and the actual implementation that we want to do。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们从模型类调用的拟合实际上将调用委托给后端分类器的拟合，对吧？这是一个你在开始进行**依赖注入**和组合时会经常看到的图形。现在这是模型的样子，可以看到我们所做的是去掉了刚构建的模型的耦合。我们去掉了它与实际实现之间的耦合。
- en: right？ Now the implementation is also back in the surface。 So now we have this
    idea of dependence injection as fixing some of the problems we've just like。 put
    ourselves into， right？ But then of a sudden someone tells us， I want to remove
    a feature， right？
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧？现在实现也回到了表面上。所以我们现在有这个**依赖注入**的想法，作为修复我们刚刚置身其中的一些问题，对吧？但突然有人告诉我们，我想去掉一个功能，对吧？
- en: From the other side that we have， I want to simply remove a feature away。 It's
    not something that is going to go into production。 I just want to know how the
    model will perform if we didn't have one of these features。 And we take a look
    at the goal that we have and we say on one hand， well， yes， maybe some。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们这边来看，我想简单地去掉一个功能。这不是一个要投入生产的东西。我只是想知道如果没有这些特性，模型会表现如何。我们看看我们的目标，另一方面我们说，好吧，也许有一些。
- en: dependence injection can help。 I'm not saying that that that it doesn't。 But
    nonetheless。 if this is what we want to do， we will have to re-implement the removal。
    of features inside of this code， right？ I mean， we will have to write it。 we will
    have to document it， we will have to test it。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入可能会有所帮助。我并不是说它没有帮助。但无论如何。如果这是我们想要做的，我们必须在这段代码中重新实现特性的删除，对吧？我的意思是，我们需要去写它，去记录它，还要测试它。
- en: we will have to troubleshoot any problems that the users are going to have。
    So what we're seeing here is that in this data set。py file， there's something
    different。 that we have to do。 And what we need to do to answer the question of
    what's the challenge that is putting down。 here is to reflect on what we've done，
    actually， when doing the dependence injection， right？
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不排查用户可能遇到的任何问题。因此，我们在这个数据集.py文件中看到的是有些不同的事情。我们需要做的，来回答是什么挑战在这里提出的，就是反思我们在进行依赖注入时实际上做了什么，对吧？
- en: '![](img/da90557b6b750703f3d8676bdc5d1ce1_18.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da90557b6b750703f3d8676bdc5d1ce1_18.png)'
- en: I argue here that what we've done isn't only the dependence injection of the
    cycle-learn。 model in the model step， but we've also exposed a known liability
    to data scientists， right？
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里争辩，我们所做的并不仅仅是对cycle-learn模型在模型步骤中的依赖注入，而是我们也向数据科学家暴露了一个已知的责任，对吧？
- en: '![](img/da90557b6b750703f3d8676bdc5d1ce1_20.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da90557b6b750703f3d8676bdc5d1ce1_20.png)'
- en: By doing the dependence injection， we didn't introduce any dependency。 The dependency
    that we are introducing is the psychic-learn library that scientists are。 very
    familiar with， right？ They come already with this stack。 If they have any question。
    they know how to rule for it， they know how to stack overflow。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进行依赖注入，我们并没有引入任何依赖。我们引入的依赖是科学家们非常熟悉的psychic-learn库，对吧？他们已经具备了这个堆栈。如果他们有任何问题，他们知道如何解决，知道如何在Stack
    Overflow上查找。
- en: they know how to communicate with each other about possible solutions。 So what
    if we take this lesson from what actually worked from here and we do a similar
    thing。 with the data set？ Right now the data set， instead of loading the CSV file
    and splitting into features and。 targets， and the targets， sorry。 Now it simply
    fills the data frame attribute and we leave it exposed for everyone to use。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 他们知道如何相互沟通可能的解决方案。那么如果我们从这里的成功经验中汲取教训，做类似的事情来处理数据集呢？现在，数据集不再加载CSV文件并拆分成特征和目标，而是简单地填充数据框属性，并让它对所有人开放使用。
- en: it， right？ So the target and the feature selection are done in the application
    code and then it's。 changed that we want to make is right away， right？
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，对吧？因此目标和特征选择是在应用程序代码中完成的，然后我们想要做的改变是立刻的，对吧？
- en: It's at the tip of our hands when developing the application。 So what is here
    that。 what is it that we have been building here， right？
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，这就在我们的指尖之上。那么这里是什么呢？我们在这里构建的是什么，对吧？
- en: And I'd like first to take a moment to reflect on how it is that this works
    out。 What we have been building with the data set， with the model and so on are
    just abstractions， right？
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我想先花点时间反思一下这如何运作。我们用数据集、模型等构建的只是抽象，对吧？
- en: And there are many ways in which you can define the abstraction in software
    engineering， but。 the one that I really like a lot is the one that Shoyl Spolsky
    wrote that is very simple。 but also cuts to the core of it， right？ That an abstraction
    is a simplification of something much more complicated that is going。 on under
    the colors。 And why do I like this explanation a lot？ First of all。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，有很多种方法可以定义抽象，但我特别喜欢的是Shoyl Spolsky写的那种，它非常简单，但也直击要点，对吧？抽象是对更复杂事物的简化，这些复杂的事情在表面之下发生。我为什么特别喜欢这个解释？首先。
- en: because it's like in a very plain language， but also because it exposes。 the
    subjective thing about what's an abstraction， right？ What's an abstraction。 what's
    an implementation detail？ All of this is very subjective， right？
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这用非常简单的语言表述，同时也揭示了什么是抽象，右？什么是抽象，什么是实现细节？所有这些都是非常主观的，对吗？
- en: We cannot know beforehand what should belong under the colors。 We don't know
    beforehand what is much more complicated， much more complicated for whom， right？
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法预知什么应该属于抽象的部分。我们不知道什么对谁来说更复杂，更复杂的程度是什么，对吗？
- en: Probably for the other scientists working with like， you learn it's not much
    more complicated。 at all， it's something that they have been doing for a lot of
    their professional time。 In this article that is called the Law of Leake abstractions，
    that is 20 years old。 this is still amazes me， right？ It's 20 years old and to
    me it's evergreen。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他科学家来说，像是学习这并没有复杂得多。这是他们在职业生涯中做了很长时间的事情。本文称之为“泄漏抽象的法则”，已有20年的历史，这让我仍然感到惊讶，对吗？它20年了，对我来说仍然是常青的。
- en: Schrodel Spolsky writes the law of leaky abstractions。 What he says is that
    all non-trivial abstractions to some degree are leaky。 What does it mean to have
    a leaky abstraction？ What it means is that no matter how hard we try to hide the
    implementation details under。 the colors， some of the things are going to go back
    to the surface， right？
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 施罗德·斯波尔斯基写下了泄漏抽象法则。他所说的是，所有非平凡的抽象在某种程度上都是有缺陷的。什么是有缺陷的抽象？这意味着无论我们多么努力地隐藏实现细节，一些东西最终还是会浮出水面，对吗？
- en: Some of the things are going to appear， they're going to leak into application
    code， no matter。 how much effort you put in hiding them in the library code。 That's
    this mean that we don't have to be abstractions， absolutely not， right？
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有些东西会渗透到应用代码中，无论你多么努力地将它们隐藏在库代码中。这并不意味着我们不需要抽象，绝对不是，对吗？
- en: We have to be abstractions， but we have to be wary of this because what we are
    seeing here。 is not only like the law of leak abstractions working out in the
    wild。 We're also seeing pressure for these abstractions to leak， right？ The data
    scientists。 the users of the application code are putting pressure for us to leak
    this。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须进行抽象，但我们必须对此保持警惕，因为我们在这里看到的不仅仅是泄漏抽象法则在实际中的运作。我们也看到这些抽象受到压力要泄漏，对吗？数据科学家，应用代码的用户正在施加压力，要求我们泄漏这些信息。
- en: implementation details or what we thought were experimentation details。 There
    is pressure for them to go back to the surface， right？
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实现细节或我们认为是实验细节的东西。它们会受到压力重新浮现，对吗？
- en: So we'll have to make this compromise in our own abstractions， right？
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们必须在自己的抽象中做出妥协，对吗？
- en: We have to let the abstractions leak because they will eventually do it。 But
    from the moment we recognize that this is something that will happen and that
    simplifies。 the exploration， we can choose how they leak， right？
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须让抽象泄漏，因为它们最终会这样做。但从我们意识到这一点并简化探索的那一刻起，我们可以选择它们如何泄漏，对吗？
- en: So what we have been building here is not like simply a library。 We're not trying
    to recreate pandas， nor recreate scikit-learn。 What we're trying to do is to provide
    a framework for the code development and while we're doing。 this framework， we're
    leveraging the knowledge of Python， of pandas， of scikit-learn that the。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里构建的并不仅仅是一个库。我们并不是试图重建pandas，也不是重建scikit-learn。我们想做的是提供一个代码开发的框架，同时在这个框架中，我们利用了应用用户已经掌握的Python、pandas和scikit-learn的知识，对吗？
- en: application user already has， right？ We are using them in our favor and this
    would work also in the case of many other different。 libraries， right？ If the
    library was a Pyspark， TensorFlow， PyTorch。 whichever of the libraries that we
    have in the， stack。 we can do a similar approach in which we leverage the knowledge
    that the application。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此基础上加以利用，这在许多其他不同的库中也同样适用，对吗？如果库是Pyspark、TensorFlow、PyTorch，无论我们在技术栈中使用哪个库，我们都可以采用类似的方法，利用应用程序的知识。
- en: user has and use it in our favor。 So let's take a look at how this tries to
    fulfill the four pillars with the case in the beginning。 First of all， the fast
    and easy exploration and I want us to think now that， suppose that。 one of the
    things we want to try out is what would happen if， I don't know， if we removed。
    the long seples， right？ What would happen if in our dataset we wanted to remove
    the seples that are longer than five？
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 用户拥有并利用这些来为我们服务。那么让我们看看这如何试图在开始的案例中实现四个支柱。首先，快速且简单的探索，我希望我们现在想一下，假设我们想尝试的事情是，如果，我不知道，如果我们移除冗长的序列，会发生什么？如果在我们的数据集中，我们想移除长度超过五的序列，会发生什么？
- en: So the exploration is trivial， right？ That scientists already know how to deal
    with pandas。 they already know how to write this， query that is maybe like two
    or both for us。 We don't think about putting these like this directly into production，
    but they can do it。 if they want， right？ So we are allowing the possibility of
    this kind of exploration。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所以探索是微不足道的，对吧？科学家们已经知道如何处理 pandas。他们已经知道如何编写这些查询，可能对我们来说有点像二者结合。我们并不考虑将这些直接投入生产，但他们可以这样做，如果他们想，对吧？因此，我们允许这种探索的可能性。
- en: But now how do we make this declarative and intentional revealing？
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们如何使其成为声明式和有意的揭示呢？
- en: And this is where the power of the abstraction works in our favor， right？
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是抽象的力量为我们所用的地方，对吧？
- en: Not only the leakish works in favor of the application called the developer。
    but the abstraction works， in our favor as well。 Because we can remove the long。
    the weird query that we have that can be much， much larger， right？ And much with
    much more detail。 we can abstract it and verify it into a method that is declarative。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅抽象为开发者所用，也为应用程序所用。因为我们可以移除冗长的、奇怪的查询，而这些查询可能会更大，更详细。我们可以将其抽象并验证为一种声明式的方法。
- en: and intentional revealing enough。 So now when we take a look at the call in
    train。py。 we are very clearly seeing what's， going on in here， right？
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 并且有意的揭示要足够明显。所以现在当我们查看 train.py 中的调用时，我们可以很清楚地看到这里发生了什么，对吧？
- en: We are not seeing like a query and pandas out in the wild。 We are seeing that
    we are removing the long seples from the dataset， right？
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有看到在实际应用中直接用到查询和 pandas。我们看到的是我们正在从数据集中移除冗长的序列，对吧？
- en: Another important thing here is what we've discussed are sensible checkpoints，
    right？
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事情是，我们讨论的都是合理的检查点，对吧？
- en: The ability for us to latch on and latch off the production code whenever we
    want。 And for this。 I want to say something。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够随时连接和断开生产代码的能力。而为此，我想说一些事情。
- en: '![](img/da90557b6b750703f3d8676bdc5d1ce1_22.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da90557b6b750703f3d8676bdc5d1ce1_22.png)'
- en: There's a lot of stuff we can discuss in the checkpoints， right？ From persisting
    to， I don't know。 to changing temporal views and so on。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查点中我们可以讨论很多内容，对吧？从持久化到，我不知道，到改变时间视图等等。
- en: '![](img/da90557b6b750703f3d8676bdc5d1ce1_24.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da90557b6b750703f3d8676bdc5d1ce1_24.png)'
- en: But I'd like for you to consider the idea of exposing the basic types and by
    basic types。 here I also mean data frames， right？ To consider exposing the basic
    types instead of your custom abstractions。 This is what is going to be doing flexibility
    between checkpoints， right？
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 但我希望你考虑暴露基本类型的想法，这里的基本类型也包括数据框，对吧？考虑暴露基本类型，而不是你们自定义的抽象。这将有助于在检查点之间实现灵活性，对吧？
- en: Because this is what will allow people to feed the features and data sets， however
    they。 built it as pandas data frame， right？ So we will prefer or at least consider
    the idea of doing the implementation on top that。 has the feature on the target
    explicitly written down there instead of the feature instead。 of the implementation
    on the bottom part of the screen。 Now I should say something。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这将允许人们以他们构建的 pandas 数据框的方式来提供特征和数据集，对吧？所以我们将更倾向于或至少考虑在此基础上进行实现，特征在目标中明确写出，而不是特征而是屏幕底部的实现。现在我应该说点什么。
- en: Just be wary when you do this， we don't have to pollute completely the code
    with basic data， types。 This is like a very well-known code smell that has to
    me one of the best names of them all。 that's called the primitive obsession。 We
    don't want to be obsessed with using the basic types but we want to know when
    using。 them is a good compromise to provide the flexibility。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行此操作时要小心，我们不必让代码完全被基本数据类型污染。这是一种非常著名的代码气味，拥有所有气味中最好的名称，那就是所谓的原始类型迷恋。我们不想迷恋使用基本类型，但我们要知道在使用它们时，何时是一个好的妥协以提供灵活性。
- en: How does this help us for seamless tracking and monitoring？ Again。 now the abstraction
    is working in our favor。 Now inside the feed model that we were seeing there。
    we can add simply a login line， right？ With the custom lower， however we want
    to build it。 there are many tools to do it automatically。 I'm not saying that
    you have to write a logger by yourself。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这如何帮助我们实现无缝跟踪和监控？再次强调，现在抽象在我们这边起作用。现在在我们看到的那个馈送模型内部，我们可以简单地添加一行登录信息，对吧？使用自定义记录器，无论我们想要如何构建，有很多工具可以自动完成。我并不是说你必须自己编写记录器。
- en: What I'm saying is that however you get to that logger， you can insert it in
    the app in。 the library part without touching at all the application， right？
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的是，无论你如何获取到那个记录器，你都可以在应用程序的库部分中插入它，而无需触碰应用程序，对吧？
- en: This is one of the advantages that we have。 Again。 the abstraction playing in
    our favor for us to work on it。 One word of caution when you start to do this
    kind of stuff that is going to happen。 the API might be wider than what you expected。
    This is like a recurring theme when you're working with library development。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们拥有的一个优势。再一次，抽象在我们这边为我们工作。当你开始做这种事情时要小心，API可能比你预期的要广泛。这在库开发中是一个反复出现的主题。
- en: is that you， want to have your library as a arrow and as deep as possible， right？
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望你的库尽可能地像一个箭头一样深入，对吧？
- en: So not to expose a lot but expose things that have a lot of depth， that do a
    lot of stuff。 that abstract several things。 Again this is something that we should
    strive in general when trying to develop the code。 but keep in mind that for the
    cause of the abstraction leakage that we're going to have， here。 we will probably
    end up with wider APIs than we wanted to。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所以不要暴露太多，但要暴露那些具有深度、做很多事情、抽象出多种内容的东西。再一次，这应该是我们在开发代码时普遍追求的目标，但请记住，由于我们将面临的抽象泄漏，我们最终可能会拥有比我们想要的更广泛的API。
- en: This is an example that right here that will probably happen the second you
    start doing。 this kind of development in which different people say， "I want to
    load sometimes from。 a data frame， sometimes I want to load from a CSV file， sometimes
    I want to load nothing。"。 These kind of things are going to happen and we need
    to make sure that we provide this， flexibility。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例，可能在你开始进行这种开发的瞬间就会发生，不同的人会说：“我有时想从数据框加载，有时想从CSV文件加载，有时我什么也不想加载。”这些事情将会发生，我们需要确保提供这种灵活性。
- en: Always， as I said， being very cautious about what you're using for exposing
    to the application。 and what you're using for your internal development。 This
    is like a distinction that probably you can make in order to handle the complexity。
    that will come eventually with this。 Of course， if the APIs get too wide eventually。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一直以来，正如我所说，使用时要非常谨慎，注意你在应用程序中暴露的内容，以及你用于内部开发的内容。这是一种区分，可能有助于你应对最终会出现的复杂性。当然，如果API最终变得过于广泛。
- en: you might think about doing a little bit of， refactoring and thinking about
    how this is a composition of different methods。 But essentially， keep in mind
    that one of the goals that we cannot forego here is that we。 have to give sensible
    checkpoints and fast exploration for the people that are going。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会考虑进行一些重构，思考这是不同方法的组合。但本质上，请记住我们无法放弃的目标之一是：我们必须为正在进行的人员提供合理的检查点和快速探索。
- en: '![](img/da90557b6b750703f3d8676bdc5d1ce1_26.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da90557b6b750703f3d8676bdc5d1ce1_26.png)'
- en: to be using our library。 Okay， now， as conclusions， first of all。 one of the
    things that I've learned while doing， this kind of stuff is that what is an implementation
    detail lies in the eye of the beholder。 What for one can be a detail of very complicated
    things that we actually want to happen under。 the whole。 For some people， it's
    the code of what they are developing。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以便使用我们的库。好的，作为结论，首先，我在做这类事情时学到的一件事是，什么是实现细节在于观察者的眼中。对某些人来说，可能是非常复杂的事情的细节，而这些事情实际上是我们希望在整个过程中发生的。对某些人来说，这就是他们所开发的代码。
- en: We need to understand the duality of the implementation and where it's a detail
    or not as quickly。 as we can so we can use it in our favor instead of fighting
    against it。 Another important thing is we have to allow the flexibility of the
    application goal by。 letting it speak the language of the developer。 We have application
    goal developers that already know a lot about pandas。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要尽快理解实现的二元性，以及哪些是细节，哪些不是，以便能够利用它而不是与之对抗。另一个重要的事情是，我们必须允许应用目标的灵活性，让它以开发者的语言表达。我们有一些应用目标的开发者，他们已经对pandas了解很多。
- en: that already know， a lot about PISPARC， a tensorflow。 Don't hide this away from
    them。 Allow them to write the goal in the same way that they have been learning
    for their。 entire professional lives。 Allow them to write things in a language
    that is common for these application developers。 They can travel through questions
    with each other。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 他们已经对PISPARC和tensorflow有了很多了解。不要把这些信息藏起来。允许他们以他们整个职业生涯所学习的方式来书写目标。允许他们用这些应用开发者常用的语言来表达。他们可以在彼此之间交流问题。
- en: They can even ask them in a wider forum and leverage help from different sources。
    Another thing is。 as we mentioned， some of the instructions will eventually leak
    to the， application goal。 Instead of thinking hard about how we can make these
    abstractions， how we can prevent。 them from leaking， we can just be in peace with
    the fact that they are going to leak eventually。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 他们甚至可以在更广泛的论坛上提问，并利用不同来源的帮助。还有一件事，如我们所提到的，某些指令最终会泄漏到应用目标中。与其费尽心思去思考如何制作这些抽象，如何防止它们泄漏，我们不如接受它们最终会泄漏的事实。
- en: and instead of fighting them， channel them to leak in a way that allows us to
    have the。 goal with fast exploration that eventually gets to be the clarity that
    the customer。 will check points and that allows us to have seamless tracking of
    the experiments。 That's it that I have for now。 Thanks。 Thank you， Paula， for
    the excellent talk。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是与之对抗，应该引导它们以一种方式泄漏，让我们能够快速探索目标，并最终达到客户所检查的清晰度，从而实现实验的无缝跟踪。以上就是我目前的分享。谢谢。感谢你，Paula，带来了精彩的演讲。
- en: '![](img/da90557b6b750703f3d8676bdc5d1ce1_28.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da90557b6b750703f3d8676bdc5d1ce1_28.png)'
