- en: P87：Typing Summit - at VikingDen7 - BV1f8411Y7cP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P87：打字峰会 - 在VikingDen7 - BV1f8411Y7cP
- en: Hi， I'm David Foster and yeah， welcome to the Typing Summit。 So I thought it
    might be useful to present a roundup of some new typing features that。 are in
    the current version of Python that we have right now， Python 3。10， and the new。
    version of Python that's coming up later this year， Python 3。11。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 嗨，我是大卫·福斯特，欢迎来到打字峰会。所以我认为呈现一些当前版本Python 3.10中的新打字功能的总结可能会很有用，以及今年晚些时候即将推出的新版本Python
    3.11。
- en: So I'm just going to go through them somewhat quickly。 First。 I guess I should
    introduce myself a little bit further。 Okay， David Foster。 contributor to MyPy
    and especially typed dict。 When I'm not doing open source。 I am chief technology
    officer at TechSmart where we are。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我将快速浏览这些内容。首先，我想进一步介绍自己。好的，我是大卫·福斯特，MyPy的贡献者，特别是在typed dict方面。当我不在做开源的时候，我是TechSmart的首席技术官。
- en: bringing world-class computer science education to the next generation of K-12
    students and。 teachers。 So getting kids excited about coding and you can find
    me online at these places。 So a couple of years ago， just last year actually，
    just in early 2021， I wrote an article that。 is proclaiming that Python was in
    the middle of a type-checking renaissance because we've。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为下一代K-12学生和教师提供世界级的计算机科学教育。因此，让孩子们对编码感到兴奋，你可以在这些地方找到我。几年前，其实是去年的早些时候，我写了一篇文章，宣称Python正处于类型检查的复兴中。
- en: had so many peps recently that are introducing new typing related features。
    And this year， 2022。 no exception to that。 So as mentioned， I am hoping to in
    this talk to go through some of the specific features。 that are in both the current
    version of Python and the new version of Python 3。11 that will。 be released later
    this year。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最近有很多PEP引入了新的打字相关特性。今年2022年也不例外。因此，如前所述，我希望在这次讲座中介绍一些当前版本Python和即将发布的Python
    3.11中的具体特性。
- en: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_1.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_1.png)'
- en: So let's talk about where we are right now with Python 3。10。 We've got four
    typing related peps here。 A couple that are introducing new kinds of types。 So
    peram。 spec， and type guard。 There's other types of notation that's been added。
    And one theme that I think is recurring is eliminating imports required from the
    typing。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈Python 3.10的现状。我们有四个与打字相关的PEP，其中一些引入了新的类型。因此，有peram spec和type guard。还有其他类型的符号被添加进来。我认为一个反复出现的主题是消除对typing模块的导入需求。
- en: module itself， which makes typing annotations more easy to use。 So just to go
    through some of these briefly， I'll show an example of code before the introduction。
    of the feature and what you can do after the feature。 In 3。10。 the first thing
    I have up is peram spec， which is particularly useful for annotating， decorators。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 模块本身使得打字注释更容易使用。为了简要介绍一下这些内容，我将在引入该特性之前展示一段代码示例，以及在3.10引入该特性后的代码示例。我首先要介绍的是peram
    spec，这对于注释装饰器特别有用。
- en: So you can use that as a placeholder for any set of parameters。 And so then
    it becomes possible to have this decorator nicely typed， which has been a problem。
    for some time。 So you can do that now。 Moving on， type guard。 So this is particularly
    common in JavaScript， but also happens in Python where you have。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以将其用作任何参数集的占位符。因此，使用这种装饰器变得可能具有良好的类型，这在一段时间以来一直是个问题。所以现在你可以做到这一点。接下来是type
    guard。这在JavaScript中尤其常见，但在Python中也会发生。
- en: a function that is used to check whether something is of a particular property
    that a type checker。 can't figure out。 So in this case， you have an example of
    a function that checks whether something is a list of。 strings。 So we have a function
    that just returns a bool here， which is okay， but it would be nice。 that if you
    called this function and it returned true， that a type checker could narrow the。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个函数用于检查某个东西是否具有类型检查器无法确定的特定属性。在这种情况下，你有一个检查某个东西是否是字符串列表的函数。因此我们有一个只返回布尔值的函数，这样可以，但如果调用这个函数并返回true，类型检查器能够缩小类型范围，那就更好了。
- en: type of the thing that you passed to this function to be a stir of list。 And
    with type guard。 you can do that。 If you set the return type to type guard list
    of stir， you return true。 narrowing happens。 Beautiful。 Moving on， type alias。
    So in Python。 we've had the ability to define type aliases for a long time implicitly
    by。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你传递给这个函数的东西的类型应该是一个字符串列表。通过类型保护，你可以做到这一点。如果你将返回类型设置为类型保护字符串列表，你返回true。这样就会发生缩小。太美妙了。继续，类型别名。在Python中，我们长期以来一直可以隐式定义类型别名。
- en: assigning a effectively a type expression to a variable。 And then that is interpreted
    by type checkers as a type alias。 However。 there are cases where you want to be
    explicit that that's actually what you're， doing。 And at the moment， if you do
    something very similar， which is you assign a string of five。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个有效的类型表达式分配给一个变量。这被类型检查器解释为类型别名。然而，在某些情况下，你希望明确表示这实际上是你所做的。此时，如果你做一些非常相似的事情，比如分配一个五个字符的字符串。
- en: type expression to a variable， a type checker will not be able to figure out
    that you actually。 wanted to make a type alias there。 So now with type alias。
    you can make the otherwise implicit aliases explicit and you。 can now use forward
    references for stringified references， which is useful。 So that's kind of cool。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 将类型表达式分配给变量时，类型检查器将无法判断你实际上是想在这里创建一个类型别名。因此，现在通过类型别名，你可以使隐式别名变为显式，并且你现在可以对字符串化引用使用前向引用，这非常有用。这真是太酷了。
- en: Next up， one of my favorites is the ability to write union types and optional
    types， which。 is a variable or the constant none using the pipe operator。 So this
    eliminates a few typing imports from the typing module。 So no more important typing
    module。 And you don't have to type as much either because instead of writing union，
    you can use。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我最喜欢的之一是编写联合类型和可选类型的能力，即使用管道运算符表示变量或常量none。这消除了从typing模块导入的一些类型。这样你就不再需要导入typing模块了。你也不必输入太多，因为你可以用管道符代替写联合。
- en: a pipe instead of writing optional。 You can just say pipe none works great is
    explicit。 So that's Python 310。 That's what we have access to today in the final
    release。 There is also Python 311， which is just about to enter its first beta，
    I believe， either。 today or tomorrow。 And I heard a clarification next week。 Next
    week。 Okay， 310 beta one next week。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用管道代替写可选。你可以直接说管道none，这样是显式的。这是Python 310。今天我们在最终版本中可以访问的内容。还有Python 311，似乎即将进入它的第一个beta版本，我相信，要么是今天，要么是明天。我听说下周会有进一步的说明。下周。好的，310
    beta一将在下周发布。
- en: So these types of types are now available。 So we have， let's see， one， two，
    three， four， five。 peps here。 So I'll just briefly go through those as well。 So
    let's talk about literal string。 So there are a number of APIs that expect some
    kind of fixed format string， command string。 of some kind。 And in the documentation
    first， that API's。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型现在可以使用了。我们有，嗯，让我看看，一、二、三、四、五。这几个peps。所以我将简单介绍一下这些内容。我们先说说字面字符串。有许多API期望某种固定格式的字符串，命令字符串。文档首先是该API的。
- en: they may say that you really should just use， like a string literal。 but there's
    no way for it to actually enforce that。 Because that's just in the documentation。
    So common cases， you have something that's running like a SQL command or as a
    second example。 I'll show you in a moment。 If you're writing a format string to
    a logging function。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 他们可能会说你真的应该只使用字符串字面量，但实际上没有办法强制执行这一点。因为这只是文档中的内容。因此，常见的情况是，你有一些像SQL命令一样运行的东西，作为第二个例子。我稍后会向你展示。如果你正在为一个日志记录函数编写格式字符串。
- en: So right now there's no way to tell a type checker that this string that you're
    passing。 in should be a literal。 But with a literal string。 you can actually annotate
    it that there should be specifically， a literal passed in。 And if you don't do
    that， a type checker will tell you that that's no good。 So that's pretty cool。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在没有办法告诉类型检查器，你传入的这个字符串应该是一个字面量。但是使用字面字符串，你可以实际注释它，说明应该传入一个字面量。如果你不这样做，类型检查器会告诉你那不好。所以这非常酷。
- en: So you can avoid command injection for people who use APIs with literal string
    who also。 are running type checkers on their code base。 And for many large code
    bases， this is already done。 So as mentioned， there's a second example here of
    formatting strings， which is another。 type of command string。 And in particular，
    we had an issue recently with log4j where you had some unexpected use。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以避免命令注入，针对那些使用字面字符串的API，并且也在其代码库上运行类型检查器的人。对于许多大型代码库，这已经完成了。如前所述，这里还有一个格式化字符串的第二个示例，这是另一种命令字符串类型。特别是，我们最近在log4j上遇到了意外的使用问题。
- en: of things in command strings。 And that would be harder to exploit。 If you had
    something like this used to type annotate a function expecting a format string。
    So that's literal string。 Type guard double。 So this is interesting。 So there
    are a couple of libraries that define array like classes。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 命令字符串中的东西。如果你有类似的东西用于类型注释期望格式字符串的函数，那么这会更难被利用。因此，这是字面字符串。类型保护双重。这很有趣。有几个库定义了类似数组的类。
- en: So NumPy's nd array class tensor flows tensor class。 In there are many cases
    where the data inside these has either a particular set of expected。 data types
    or dimensions。 And right now， the only way that you can。 right now you can only
    put that information， in comments and documentation。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所以NumPy的ndarray类和TensorFlow的张量类。在许多情况下，这些内部数据都有特定的预期数据类型或维度。而现在，你只能将这些信息放在注释和文档中。
- en: It's not enforceable automatically in any way。 So here I've just got a comment
    here that's saying like this is an image and it happens。 to have a height and
    width as its dimensions here。 But with type bar tuple。 you can define array types
    that you can just give generic properties。 for each of either the dimensions or
    the data types or whatever property that you think。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这在任何情况下都不能自动强制执行。因此，在这里我有一个注释，说明这是一个图像，恰好有高度和宽度作为其维度。但是通过类型条元组，你可以定义数组类型，只需为维度或数据类型或任何你认为的属性提供通用属性。
- en: is useful to be enforced as consistent。 So here we're doing。 you can actually
    just say height and width explicitly。 Because they're new types。 it won't allow
    you to like mix them up。 Like instead of height width， maybe you put width height。
    easy to get it mixed up if you， have column based ordering versus row based ordering。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性很重要。因此在这里我们这样做。你实际上可以明确地说高度和宽度。因为它们是新类型，它不会允许你混淆。例如，不小心把高度和宽度颠倒了。如果你有列优先和行优先的顺序，很容易搞混。
- en: So that's type bar tuple。 Self。 So there are a number of APIs that are written
    in a so called fluent style where you have。 methods that on a class that return
    the same instance of that class after they finish。 so they return itself at the
    end。 Before it was possible， although rather cumbersome and verbose。 to annotate
    the return type of， such methods to describe to the type checker that it's actually
    still returning itself。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是类型条元组。Self。所以有许多API是用所谓的流式风格编写的，其中方法在类上返回该类的同一实例，完成后返回自身。在此之前，虽然可能，但相对繁琐且冗长，要注释此类方法的返回类型，以告诉类型检查器它实际上仍在返回自身。
- en: You can do that with this fancy thing with a type bar。 Well now you can just
    do it directly。 So if a function returns the value self， you can also say that
    in its signature that returns。 the type of self and it will do all of that magic
    for you， which is great。 Data class transform。 So this one's interesting。 So there
    are a number of libraries that define things like data class。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过这个带有类型条的花哨东西来做到这一点。现在你可以直接这样做。如果一个函数返回值为self，你也可以在它的签名中声明返回self的类型，这样它就会为你完成所有魔法，这太好了。数据类转换。所以这个很有趣。有很多库定义了像数据类这样的东西。
- en: model classes of various， kinds。 So you have adders as an old one。 Pidantic
    is a newer one。 but there are many of these libraries that define classes that，
    act like the built in data class。 And right now in order for a type checker to
    support these various libraries， there。 has to be a special plugin that is written
    for each library and each type checker。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 各种类型的模型类。你有较旧的添加器，Pidantic是较新的，但还有许多库定义了像内置数据类一样的类。现在，为了让类型检查器支持这些不同的库，必须为每个库和每个类型检查器编写一个特殊插件。
- en: So a lot of times these plugins simply don't get written。 Well now there's a
    way for library authors who are making something like a pidantic model。 or an
    adders based model to specify on those sort of meta models effectively。 They can
    add this data class transform decorator， which tells type checkers that it acts
    like。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所以很多时候，这些插件根本没有被编写。现在，库作者有了一种方式，可以在这些元模型上有效地指定类似于pidantic模型或基于adders的模型。他们可以添加这个数据类转换装饰器，告诉类型检查器它像一个数据类。
- en: a data class。 And so then you don't need the definer of the metal model。 It
    doesn't need to start writing a series of plugins for all the type checkers。 So
    that's great。 And last but not least， there is an extension to the existing type
    to dict type to dictionaries。 data type。 Previously it was possible to define
    a type to dict， which is a dictionary with a set of。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你不需要元模型的定义者。它不需要为所有类型检查器开始编写一系列插件。这太好了。最后但并非最不重要的是，现有的类型到字典的数据类型有一个扩展。之前可以定义一个类型到字典，这是一个具有一组的字典。
- en: a particular expected keys that have expected values。 Very common in JSON。 It
    was possible to define a type to dict where some of the keys are either required。
    and some of them where they are not required。 You had to do this weird hack where
    you had one type to dict inheriting from another type。 to dict in order to mark
    some keys as required or not required。 Now you can just mark it directly。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 期望的特定键具有预期值。这在JSON中非常常见。可以定义一个dict的类型，其中一些键是必需的，而一些则不是。你必须使用一个奇怪的黑客手段，让一个类型继承自另一个类型，以标记某些键为必需或非必需。现在你可以直接标记它了。
- en: So very common is you have a lot of keys that are required and a few that are
    not required。 So much。 much simpler to write。 So that is what I've got。 If you're
    looking for more information。 for example， a list of typing related peps， I've，
    assembled an updated list in that blog post。 Python's type checking renaissance。
    If you search for that。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见的是，你有很多必需的键，而有一些则不是。这是简单得多的写法。这就是我所拥有的。如果你想要更多信息，例如与输入相关的peps列表，我在那篇博客文章中整理了一个更新的列表。搜索“Python的类型检查复兴”即可找到。
- en: you'll find that list of typing related peps and you can get， the pet links
    there as well。 Thanks for listening folks。 So I've got like two， three minutes
    for questions。 Hit me。 Will this be available in typing extensions or， you know，
    versions of a create instance？
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你会找到与类型相关的peps列表，你也可以在那里获取peps链接。谢谢大家的倾听。我有大约两到三分钟的时间来回答问题。问我吧。这会在typing extensions中可用吗？或者，你知道的，创建实例的版本吗？
- en: So the question was， are the features that you mentioned available in typing
    extensions。 or will they be available in typing extensions？ In general。 all new
    typing features are added to typing extensions first and they will work。 in any
    version of Python。 So yes， you can use these today even if you're using a older
    version of Python in most cases。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，你提到的功能在typing extensions中可用吗？或者它们会在typing extensions中可用吗？通常，所有新的类型特性首先添加到typing
    extensions中，并且它们可以在任何版本的Python中工作。所以是的，你可以在大多数情况下今天使用这些，即使你使用的是较旧版本的Python。
- en: Because I love things like peps。 So for you sometimes have to lie and use computer
    annotations and that will break if you also。 kind of use programming。 So peps。04，
    can you tell me what that maps to？ Type。 Sorry。 Next， pipe y。 That will work at
    runtime。 You have to have fun teaching and fun annotations and if you try to use
    have runtime。 you can， guess。 If you have runtime uses of that， that's a little
    bit more tricky。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我喜欢像peps这样的东西。所以有时你必须撒谎并使用计算机注释，如果你同时使用编程，这将会破坏它。因此peps.04，你能告诉我这映射到什么吗？类型。抱歉。下一个，pipe
    y。这在运行时将会工作。你必须乐在其中教学和有趣的注释，如果你尝试使用运行时，你可以，猜测。如果你有运行时使用，这就有点棘手了。
- en: You can stringify the type of annotation in some cases but then you still can't
    use it。 from the front。 With her right， front result of the people who work。 Her
    right。 she can't use it at runtime in that case unless you're doing the library。
    It knows how to email them but actually I think it's going to work in the ability
    to work。 Yeah。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可以将类型注释转换为字符串，但你仍然不能从前端使用它。根据她的要求，工作中的人不能在运行时使用它，除非你在库中。它知道如何通过电子邮件发送，但实际上我认为它在工作能力上会有效。是的。
- en: that doesn't work in my case。 Oh， the overup words about I don't know what you're
    saying。 I had a question on why we didn't support non-pipe X。 I mean X， pipe，
    no。 Whether that's something that might be on the right。 Because I don't know。
    No， no， no， no， no。 I do not know if that works or not。 I learned something。 Okay，
    so yeah。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，这行不通。哦，关于你说的我不知道的问题。我有一个问题，为什么我们不支持非管道X。我是说X，管道，no。是否有可能在正确的方向上。因为我不知道。不，不，不，我不知道这是否有效。我学到了一些东西。好吧，是的。
- en: the question was does we have X， pipe， none， but maybe not non-pipe X。 Apparently
    from research here both work。 Got a question here。 What are we going to get in
    three twelve？ Three twelve。 Three。 so there are two things that I know about one
    which is tentatively called either type。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们是否有X，管道，none，但也许没有非管道X。显然，从这里的研究来看，两者都有效。这里有个问题。我们将在三十二号得到什么？三十二。三。所以我知道有两件事情，其中一件暂定称为类型。
- en: form or annotation type。 That's something that I'm working on which will allow
    you to label the type of a type annotation。 object which is very close to type
    of T。 The type of T doesn't accept certain things like unions and a few other
    things。 That's something I'm planning on adding。 And there is a second one from
    that article which I do not remember offhand。 You'll have to go look it up for
    me。 Optional is one of the most confusing words I had ever thought about。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 形式或注释类型。这是我正在研究的内容，它将允许你标记类型注释的类型。对象非常接近类型T。类型T不接受某些内容，如联合和其他几个内容。这是我计划添加的内容。还有一篇文章中的第二个我现在不记得了。你得帮我查一下。可选是我曾考虑过的最令人困惑的词之一。
- en: Optional X is not in basic classes for example， optional。 Could we take。 could
    we replace it with a Y or a Y？ We can't in favor of five now。 So the discussion
    that was made up was related to that the thought was that optional was basically。
    too big with us too deprecate。 So probably we're going to be with it for a long
    time at the very least。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可选X不在基本类别中，例如可选。我们可以替换成Y或Y吗？我们现在无法支持五。因此，讨论的内容与可选的思考有关，认为可选基本上是对我们来说太大而无法弃用。所以我们可能至少会与其相处很长一段时间。
- en: Rather than either reclassifying use of the word optional or going completely
    eliminating。 That was more or less the consensus that seemed to be the case。 So
    yeah。 for those of you who don't know me， I'm a sadest one。 And today I will be
    talking about basically the word that has been going on around tense word typing
    in the past。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与其重新分类可选一词的使用，不如完全消除。这似乎是比较一致的共识。所以，对于那些不认识我的人，我是一个悲伤的人。今天我将谈论的是过去围绕时态词类型发生的事情。
- en: What is going on now？ What is the next step today？
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在发生了什么？今天的下一步是什么？
- en: What's going on there for those of you who are not going to take a sentence？
    So first of all。 like first I think it's a very analogous topic because it really
    works a lot of things and。 getting anything that appears in numerical language。
    So on the one hand we have very clear aspects like creating a pencil or getting
    a pencil or doing some basic。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不打算采纳句子的人来说，那里发生了什么？首先，我认为这是一个非常类似的话题，因为它确实涉及许多事物，并且涉及任何出现在数值语言中的内容。所以一方面，我们有一些非常明确的方面，比如创建铅笔、获取铅笔或进行一些基本操作。
- en: multiplication or concatenation。 We have numerical language and language。 And
    we can start the end of the day。 The layers are just performing multiple locations。
    We are talking about typing a sentence or typing a language and would be very
    fine in the input and how to。 make it possible。 And then we also have a wide range
    of operations that are in our traffic experience and that is very open in。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法或连接。我们有数值语言和语言。我们可以在一天结束时开始。层只是执行多个位置。我们谈论的是输入一个句子或输入一种语言，并且在输入的方式上会非常精细。然后我们还有一系列在我们的流量体验中非常开放的操作。
- en: numerical categories。 For example， you have a pencil。 You have a pencil。 You
    have a button in ten tours。 You have a green， perfect casting or some very popular
    operations like comics。 comics， and we have a dashboard。 So unfortunately there
    is one person that has a little bit of a problem instead of going to solve this
    problem。 with a combination of tours。 And we can put them into drawing categories，
    one for lyrics。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 数值类别。例如，你有一支铅笔。你有一支铅笔。你有十次操作中的一个按钮。你有一个绿色的、完美的铸造，或者一些非常流行的操作，如漫画。漫画，我们有一个仪表盘。不幸的是，有一个人遇到了一点问题，而不是去解决这个问题。结合多次操作。我们可以把它们放入绘图类别中，一个用于歌词。
- en: another for lyrics。 And it's one of these two responses that we have to solve
    this problem。 So here for lyrics， I love to solve something in the background。
    And it's the line in itself with a concept of cancer。 like a class with a variable
    number of parameters， which is in the dynamic successes。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个是歌词。这是我们必须解决这个问题的两种回应之一。因此，对于歌词，我喜欢在后台解决一些问题。并且它自身就是一个关于癌症的概念，就像一个具有可变参数数量的类，这在动态成功中是存在的。
- en: And also I want to say that we are moving for like I mentioned。 or for example
    in the magazine application。 And then there are many。 just key in every time that
    there is some arithmetic operation in the dimensions， right？
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想说我们正在进行类似我提到的工作。或者例如在杂志应用中。而且每当在维度上有一些算术运算时，都有很多关键内容，对吧？
- en: Or something like an animation and a special operation on a conversion。 And
    then custom operators are needed for， also created， kind of the experts in another
    week。 And that's very common。 For example， broadcasting。 For example。 for casting
    is for whatever the place in numerical areas。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 或者像动画和转换上的特殊操作。然后，定制操作符是必要的，另外在下周创建的专家。这是非常常见的。例如，广播。例如，类型转换是在数值领域中的任何地方都适用的。
- en: And it kind of gives us a little bit more of a technical。 So as of now。 I think
    something we really proud of is the huge milestone that I've been having with
    respect to last year。 That is a sense of 36 or 6。 Now it's available from 5-month
    payload。 I think what we have talked much about this from in the past years is
    one of the reasons why I'm able to keep working together in venture farming。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了一些技术上的提升。到现在为止，我认为我们非常自豪的是，关于去年的巨大里程碑。这是36或6的感觉。现在可以从5个月的有效载荷中获取。我认为我们在过去几年中对此进行了很多讨论，这也是我能够继续在风险投资中工作的原因之一。
- en: So that this is already done， it's quite an achievement and I think they are
    very middle。 Then on the definitely big side， I'm working with gravity on having
    a value or a portion。 Although for the poor ones， to drive， you know that this
    is a value of an entire scene。 By trying to think this from the value again。 And
    it's also nice to have it to show that this magnitude was implemented and to get
    insights about what are the implications of an implementation。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经完成了，确实是一个成就，我认为它们处于一个很好的中间状态。然后在确实较大的方面，我正在研究引力的价值或部分。虽然对贫困者来说，驱动这一点，你知道这代表了整个场景的一个价值。通过再次从这个价值进行思考也是很好的。并且展示这个大小是如何实现的，以便深入了解实施的影响是什么。
- en: And then customer break-tors is what I mean is so big that helping a lot of
    discussion about what all the operators are and important。 Some of them that I
    mentioned were casting is very common of the product。 This is already available
    in fire and there are no tricks that they will be coming to the table。 So what
    I have is a few minutes to take a look at what we used to have on the camera。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，客户中断器是我所指的，是如此庞大，以至于帮助了关于所有操作符的重要讨论。我提到的一些操作符，类型转换是非常常见的。这在火中已经可用，没有什么花招会出现在桌面上。所以我有几分钟的时间来看看我们以前在相机上使用的内容。
- en: So basically before we put an express that we have a tensor pain and a lot of
    dimension。 Instead to work with dimensions in terms of we need to have more。 at
    least define a class with for every number of dimensions。 Tensor one dimension
    to dimension to dimension to dimension and this applies also to methods。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，在我们明确表示之前，我们有一个张量的痛苦和许多维度。相反，我们需要在维度方面进行更多工作。至少为每个维度定义一个类。张量从一个维度到另一个维度，这同样适用于方法。
- en: So you need to work those for any number of dimensions。 There are two or three
    parameters going to allow this kid to work on another version that is crazy。 Actually，
    my programmer probably was in the library that was trying to use this idea and
    at the end of the product。 there were so many combinations that people understood。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你需要处理任何数量的维度。有两三个参数将允许这个孩子在另一个疯狂的版本上工作。实际上，我的程序员可能在尝试使用这个想法的库中，在产品结束时，有如此多的组合让人们能够理解。
- en: But now we have to have the one that we wanted to be able to express having
    a tensor and the one that we want to mention a lot of in any number of dimensions。
    And I think this is a very nice thing to have。 And it makes also very easy to
    work with dimensions later。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们必须有我们想要表达的张量，以及我们想要提及的任何数量维度的内容。我认为这是一件非常好的事情，也使后续处理维度变得非常简单。
- en: For example， you see that now we don't need to be overly loving but as well
    as the numbers to express something that are not necessarily tensor specific。
    For example， when we find the enecro， we don't pass a dimension。 So we have a
    variable number of numbers that will be converted into a set of dimensions where
    we can project and extract dimensions and put them into a tab。 So having this
    makes big difference on what can be modeled and how much the words to do a lot
    of things。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你会看到现在我们不需要过于依赖数字来表达一些不一定是张量特定的内容。例如，当我们找到enecro时，我们不会传递维度。因此，我们有一个可变数量的数字，这些数字将被转换为一组维度，在这里我们可以投影和提取维度并将它们放入一个表格中。因此，这使得可以建模的内容和可以做的事情之间有了很大的不同。
- en: So once again， having this as the library news， then type arithmetic。 Now that
    we have already added this kind of one of the most clear things that would have
    been the word to support many other news cases。 especially when they want to hold
    machine learning。 So type arithmetic basically appears anywhere where you need
    to do some arithmetic operations on the dimension。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所以再次提到，作为库的新闻，然后是类型算术。现在我们已经添加了这种最明确的内容，那就是支持许多其他新闻案例的词汇。特别是当他们想要进行机器学习时。因此，类型算术基本上出现在你需要对维度进行一些算术操作的任何地方。
- en: For example， if you want to come up and into tensor。 you will need to get the
    addition of the tensor。 You want to get an instance of tensor。 you will need to
    put the subscription。 You need to generate tensor with values in some range。 You
    will work on the means of the fractional deviation or something like social plus
    allocation and going with requirement deviation。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想进入张量。你需要得到张量的加法。你想要获取张量的实例。你需要放置订阅。你需要生成一个值在某个范围内的张量。你将处理分数偏差或类似社会加配和需求偏差。
- en: Perhaps the main exponent of what the library may be coming is a convolution。
    The convolution has a pre-intiming formula when you look at it。 you will tend
    to think more carefully and realize that at the end it's a binary method。 Basically
    the convolution is convoluted by definition， but it's pretty simple。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 也许这个库的主要指数是卷积。卷积有一个预定的公式，当你查看它时，你会更仔细地思考，并意识到最后这是一种二元方法。基本上，卷积是按定义卷积的，但它相当简单。
- en: There is a subtractional deviation on the dimension。 So basically we are able
    to support every minute， we will be able to support tensor completely。 as this
    no matter how we combine it， how many layers there are。 we should be able to verify
    that what is happening here is correct。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在维度上存在一个减法偏差。所以基本上，我们能够支持每分钟，我们将能够完全支持张量。不管我们如何组合它，有多少层，我们应该能够验证这里发生的事情是正确的。
- en: And this is a challenge for pre-minus programming because this formula is also
    complicated。 so we can easily get those on them to have it verify that on bad
    timing。 And then my extension by supporting this， we also support the important
    programming in the sense that we are also capable of giving to variables that
    they represent dimensions。 We are able to represent their expressions because
    this way we can verify that the input that you are providing to an everyone in
    words corrects and you are not passing something like a word something like a
    word that's a good thing。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这对预减编程是一个挑战，因为这个公式也很复杂。所以我们可以轻松地验证那些在不良时机上出现的内容。然后通过支持这个扩展，我们也支持重要的编程，意味着我们能够将变量赋值为它们代表的维度。我们能够表示它们的表达式，因为这样我们可以验证你提供给每个人的输入是否正确，而不是传递一些像词那样的东西。
- en: So probably so pretty good work， but at the end the semantics of the operators
    are quite a separate problem。 First of all we assume that we are going to be using
    the parameters for defining the values of the sets of dimensions。 and then basically
    the mathematical parameters became really likely if they have a potential。 Later
    as two， later on three， we have five and so on and so forth。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所以可能这是一项相当不错的工作，但最终运算符的语义是一个完全不同的问题。首先，我们假设我们将使用参数来定义维度集的值。然后，基本上数学参数变得非常可能，如果它们具有潜力。后来是两个，然后是三个，我们有五个，依此类推。
- en: So building in these cases that's so big material is far behind any other handling
    in and what this requires some more discussion。 but this one that we have a little
    bit of， but that's simple summary。 And then the other key part of what's important
    about it is equality。 Because so far they have been commenting， that's surprising。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这些情况下构建如此大的材料远远落后于任何其他处理，这需要更多讨论。但我们有一点点，这就是简单的总结。然后，关于它的重要性的另一个关键部分是平等。因为到目前为止，他们一直在评论，这令人惊讶。
- en: because you have a system where you have to prescribe an address by part。 but
    it's not enough because at the end you are going to be doing all the time expressions
    and sensors that they are going to get equivalent but with different expressions。
    And the problem is that you will get an error from the net secretary to create
    like for example。 they do have a tensile size， a black bean， and so they don't
    size a deep plastic。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你有一个系统，需要按部分指定地址。但这还不够，因为最后你将一直处理时间表达和传感器，它们会得到等效但使用不同的表达式。问题是你会收到网络秘书的错误提示，比如说，他们确实有一个拉伸尺寸，一个黑豆，所以他们并不考虑深塑料的尺寸。
- en: so they are not the same when you are a Christian。 but for us like these are
    usually the same way because I think it's comfortable。 but throughout the net
    secretary this is popular and is surprised to have very wide range of expression
    that they will be hearing absolutely normal circumstances。 So supporting them
    is a must for the main discrete or usual。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当你是基督徒时，它们并不相同。但对我们来说，这通常是相同的，因为我觉得这样很舒适。但在整个网络秘书中，这种表达方式非常流行，令人惊讶的是他们会在绝对正常的情况下听到非常广泛的表达。所以支持它们是主要离散或通常的必须。
- en: but at the same time we want to make sure that this is not going to make the
    language way more complicated because now all the other languages that can do
    such a thing are depending on the type in languages。 where basically the only
    way to provide that approach that there is an equality in the expression and that's
    definitely far from the division that we have for 5 months of language。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但同时我们想确保这不会使语言变得更加复杂，因为现在所有可以做到这种事情的其他语言都依赖于类型语言。在这里，基本上提供这种方法的唯一方法是表达中存在平等，这与我们5个月语言的划分显然相距甚远。
- en: So basically the idea is that we need to show that whatever we are is going
    to ask you over heads for the parameter。 like the potential we have done at it，
    and the only kind of advantage that we have is that we have limited ourselves
    to have a few number of operators。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本的想法是我们需要展示无论我们是什么，都会在参数的开销上向你询问。就像我们在潜力上所做的那样，而我们唯一的优势是我们限制了操作符的数量。
- en: right？ We don't want to separate ourselves to be any thing in the tensile price。
    we only want to press a number of operators， so we can't make sure that we can
    and that's basically the same thing in the proposal。 That is to create a generic
    representation。 Basically the idea is that we have two expressions which are irrelevant。
    based on the internal distribution in the same way。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧？我们不想让自己与拉伸价格中的任何事物分开。我们只想按操作符的数量，所以我们不能确保我们可以，这基本上与提案相同。那就是创建一个通用表示。基本的想法是我们有两个无关的表达式，基于内部分布以相同的方式。
- en: and if we have to use them and quality comparisons are free。 So how does this
    work？ Well。 for the guess of additional expression and notification we can think
    about this as polynomials。 so the problem becomes just how can we compare polynomials
    and so they could。 For this。 we go through a series of steps that are called expanding
    polynomials。 Monomials group in them。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须使用它们，质量比较是免费的。那么这是如何工作的呢？好吧。对于额外表达和通知的猜测，我们可以将其视为多项式。所以问题变成了我们如何比较多项式，因此他们可以。为此，我们经过一系列称为扩展多项式的步骤。单项式在其中分组。
- en: reason， zero， something like that。 And with this we go on and get it。 we go
    on and get it with a bit of a simple， simple， simple。 It's not that much that
    we know exactly how to do this， and they are leveraged。 they are kind of automatically
    like take this property。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 原因、零、类似的东西。通过这个我们继续并获得它。我们继续并简单地得到它。这并不是说我们完全知道如何做到这一点，它们是有杠杆的。它们就像自动一样，具有这个属性。
- en: but I think in this case it's quite clearly how can we achieve it。 In the initial
    division it's a bit tricky because this is not just division。 this is in the deviation
    on the floor division。 So this is not such a common mathematical function。 based
    on the many rules that are popular。 But basically it's hand-rocks that are played
    for the idea of normal division and availability of division。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我认为在这种情况下，我们如何能实现这一点是相当明显的。在最初的划分中有点棘手，因为这不仅仅是简单的划分。这涉及到向下取整的偏差。因此，这不是一种常见的数学函数，基于许多流行的规则。但基本上，这是为正常划分和划分的可用性而玩的手摇石头。
- en: Perhaps the most obvious is a hand divided by two class and divided by two-ish
    in order。 We have an example， right？ One area by two， the one where the two-ish
    actually should。 So all these things will make a big difference in mind to make
    sure that the rules of the tabular and mathematical。 consistent with the runtime
    behavior of the California 5th and 5th。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 或许最明显的是手除以二类，按顺序除以二。我们有一个例子，对吧？一个区域除以二，那个实际上应该是二的地方。因此，所有这些事情在心中会有很大的不同，以确保表格和数学的规则与加利福尼亚第5和第5的运行时行为一致。
- en: So that's a overview of the rules of equality。 Here is a comment about some
    experience that I have taught myself in implementing the tabular and mental empire。
    So I was typing some part of the last night， this is a random working with 5。
    I'm going to go to the main challenges， the main content， what makes it hard to
    dive in。 The fact is that at some point I could type this part of the network
    where there is a long series of convolutional layers。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于等式规则的概述。这里是我在实施表格和心理帝国方面的一些经验评论。我昨晚打字的一部分，这与5有关。我将要讨论主要挑战，主要内容，是什么让人难以深入。事实上，在某个时刻，我可以输入网络的这一部分，其中有一系列长长的卷积层。
- en: And if you remember what the formula for convolution is quite sophisticated。
    so if you're just imagine doing this five times， one side of your folder。 the
    formula gets pretty complicated。 But the interesting thing here is that if you
    look at the return value of the function。 which is that the actual dimension of
    the dimension of the return value is really simple。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得卷积的公式相当复杂。那么如果你想象一下这样做五次，文件的一侧。公式变得相当复杂。但有趣的是，如果你查看函数的返回值，实际返回值的维度是非常简单的。
- en: And this is the figure of the equality and the material quality system。 It's
    coupled with realizing that it's quite making a lot of sequences of these complicated
    transformations。 A lot of things can get simplified and overall get simple， very
    simple。 So I think that's a way of solving the problem and the plans of quality
    techniques coupled with。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是等式和物质质量系统的图像。它与意识到进行这些复杂变换的序列密切相关。许多事情可以简化，整体变得简单，非常简单。因此，我认为这是解决问题的方法，以及与质量技术结合的计划。
- en: Finally， there's something I was custom operators。 Again。 this is like a growth
    category to put together many different ideas that would contribute to venture
    planning。 But clearly， one of the most part of all is broadcasting because so
    far we have claimed that we could support many operators in the support for parallatics。
    the variety， but the five is the emotional libraries。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我有一些自定义操作符。这又像是一个增长类别，将许多不同的想法结合在一起，为创业规划做出贡献。但显然，所有内容中最重要的部分是广播，因为到目前为止我们声称能够支持许多操作符，以支持并行处理，种类繁多，但五个是情感库。
- en: almost all operators have a variant for their broadcasting case。 Basically。
    the potential in that event， they will go to Scotland。 So。 to fully support all
    these libraries that we're broadcasting， we need to be able to express it。 The
    things that we're cutting up here seem all the key operators like at least on
    suppression。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有操作符都有其广播案例的变体。基本上，在那种情况下，他们将去苏格兰。因此，为了全面支持我们正在广播的所有这些库，我们需要能够表达它。我们在这里切割的内容似乎都是关键操作符，至少在压制方面。
- en: application， evaluation， comparison。 There are a lot of other places。 They don't
    have a broadcasting， but being able to express this is very important。 Fortunately。
    we're broadcasting a very standardized or a semantics。 The case should not be
    saving by a potential flow， so that's， I would think， nonetheless， again。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 应用、评估、比较。有很多其他地方。他们没有广播，但能够表达这一点是非常重要的。幸运的是，我们正在广播一个非常标准化或语义化的内容。这个案例不应该被潜在的流所保存，所以我会认为，尽管如此，再次如此。
- en: we're having broadcasting the challenge of making sure that the people and different
    broadcasting expressions。 we can verify that they're the same。 We don't realize
    that the broadcasting of the young people in the same area。 we don't have any
    problem。 Or， so， we stay with this man。 or we don't have multiple situations for
    doing so。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面临广播的挑战，确保人们和不同的广播表达式相同。我们没有意识到年轻人在同一领域的广播，我们没有任何问题。或者，所以，我们就和这个人呆在一起。或者我们没有多种情况来做到这一点。
- en: And our operators that we have talked about in the past， for example。 I mentioned
    many times the product。 You need to make the product of all the dimensions， for
    example。 for example， you want to have a save or pay the value of the tensor。
    you want to have plenty of this。 It's true that we will overload the lines and
    modifications。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们过去提到的操作符，例如。我多次提到产品。你需要对所有维度进行乘积，例如。例如，你想保存或支付张量的值。你想拥有很多这种值。确实，我们会过载行和修改。
- en: nonetheless， like this is not a good example， especially when you have multiple
    parameters and you can install it in a too many combinations。 And then a pattern
    that appears very open is when we are removing a dimension from a tensor。 when
    we are replacing a dimension from a tensor。 These operators were mentioned by
    a private。 not so long time ago， and I remember， you can send checks and there
    were like 40 or 50 or more different operators in factors that wouldn't mean these
    two extra dimension。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这并不是一个好的例子，尤其是在你有多个参数并且可以以太多组合安装时。然后，一个非常开放的模式是当我们从张量中移除一个维度时，当我们替换张量的一个维度时。这些操作符不久前由一位私人提到，我记得，你可以发送检查，那里有40或50个或更多不同的操作符，这些操作符并不意味着这两个额外的维度。
- en: So this is how common this pattern is， for example， in the pattern。 so I mean
    that this pattern is very common on the use。 You have a very interesting model
    in one dimension， so the tensor has one of the positions。 Or。 for example， when
    you are doing a task force by definition。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这个模式的普遍性，例如，在这个模式中。我是说这个模式在使用中非常普遍。你在一个维度上有一个非常有趣的模型，所以张量在其中一个位置。或者。例如，当你按定义进行任务组时。
- en: you are doing a motion to do the dimension， so you will be doing a task force。
    So。 how do you support for this？ Certainly， over the language。 And that's basically
    a summary of all the key elements for a tensor typing， I think。 against it's important
    to realize that the difference is forward， it has been 36 and 4。5。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在做维度的运动，因此你将会进行一个任务组。那么，你如何支持这一点呢？当然，跨越语言。这基本上是我认为张量类型的所有关键要素的总结。重要的是要意识到差异在于前进，它是36和4.5。
- en: So maybe there were lots of things on that， and also to be excited about what
    was going to be achieved for the month。 So， yes， that was a written from my side。
    Thank you very much for your attention。 And for the first Kelly Popper， to my
    discussion， I think in my one day we are going to be telling you。 and I'm going
    to take a look at where we came from here。 So， yes， thank you very much。 [Applause]。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，也许在这方面有很多事情，而且也对即将实现的目标感到兴奋。所以，是的，那是我这边写的。非常感谢你的关注。对于第一次Kelly Popper的讨论，我想在某一天我们会告诉你。我会看看我们从这里走过的路。所以，是的，非常感谢。[掌声]。
- en: '[Indistinct chatter]， [Indistinct chatter]， [Indistinct chatter]， [Indistinct
    chatter]。 So broadcasting means that you can add tensors that are not identically
    their dimensions。 but are aligned along with cross certain dimensions。 For example，
    you have one tensor of dimensions。 5， 1， and the other one of 1， 4。 So they''re
    not identically， so you might think they can''t add them。'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[听不清的喃喃声]，[听不清的喃喃声]，[听不清的喃喃声]，[听不清的喃喃声]。所以广播意味着你可以添加维度不完全相同的张量，但在某些维度上对齐。例如，你有一个维度为5，1的张量，另一个维度为1，4的张量。所以它们不完全相同，所以你可能认为它们不能相加。'
- en: but clearly， you might be able to add them and get a tensor of 5， 4， because
    it's like 5。 all the ones that are not basically， and sort of collapsing together。
    So that's still tied in from a shape point。 So we need that， because without that。
    we will be able to check。 So we need broadcasting to be able to support usual
    touch。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但显然，你可能能够添加它们并得到一个5，4的张量，因为它就像5。所有不基本的，某种程度上是结合在一起的。因此，从形状的角度来看，这仍然是相关的。所以我们需要这个，因为没有它。我们将能够检查。因此，我们需要广播来支持常规触控。
- en: a tensor of opportunity。 The key example is， if you take a matrix and add a
    steel。 it will just magically work， even though the steel is not in the matrix。
    [Indistinct chatter]。 Any other questions？ [Indistinct chatter]， [Indistinct chatter]。
    So I went to a audience that I mentioned that we have right now， and I'm like。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个机会的张量。关键示例是，如果你取一个矩阵并添加一个钢铁，它会神奇地工作，即使钢铁不在矩阵中。[模糊的聊天]。还有其他问题吗？[模糊的聊天]，[模糊的聊天]。所以我去到一个我提到的观众那里，我们现在有的，我就是这样。
- en: '"What operators do we need for each one？"， [Indistinct chatter]， [Indistinct
    chatter]。 [Indistinct chatter]， I didn''t understand one part of the slides where
    I think we did the E of Zero Prove。 to make this work。 But it sounds like you''re
    lifting the whole like context where it''s been into typing。 and typically from
    what I know from like the post-plus， I know the type of content。'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: “我们需要什么操作符？”[模糊的聊天]，[模糊的聊天]。[模糊的聊天]，我没有理解幻灯片中的一部分，我认为我们进行了零证明的E。为了使这有效。但是听起来你是在提升整个上下文，而这些内容是由打字产生的。根据我对后加法的了解，我知道内容的类型。
- en: '[Indistinct chatter]， [Indistinct chatter]， So the thing is for addition and
    multiplication。 you''re able to sort of get a canonical representation。 so that
    you don''t need to prove that these two types are equal。 But for division。 right
    now we sort of have a best effort and simplification。'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[模糊的聊天]，[模糊的聊天]，所以对于加法和乘法。你能够获得一种标准表示法。这样你就不需要证明这两种类型是相等的。但是对于除法。现在我们有一种尽力而为的简化。'
- en: And if you divide because it's integer division， and as I mentioned， n by 2
    plus n by 2。 they're not equal to n by 2。 So in that case， we do have equivalent
    expressions that the fact you're going to do not move。 So it's important。 So，
    so， so， so， yeah。 I would like to add that since the last year。 like I would probably
    be surprised by the power of Zimpy， I think Zimpy， right？
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进行整数除法，如我提到的，n除以2加上n除以2。它们并不等于n除以2。因此，在这种情况下，我们确实有等效表达式，事实上你将不移动。所以这很重要。所以，所以，所以，所以，是的。我想补充的是，自去年以来，我可能会对Zimpy的强大感到惊讶，我觉得是Zimpy，对吧？
- en: And they have some specific functions for doing pretty much the same， but in
    the conversation。 Quite a method， but we can change variables to whatever Zim，
    safer。 And we think that they do guarantee that your division acquires its equals。
    just so that it's going to be the best case。 So I think that's the recommendation
    for when on view this will be delivered and I like everything。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它们有一些特定的功能，几乎做同样的事情，但在对话中。相当的方法，但我们可以将变量更改为任何Zim，安全。我们认为他们确实保证你的除法获得其等价物。只是为了确保这是最好的情况。因此，我认为这是在查看时的建议，将会交付，我喜欢所有这些。
- en: '[Indistinct chatter]， [Indistinct chatter]， Yeah， yeah， thank you。 [Applause]，
    [Indistinct chatter]。'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[模糊的聊天]，[模糊的聊天]，是的，是的，谢谢。[掌声]，[模糊的聊天]。'
- en: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_3.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_3.png)'
- en: '[Indistinct chatter]。'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[模糊的聊天]。'
- en: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_5.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_5.png)'
- en: Thank you。 [Laughter]， My next journey。 Yeah， David already told us about all
    of your paths and back up big we did that。 There's actually a bunch more smaller
    features we're also getting and going to introduce those。 But the other least，
    perhaps， not going to talk about them。 Instead of you have this revealed type。
    never assert never assert type get overdose， change to final and any use of this
    class。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢。[笑声]，我的下一个旅程。是的，David已经告诉我们你们所有的路径，以及我们如何回顾。实际上还有更多更小的功能我们也在获取，并将介绍它们。但是至少，可能，不会谈论它们。相反，你有这个显式类型。永远不要断言永远不要断言类型获取过量，改为最终，并且任何使用此类的地方。
- en: You're starting to be revealed type。 So we started talking about this。 actually
    called revealed type was already implemented in that point for instance。 It wasn't
    because it was a night type， you always had it so you're still going to use it。
    So the benefit to typing people in the left hand， a expenditure I think that what
    you're on time includes that you can run your test suite at the same time as you're
    defining your types。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你开始变成显式类型。所以我们开始谈论这个。实际上称为显式类型，已经在那时实现。例如。不是因为它是夜间类型，你总是有它，所以你仍然会使用它。因此，给左手打字的好处，我认为你在时间上包括的就是你可以在定义类型的同时运行测试套件。
- en: And if you're using it in education， you can run your examples which reveals
    that in them and they actually work around them。 Now you've never， no return has
    been in the type system since pretty much the beginning。 But it doesn't have to
    be only used for functions that never return。 But every type checker they decide
    is we want to volunteer and you're going to use never for that。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在教育中使用它，你可以运行你的示例，显示出它们的实际效果。自始至终，类型系统中从未出现过返回值为“never”。但它并不仅限于从不返回的函数。每个类型检查器都决定我们希望志愿者使用“never”来处理这个。
- en: To make that clearer， people do not have your adding never as basically the
    equivalent of no return。 So you can make the type checkers treat them as the same
    in their internal representations。 That's in our message and we recommend to you
    how they never make your own people develop in the world you are。 Good afternoon，
    we end in a server never function。 This isn't actually a text system feature。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚，人们并没有将“never”添加为基本上等同于没有返回。因此，你可以让类型检查器在它们的内部表示中将它们视为相同。这在我们的信息中，我们建议你如何让人们在你所在的世界中发展。下午好，我们在一个服务器的never函数中结束。这实际上不是一个文本系统功能。
- en: you would even understand it's in user code just as easily。 But it's kind of
    hard to discover and a lot of people have to discover it in a memory。 So we're
    having it to type things and make it easy or not going to find out that it can
    use it。 So in this case， it's that you will do a server that some code is unmeachable
    and the text ever can prove that it's unmeachable。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至能轻松理解它在用户代码中。但发现它有点困难，很多人必须在记忆中发现它。因此，我们正在处理类型问题，让它更简单，或者不去发现它能被使用。在这种情况下，你会做一个服务器，有些代码是不可达的，文本永远可以证明它是不可达的。
- en: In this example， we know that you're only two bullions， so if not true or false。
    then it's obviously impossible。 And with this， a server never call。 the text ever
    will tell you if there's a third bullion， you expect it to return very much。 Then
    you'll update your code。 The next thing that is helpful for asserting that if
    you put type annotations in the text。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们知道你只有两个布尔值，所以如果不是true或false，那显然是不可能的。至此，一个服务器的never调用，文本永远会告诉你如果有第三个布尔值，你期望它返回非常多的值。然后你会更新你的代码。接下来有助于断言的是，如果你在文本中添加类型注解。
- en: it actually understands that the way you intended them。 In this simple case。
    it would end in the type of function annotations， so obviously the text will think
    that the text doesn't end。 In this case， it's of course trivial。 In this case。
    we discussed in text sets where we want to test that the stuff we provide actually
    resulting in the types that we think they're resulting in。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上理解你所期望的方式。在这个简单的情况下，它将在函数注解的类型中结束，因此显然文本会认为文本没有结束。在这种情况下，当然是微不足道的。在这种情况下，我们在文本集中讨论，我们希望测试我们提供的东西实际上是否导致我们认为的类型。
- en: Because sometimes we do pretty complicated things with overloads and generic
    self-types and protocols and what else？
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有时我们会用重载、泛型自类型和协议等进行相当复杂的操作，还有其他什么呢？
- en: We want to make sure that text actually understands what they're doing in a
    way that they intended it。 And actually， as of yet， go ahead。 So， is it null？
    It does nothing as rather than。 I think you just made this picture of doing literally
    nothing。 It's purely for checking that this static type is what you think it is。
    It returns the value。 Oh。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望确保文本实际上理解他们所做的事情，以他们意图的方式。实际上，到目前为止，可以继续。那么，它是null吗？它没有任何作用。我认为你只是展示了字面上什么也不做的图景。它纯粹是为了检查这个静态类型是否如你所想。它返回值。哦。
- en: yes， yes。 You've got to return the value so that you can put it in the next
    question and keep using it。 The specific things I think were the something that
    I had a link with some questions。 It's an exact type check。 It's possible if you
    have to think more about details。 One thing that I actually ran into recently
    was if you have two protocols that have the same methods。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，是的。你必须返回值，以便你可以将其放入下一个问题并继续使用它。我认为具体的事情是我与某些问题有联系的东西。这是一个精确的类型检查。如果你必须更仔细地考虑细节，那是可能的。我最近遇到的一件事是，如果你有两个具有相同方法的协议。
- en: should that's a sort of type thing， the other thing。 And the way you can get
    the night height。 it doesn't think that same thing， but any issue。 What is a reveal
    type of a current time？
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 应该这是某种类型的东西，另一件事。你可以得到的高度。它并不认为是同一回事，但有任何问题。当前时间的揭示类型是什么？
- en: Is it printed out or do you sign any？ It prints the type of the value。 Can't
    return to the value also。 Yes， it also returns to the value。 Yeah。 that's one
    of the things we found out about the time it energizes， it's definitely， implemented。
    but all that really influences it， exactly to say。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 是打印出来还是需要你签名？它打印出值的类型。也不能返回值。是的，它也会返回值。对，这就是我们发现的，它在能量激发的时间上，确实实现了。但所有这些真的影响了它，确切地说。
- en: The returning value thing is what night height is。 Before people stand。 you
    can just put a reveal type anywhere in the expression and it might。 tell you what
    type is at that particular point。 So that's the temporary type of standard action。
    I think that's to change the information that I've got to do。 At the best of playing
    levels。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值的事情是晚上高度的。在人们站立之前。你可以在表达式的任何地方放一个揭示类型，它可能会告诉你在那个特定时刻是什么类型。所以那是临时的标准行动类型。我认为那是要改变我所获得的信息。在最佳游戏水平下。
- en: I think that code is going to show me enormously confused new users。 You see
    that and they assume that they're going to hard check it around time。 It's possible，
    yes。 he wins over a lot of possible names for this function and also the。 type
    of development was better than the serf type。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为那段代码会让全新的用户非常困惑。你看到这个，他们以为他们要在时间上进行严格检查。这是可能的，是的。他赢得了许多可能的函数名称，还有开发类型比仆人类型更好。
- en: The type of the clarity in the documentation wanted does。 If you have suggestions
    for how to make it even more clear， we can still change the information。 One final
    trick， go ahead and set it down like that。 The other one time is set， but it's
    not。 That's true。 That's a good thing。 Yeah， it's possible。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 文档中所需的清晰类型。如果你有如何使其更加清晰的建议，我们仍然可以更改信息。最后一个技巧，继续像那样设定。另一个时间设置了，但不是。确实如此。这是件好事。是的，这是可能的。
- en: I guess I didn't want anything to do while I'm here。 That's a shock type。 Check
    text can be something more likely than you're going to say。 I think we've been
    talking about any of these and the couldn't come up with any of these。 I guess
    the last thing I want to see is we are already using this intention right now。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我不想在这里做任何事情。那是一种冲击类型。检查文本可能会比你要说的更可能。我认为我们一直在谈论这些，无法提出任何这些。我想我最后想看到的是我们现在已经在使用这个意图。
- en: We have a lot of good evidence for our parents。 Last week I think。 And night
    time。 we just released supports and we're going to have night time。 A serf type
    check is a type check。 Also very soon， if the parent people want the parent to
    do the same thing， please consider that。 I think one thing that's worth saying
    about the name is just， we use cases for this。 Most people。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多好的证据供我们的父母参考。上周我认为。还有晚上。我们刚刚发布了支持，我们将有晚上。一个仆人类型检查就是类型检查。如果父母们希望父母做同样的事情，请考虑一下。我认为关于名称有一件值得说的事，就是我们使用案例来说明这一点。大多数人。
- en: influencers and type checkers are a very complicated type library。 So it's not
    a kind of thing。 It's likely to show up and go to the end of the scene。 Yeah。
    I guess the name is you see it in either the type of no connection。 You see it
    and you don't know it's important。 That's your hand。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 影响者和类型检查器是一个非常复杂的类型库。所以这不是一种事情。它很可能会出现在场景的尽头。是的。我想这个名字是你在没有连接的类型中看到的。你看到它，但不知道它重要。这就是你的手。
- en: and most people want to see it very much。 Yeah。 This is a feature of Python
    right now。 Are you talking about something？ Yeah， so it's in typing a player。
    It's in typing extensions。 Obviously the right hand goes， I guess it just returns
    the value。 The interesting implementation is in type checkers。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人非常想看到这个。是的。这是Python现在的一个特性。你在谈论什么吗？是的，所以它在输入玩家中。它在输入扩展中。显然，右手去，我想它只是返回值。有趣的实现是在类型检查器中。
- en: And night time and time and support is a type type of game。 Support is on the
    list。 So the right。 Yeah。 We need to put a type of extension。 A serf type。 I think
    we need to just like daily if there's something in typing。 Okay。 Yeah。 Alright。
    That's a serf type。 Another type of work questions。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 晚上的时间和支持是一种类型的游戏。支持在列表上。所以对了。是的。我们需要放一个扩展类型。一个仆人类型。我认为我们需要像日常一样，如果有输入的内容。好的。是的。好的。那是一个仆人类型。另一个工作问题。
- en: Then the next thing we have is a support for run time use of typing。 The way
    F overload， you see。 was implemented， it would just completely throw away the
    overloads after the actual function is defined。 So in this example， before pick
    with the anthem， the overload is for a function for half。 You've just never even
    got the guess because it's lost in one of the namespace。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们有的是对运行时使用类型的支持。重载的方式，你看。被实现时，它会在实际函数定义后完全抛弃重载。因此在这个例子中，在与圣歌一起选择之前，重载是针对一个函数的一半。你根本就没有猜到，因为它在一个命名空间中丢失了。
- en: There's no more evidence to this。 This means that it's possible for step type
    checkers that look at their gun time types to ever time and over and over again。
    So we added something that's got visitors to overdose in basically the dictionary
    in the typing mode you had run time。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对此没有更多的证据。这意味着对于查看其运行时间类型的步骤类型检查器而言，可能会一次又一次地执行。因此，我们添加了一些访客基本上是在运行时的字典中对过量进行的。
- en: So that you can then hold a get over those functions to retrieve the overdose
    again and see what they are。 I just wanted to add this because in the type checker
    I work only， I need this to get overdose。 Another use case is that in health outwards
    as what I've done with the mutation。 we will now be able to show overdose because
    again they are completely successful around them。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你就可以持有并获取那些功能，以再次检索过量并查看它们是什么。我只是想添加这一点，因为在我工作的类型检查器中，我需要这个来获取过量。另一个用例是，在健康外部，我与突变所做的。我们现在能够显示过量，因为它们完全成功地围绕着它们。
- en: And so you can even find them。 How does that work at one time visits？
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你甚至可以找到它们。那在一次访问中是怎么工作的？
- en: Is the decorative fashion some secret names somewhere？ That's just a dictionary
    in typing that's。 I think they may be doing this for module to function name to
    the list of overdose。 The depth of this is that the social system memory usage
    because the distance you have and the echo of the bed for the little bit slower
    than the ground time because it has to do little bit more work。 Similarly for
    final， also it was impossible for a ground time checker to support not self-testing
    final class because final district or classroom chase。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰风格是某个秘密名称吗？这只是在类型中的一个字典。我认为他们可能会为模块到函数名称做这个，以列出过量。其深度在于社会系统的内存使用，因为你拥有的距离和床的回声对于基础时间来说稍微慢一点，因为它必须做更多的工作。同样对于最终类，基础时间检查器也不可能支持非自我测试的最终类，因为最终地区或课堂追逐。
- en: there's no way to know that this class was decorated as final。 So now we have
    this number of final attributes on the different class or methods。 I think this
    now means that all type of graders are in respect for the ground time if you need
    them。 So lastly here's a condition from Shenzil， but you're getting in a stop
    support of self-classing any for cases where you have something that you can face
    do anything with but also want some custom behavior。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 没有办法知道这个类被标记为最终类。所以现在我们在不同的类或方法上有了一些最终属性。我认为这现在意味着所有类型的检查器在需要它们时对基础时间都是尊重的。所以最后这是来自Shenzil的一个条件，但你在停止自类支持的情况下，如果你有一些东西可以面临任何事情，但也想要一些自定义行为。
- en: When most common example is more objects which you can use it past anywhere
    but they also have some methods that are just kind of unboxed。 So there's a people
    who do nothing which will also be on the ground time。 Yeah。 and so take this one，
    this includes that， there's still room for improvements。 There's more things you
    can have at。 If there's new ideas that you think are useful。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的例子是可以在任何地方使用的多个对象，但它们也有一些方法是未解包的。因此，有人什么都不做，这也将在基础时间上。是的。所以以这个为例，这包括了这一点，仍然有改进的空间。还有更多的东西可以拥有。如果有新的想法你认为是有用的。
- en: then consider them for Q412 or if we are really ambitious for Q413 or if we
    do that one for Q3。 And actually， today you've spread that complex。 So if you
    have some idea of compactly and then you can get it in time and still。 Yeah， so
    maybe you can then people develop it in better if there's more new ideas。 And
    last。 as I mentioned， the bonus slide。 This is something that's starting to stretch
    out which is very active for developer。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 那么考虑将它们用于Q412，或者如果我们真的有雄心，可以用于Q413，或者如果我们为Q3做那个。实际上，今天你已经传播了那个复杂性。因此，如果你对紧凑性有一些想法，然后你可以及时获取它，仍然是的。所以也许你可以让人们更好地发展它，如果有更多的新想法。最后。正如我提到的，奖金幻灯片。这是开始扩展的东西，对于开发者来说非常活跃。
- en: there's the R4 today。 Currently， every on time， it's impossible to make a generic
    name to book just because someone calls thanks to new implementation。 Even though
    to be a basic， it seems pretty natural。 I think as an example， he has an A2 poll。
    while he'll do his hits， all he'll do is defend him with a generic。 So I think
    it applies to allowing his keyword to learn him versus PR and make his support
    the ground time。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的R4。当前，每次准时，它都不可能因为某人的称呼而制定一个通用名称来预定，只是因为新实施。尽管这很基础，但看起来相当自然。我认为作为一个例子，他有一个A2投票。虽然他会做他的成功，但他所做的只是用一个通用来保护自己。因此，我认为这适用于允许他的关键字学习他与公关的区别，并使他的支持在基础时间上。
- en: My only hesitation is that maybe there's some reason in the static type system
    that this opens a giant hole and there's some reason not to do it。 Please let
    me know and begin。 We must get out。 Would it work like you might buy items box？
    No。 My guys actually， the main reason I think it doesn't work。 Yeah。 I think that
    my guys internal people support this doesn't go generic at all。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我唯一的犹豫是，也许在静态类型系统中，有一些原因会打开一个巨大的漏洞，并且有某种原因不这样做。请告诉我并开始。我们必须出去。它会像你可能买的物品盒那样工作吗？不。我的团队实际上，主要原因我认为它不工作。是的。我认为我的内部团队支持这根本不通用。
- en: So generic names of both are not trying to work unless not my changes significantly。
    I think that shouldn't stop us。 I think it seems like a natural way to extend
    the tax system。 I don't support it， but you don't have to wait for them to do
    that。 There's nothing he uses for long time things like a fight。 Maybe。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所以两个通用名称都不是在尝试工作，除非我的更改显著。我认为这不应该阻止我们。我认为这似乎是扩展税收系统的自然方式。我不支持它，但你不必等他们去做。没有什么东西可以像打斗那样用很长时间的东西。也许。
- en: maybe you use a new generic signature。 We have generic version of models。 Yeah。
    it's handy because I know I'm done， but I think people seem to use it。 I don't
    understand。 But especially your classes are just classes and opening to both。
    So that's not going to work anymore。 It doesn't need to be a sentence。 So you
    know， like。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你使用一个新的通用签名。我们有模型的通用版本。是的。这很方便，因为我知道我完成了，但我认为人们似乎在使用它。我不明白。但特别是你的类只是类，并且对双方开放。因此，这将不再有效。它不需要是一个句子。所以你知道，像这样。
- en: with the generic or the many variables， like the full game， but you like X，
    Y， Y， and X， Y。 I think so。 Yeah， I guess， if you're over this morning。 I think
    we did the best of just adding this slide。 That's a good recommendation。 But I
    think it should just be generic。 You can make a generic or type practical code
    read if you want to。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过通用或许多变量，就像完整的游戏，但你喜欢X、Y、Y和X、Y。我认为是这样。是的，我想，如果你早上超过这个。我认为我们做得最好只是添加这个幻灯片。这是一个不错的建议。但我认为它应该只是通用的。如果你愿意，你可以制作通用或类型实用代码读取。
- en: One thing I was concerned about is the variance。 Should it be automatically
    coherent because two goes out。 What happens if it is contra variant？ Yeah， I guess
    that's something for type。 It's probably something that the random doesn't need
    to care about。 I guess the pills can be both areas。 You can also have methods
    for a random type of difference。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我关心的一件事是方差。它是否应该自动连贯，因为两个出去。如果是对立方差，会发生什么？是的，我想那是类型的问题。可能是随机的东西不需要关心。我想药丸可以是两个区域。你也可以有随机类型差异的方法。
- en: If you have a method argument that's generic， you could probably want to use
    the quantum variance on a variable。 That's a good error。 Also， what types of text
    you have to protect it？
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个通用的方法参数，你可能想在一个变量上使用量子方差。这是一个不错的错误。另外，你必须保护它的文本类型是什么？
- en: I know the type of code can't be generic right now。 Yeah。 it actually is better
    to do thinking for type things。 I think that's something sitting near you a little
    bit about type things。 I guess the quick thing about grand time， it doesn't work。
    You have to ask support for that。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道代码的类型现在不能是通用的。是的。实际上，思考类型的事情更好。我认为这是关于类型的事情坐在你旁边。我想关于基础时间的快速事情，它不工作。你必须请求对此的支持。
- en: And I think there's mostly work on sort of supporting you in the text system。
    That's any day that you have anything to ask。 Yeah。 this is one of the four things
    that I'm looking at。 And I'm sure it's generic type of this。 So you've instantiated
    that this has a D square root of the intercept。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为大多数工作都是为了支持你在文本系统中。任何一天你有任何问题。是的。这是我正在关注的四件事情之一。我相信这是通用类型的。所以你已经实例化了这个有D平方根的截距。
- en: I guess that's not the type check。 Do we incur from the assets type check？ If
    you do NCE12。 the type check would incur that。 I think it should just work like
    any generic class。 I will say it's currently used to be some surprise that it
    didn't work。 Yeah。 it just did something else because it wasn't essential。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我想这不是类型检查。我们是否从资产类型检查中产生？如果你做NCE12。类型检查会产生那样的影响。我认为它应该像任何通用类一样工作。我会说目前被使用的某些惊讶之处在于它并不工作。是的。它只是做了别的事情，因为这并不重要。
- en: but it was surprising that you couldn't get it。 Yeah， I feel the same way。 Like
    it feels like it should work， but it doesn't。 Yeah。 Yeah， it's also like。 my title
    is called "Can I？ No more people's like not many people's。 can I have people's
    answer both but my type？"， Yeah。 Yes， I think。 Yeah。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但令人惊讶的是你无法获得它。是的，我有同样的感觉。感觉应该有效，但它没有。是的。是的，这也像。我标题叫“我可以吗？没有更多人像不是很多人。可以让我有两者的答案，但我的类型？”是的。是的，我认为。是的。
- en: I think there's just an artifact with the baby's picture that represents the
    night type。 the path for generic and path for tuple just don't affect the market
    each other。 Do you see that my five doesn't support generic tuples？ Yeah。 Yeah，
    so much better than that。 Yeah。 so much better than that。 Okay。 Yeah， we're good。
    We're the final one。 So。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这只是与婴儿的照片相关的一个伪影，代表夜类型。通用路径和元组路径互不影响。你看到我的五不支持通用元组吗？是的。是的，远比那要好。是的。远比那要好。好吧。是的，我们很好。我们是最后一个。所以。
- en: we have to talk about runtime usage。 Like， if you mark class as final。 you try
    to get a carrot from it and then go out your code。 And then you can do it。 I think
    it's maybe it should be a different decorator because final as an existing now
    already means like it's established that it doesn't get necessarily checked around。
    So， you're not the people depending on that thing that they're doing。 That's the
    group's ask。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须谈谈运行时使用情况。比如，如果你将类标记为final。你试图从中获取一个结果，然后退出你的代码。然后你可以做到这一点。我认为这可能应该是一个不同的装饰器，因为final作为现有的现在已经意味着它不一定会被检查。所以，你不是依赖于他们正在做的事情的人。这是小组的要求。
- en: If it was to be group has a decorator in some of our depth actually makes it
    fast。 not self-classical。 You could have it as non-， Yeah。 I guess the interesting
    thing is that the group's even have that。 Personally。 I don't feel like a very
    strong means， but that's the group I'm doing。 Yeah。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一个小组有一个装饰器在我们某些深度上实际上让它变得快速。不自我经典。你可以把它作为非-，是的。我想有趣的是小组甚至有这个。就个人而言。我觉得这不是一个非常强的手段，但这就是我正在做的小组。是的。
- en: it's also not for methods。 I just put a class on the example that's basically
    the very final work that I've done。 Is it tries to step advantage of use in fields，
    in terms of error。 any district there's whatever it comes to。 Okay。 I have a question
    about get overloads。 If it sees a function that is a single dispatch function。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这也不适用于方法。我只是把一个类放在例子中，这基本上是我所做的最后工作。它试图利用字段中的使用优势，就错误而言。任何领域都有，无论它是什么。好吧。我对获取重载有一个问题。如果它看到一个单一调度的函数。
- en: we would be able to read that registry overloads， because I don't even get the
    ones that are。 It's only over notes。 The action is， including this， I mean。 it
    ties into generalize a single dispatch， but we decided it's too different。 If
    that's just to keep it too different， I'm not。 I'm not。 I'm not。 I'm not。 I'm
    not。 I'm not。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够读取那个注册重载，因为我甚至没有得到那些。它只是关于笔记。这项行动是，包括这个，我的意思是。它与单一调度的概括相关，但我们决定它太不同。如果只是让它太不同，我不是。我不是。我不是。我不是。我不是。我不是。
- en: I'm not。 I'm not。 Okay。 The last thing I want to talk about is the intubl system。
    Also。 here I'm from Turkey that makes it possible to inherit anything and make
    a name to both。 I actually like to not do that。 I feel like it would make it too
    far as to reason why it's not made to most not textures。 It's going to make an
    inherit from arbitrary non-name to both classes because name to both are many
    different things。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我不是。我不是。好吧。我想谈的最后一件事是intubl系统。此外。我来自土耳其，这使得继承任何东西并同时命名成为可能。其实我喜欢不这样做。我觉得这样会使理由变得过于复杂，为什么大多数非纹理的东西并未被制作。它将从任意非名称继承到两个类，因为名称对两个来说是很多不同的东西。
- en: That would also be happen to hear more of anything to that。 I have a question
    about the actual workloads。 You said it's like an acting of non-stroke functioning
    to both worlds。 Yeah。 What happens if you have a workloads？ Not that I've ever
    used this。 I'm just curious。 You mean the kind of overloads inside the function？
    Yeah。 Yeah， they would get over again。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这也会听到更多与此相关的事情。我有一个关于实际工作负载的问题。你说这像是非主动功能在两个世界之间的表现。是的。如果你有工作负载，会发生什么？不是说我曾经用过这个。我只是好奇。你是指函数内部的那种重载吗？是的。是的，它们会再次重叠。
- en: So every time you do it， I guess it will pay new overloads and put them in the
    same place。 Actually。 this was something we thought about a lot of。 I think this
    was a concern that you keep doing this。 You just get a lot of them。 We're used
    to do it every time you do it， you get more overloads。 So the result is actually
    that the line number of the overloads part of the key。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 所以每次你这样做，我想这会支付新的重载并将它们放在同一个地方。实际上。这是我们考虑了很多的事情。我认为这是一个关注点，你不断这样做。你只会得到很多。我们习惯于每次这样做，你会得到更多重载。因此，结果实际上是重载的行号是关键的一部分。
- en: So if you define a new overload， the same line number， it gets over again。 This
    kind of has slightly unexpected effects。 It generates domestic functions。 We didn't
    think it was a good outcome。 So I'm guessing that's your thing of looking for
    it。 I was actually thinking of like the two functions that both define the same，
    but it's the same name。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你定义一个新的重载，行号相同，它会再次重叠。这种情况有些意外的效果。它会生成内部函数。我们觉得这不是一个好的结果。所以我猜这就是你要寻找的东西。我其实是在考虑像这两个函数，虽然定义相同，但名字是相同的。
- en: But if the line number is part of it， then I guess that's all of that。 Yeah。
    I guess if this came in the name of the same load， you know。 I forgot what exactly
    makes the key speed。 That's a nice component。 I have a good idea。 Is there more
    questions？ I can answer them。 If there's no more time。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果行号是其中的一部分，那么我想这就是所有内容。是的。我想如果这在同一个负载的名字下，你知道。我忘了具体是什么让关键速度。那是一个不错的组成部分。我有一个好主意。还有更多问题吗？我可以回答。如果没有更多时间。
- en: then we can move on to the next question。 Yeah。 Also， in reverse， I mean。 if
    you're looking at it like there's been many times where I wanted。 not necessarily
    a name to people， but just a immutable， no more other play structure essentially。
    Did it last quite a year？ Yeah。 But then you have， well， I mean， it's all data
    class。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以继续下一个问题。是的。还有，从反面来看，我是说。如果你考虑到，有很多次我想过。不一定是给人的名字，而是一个不可变的、基本上没有其他结构的东西。这持续了一年吗？是的。但是你有，嗯，我是说，这都是数据类。
- en: It's doing runtime stuff。 I don't know。 I know for many people， it's internal。
    and I don't care that it's any people。 Yeah。 I guess that's kind of a style question。
    I think we don't want to add too much more than any more things to the name to
    people because。 data class is generally a better solution。 It doesn't make you
    better than you do it too。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在做运行时的事情。我不知道。我知道对很多人来说，这很内部。我不在乎有任何人。是的。我想这算是一个风格问题。我认为我们不想再给人们的名字添加太多东西，因为。数据类通常是一个更好的解决方案。这并没有让你比做得更好。
- en: And that you iterate well， and it is usually not what you want。 Yeah。 So， you
    can't just do it。 I think it's a good thing。 I think it's a good thing。 I think
    it's a good thing。 I think it's a good thing。 I think it's a good thing。 I think
    it's a good thing。 I think it's a good thing。 [ Silence ]。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 而且你迭代得很好，这通常不是你想要的。是的。所以，你不能只是这样做。我认为这是一件好事。我认为这是一件好事。我认为这是一件好事。我认为这是一件好事。我认为这是一件好事。我认为这是一件好事。我认为这是一件好事。[沉默]。
- en: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_7.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_7.png)'
- en: Hi everyone。 This is Bia Helen Mann。 My name is Rebecca。 I work at Google on
    the type type checker。 Today I am not talking about type type ruins。 It talks
    about the classical extension to PEP 647。 which is the user defined type guards。
    These sides were made in collaboration with their child who was the author of
    PEP 647。 He was not able to make it to Python， but he was a huge help in putting
    together this presentation。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 嗨，大家好。这是Bia Helen Mann。我叫Rebecca。我在谷歌工作，负责类型检查器。今天我不谈类型破坏。它讨论的是对PEP 647的经典扩展。这些内容是与其孩子合作完成的，他是PEP
    647的作者。他没能来到Python，但在制作这个演示文稿方面给予了很大帮助。
- en: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_9.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_9.png)'
- en: So， we start with a brief refresher on PEP 647。 We want some criticisms of the
    PEP。 We look at extension proposals to cover these criticisms。 and then we should
    have some time for discussion at the end。 So， first off， what is a type guard？
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '所以，我们先简单回顾一下PEP 647。我们希望对该PEP提出一些批评。我们查看扩展提案以涵盖这些批评，然后我们应该有时间进行讨论。所以，首先，什么是类型保护器？ '
- en: It's an expression used to make conditional to narrow the type of another expression。
    So。 if we look at this example， VAL is not none。 It's a type guard that narrows
    the type of VAL。 In the positive case， when the type guard returns true。 VAL is
    narrowed to the non-non-type function。 And in the negative case。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '这是一个用于使条件表达式缩小另一个表达式类型的表达式。所以，如果我们看这个例子，VAL不是无。它是一个类型保护器，缩小VAL的类型。在积极情况下，当类型保护器返回true时，VAL的类型缩小为非非类型函数。而在消极情况下。 '
- en: the type is narrowed to none。 So， what PEP 647 does is that it allows users
    to define their own type guards。 So， this case is stir list。 It is a type guard。
    In the positive case。 it narrows the type of its input to list of stirs。 And in
    the negative case。 it leads to type of changed。 So， for some background on this
    PEP。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '类型被缩小为无。所以，PEP 647所做的是允许用户定义自己的类型保护器。因此，这种情况是阶梯列表。它是一个类型保护器。在积极情况下，它将输入的类型缩小为阶梯列表。而在消极情况下，它会导致类型发生变化。所以，关于这个PEP的一些背景知识。 '
- en: it was inspired by a type guard in a type script。 Eric， top of the type script
    team。 a bit about what would they have done differently if they could go back
    in time。 And based on those conversations， he made type guard and type guard as
    flexible as possible。 There are no restrictions on the type guard type。 So。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '它的灵感来源于类型脚本中的类型保护器。埃里克，类型脚本团队的负责人，谈到了如果他们能回到过去会有什么不同的做法。根据这些对话，他使类型保护器尽可能灵活。类型保护器类型没有限制。所以。 '
- en: that's why examples and previous work are narrow list of the project to list
    of stirs。 even though there's no sub-type evaluation to bear。 So， this。 what's
    known as lead to some trade-offs， which is what I want to talk about next。 to
    motivate this and start with an example。 So， number time is a popular and numerical
    computed library。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '这就是为什么示例和以前的工作是项目的狭窄列表，而不是阶梯列表。即使没有子类型评估。因此，这就是所谓的带来一些权衡，我想接下来谈谈这个，以激励这一点并从一个例子开始。所以，数字时间是一个流行的数值计算库。 '
- en: It has this function called is scalar， which approximately speaking， what it
    does is。 it takes no value。 That can be of any type。 And it will return true if
    the type is string or supports float。 So， if you pass is scalar， the value that
    is either supports float or a non-high endearay。 then with is scalar that is true，
    you know that supports float。 Otherwise。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '它有一个名为is scalar的函数，简单来说，它的作用是接收任何类型的值。如果类型是字符串或支持浮点数，则返回true。所以，如果你传递is scalar，值是支持浮点数或非高可爱的数组，那么使用is
    scalar返回true，你就知道它支持浮点数。否则。 '
- en: you know it's an endearay。 So， this is pretty honestly a type guard in the pool
    of goal sense。 But if we annotate is scalar using pep 6。7 type guards， you'll
    see that a type checker。 would actually infer the wrong types。 Do you remember
    we wanted a supports float in the positive case。 an endearay in the negative，
    case， and we would get these both wrong。 So， why is that？ So。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '你知道这是一个可爱的数组。所以，这在目标语境中，老实说，这是一个类型保护器。但如果我们使用PEP 6.7类型保护器来注释标量，你会看到类型检查器实际上会推断出错误的类型。你还记得我们在积极情况下希望支持浮点数，在消极情况下希望支持可爱的数组吗？我们会都弄错。所以，为什么会这样呢？ '
- en: in the negative case， the problem is that type guard does not do any type narrowing。
    So。 we are able to get rid of that supports float。 And in the positive case。 the
    problem is that the type guard type is actually the union。 that contains this
    stir element that we should be able to tell is impossible based on the。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在消极情况下，问题是类型保护器并不进行任何类型缩小。所以，我们能够摆脱那个支持浮点数。而在积极情况下，问题是类型保护器的类型实际上是联合体，包含这个阶梯元素，我们应该能够根据这些元素判断这是不可能的。
- en: input type。 But type guard does not do this， you know。 like elimination of impossible
    union elements。 So， quick question。 why does these type guards do these operations
    to refine the type？
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '输入类型。但类型保护器并不这样做，你知道的。就像消除不可能的联合元素。所以，快速问题。为什么这些类型保护器进行这些操作以细化类型？ '
- en: And the answer to that is that they're not always thick because a type guard
    can do checks。 that aren't included in the type information。 So， if you have a
    type guard that checks whether something is a list of single character strings。
    when the type guard evaluates to false， the input can still be a list of stir。
    You can't actually eliminate that type。 And type guard， especially。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题的答案是，它们并不总是复杂，因为类型保护可以执行在类型信息中未包含的检查。因此，如果你有一个类型保护，检查某个东西是否是单字符字符串的列表，当类型保护评估为假时，输入仍然可以是字符串的列表。你实际上无法消除该类型。尤其是类型保护。
- en: there's no guarantee about the relationship between the type guard， and the
    input type。 so it's even more unsafe to try to do these sorts of operations。 So。
    even though these operations are unsafe， we saw that there's an obvious use case
    for them。 So。 the next thing I'm going to talk about is a few proposals made to
    extend type guard。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 没有关于类型保护与输入类型之间关系的保证。因此，尝试进行这些操作会更不安全。尽管这些操作不安全，我们仍然看到了它们明显的用例。因此，接下来我将讨论一些扩展类型保护的提议。
- en: to do these things。 And we'll cover the proposals basically in chronological
    order。 We're going to show a couple of the earlier ones that we're determined
    to not really be sufficient。 and hopefully that will show why the final proposal
    is what it is。 Sort of the first and most obvious proposal was to add a two-argument
    form of type guard。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要做这些事情。我们将按照时间顺序基本上涵盖这些提议。我们将展示几个较早的提议，确定它们实际上并不足够，希望这能说明最终提议为何如此。第一个也是最明显的提议是添加一种具有两个参数的类型保护形式。
- en: In this case， the first argument was best by the type of narrative in the positive
    case。 and the second argument， the type of narrative in the negative case。 And
    one sort of nice thing about this proposal is that it would actually give a way
    to express type asserts。 which are functions that raise an exception if the type
    isn't -- sorry。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，第一个参数在正例中由叙述的类型提供，而第二个参数在负例中由叙述的类型提供。这个提议有一个不错的地方是，它实际上会提供一种表达类型断言的方法，这些函数在类型不匹配时会引发异常——抱歉。
- en: if its input isn't of a specified type。 You just put no return as the type in
    the negative case to show that it raises an exception。 But as the appealing as
    this proposal looks， it has a couple of disadvantages that were considered to
    be deal-breakers。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它的输入不是指定类型，你只需在负例中将返回类型设置为无，以表明它引发了一个异常。但尽管这个提议看起来很吸引人，但它有几个被认为是决定性障碍的缺点。
- en: So， the first one is that it doesn't address that issue of not eliminating impossible
    union elements in the positive case。 And that's just because that was a requirement
    that came up somewhat later in the discussion。 And another problem is that for
    this to be useful， you really want to be able to say some type。 but the type of
    the negative case is anything but the type of the positive case。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它并没有解决在正例中不消除不可能的联合元素的问题。这只是因为这是在讨论中稍晚出现的一个要求。另一个问题是，为了使这项提议有用，你真的希望能够指定某种类型。但是负例的类型与正例的类型截然不同。
- en: And this proposal does not give a way to express that。 There's a last sort of
    minor thing。 which is that it would also be a usual definition for type guard。
    different from other generic types， although that's not as big a video。 So that
    brings us to the second proposal， which is just to modify the semantics of the
    existing type guard type。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 而这个提议并没有提供表达这一点的方法。还有一个较小的事情，就是它也将成为类型保护的常规定义，与其他通用类型不同，尽管这并不是一个重大问题。这使我们进入第二个提议，即修改现有类型保护类型的语义。
- en: So， say if you pass in a union type to a type guard。 and the type guard type
    is on the type in the union。 then just go ahead and apply type-nanorite in the
    negative case。 This seems like a pretty straightforward change。 Again， there are
    a few disadvantages。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你将联合类型传递给类型保护，而类型保护类型在联合类型中，那么就可以在负例中应用类型保护。这似乎是一个相当直接的改变。不过，还有一些缺点。
- en: It doesn't address that issue of impossible union elements in the positive case。
    And also。 this would change existing behavior in an unsafe way。 It could have
    music code that's already using type guard。 make this change in something during
    the wrong thing。 And the last thing， sir。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 它并没有解决在正例中无法消除不可能的联合元素的问题。此外，这将以不安全的方式改变现有的行为。它可能会影响已经使用类型保护的代码，在错误的情况下做出这种改变。最后一点，先生。
- en: is that you start adding all these rules for what type-nanorine does， and it
    doesn't occur。 starts to get pretty complicated。 So that brings us to the last
    proposal。 which is to forget about modifying the existing type guard construct。
    And instead。 adding a construct called strict type guard， that does all these
    things that we wanted for a instigator。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 是你开始添加所有这些规则来定义什么是类型收敛，而它并没有发生。事情开始变得相当复杂。所以这把我们带到了最后的提议。那就是忘记修改现有的类型保护构造。而是，添加一个叫做严格类型保护的构造，它可以完成我们希望为引发者做的所有事情。
- en: By type-nanoring in the negative case， eliminate impossible union elements in
    the positive case。 In order to make these operations a little safer， strict type
    guard would also enforce that the type guard type is a subtype of the input type。
    So， this would be a complete solution， also pretty complex。 And the strict type
    guard is already prototyped。 In Hyride today， you can try it out if you want。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在负面情况下进行类型收敛，消除在正面情况下不可能的联合元素。为了使这些操作更安全，严格类型保护还会强制要求类型保护的类型是输入类型的子类型。因此，这将是一个完整的解决方案，也相当复杂。而严格类型保护已经被原型化。在今天的Hyride中，如果你愿意，可以试用。
- en: But what Eric told me is that he hasn't gotten much feedback on strict type
    guard， good or bad。 So the question at this point is， is there much interest or
    appetite in this， like。 it has to do with the type-4？ No。 And that's about all
    I have。 So。 let me give you all a hug on this。 [applause]， Yes。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 但是埃里克告诉我，他对严格类型保护没有得到太多反馈，无论是好还是坏。因此，此时的问题是，是否对此有足够的兴趣或渴望，比如说。这和类型4有关吗？不。这就是我所掌握的一切。所以，让我给大家一个拥抱。
    [掌声]，是的。
- en: Is there a threat specifically around strict type guard and either a typing-c
    or another location？
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 严格类型保护是否存在特定的威胁，涉及到类型c或其他位置？
- en: Are there a step or I did not think to link them in this slide？
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有一个步骤，或者我没有考虑在这个幻灯片中将它们链接起来？
- en: I did not know that there was a question that there was a meeting to be considered
    as a no-thing。 So， yes， I believe Simon's support is a problem。 So， last moment，
    I was in the institute。 and I was very proud of him。 For the strict type guard
    to make your union。 we got to make how it works with hence on。 Yeah， for example，
    in a strict type guard。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道是否有一个会议需要被视为无关紧要。所以，是的，我相信西蒙的支持是一个问题。因此，在最后一刻，我在研究所。我为他感到非常自豪。为了让严格类型保护与你的联合配合。我们必须弄清楚它如何运作。是的，比如说，在严格类型保护中。
- en: if the input types in union can be used special narrowing。 wouldn't that mean
    that's the way you think works with hence or whether the type-checker happens
    to incur a union in their case？
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果联合中的输入类型可以使用特殊收敛。这是否意味着这是你认为与之相关的方式，或者类型检查器恰好在它们的情况下产生了一个联合？
- en: Is there a type-checker in the first， some different type of union？
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况中是否有一个类型检查器，某种不同类型的联合？
- en: It's somebody who is very different。 So， talking about this case here？ Yeah，
    so in this case。 it's obvious that it follows the union because it's in a function
    representation。 But in the general case， it might be some local variable。 And
    better or not。 if it's a purpose of union， it can be how the type-checker does
    this type of union。 Yeah， that is。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有人是非常不同的。那么，谈论这个案例吗？是的，所以在这个案例中。显然它遵循联合，因为它在函数表示中。但在一般情况下，它可能是某个局部变量。更好或者更糟。如果这是联合的目的，它可以是类型检查器如何处理这种类型的联合。是的，确实如此。
- en: You can make a variable to sign it to different points， chase different types。
    Yeah。 so like if it's the times as either a valid or something else。 you might
    be a particular type of a literal type， or the common type of a term。 depending
    on what type of type of use to the type of equals。 So。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个变量，将其指向不同的点，追逐不同的类型。是的。如果它的时机是有效的或其他的。你可能是一个特定类型的字面类型，或者是一个术语的通用类型。根据使用类型的类型来决定。所以。
- en: just the mission is the type guard type includes the union。 but only when the
    groups of union are stateless， so specific decisions in the type-checker on type
    of a inference。 And so， I guess， if I find by the type guard type here。 I mean
    that the type that's specified between the brackets after type， is after type
    bar。 So， yeah。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 任务只是类型保护类型包括联合。但仅当联合组是无状态时，因此在类型检查器的类型推断上做出特定决策。所以，我想，如果我在这里找到类型保护类型。我是指在类型后括号中指定的类型，是在类型栏之后。因此，是的。
- en: whether that's a union or not to be pretty obvious， but it's definitely true
    that whether the。 union type is a union， it can't be a type of a type of error。
    Yeah。 There are the union cases and eliminating some kind of possibility。 Do you
    ever consider it over votes？ I know it would be overwhelming to be appropriate
    to follow the conversation。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否是一个联合体或不太明显，但肯定可以说，是否这个。联合类型是一个联合体，它不能是一种错误类型。是的。有联合情况，并消除某种可能性。你是否曾考虑过重载？我知道这样做会让人感到不知所措，适合跟随对话。
- en: Or you can use having a global integer type guard in the type of option。 That's
    probably going to be something that has been considered。 I think people， like，
    you know。 you have the slide， but this is， you know， our case， if you have an
    overload on the hope。 if a strain is passed in， then a like， a type of strain
    in it， but a load is passed。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以在选项的类型中使用全局整数类型保护。这可能是已经被考虑过的事情。我觉得人们，你知道，你有这个幻灯片，但这是，我们的情况，如果你在希望上有一个重载。如果传入了一种应变，然后就像其中的一种应变，但却传入了一个负载。
- en: then a type of a short quote。 Or they are a sports book。 And I'm trying to make
    it， you know。 you have to think about that somehow。 No， but， according to Tony's
    objects， we've only exactly like。 like， this， right， a global state when you already
    move the type of strain。 So， you know。 the next slide， like， with this one， people
    have like two different。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是一种短引用的类型。或者它们是一本运动书。我试图让它，你知道。你必须以某种方式考虑这一点。不，但根据托尼的对象，我们只有完全一样的。就像，这，对吧，已经移动了应变类型时的全局状态。所以，你知道。下一张幻灯片，就像这一张，人们有两种不同的。
- en: imaginations of this era or in both。 And the first is when it's coming into
    support flow or individual。 In case where you might have just opted to think the
    overall movement。 I think we could be able to overload this scale， like， like
    a strain is passed in this era。 But。 yeah， you can't think the right one。 So you
    wind up hitting the catch on the children's face。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个时代的想象力或在两者中。当它进入支持流或个体时。以防你可能只是选择考虑整体运动。我认为我们可以超载这个规模，就像，在这个时代传入了一种应变。但。是的，你无法想出正确的那一个。所以你最终会在孩子的脸上打到那个捕捉。
- en: But that's what you're saying。 Yeah。 [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]， [ Inaudible ]， [ Inaudible ]。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 但这就是你在说的。是的。[听不清]，[听不清]，[听不清]，[听不清]。[听不清]，[听不清]，[听不清]，[听不清]，[听不清]，[听不清]。[听不清]，[听不清]，[听不清]，[听不清]，[听不清]，[听不清]。[听不清]，[听不清]，[听不清]，[听不清]，[听不清]，[听不清]。
- en: '[ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]， [ Inaudible ]。'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[听不清]，[听不清]，[听不清]，[听不清]，[听不清]，[听不清]。[听不清]，[听不清]，[听不清]，[听不清]，[听不清]，[听不清]。[听不清]，[听不清]，[听不清]，[听不清]，[听不清]，[听不清]。[听不清]，[听不清]，[听不清]，[听不清]，[听不清]，[听不清]。'
- en: '[ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]， [ Inaudible ]。'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[听不清]，[听不清]，[听不清]，[听不清]，[听不清]，[听不清]。[听不清]，[听不清]，[听不清]，[听不清]，[听不清]，[听不清]。[听不清]，[听不清]，[听不清]，[听不清]，[听不清]，[听不清]。[听不清]，[听不清]，[听不清]，[听不清]，[听不清]，[听不清]。'
- en: '[ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]， [ Inaudible ]。'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[听不清]，[听不清]，[听不清]，[听不清]，[听不清]，[听不清]。[听不清]，[听不清]，[听不清]，[听不清]，[听不清]，[听不清]。[听不清]，[听不清]，[听不清]，[听不清]，[听不清]，[听不清]。[听不清]，[听不清]，[听不清]，[听不清]，[听不清]，[听不清]。'
- en: '[ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]， [ Inaudible ]。'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见
    ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见
    ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。'
- en: '[ Inaudible ]， [ Inaudible ]。'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 听不见 ]， [ 听不见 ]。'
- en: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_11.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_11.png)'
- en: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_12.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_12.png)'
- en: '[ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]， [ Inaudible ]。'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见
    ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见
    ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。'
- en: '[ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]。'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见
    ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。'
- en: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_14.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_14.png)'
- en: '[ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]， [ Inaudible ]。'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见
    ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见
    ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。'
- en: '[ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]， [ Inaudible ]。'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见
    ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见
    ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。'
- en: '[ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]。 [ Inaudible ]。'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]。'
- en: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_16.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_16.png)'
- en: '[ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]， [ Inaudible ]。'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见
    ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见
    ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。'
- en: '[ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]， [ Inaudible ]。'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见
    ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见
    ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。'
- en: '[ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]， [ Inaudible ]。'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见
    ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见
    ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。'
- en: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_18.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_18.png)'
- en: '[ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]。'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见
    ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。'
- en: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_20.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72794c0e62b7ca31ad9a9acd049cde2f_20.png)'
- en: '[ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]， [ Inaudible ]。'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见
    ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见
    ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。'
- en: '[ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]，
    [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible
    ]， [ Inaudible ]。 [ Inaudible ]， [ Inaudible ]， [ Inaudible ]， [ Inaudible ]。'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见
    ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。 [ 听不见 ]， [ 听不见 ]， [ 听不见 ]， [ 听不见 ]。'
