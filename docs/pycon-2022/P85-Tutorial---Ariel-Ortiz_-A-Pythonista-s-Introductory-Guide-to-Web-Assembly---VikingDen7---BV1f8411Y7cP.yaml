- en: P85：Tutorial - Ariel Ortiz_ A Pythonista's Introductory Guide to Web Assembly
    - VikingDen7 - BV1f8411Y7cP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P85：教程 - 阿里尔·奥尔蒂斯_ Pythonista的WebAssembly入门指南 - VikingDen7 - BV1f8411Y7cP
- en: Good morning， everyone。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大家早上好。
- en: '![](img/86495766b190929aba361b4772d72632_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_1.png)'
- en: '![](img/86495766b190929aba361b4772d72632_2.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_2.png)'
- en: Do you have a good trip？ Yep。 Awesome。 Okay。 Thank you very much。 Thank you
    for enrolling to this tutorial。 Okay。 I just sent a message a moment ago sharing
    this link as well。 If you're unable to type this， check out the messages at our
    website or at the conference， website。 Okay。 So， I think we're going to start
    now。 My name is Ariel Ortiz。 You can just call me Ariel。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你们旅途愉快吗？是的。太棒了。好的。非常感谢。感谢你报名参加这个教程。好的。我刚刚发了一条消息，分享了这个链接。如果你无法输入这个，请查看我们网站或会议网站上的消息。好的。所以，我想我们现在可以开始了。我叫阿里尔·奥尔蒂斯。你可以叫我阿里尔。
- en: I'm a full-time faculty member at Technological Monterey。 This is a university
    back in Mexico。 It's the largest private university there。 I've been in the teaching
    business for several years now。 I've been actually a full-time faculty member
    for 28 years。 And I started coming here to PyCon recently。 Well。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我是蒙特雷科技大学的全职教师。这是一所位于墨西哥的大学，是那里的最大私立大学。我从事教学工作已经好几年了，实际上我已经担任全职教师28年。我最近开始来到PyCon。好吧。
- en: relatively recently 2017 was the first time I've come to this conference。 It
    was really awesome to be here again after two years of not being able to see everyone，
    in person。 I've been working with PyCon since， I think it was a year 2001， so
    I have a little bit。 more than 20 years using the language。 I really， really like
    Python。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，2017年我第一次参加这个会议。两年没有见到大家，能再次回来真是太棒了。我从2001年开始与PyCon合作，所以我有超过20年的使用经验。我真的非常喜欢Python。
- en: It's one of several languages that I use in my courses。 Well。 this is a Pythonesis
    introductory guide to WebAssembly。 Once again。 this is a really interesting topic
    and it would take us a lot of time to actually see it in much more detail。 So
    hopefully after this tutorial you should have a general idea of what it is。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在课程中使用的几种语言之一。这是一个Pythonista的WebAssembly入门指南。再说一次，这是一个非常有趣的话题，我们将花费大量时间才能更深入地了解它。希望在这个教程结束后，你能对它有一个总体的了解。
- en: And if you're interested in going deeper， well， I'll give you some pointers
    so that you can check more information。 But once again， just to keep our expectations
    in place， just have in mind that there's a lot to see。 And we're just going to
    cover a little bit of this really awesome technology。 So these are the tutorial
    notes。 Hopefully I hope everybody is connected to the internet。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣深入了解，我会给你一些指引，帮助你查看更多信息。但再次强调，为了管理我们的期望，请记住还有很多内容要看。我们将只是覆盖这项非常棒的技术的一小部分。这是教程笔记。希望大家都能连接到互联网。
- en: to the Wi-Fi， because we're going to be working on the cloud for simplicity's
    sake。 So what we're going to be looking at today， these are the four main topics。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 连接Wi-Fi，因为为了简化，我们将使用云端工作。所以今天我们要讨论的有四个主要主题。
- en: '![](img/86495766b190929aba361b4772d72632_4.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_4.png)'
- en: First of all， we're going to be looking at what is WebAssembly in general overview。
    And then as a second topic here， we're going to look quickly to this technology
    called Pyodide。 This will allow us to see how we can use Python on a web browser
    thanks to this WebAssembly technology。 Our third topic is hand coding WebAssembly。
    We're going to have a hands-on experience on how to write a little bit of WebAssembly
    by hand。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将概述一下WebAssembly是什么。作为第二个主题，我们将快速了解一种叫做Pyodide的技术。这将让我们看到如何利用WebAssembly技术在网页浏览器中使用Python。我们的第三个主题是手动编码WebAssembly。我们将亲手体验一下如何手动编写一点WebAssembly。
- en: And finally， our fourth topic is writing a tiny compiler。 Actually。 most of
    the compiler is actually written。 We're just really going to explain how it works
    and you're going to be having the opportunity to extend it with some additional
    functionality。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的第四个主题是编写一个小编译器。实际上，大部分编译器的代码已经写好了。我们只会解释它是如何工作的，你也将有机会扩展一些额外的功能。
- en: '![](img/86495766b190929aba361b4772d72632_6.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_6.png)'
- en: Okay？ So what is WebAssembly？ Okay， WebAssembly is a binary instruction format
    for a virtual machine。 We call it a stack-based virtual machine。 So it is what
    we call an instruction set。 Just like x86。 just like ARM， just like the instruction
    set for the Java virtual machine or the instruction set for the common language
    infrastructure。 Which is the 。NET technology。 Basically， it's a series of instructions
    that are executed。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？那么，什么是 WebAssembly？好的，WebAssembly 是一种虚拟机的二进制指令格式。我们称之为基于栈的虚拟机。因此，它就是我们所称的指令集。就像
    x86，就像 ARM，就像 Java 虚拟机的指令集或通用语言基础设施的指令集。这就是 .NET 技术。基本上，它是一系列可执行的指令。
- en: In this case， we call a virtual machine because it's not really a CPU which
    is in hardware。 It's actually a software machine。 But we can get some really interesting
    properties when we actually use this。 So what's special about this？ I mean， because
    once again。 this idea of having a virtual machine is really not new。 It's something
    that we've had since many。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们称之为虚拟机，因为它实际上并不是硬件中的 CPU。它实际上是一个软件机器。但是，当我们实际使用它时，我们可以获得一些非常有趣的特性。那么，这有什么特别之处？我的意思是，因为再一次，拥有虚拟机的这个想法实际上并不新颖。自古以来我们就有了。
- en: many decades ago。 Specifically， WebAssembly was designed to be a portable compiler-generated
    language for implementing client and server-side applications。 Okay？ It's not
    meant to be written by hand， although we're going to do that here。 I think it's
    really interesting。 It's really educational to do it。 But strictly speaking。 the
    most common use case is to actually use a compiler for a higher level language。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年前。具体来说，WebAssembly 被设计为一种便携的编译器生成语言，用于实现客户端和服务器端应用程序。好吧？它并不是为了手动编写，尽管我们将在这里这样做。我认为这非常有趣。这样做非常具有教育意义。但严格来说，最常见的用例是实际使用更高层语言的编译器。
- en: and let that high level language actually produce the WebAssembly code。 But
    we're actually going to see both situations when you write it by hand and when
    you actually use a tool in order to generate our WebAssembly programs。 Okay？ So，
    WebAssembly actually is a fairly recent technology。 It was proposed somewhere
    around 2015。 They started writing an initial draft which appeared somewhere， I
    think it was March 2017。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 并让该高级语言实际上生成 WebAssembly 代码。但我们实际上会看到两种情况：手动编写和使用工具生成我们的 WebAssembly 程序。好的？因此，WebAssembly
    实际上是一项相对较新的技术。它大约在2015年提出，他们开始编写初稿，这份草案大约在2017年3月出现。
- en: And around， I think it was October， November 2017。 the four major browser players
    actually had an implementation that was actually being able to run programs。 designed
    for this minimal， vile product of WebAssembly 1。0。 So， as you can see here。 there
    was support at the end of 2017， 2017。 There was support for WebAssembly in Chrome，
    in Edge。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我认为是2017年10月或11月时，四大主要浏览器厂商实际上都实现了可以运行程序的功能，这些程序是为这一最小的、可怕的 WebAssembly 1.0
    产品设计的。因此，正如您所看到的，2017年末，Chrome 和 Edge 中支持 WebAssembly。
- en: in Firefox and in Safari。 What are the main features of this technology？ Well，
    it's secure。 WebAssembly implementation that runs on browsers actually uses the
    same sandbox as JavaScript。 So。 in general， it has been tested fairly well。 And
    as usual。 we always get some security issues at some point。 But most of the security
    issues have been solved so far。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Firefox 和 Safari 中。这项技术的主要特点是什么？嗯，它是安全的。WebAssembly 的实现实际上使用与 JavaScript 相同的沙箱。因此，总体而言，它经过了相当良好的测试。和往常一样，我们总会在某个时刻遇到一些安全问题。但到目前为止，大多数安全问题都已得到解决。
- en: So， in general， we do consider this platform fairly secure。 It's portable。 We
    can run this in not only Web browsers， but it actually runs on a variety of devices。
    It runs on mobile devices in the same browsers that we mentioned ago。 And actually。
    by the year 2021， last year， actually， it was estimated that 94% of all browsers
    in the world actually supported WebAssembly。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总体而言，我们确实认为这个平台相当安全。它是可移植的。我们不仅可以在 Web 浏览器中运行它，还可以在各种设备上运行。它在我们之前提到的同样的浏览器中的移动设备上运行。实际上，到2021年，去年，估计全球94%的浏览器都支持
    WebAssembly。
- en: So， it's a fairly ubiquitous technology that we can now depend on。 Another feature。
    and this is probably the main motivation that it had。 It is really performant。
    It runs very。 very fast。 This instruction set， which is WebAssembly。 is really
    made for a compute intensive processes。 Okay， so typically。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是一项相当普遍的技术，我们现在可以依赖它。另一个特点，这可能是它的主要动机。它的性能确实很强。它运行得非常非常快。这一指令集，即 WebAssembly，确实是为计算密集型过程而设计的。好的，通常来说。
- en: you will need to understand that when we talk about WebAssembly。 what we can
    do is fairly limited in the sense that we can only do computations on numerical
    values。 If we need to interface with the rest of the world。 it is important that
    we actually call some auxiliary functions written probably in some other language。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要理解，当我们谈论WebAssembly时，我们所能做的在某种意义上是相当有限的，因为我们只能对数值进行计算。如果我们需要与外界进行交互，重要的是我们实际上需要调用一些可能用其他语言编写的辅助函数。
- en: Typically， it could be JavaScript， but we're going to see that it can be Python
    or some other language as well。 How performant is it？ Well， the original design
    of WebAssembly was made to actually try to run as close as possible to native
    code。 I did a few months ago a little benchmark of my own。 which wasn't really
    scientific or any of that kind of stuff。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，它可能是JavaScript，但我们将看到它也可以是Python或其他语言。它的性能如何？好吧，WebAssembly的初始设计实际上是为了尽可能接近本地代码运行。我几个月前做了一个小的基准测试，这并不科学或任何那种东西。
- en: In the sense that it wasn't really formal， I just wrote a program。 It was a
    program that actually used numerical integration to compute the value of Pi doing
    a few。 I don't remember， it was a few million iterations。 I benchmarked and saw
    how that program run if it was running in Python and how fast it was when converting
    this same code in Python to C and then using a compiler to produce WebAssembly
    and to produce native code。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从非正式的角度来看，我只是写了一个程序。这个程序实际上使用数值积分计算π的值，我不记得具体是几百万次迭代。我基准测试并观察了这个程序在Python中运行的情况，以及将同样的代码从Python转换为C，并使用编译器生成WebAssembly和本地代码时的速度。
- en: In the case of Python compared to the native code running on an x86 computer。
    the Python code was 80 times slower。 The native code was 80 times faster if you
    want to see it that way than the corresponding Python code。 Then， once again，
    I translated that C code into WebAssembly and ran the same benchmark。 It was 40
    times faster than Python。 We do have that this technology is fast。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python与在x86计算机上运行的本地代码相比，Python代码慢80倍。如果你从这个角度来看，本地代码比相应的Python代码快80倍。然后，再次，我将C代码转换为WebAssembly并进行了相同的基准测试。它比Python快40倍。我们确实看到这项技术是快速的。
- en: It tries to be as fast as native code， but currently it's not really as fast。
    More or less。 what I was able to see is that it was about twice as fast as native
    code。 but very much faster than Python。 I didn't measure this program with other
    languages like JavaScript。 but probably wouldn't see， I guess not too much of
    a difference of what Python actually takes in question of in a matter of time。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 它试图像本地代码一样快，但目前并没有那么快。大致上，我所看到的是，它的速度大约是本地代码的两倍，但比Python快得多。我没有用JavaScript等其他语言来测量这个程序，但我猜大概看不到Python在时间上的太多差异。
- en: And lastly， and this is also something very important。 It is an open standard。
    So here。 the browser vendors are able to actually implement their own versions
    and any other people that want to have their own implementation of WebAssembly。
    They can just go and implement the specifications。 They don't need to pay any
    royalties。 So it really makes it a very convenient technology because there's
    no main company who owns this technology。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这也是非常重要的。它是一个开放标准。因此，在这里，浏览器供应商能够实现他们自己的版本，任何想要拥有自己WebAssembly实现的人都可以去实现规范。他们不需要支付任何版权费。因此，这确实使它成为一项非常方便的技术，因为没有主要公司拥有这项技术。
- en: Several companies actually are involved in the design of the technology， but
    in general。 the standard is open， so this is very good news。 So in 2019， 2019，
    what happened？ Well。 the worldwide web consortium， the W3C， it announced that
    WebAssembly was now the fourth language of the open web。 and this is together
    with HTML， CSS and JavaScript。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 几家公司实际上参与了这项技术的设计，但总体而言，标准是开放的，所以这是个好消息。那么在2019年发生了什么？好吧，全球万维网联盟W3C宣布WebAssembly现在是开放网络的第四种语言，与HTML、CSS和JavaScript一起。
- en: One thing worth noting here is that WebAssembly is not a substitute of JavaScript。
    They're actually complementary。 So it means that a lot of the things that are
    done in the browser typically are going to still be done using JavaScript。 but
    now we have another option that will allow us to write parts of our program in
    some more high performance language like C or like Rust or many other languages。
    And we're going to be able to integrate it with JavaScript or some other language。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的一点是，WebAssembly并不是JavaScript的替代品。它们实际上是互补的。这意味着浏览器中通常进行的许多操作仍将使用JavaScript进行，但现在我们有了另一个选项，可以让我们用更高性能的语言如C或Rust或其他多种语言编写部分程序。我们将能够与JavaScript或其他语言集成。
- en: and we should be able to actually get programs that still are able to interact
    with the user。 but in certain parts， they can run actually faster than a typical
    JavaScript code if we're thinking just in terms of the browser。 But once again，
    the technology is not limited to the browser。 Currently。 there are several implementations
    of the WebAssembly runtime that are able to run embedded devices and your ordinary
    laptop and desktop computers。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够获得仍能与用户互动的程序，但在某些部分，它们在浏览器中可以比典型的JavaScript代码运行得更快。但再一次，这项技术并不限于浏览器。目前，有几种WebAssembly运行时的实现能够在嵌入式设备以及普通的笔记本和台式计算机上运行。
- en: So we're going to have the chance to actually see these use cases in Python
    when it runs on the browser and when it runs on our computer。 more generic computer。
    So it's worth noting that there are some few disadvantages at the current technology。
    how it is currently at this moment。 First of all， as I mentioned a moment ago。
    it really only has support for numeric types。 It supports integers。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将有机会实际看到这些用例在浏览器和我们的计算机上运行时的表现，更多是通用计算机。因此，值得注意的是，目前的技术有一些缺点，尤其是它在这个时刻的状态。首先，正如我刚才提到的，它实际上仅支持数值类型，支持整数。
- en: it supports floating point numbers， but anything else is a little bit more elaborate。
    You are able to actually simulate and have support for other data types like objects
    and strings and arrays and so on。 but it doesn't come directly supported by the
    technology itself。 You have to do some additional tweaks to actually get this
    running。 But once again。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它支持浮点数，但其他类型则稍微复杂一些。你实际上能够模拟并支持其他数据类型，如对象、字符串和数组等等，但这些并不直接由技术本身支持。你需要做一些额外的调整才能使其正常运行。但再一次。
- en: this is because WebAssembly in this first version is actually designed just
    to focus on computations。 on numerical computations。 Another thing that is a limitation
    is that it does not have garbage collection。 Most modern languages actually rely
    on garbage collection to manage their memory。 That's the case of Python。 But most
    languages that have appeared in the past few years include languages like Go。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为WebAssembly在这个版本中实际上设计的重点是计算，特别是数值计算。另一个限制是它没有垃圾回收。大多数现代语言实际上依赖于垃圾回收来管理内存，这也是Python的情况。然而，过去几年出现的大多数语言，如Go等，已经有了不同的实现。
- en: Traditionally interpreted languages like Ruby and JavaScript all of them depend
    on garbage collection。 The few exceptions to this are languages like CC++ and
    Rust。 Most languages will find this as a limitation。 The work around currently
    is to actually add the garbage collection as an additional supported sort of module
    to your code。 which of course takes a little bit of time。 Hopefully。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的解释性语言如Ruby和JavaScript都依赖于垃圾回收。唯一的例外是像C和C++以及Rust这样的语言。大多数语言会将此视为一种限制。当前的解决方法实际上是将垃圾回收作为额外支持的模块添加到代码中，这当然需要一些时间。希望。
- en: next version of WebAssembly might actually have garbage collection。 We will
    have to see in the next few months if that is actually incorporated。 This is something
    they do have planned to do。 At the very moment。 at least how most browsers implemented，
    they do not have this support not yet。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下一版本的WebAssembly可能会实际包含垃圾回收。我们需要在接下来的几个月中观察这是否会被纳入。这是他们计划要做的事情。至少目前来看，如何在大多数浏览器中实现，尚未支持这一功能。
- en: Thinking of this as being a Web2Dology， one of the main limitations also is
    that there is no direct access to the document object model。 Remember， the DOM
    is the data structure and memory that represents the HTML structure of a web page。
    You are not allowed directly， at least， to modify your DOM tree from WebAssembly。
    You need to do it through some other language like JavaScript。 Once again。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将其视为Web2Dology时，主要的限制之一是没有直接访问文档对象模型。请记住，DOM是表示网页HTML结构的数据结构和内存。至少，从WebAssembly中你不被允许直接修改DOM树。你需要通过其他语言，比如JavaScript，来做到这一点。再一次。
- en: this might actually get changed in the future。 It might actually be different。
    At this moment。 you still need to interact with the hosting platform to actually
    do that。 Typically。 that means calling code written in some other language。 What
    languages。 what tools are currently available？ These are probably the most popular
    ones， but there are many。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这在未来可能会发生变化。实际上可能会有所不同。在这一刻，你仍然需要与托管平台进行交互来做到这一点。通常，这意味着调用用其他语言编写的代码。现在有哪些语言和工具可用？这些可能是最流行的，但还有很多其他选择。
- en: many others。 Many others are being designed at this moment。 What are most popular
    ones？
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他语言。目前正在设计许多其他语言。最受欢迎的是什么？
- en: This is a compiler called MScripten。 This runs over the LLVM toolset or toolchain。
    This one was designed to work with C and C++， but it does support some other languages
    that are able to be integrated with LLVM。 This is a very popular technology and
    has been used to actually port a lot of already written C code to WebAssembly。
    Actually， we are going to see in a moment this Piodi technology is actually a
    port of C Python compiled using MScripten。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种称为MScripten的编译器。它运行在LLVM工具集或工具链上。这个编译器是为C和C++设计的，但它确实支持一些其他能够与LLVM集成的语言。这是一项非常流行的技术，已经被用来实际将大量已经编写的C代码移植到WebAssembly。实际上，我们稍后会看到的Piodi技术实际上是用MScripten编译的C
    Python的移植版本。
- en: so that it can be executed in a web browser。 This is a very central technology
    for us people that work with Python。 Rust， this is a relatively new language。
    It has a really interesting concept around shared memory。 It is considered much，
    much more safer than C and C++ to run really perform in code。 This is a really
    interesting technology if you haven't seen it or used it。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这样它可以在网页浏览器中执行。这对我们这些从事Python工作的人来说是一项非常核心的技术。Rust是一种相对较新的语言。它有一个关于共享内存的非常有趣的概念。与C和C++相比，它被认为更安全得多，能够真正高效地运行代码。如果你还没见过或使用过，这是一个非常有趣的技术。
- en: Probably it's worth to check out。 A lot of what is currently in WebAssembly
    is done through Rust。 Another technology that I've seen that has been becoming
    fairly popular is this thing called Blazer from Microsoft。 This allows you to
    use C# to actually produce your WebAssembly modules。 There is this new language
    called assembly script which is basically a subset of TypeScript。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一看。目前在WebAssembly中的很多内容都是通过Rust实现的。另一种我见过的相当受欢迎的技术是微软的Blazer。这使你能够使用C#来实际生成你的WebAssembly模块。还有一种新的语言叫做AssemblyScript，基本上是TypeScript的一个子集。
- en: which is a variation or extension of JavaScript which is targeted exclusively
    to run or to produce code for WebAssembly。 This is an interesting alternative。
    If you need to learn a language and you want to use a language that is really
    designed to produce adequate code for WebAssembly script is the way to go。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JavaScript的一个变体或扩展，专门针对运行或生成WebAssembly代码。这是一个有趣的替代方案。如果你需要学习一门语言，并且想使用一门真正为生成适当的WebAssembly代码而设计的语言，WebAssembly脚本就是一个不错的选择。
- en: It's worth mentioning there is this other technology。 We are not going to go
    too much into discussing it。 I want you to know that it exists。 It's called Wazzy。
    This is probably going to be very relevant in the future。 Wazzy is a WebAssembly
    system interface。 This is an independent technology from WebAssembly but it works
    with WebAssembly。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，还有另一项技术。我们不会深入讨论它。我想让你知道它的存在。它叫做Wazzy。这在未来可能会非常相关。Wazzy是一个WebAssembly系统接口。这是与WebAssembly独立的技术，但它与WebAssembly一起工作。
- en: It's totally linked or bound to this technology but it is considered a separate
    project and it's currently being developed。 Basically what Wazzy is is it allows
    to run WebAssembly outside the browser。 That's probably the most interesting thing。
    It could happen。 It's not the current state now but in the future we might actually
    be producing WebAssembly plus C#。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全与这项技术相关联，但被视为一个独立项目，目前正在开发中。基本上，Wazzy 的作用是允许在浏览器之外运行 WebAssembly。这可能是最有趣的事情。它可能会发生。现在还不是这种状态，但未来我们实际上可能会生成
    WebAssembly 加 C#。
- en: We would have a portable executable that could run without any modifications
    without having to recompile it in other platforms。 This sounds like a convenient
    technology and we have to keep an eye on it。 It's basically a standard API for
    WebAssembly modules that allows them to access system models。 It's basically a
    standardized API for WebAssembly modules that allows them to access system resources。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将拥有一个可移植的可执行文件，可以不进行任何修改地运行，而不必在其他平台上重新编译。这听起来像是一项便利的技术，我们必须关注它。它基本上是一个 WebAssembly
    模块的标准 API，允许它们访问系统模型。它实际上是一个标准化的 API，允许 WebAssembly 模块访问系统资源。
- en: Currently you're not allowed to access from WebAssembly directly things like
    the file system or networking or any kind of the interesting packages that we
    typically use。 But hopefully with Wazzy we will be able to do this in a very portable
    fashion。 This is something that is worth keeping an eye on。 Let's go to our tutorial
    notes。 Just a quick reminder especially for the people who arrived a little bit
    late。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 目前你不能直接通过 WebAssembly 访问文件系统、网络或任何我们通常使用的有趣包。但希望有了 Wazzy，我们能以一种非常便携的方式做到这一点。这是值得关注的事情。让我们去看看我们的教程笔记。特别提醒一下那些稍晚到的人。
- en: This is the URL for our tutorial notes。 Once again this URL I sent it through
    the message board in the corresponding Python interface in the website that we
    have available for all of us。 Let's go and see what we have here。 Excuse me。 Here
    are the notes。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们教程笔记的链接。再一次，我通过我们在网站上提供给大家的相应 Python 接口的留言板发送了这个链接。让我们看看这里有什么。不好意思。这里是笔记。
- en: The slides you saw are available from this link。 If you want to check them again
    they are available there。 This introduction is the same description that you had
    when you enrolled to this tutorial。 I'm not going to spend any time with that。
    You've already read it。 What we are going to do here is use this site called Gitpod。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的幻灯片可以通过这个链接获取。如果你想再次查看，它们可以在那里找到。这段介绍与你报名参加这个教程时的描述相同。我不会花时间在这上面，你已经读过了。我们要做的是使用这个名为
    Gitpod 的网站。
- en: Once again if you remember I sent you a couple of days ago just a message saying
    that you needed to make sure you had an account in GitHub。 In Gitpod and Gitpod
    are two different services。 If you don't have a GitHub account just make sure
    to create one before you proceed。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，如果你记得我几天前发了一条消息，告诉你需要确保在 GitHub 上有一个帐户。Gitpod 和 GitHub 是两个不同的服务。如果你没有 GitHub
    帐户，请确保在继续之前先创建一个。
- en: The only thing you need to do for this tutorial is follow this link here。 This
    will open a new window or new tab。 If everything is working fine we should have
    a clone of my GitHub repository which has all the software that we are going to
    be using now。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程你需要做的唯一事情就是跟随这个链接。这将打开一个新窗口或新标签页。如果一切正常，我们应该能克隆我的 GitHub 仓库，里面有我们现在要使用的所有软件。
- en: '![](img/86495766b190929aba361b4772d72632_8.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_8.png)'
- en: You are probably going to see this in a light color。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到这是一种浅色。
- en: '![](img/86495766b190929aba361b4772d72632_10.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_10.png)'
- en: It probably makes sense to make this larger。 There are some settings you can
    change here。 You can change it to a darker color。 Just go here where the cog is
    at the bottom and there is an option that says here settings。 For the color of
    the theme type theme here， and you are looking at this site with something like
    default is default light。 If you don't like it change it to whatever it is。 What
    you see here is actually a web version of Visual Studio code。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能合理地让它变大。有一些设置可以在这里更改。你可以将其更改为较深的颜色。只需去底部的齿轮位置，有一个选项说这里的设置。对于主题颜色，输入主题，你所看到的这个网站的默认设置是默认浅色。如果你不喜欢它，可以改成你想要的。你在这里看到的实际上是
    Visual Studio Code 的网页版。
- en: Most of the functionality in Visual Studio code in the desktop is here。 You
    probably have a message saying that if you want to run Visual Studio code from
    the desktop just close that window there。 We are not going to be using the desktop
    version。 It makes sense for what we are doing here。 Let me make this a little
    bit larger。 Can everybody see here the words that we have over here？
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 桌面版的大多数功能都在这里。你可能会收到一条消息，告诉你如果想从桌面运行 Visual Studio Code，只需关闭那个窗口。我们不打算使用桌面版本。这对我们在这里做的事情是有意义的。让我把这个稍微放大一点。大家能看到我们这里的文字吗？
- en: Is that okay？ I know the default sizes might be very tiny。 If you want to change
    your font size。 just type over here in the settings。 Just type font。 Somewhere
    you should see the size of the font。 It is a editor font size。 I am currently
    using 18 but I made it larger so you can see it here。 I think by default it is
    12 but you can change it to something that makes it more sense to you。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 可以吗？我知道默认的字体大小可能非常小。如果你想更改字体大小，只需在设置中输入。在这里输入 font。你应该能看到字体大小。它是编辑器字体大小。我目前使用的是
    18，但我把它调大了，以便你能看到。我想默认是 12，但你可以将其更改为更适合你的大小。
- en: Once again put it according to your personal preferences。 Let me go back to
    the themes。 I usually like a theme that is called Dracula。 It seems to be very
    popular。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 再次根据你的个人偏好进行设置。让我回到主题上。我通常喜欢一个叫 Dracula 的主题。它似乎非常受欢迎。
- en: '![](img/86495766b190929aba361b4772d72632_12.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_12.png)'
- en: This is not installed by default so if you want to install it go to this icon
    here in the left-hand side that says extensions。 If you know the name of your
    favorite theme type it there。 I like this one called Sweet Dracula。 I already
    have it installed but if you don't have it installed you should have a button
    like this。 It says install so just put it there and you should be able to install
    it and start using it。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是默认安装的，所以如果你想安装它，去左侧这个标有扩展的图标。如果你知道你喜欢的主题的名称，就在这里输入。我喜欢一个叫 Sweet Dracula 的主题。我已经安装了，但如果你没有安装，你应该会看到一个类似的按钮。它会显示安装，所以只需点击那里，你应该能够安装并开始使用它。
- en: I am going to request it to change it to our Dracula soft。 Sweet Dracula is
    the one that I like。 For some reason most developers actually prefer dark themes。
    The problem is if you use a light theme many people say how do people know I am
    a hacker if I am using a light theme。 They prefer to use a dark because that is
    how it appears always in the movies。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我打算请求将其更改为我们的 Dracula 主题。我喜欢的主题是 Sweet Dracula。出于某种原因，大多数开发者实际上更喜欢黑暗主题。问题在于，如果你使用亮色主题，很多人会说，如果我使用亮色主题，别人怎么知道我是黑客呢？他们更喜欢使用黑暗主题，因为在电影中通常是这样的。
- en: Let's take some space here。 Here is some information if you want to see how
    to use the Gitpod workspace。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里留点空间。如果你想了解如何使用 Gitpod 工作区，这里有一些信息。
- en: '![](img/86495766b190929aba361b4772d72632_14.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_14.png)'
- en: Just a quick mention here。 Whenever you go back to the Gitpod。io URL this is
    the main site for Gitpod。 It will take you to the dashboard。 If at any moment
    you need to go to the dashboard probably the easiest thing is just to put in your
    address bar。 Gitpod。io and it will take you here to your workspaces。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里简单提一下。每当你返回到 Gitpod.io 的 URL，这是 Gitpod 的主站点。它会将你带到仪表盘。如果你在任何时候需要去仪表盘，最简单的方法就是在地址栏中输入
    Gitpod.io，它会将你带到你的工作区。
- en: '![](img/86495766b190929aba361b4772d72632_16.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_16.png)'
- en: We will probably go there several times in a moment。 We will be using the terminal
    a lot。 I hope you don't get frightened by using the terminal。 Depending on the
    kind of system you are using if you are using windows， Linux， Chrome。 whatever
    with control J you should be able to open terminal。 If you are using Mac OS。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会很快去那里几次。我们会频繁使用终端。我希望你不会因为使用终端而感到害怕。根据你使用的系统类型，如果你使用的是 Windows、Linux、Chrome，或其他系统，按下控制键
    J 应该能够打开终端。如果你使用的是 Mac OS。
- en: command J should open。 I currently have it open here but I think you probably
    don't。 If you currently are not looking at the terminal， a window is usually in
    the bottom part of your browser here。 Just type control J or command J and it
    opens the terminal。 If you are using the little X or you can type control J or
    command J and it will open and open if it is closed。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 按下命令键 J 应该会打开终端。我目前在这里打开了它，但我想你可能没有。如果你现在没有查看终端，窗口通常位于浏览器的底部。只需输入控制键 J 或命令键
    J，它就会打开终端。如果你使用的是小 X，或者你可以输入控制键 J 或命令键 J，它就会打开（如果关闭的话）。
- en: It toggles the terminal very easily。 Something that is very important。 please
    make sure that you get this。 We need to set some environment variables。 For simplicity
    I put it here in this file called PyCon 2022。 You need to do this every time you
    open a new terminal。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能可以很容易地切换终端。非常重要的一点是，请确保你明白这一点。我们需要设置一些环境变量。为了简单起见，我把它放在这个名为 PyCon 2022 的文件里。每次打开新终端时，你都需要执行此操作。
- en: '![](img/86495766b190929aba361b4772d72632_18.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_18.png)'
- en: You will see this little message saying PyCon USA 2022 tutorial and the name
    of the tutorial。 The prompt here appears with the name you have in GitHub。 It
    tells us the current working directory in our system。 Here is just an ordinary
    bash terminal。 This is a virtual machine running in the Git pod servers。 It is
    really nice。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这个小消息，显示“PyCon USA 2022 教程”和教程名称。这里的提示符显示的是你在 GitHub 上的名称。它告诉我们系统中的当前工作目录。这里只是一个普通的
    bash 终端。这是一个在 Git pod 服务器上运行的虚拟机。真是太好了。
- en: I haven't used this tool before。 I have used other integrated development environments
    in particular。 Basically you have a full integrated development environment。 It
    is really nice。 As a teacher。 as an instructor， I really like this because I get
    all my students working in the same environment。 In the past， whenever I taught
    web design， I had some issues because the people that were。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前没有使用过这个工具。我使用过其他的集成开发环境。基本上，你拥有一个完整的集成开发环境。真的很好。作为一名教师和讲师，我非常喜欢这一点，因为我让我的所有学生在相同的环境中工作。过去，每当我教授网页设计时，我遇到了一些问题，因为使用者的环境不同。
- en: using windows didn't work the same as the people using Mac or the people who
    were using Linux。 There were sometimes people that were using that system。 Having
    anything in the cloud is a convenient way of everybody working the same way。 That
    is the same reason why I am requesting you to use it here。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Windows 的体验与使用 Mac 或 Linux 的人不一样。有时也有人使用那些系统。在云端工作是每个人都以相同方式工作的便利方式。这也是我要求你在这里使用它的原因。
- en: We have all the software that we need for the tutorial。 We have several important
    tools here。 We have Python， the most recent version of Python available。 You can
    try it out。 Just type here Python。 Remember， type this after what I explained
    a moment ago。 Whenever you open a terminal， make sure you actually execute this
    command source。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有进行教程所需的所有软件。这里有几个重要工具。我们有 Python，最新版本的 Python。你可以试试。在这里输入 Python。记住，在我刚才解释后再输入这个命令。每次打开终端时，请确保你实际执行这个命令
    source。
- en: You should see this。 If you now type Python， you should see that we are using
    Python 3。10。4。 I think yesterday this was the most recent version of Python。 Once
    again。 this is Python running on the cloud。 A server provided courtesy of this
    company called GitPah。 To exit， type control D。 This is control D independent
    of what platform you are at。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到这个。如果你现在输入 Python，你应该看到我们正在使用 Python 3.10.4。我想昨天这是最新的 Python 版本。再说一次，这是在云端运行的
    Python。这是由名为 GitPah 的公司提供的服务器。要退出，请输入控制 D。无论你使用哪个平台，这都是控制 D。
- en: It is control and D。 Not command if you are using Mac OS。 Apart from the most
    recent version of Python， we also have here tools from a suite called， Webit。
    You have a question？ There is a package or suite of applications called Webit。
    We will use one of those tools in a moment。 They allow us to do several interesting
    things with WebAssembly from the terminal。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 控制 D 是对的。如果你使用的是 Mac OS，那就不是命令 D。除了最新版本的 Python，我们这里还有一个叫 Webit 的工具包。你有问题吗？有一个叫
    Webit 的应用程序套件。我们稍后会用到其中一个工具。它们允许我们从终端对 WebAssembly 进行一些有趣的操作。
- en: We have Wasm3， which is an interpreter of WebAssembly， which we will use in
    a moment。 We also have Wasmr for Python installed。 All these things work。 It does
    not matter what system you are using locally。 Because we are running all this
    in a virtual machine， this should work without any issues。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 Wasm3，这是一个 WebAssembly 的解释器，我们很快会用到。我们还安装了用于 Python 的 Wasmr。所有这些工具都能正常工作。无论你在本地使用什么系统，因为我们在虚拟机中运行这一切，这应该都没有问题。
- en: Just a few words about GitPah。 Once you have opened and cloned our repository，
    GitPah。 Enrolls you or subscribes you to a free plan called open source。 You get
    something called GitPah hours。 By default， you get 50 in this free plan。 which
    is called open source plan。 One GitPah hour is basically the opportunity to work
    in your workspace for one hour。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于GitPah简要介绍。一旦你打开并克隆了我们的仓库，GitPah会将你注册或订阅到一个名为开源的免费计划。你会获得被称为GitPah小时的东西。在这个免费计划中，默认情况下你会得到50个小时，这被称为开源计划。一个GitPah小时基本上是你在工作区工作一个小时的机会。
- en: If it gives you 50 GitPah hours， you can use it for 50 hours per month。 That
    is a fairly decent amount。 You can open simultaneously several work spaces。 but
    each work space is consuming independently。 For example。 if you open two parallel
    work spaces for one hour， it actually counts you for two hours。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它给你50个GitPah小时，你可以每月使用50小时。这是相当不错的数量。你可以同时打开多个工作区，但每个工作区是独立消耗的。例如，如果你同时打开两个工作区一个小时，实际上会计算为两个小时。
- en: Just have that in mind。 Whenever you want to finish your workspace， there is
    an option there。 Please don't exit at this moment。 I just want to show you where
    to exit。 but don't do it at this very moment。 There is a button here that says
    GitPah in the bottom left corner。 You get a menu here and there is this option
    called stop workspace。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每当你想结束你的工作区时，这里有一个选项。请不要此时退出。我只是想给你展示退出的位置，但此刻不要这样做。左下角有一个按钮，写着GitPah。你在这里得到一个菜单，有一个选项叫停止工作区。
- en: That is a way of stopping it at this very moment。 If you don't stop it， but
    for example。 it just closes your laptop and you go somewhere， 30 minutes of inactivity
    will also stop your workspace。 If you really want it to stop right now， just select
    that option。 Otherwise。 whenever you stop using it 30 minutes afterwards， you
    actually get disconnected。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种在此刻停止它的方法。如果你不停止它，例如，只是关闭你的笔记本电脑，然后去别处，30分钟的不活动也会停止你的工作区。如果你真的想立即停止，选择那个选项。否则，每当你停止使用它后30分钟，你实际上会被断开连接。
- en: It doesn't matter if you don't necessarily stop it by hand。 Another thing which
    is worth mentioning right now。 Once again， go to the dashboard here。 Once again。
    you can go with trypengitpod。io at any new tab or window that you have there open。
    You should see only one of this。 I mean， the workspace that you just created now。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不手动停止它也没关系。还有一件值得一提的事情。再次回到这里的仪表板。你可以在你打开的任何新标签或窗口中访问trypengitpod.io。你应该只看到其中一个。我是说，你刚创建的工作区。
- en: which is this one that is in green。 You need or it's recommended that you go
    here where there are three dots。 Then you select this option called pin。 Pin actually
    pins the workspace into your dashboard。 If you do not pin it 14 days after you
    last use it， it will automatically get deleted。 If you don't mind it to get deleted，
    you can leave it without the pin。 If you want to pin it。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是绿色的那个。你需要或者建议你去有三个点的地方。然后选择这个名为固定的选项。固定实际上是将工作区固定到你的仪表板上。如果你在最后一次使用它后14天没有固定，它将自动被删除。如果你不介意它被删除，你可以不固定它。如果你想固定它。
- en: it will still be there in two weeks。 Just have that in mind once again。 Otherwise。
    you might expect things to be there and then come back and see that they are not。
    Any unpinned workspace is deleted after two weeks。 I think that's all you need
    to know。 Of course。 another thing that we are over here。 If you go to the settings
    tab and you go to plans。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 两周后它仍然会在那里。再次记住这一点。否则，你可能期望东西在那里，然后回来时发现它们不见了。任何未固定的工作区在两周后会被删除。我想这就是你需要知道的一切。当然，另一个事情是，如果你去设置标签，再去计划。
- en: there are several things that you can check here。 First of all， there is the
    plan。 If anybody is interested in using this and doesn't mind paying。 you can
    see that there are several options here。 You should have been enrolled or subscribed
    here to the open source one。 which gives you 50 hours。 In my case， I got the personal
    because I'm an instructor and have some special benefits from GitHub。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几件事情你可以检查。首先，有计划。如果有人想使用这个且不介意付费，你可以看到这里有几个选项。你应该已经在这里注册或订阅了开源计划，这给你提供50小时。在我这边，我获得了个人计划，因为我是讲师，并从GitHub获得一些特别的福利。
- en: These are extended to Gitpod as well。 I have 100 hours per month given by the
    Gitpod company。 You have other options。 Most important part that I wanted you
    to see is this one here。 This tells you how many hours you have remaining in the
    month。 Once a month has gone。 it resets to 50 hours again。 If you want to keep
    on using it， just have that in mind。 Once again。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也扩展到了Gitpod。我每个月有100小时的使用时间，这是Gitpod公司提供的。你还有其他选择。我想让你看到的最重要的部分在这里。这告诉你本月剩余多少小时。一旦一个月过去，它会重置为50小时。如果你想继续使用，请记住这一点。再说一次。
- en: if you just wanted to do this during the tutorial， forget about everything。
    Probably the three hours we are going to be here is enough time for you to actually
    learn what we are going to present here。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是想在教程期间做这个，那就忘掉其他一切。我们将在这里待的三个小时大概足够你学习我们将要呈现的内容。
- en: '![](img/86495766b190929aba361b4772d72632_20.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_20.png)'
- en: Let's go to our section number three， which is this technology called Piodi。
    As I mentioned before。 Piodi actually was developed using the MScript and tool
    chain。 It's support of C Python。 This is the most common implementation of Python。
    MScript and actually received all the source code written in C。 It produced WebAssembly。
    This allows us to run， as we've explained before。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入第三部分，这是被称为Piodi的技术。正如我之前提到的，Piodi实际上是使用MScript和工具链开发的。它支持C Python。这是Python最常见的实现。MScript实际上接收了用C编写的所有源代码，生成了WebAssembly。这使我们能够运行，正如我们之前所解释的。
- en: to run Python on the browser directly。 As a first example here， let's run a
    REPL。 Remember the REPL is a read eval print loop。 Just click it here。 It should
    open a new tab or a new window。 Let's make this a little bit larger。 This is a
    standard terminal for Python。 This is running on the browser。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在浏览器上运行Python。作为第一个例子，让我们运行一个REPL。记住，REPL是一个读取、求值、打印的循环。只需点击这里。它应该会打开一个新标签页或新窗口。让我们把它放大一点。这是一个标准的Python终端。它在浏览器上运行。
- en: The Python that we saw a moment ago was running on the web and some other server。
    We are just using the browser as an interface。 This one is running here locally
    on our computer now。 Probably the first time you actually load this， it might
    take a few seconds。 I think somewhere the full module that contains all the WebAssembly
    code for C Python is somewhere around 7 or 8 mega。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的Python是在网络和其他一些服务器上运行的。我们只是将浏览器用作接口。这个现在在我们的计算机本地运行。可能第一次加载时需要几秒钟。我认为包含所有C
    Python WebAssembly代码的完整模块大约在7或8兆左右。
- en: It might actually take a little bit of while a few seconds to actually load。
    I did some tests on the speed of the Wi-Fi connections we have here。 They run
    pretty fast。 Hopefully we shouldn't have any issues with the speed of the Wi-Fi
    connection。 You can put whatever you like。 For example， let's say that we put
    here a list comprehension to produce the first 11 powers of two。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上加载可能需要一点时间，几秒钟。我对我们这里的Wi-Fi连接速度进行了测试，它们运行得相当快。希望我们不会在Wi-Fi连接速度上遇到任何问题。你可以放入任何你喜欢的内容。例如，假设我们在这里放入一个列表推导来生成前11个2的幂。
- en: I mean standard code。 An interesting thing here is that they also ported here
    some of the standard or not necessarily standard but typical libraries used by
    the people from data science。 We can import here NumPy。 Once again， the first
    time you actually bring it might take a little bit of time because sometimes it
    needs to download and convert this to the internal representation that it requires。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意思是标准代码。这里有一个有趣的地方是，他们也移植了一些标准的或者不一定是标准的，但通常被数据科学人员使用的库。我们可以在这里导入NumPy。再说一次，第一次导入时可能需要一点时间，因为有时需要下载并转换为它所需的内部表示。
- en: You can do things as usual here。 Let's say create a vector of zeros。 You can
    do whatever operation you want。 This is running locally in your browser。 This
    works the same in a tablet or in a cell phone。 It's running locally in your browser。
    This is a really cool demonstration of what WebAssembly can give you。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像往常一样在这里做事情。假设创建一个零向量。你可以做任何你想做的操作。这在你的浏览器中本地运行。这在平板电脑或手机上效果相同。它在你的浏览器中本地运行。这是WebAssembly能给你带来的一个非常酷的演示。
- en: '![](img/86495766b190929aba361b4772d72632_22.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_22.png)'
- en: This is something to have in mind。 How do we really implement this in the context
    of a client that wants to use some Python code instead of JavaScript？
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是需要记住的事情。我们如何在希望使用一些Python代码而不是JavaScript的客户上下文中真正实施这个？
- en: Because once again in order to run this we will need to add some JavaScript
    code。 This is a Python code。 Here we are in section 3。1。 These are very simple
    examples to demonstrate what we could do。 This is something that has a little
    bit of Python code。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因为再次强调，为了运行这个，我们需要添加一些 JavaScript 代码。这是一段 Python 代码。我们在第 3.1 节。这里有一些非常简单的示例来演示我们可以做的事情。这是包含一些
    Python 代码的内容。
- en: It has a list with some quotes and one liners。 We have a function here called
    getversion which gives us the current version of Python。 Get date and time gives
    us the time of this very instant。 It converts it into this ISO 8601 format。 Get
    quote chooses a random sentence here from this list of one liners。 We have some
    code here just to run it if you want to run it locally。 Let's do that。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个包含一些引用和单句子的列表。我们有一个名为 `getversion` 的函数，它给我们提供当前的 Python 版本。`get date and
    time` 给我们这个时刻的时间。它将其转换为 ISO 8601 格式。`get quote` 从这个单句子列表中随机选择一个句子。我们这里有一些代码，如果你想在本地运行，可以运行它。我们来试试。
- en: We need to change to the Pyodite directory。 If you are fluent in Linux terminal
    feel free to do it some other way。 Let's just look at currently what the terminal
    looks like。 If you type ls it will give you a listing of the current directory。
    We want to change here to the directory called Pyodite。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要切换到 Pyodite 目录。如果你熟悉 Linux 终端，可以随意用其他方式。让我们先看看当前终端的样子。如果你输入 `ls`，它会列出当前目录的内容。我们想要切换到名为
    Pyodite 的目录。
- en: You can do it with the command that is explained here。 This is a change directory
    with a full absolute path。 You can do it also changing with a local directory
    with a relative directory。 We want to change to Pyodite here。 This is a standard
    bash terminal。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这里解释的命令来实现。这个是使用完整绝对路径的更改目录命令。你也可以通过相对目录来更改本地目录。我们想要更改到 Pyodite 目录。这是一个标准的
    bash 终端。
- en: If you have ever used it remember you can use tab to do quick competitions。
    You can use it up and down hours to go through the history of your command。 That
    will allow you to go a little bit faster。 If we list the contents here of our
    current directory。 We have here a fav icon。 We have an index HTML。 We have some
    Python code。py。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过它，请记得可以使用 Tab 来进行快速补全。你可以使用上下箭头浏览命令历史。这将使你更快一些。如果我们列出当前目录的内容。我们这里有一个
    fav icon。我们有一个 index HTML。我们还有一些 Python 代码。py。
- en: Let's run this some Python code。 The typical way of running this is just putting
    Python and then the name of your script。 This runs the three functions we defined
    a moment ago。 The first one gives us what version of Python we are using。 It gives
    us the current date of your system。 It is using the UTC。 We are running this on
    the cloud。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一些 Python 代码。运行它的典型方法就是输入 Python 然后是脚本名称。这会运行我们刚才定义的三个函数。第一个函数告诉我们正在使用哪个版本的
    Python。它给我们当前的系统日期。它使用的是 UTC。我们在云端运行这个。
- en: It uses the hour of the time and date of our server。 It is not the local computer
    that we are using。 It is the server that we are running this code on。 Remember
    this is being executed on the cloud。 The GitHub cloud。 Here we have a random message
    here。 If we run it again。 Sometimes you do get some different funny quotes over
    here。 Once again here the hour。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用的是我们服务器的时间和日期。并不是我们正在使用的本地计算机。是我们在其上运行此代码的服务器。请记住，这是在云端执行的。GitHub 云。这里我们有一条随机消息。如果我们再次运行它。有时你会在这里看到一些不同的有趣引用。再一次，这里是时间。
- en: the time is specifically here。 The servers typically work with a universal coordinated
    time。 We get here a normalized time instead of our local time。 This is the command
    to run the code that we just used。 This is what you probably something similar
    you get to use。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的时间特别重要。服务器通常使用协调世界时间。我们得到的是规范化时间，而不是本地时间。这是我们刚刚使用的运行代码的命令。这可能是你用过的类似命令。
- en: How do we integrate this with a web page？ We have here an index file has what
    we need to do in order to。 integrate this with PyDide and run a program in the
    browser。 Important things you need to do here is to use a script tag over。 here
    where you are accessing the PyDide code necessary to run all， the files。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将这个与网页集成？我们这里的 index 文件包含我们需要做的事情，以便将其与 PyDide 集成并在浏览器中运行程序。你需要做的几个重要事情是使用
    `<script>` 标签，在这里访问运行所有文件所需的 PyDide 代码。
- en: This is really just an ordinary web page that has a few paragraphs， with some
    IDs。 We use the IDs to update the contents of these paragraph tags。 We need to
    put some JavaScript here。 This is the only JavaScript we are going to be using
    during this， tutorial。 You have here your main function that loads the PyDide
    module， here。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上只是一个普通的网页，包含了几个段落，带有一些 ID。我们使用这些 ID 来更新这些段落标签的内容。我们需要在这里放一些 JavaScript。这是我们在本教程中要使用的唯一
    JavaScript。你在这里有一个加载 PyDide 模块的主函数。
- en: We are using some synchronous code here。 This part runs Python code of the code
    that we saw a moment ago。 written in ordinary standard Python。 We fetch it。 We
    get it in our browser available to be run by the web。 assembly C Python implementation
    that we actually obtain with。 this source of the script of our PyDide module。
    Here we actually go -- let's make this a little bit smaller。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用一些同步代码。这部分运行我们刚刚看到的 Python 代码，使用普通标准的 Python 编写。我们获取它。我们在浏览器中可以运行它，由网络提供。我们实际上通过
    PyDide 模块的脚本源获得这个 C Python 实现。现在我们实际上去——让我们把这个缩小一点。
- en: This part here is the specific code on JavaScript that is calling， our Python
    functions。 Here we call the get version， here we call get date and time， here
    we call get quote。 All this actually calls the functions that we were looking
    at， a moment ago。 Let's open it here。 You want to see that code open here， this
    section， that is the， file explorer。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的部分是调用我们 Python 函数的特定 JavaScript 代码。这里我们调用获取版本，这里我们调用获取日期和时间，这里我们调用获取引用。所有这些实际上都是调用我们刚刚查看的函数。让我们在这里打开。你想看到这个代码在这里打开，这个部分是文件资源管理器。
- en: We are at the PyDide directory now。 If we open some Python code， this file contains
    here our code。 that we saw a moment ago in Python。 The functions that are getting
    called is this one here。 the get version， the get date and time， and the get quote。
    These are being called by the JavaScript in the index HTML file。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在 PyDide 目录。如果我们打开一些 Python 代码，这个文件包含了我们刚刚在 Python 中看到的代码。被调用的函数就是这里的这个，获取版本、获取日期和时间，以及获取引用。这些是由
    index HTML 文件中的 JavaScript 调用的。
- en: This is where they actually get called。 Anything in Python can be translated
    into equivalent。 JavaScript objects and the other way around。 I'm keeping things
    a little bit simpler。 This actually returns get version， get date， get quote，
    they return strings。 Strings in Python are converted to strings in JavaScript。
    This is a really direct translation。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它们被实际调用的地方。Python 中的任何东西都可以转换为等效的 JavaScript 对象，反之亦然。我在这里保持事情简单。这实际上返回获取版本、获取日期、获取引用，它们返回字符串。在
    Python 中的字符串被转换为 JavaScript 中的字符串。这是一个非常直接的翻译。
- en: No additional things have to be done。 Here we just upload the paragraphs。 We
    put their inner HTML with whatever these three Python， functions actually return。
    In order to see this running， you need to type the command that， we have here
    in a moment。 which is standard command to run an， HTTP server in Python。 Just
    type that command。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要做额外的事情。这里我们只需上传段落。我们放入这些三种 Python 函数实际返回的内联 HTML。为了看到这个运行，你需要输入我们稍后提到的命令，这是一条运行
    Python HTTP 服务器的标准命令。只需输入该命令。
- en: You can just copy paste it。 You can see this runs of the module HTTP server。
    You should see in a few moments a little alert message over here。 and go with
    the button that says open browser。 Usually the browser is going to stop it because
    it's sort of like。 a pop-up window there。 You should see in your browsers a message
    saying that in this。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接复制粘贴。你可以看到这个模块 HTTP 服务器的运行。你应该会在几秒钟内看到这里的一个小提示消息，并点击“打开浏览器”的按钮。通常浏览器会阻止它，因为这有点像一个弹出窗口。你应该在浏览器中看到一条消息，说明这是在。
- en: case the browser that I'm using is prevented from opening。 Just give permissions
    for this to open。 There's my index web page where what we have here was actually，
    produced by Python。 We got Python。 the version that is running here。 Notice it's
    not the same version that we ran a moment ago。 because when we run it at the terminal
    it was running the。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我使用的浏览器被阻止打开，只需授权其打开。这是我的索引网页，这里显示的内容实际上是由 Python 生成的。我们得到了 Python。当前运行的版本。注意它与我们刚刚在终端中运行的版本不同，因为当我们在终端中运行时，它是运行的。
- en: Python interpreter installed in our environment， our workspace， provided by
    Gitpod。 Here we do see the local time， 944 and we also get to see this。 The funny
    one liner quote。 If we refresh it， you'll see an updated time over here。 Once
    again you might see a different funny quote over here。 Has everybody been able
    to run this？
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的环境中安装了Python解释器，工作区由Gitpod提供。在这里我们看到本地时间是944，并且我们也可以看到这个有趣的单行引用。如果我们刷新，你会看到这里的时间已更新。再次强调，你可能在这里看到不同的有趣引用。大家都能运行这个吗？
- en: Once again， remember to get the full experience you should， really be doing
    the exercises。 Once again anybody can decide if you just want to listen。 If you
    really want to have the experience it's really worth， doing these exercises。 This
    is one way that this could actually be seen in your， browser。 Just a quick mention
    here。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，为了获得完整的体验，你确实应该进行练习。任何人都可以决定是否只是想听听。如果你真的想体验一下，做这些练习是非常值得的。这是你在浏览器中看到的一个方式。这里快速提一下。
- en: you can use control C at the terminal。 Don't do it。 Don't do it。 At the terminal
    where the server is running just type， control C whenever you want to stop it。
    Don't stop it yet because we're still going to use it。 If you stopped it already
    just run the command again to make this， request。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在终端使用控制C。不要这样做。不要这样做。在运行服务器的终端中，只需在你想停止的时候输入控制C。还不要停止，因为我们仍然需要用到它。如果你已经停止了，只需再次运行命令以发出请求。
- en: Some typical errors that people do is they open a second。 terminal and run again
    the web server and sometimes you get。 a message saying the port is already in
    use。 If that's a case you probably need to check out all the。 terminals you have
    open and use the little garbage can here to， close all those terminals。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见错误是，人们打开第二个终端，再次运行网络服务器，有时会收到消息说端口已被占用。如果是这种情况，你可能需要检查所有打开的终端，并使用小垃圾桶关闭所有这些终端。
- en: You can use the， command and run the server。 In the most simple fashion type
    control C at the terminal and。 that stops the browser。 It's time for you to do
    your first exercise。 We're now in section 3。2。 exercise A。 It says here modify
    the get date and time function from the， Pyrdide some Python code。 You need to
    open this file if you haven't already。 It's the some Python code。py。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用命令运行服务器。在最简单的情况下，在终端中输入控制C，这样可以停止浏览器。现在是你做第一个练习的时间。我们现在在第3.2节，练习A。这里要求你修改从Pyrdide获取日期和时间的函数。你需要打开这个文件，如果你还没有打开的话。它是
    some Python code.py。
- en: You need to go to this is currently in line 27， get date and， time。 You're required
    here according to the instructions to modify this。 function so that it concatenates
    to the result。 Notice there is a variable called result。 Before you return it
    here you're required to concatenate it with， one of these two strings。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要去到当前第27行，获取日期和时间。根据指示，你需要修改这个函数，使其连接到结果。请注意，有一个变量叫做 result。在你返回它之前，你需要将其与这两个字符串之一连接。
- en: If today happens to be your birthday it should say happy， birthday to me。 If
    it's not your birthday it should have the string concatenated。 It says a very
    merry on birthday to me。 You just need to put an if there somewhere。 I leave that
    to you to check it out where that would go。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果今天恰好是你的生日，应该显示“生日快乐”。如果不是你的生日，则应该连接字符串。它会显示“非常快乐的生日”。你只需要在某个地方放一个 if。我把这留给你去检查一下该放在哪里。
- en: First test it out and once again here you can open a new， terminal here。 Probably
    to do the testing。 Let's open it here。 There's this menu over here where you have
    the three lines。 You know how this is called？ What's the hamburger menu？ Yeah。
    that's how most people actually call it。 I think it's called something like the
    collapse menu or something。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先测试一下，接下来在这里打开一个新的终端。可能是为了进行测试。我们在这里打开它。这里有一个菜单，旁边有三条线。你知道这叫什么吗？汉堡菜单。是的，大多数人就是这么称呼它的。我想它也可以叫折叠菜单之类的。
- en: Here you click it and in the terminal this allows you to create， a new terminal
    here。 Let's open a new terminal。 Notice here that I'm currently running two terminals。
    As usual make sure that because we open a new terminal type here， source followed
    by PyCon 2022。 Once again remember it's very important that whenever you open。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你点击它，在终端中这允许你创建一个新的终端。我们来打开一个新终端。请注意，我目前正在运行两个终端。像往常一样，确保我们打开新终端时输入 source
    后跟 PyCon 2022。再次提醒，每次打开时都要非常重要。
- en: a terminal that you type the source space PyCon 22 command。 Once again you can
    go from one of the previous terminal where the。 web server is running to the new
    terminal by just clicking here。 the corresponding icon for that terminal。 Once
    again let's change to the Pyodi directory。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个终端中输入 `source space PyCon 22` 命令。你可以从一个之前的终端切换到新终端，只需点击相应的图标。再次让我们切换到 Pyodi
    目录。
- en: Once again do whatever change you need to do on this code。 First test it locally
    here。 Run Python and some Python code。 We haven't changed anything so far so we're
    going to get the same。 output that we did。 You need to change this so make sure
    that it runs here locally。 Once you're sure it runs there go to your window or
    to your tab， where you have this code already。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 再次对这段代码进行你需要的任何更改。首先在这里本地测试它。运行 Python 和一些 Python 代码。到目前为止我们没有更改任何内容，所以我们将得到相同的输出。你需要进行更改，所以确保它在本地运行。一旦你确认它在那里运行，去你已有此代码的窗口或标签页。
- en: Once again if the server is still running you just need to refresh， the browser。
    You should see now the new output。 Something needs to happen inside this function。
    I'll give you。 I think it's easy。 Just a quick tip here so you don't need to check
    any， documentation。 The now variable actually has today's date。 This is the now
    variable。 That one has two attributes。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器仍在运行，你只需刷新浏览器。你现在应该能看到新的输出。这个函数内部需要发生一些事情。我会给你一个提示。我觉得这很简单。这里有一个快速提示，所以你不需要查看任何文档。now
    变量实际上是今天的日期。这就是 now 变量。它有两个属性。
- en: One is called day which is a current day and month which is， current month。
    You can use those to hard code compared through the hard。 coded values of your
    birthday whatever that happens to be。 Once you've done that and if you've done
    it properly you should。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个属性叫 day，表示当前的日子，另一个是 month，表示当前的月份。你可以使用这些进行硬编码，比较你的生日的硬编码值，无论那是什么。一旦你完成了，并且做得正确，你应该能够。
- en: see the additional string as part of your result。 If it's birthday you should
    say happy birthday to me and if it's。 not very happy。 A very merry and birthday
    to me。 How many minutes do you think you can do this？
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将额外的字符串作为结果的一部分查看。如果是生日，你应该说“祝我生日快乐”，如果不是，则说“祝我非常快乐”。你认为你能做到多少分钟？
- en: Almost done。 Great。 I'll give you five minutes。 If anybody has any questions
    you can ask me。 I could go around answering any questions or solving any， issues
    that you might have。 I'll go this other way。 Great。 Thank you。 Can I see the good？
    Yes， sure。 Let's go back to --。 Sometimes you need to do a hard refresh in your
    browser。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 快完成了。太好了。我给你五分钟。如果有人有任何问题，可以问我。我可以四处走动，回答任何问题或解决你可能遇到的任何问题。我会走这边。太好了。谢谢。我可以看看代码吗？是的，当然。让我们回到——有时你需要在浏览器中进行强制刷新。
- en: Typically in many systems you press -- I think it's shift and， press the refresh
    button。 You're missing the if to actually ask if it is or not your， birthday。
    Typically you would put now。day and compare to whatever day your， birthday is
    and so on。 According to that you place the correct string at the end of， the code。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在许多系统中，你按下——我认为是 Shift 键，然后按刷新按钮。你缺少了 if 来询问这是否是你的生日。通常你会用 now.day 和你的生日进行比较，依此类推。根据这个你在代码的末尾放置正确的字符串。
- en: I see my code in the browser。 We're talking about security。 That could be an
    issue。 You can see yes the code is visible。 You have to be careful with that。
    Use some other mechanism to store any information that might， be sensitive。 Anybody
    else finished？
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我在浏览器中看到了我的代码。我们在讨论安全性。这可能是个问题。你可以看到代码是可见的。你必须对此小心。使用其他机制存储任何可能敏感的信息。还有其他人完成了吗？
- en: Great。 Let's have a look。 Okay。 Can you see the code？ Okay。 Okay。 Yeah。 If you
    have hard coded to today's birthday。 Okay。 Thank you。 Great。 Anybody else finished
    or has any questions？ Okay。 Can you see the code？ Okay。 Great。 Awesome。 Okay。
    Yeah。 As long as it works。 Okay。 It is your birthday today or just checking if
    it does work。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了。让我们看看。好吧。你能看到代码吗？好的。好的。如果你已经硬编码为今天的生日。好的。谢谢。太好了。还有其他人完成了吗？或者有任何问题吗？好吧。你能看到代码吗？好的。太好了。好的。只要它能正常工作。好的。今天是你的生日，还是只是检查它是否有效。
- en: You put today's date。 Okay。 Awesome。 Great。 Excellent。 Thank you。 Anybody have
    any questions or any issues？ No。 It's working。 Okay。 Yeah。 Sure。 Thank you。 Okay。
    Awesome。 Thank you。 Okay。 Great。 Okay。 Okay。 Okay。 Okay。 Okay。 Okay。 Okay。 Okay。
    Okay。 So what I've seen so far， the people who showed them the code， the code
    is working fine。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你填入今天的日期。好的。太好了。很棒。谢谢。有谁有任何问题或疑问吗？没有。它正在工作。好的。是的。好的。谢谢。好的。太好了。谢谢。好的。很好。好的。好的。好的。好的。好的。好的。好的。好的。所以到目前为止，我所看到的是，给他们展示代码的人，代码运行良好。
- en: So thank you very much。 Let's go to the next section。 Because there's still
    a lot of things to cover。 We're going to leave aside what we did a moment ago。
    which is， programming or using Python to program code that is going to be run
    by the browser。 As you can see， we were able to have our code written Python running
    in an ordinary Python。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢。让我们进入下一部分。因为还有很多内容要覆盖。我们将搁置刚才所做的内容，即编写或使用Python编写将由浏览器运行的代码。如你所见，我们能够在普通的Python中运行我们用Python编写的代码。
- en: interpreter locally in our cloud in the server provided by Gitpot。 But also
    we saw that we were able to use Pi。I to run it in the browser。 So that gives us
    some interesting new possibilities。 Okay。 Let's look at WebAssembly a little bit
    more in detail。 Okay。 So， I mean。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Gitpot提供的服务器上本地解释器。但我们也发现我们能够使用Pi。I在浏览器中运行它。这给我们带来了一些有趣的新可能性。好的。让我们更详细地看一下WebAssembly。好的。我的意思是。
- en: so far we've just been using WebAssembly without really looking at how it works
    and how。 it actually behaves internally。 Okay。 So we're going to do some exercises
    here that once again。 this is not the typical use case， of WebAssembly， but it
    does give a lot of insight。 Okay。 It's something that really is educational。 Okay。
    Once again， remember。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是在使用WebAssembly，而没有真正查看它是如何工作的以及它在内部的表现。好的。所以我们将在这里做一些练习，再次说明。这不是WebAssembly的典型用例，但确实提供了很多见解。好的。这确实是有教育意义的。好的。再次记住。
- en: WebAssembly is typically produced by some other tool by a compiler。 But it is
    possible to write it by hand。 And we're going to use this format called WebAssembly
    text format。 Okay。 We're going to distinguish these two formats。 When we talk
    about Wasm。 we're talking about the WebAssembly binary format， which is really，
    what the technology is。 Okay。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly通常由编译器等其他工具生成。但手动编写也是可能的。我们将使用这种称为WebAssembly文本格式的格式。好的。我们将区分这两种格式。当我们谈论Wasm时，我们在谈论WebAssembly二进制格式，这实际上就是这项技术的本质。好的。
- en: But there is a counterpart that is represented textually， which is called WebAssembly
    text format。 Okay。 And we usually just call it wet。 Okay。 So there's Wasm， which
    is binary。 There's wet。 which is textual。 Okay。 And when we run， when we actually
    write it by hand。 what we're going to be writing is wet。 And we need a tool to
    translate what， which is textual。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一个以文本形式表示的对应物，称为WebAssembly文本格式。好的。我们通常称之为wet。好的。所以有Wasm，它是二进制的。还有wet，它是文本的。好的。当我们运行时，实际上我们手动编写的就是wet。我们需要一个工具来翻译文本形式的内容。
- en: into Wasm， which is in binary form。 Okay。 So， first out of curiosity。 has anybody
    programmed any kind of assembly language before？ Oh， several of you have experience。
    Okay。 I used to teach assembly language about 20 years ago。 X86 assembly language。
    Okay。 So compared to those assembly languages of the past， I mean， even when I
    was in school actually。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 变为Wasm，它是二进制格式。好的。所以，首先出于好奇。有没有人以前编写过任何类型的汇编语言？哦，几位你们有经验。好的。我大约20年前教过汇编语言。X86汇编语言。好的。与过去的汇编语言相比，我的意思是，甚至在我上学的时候。
- en: I think I programmed assembly language for the 6502 processor。 6502 was the
    processor that was available for the Apple IIs。 I don't know if you remember those
    kinds of computers。 I mean， I'm talking about the mid-1980s。 Well， WebAssembly
    in its textual format is similar to that。 It's a really low-level language。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得我为6502处理器编写过汇编语言。6502是Apple II可用的处理器。我不知道你是否记得那种计算机。我是在谈论1980年代中期。嗯，WebAssembly的文本格式与此类似。这是一种非常低级的语言。
- en: But we're going to see that it's stack-based。 Okay。 So this requires a little
    bit of thinking。 a little bit of different from most traditional， assembly languages
    that are available for different real hardware CPUs。 which typically are based
    on registers。 Here we're going to see whether assembly is a stack-based。 And we're
    going to see what that means in a moment。 Okay。 But first of all。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们将看到它是基于栈的。好的。这需要一些思考，与大多数传统的可用于不同真实硬件CPU的汇编语言有些不同，后者通常是基于寄存器的。在这里，我们将看到汇编是基于栈的。我们马上就会看到这意味着什么。好的。但首先。
- en: we need to mention that WebAssembly actually works with， in the textual format。
    works with S expressions。 So this is what an S expression looks like。 Okay。 This
    is。 we're in section 4。1。 So， an S expression， something that starts with an opening
    parentheses。 then has some symbols or elements there。 Okay。 And then a closing
    parentheses。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提到WebAssembly实际上是以文本格式工作的，使用S表达式。所以这就是S表达式的样子。好的。这是。我们在第4.1节。所以，S表达式是以一个开括号开始。然后有一些符号或元素。好的。最后是一个闭括号。
- en: Those symbols or elements that are nested can be all their S expressions。 Okay。
    So this notation was actually first used in LISP in the late 1950s。 If anyone
    has used LISP or any of its variants before， it could be， I don't know， scheme，
    racket。 closure or any of these languages。 This is the same notation that is actually
    used there。 Okay。 Yes。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 那些嵌套的符号或元素可以都是他们的S表达式。好的。所以这种表示法实际上是1950年代末首次在LISP中使用的。如果有人以前使用过LISP或其任何变体，可能是，我不知道，Scheme、Racket、Closure或这些语言。这是那里实际使用的相同表示法。好的。是的。
- en: they're called S expressions。 Okay。 If you haven't used it before， no， don't
    worry。 Okay。 You'll have a chance to look or use this notation just briefly。 Okay。
    So， well。 we're going to be writing our code using S expressions。 A quick reminder
    here。 We've mentioned this already。 There are only four data types supported in
    WebAssembly。 Okay。 So。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 它们被称为S表达式。好的。如果你之前没有使用过，没关系。好的。你会有机会简要地查看或使用这种表示法。好的。所以，好的。我们将使用S表达式编写我们的代码。这里提醒一下。我们已经提到过这一点。WebAssembly只支持四种数据类型。好的。所以。
- en: we got an I32， which represents a 32-bit integer。 An I64， which is a 64-bit
    integer。 can be positive or negative numbers。 Okay。 And we also have two versions
    of floating point numbers。 32-bit float， which is called F32。 And F64， which is
    a 64-bit floating point number。 Okay。 So。 these floating point numbers usually
    are equivalent to floats and doubles in other， languages。 Yes。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个I32，表示32位整数。一个I64，是64位整数，可以是正数或负数。好的。我们还有两种版本的浮点数。32位浮点数，称为F32。和F64，是64位浮点数。好的。所以。这些浮点数通常等同于其他语言中的浮点数和双精度数。是的。
- en: '[inaudible]， I think they actually decided to use these because that''s typically
    what is supported in most。 physical， real hardware CPUs。 Okay。 I mean， x86 actually
    supports also the extended floating point format。 which is 80 bits， of the data。
    But it''s not very common in modern years because。 as I''ve seen at least most
    of the variations， of SIMD instructions and so on are typically used at most 64-bit
    floats。'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[听不清]，我想他们实际上决定使用这些，因为这是大多数物理、真实硬件CPU通常支持的格式。好的。我是说，x86实际上也支持扩展浮点格式，即80位的数据。但在现代几年中并不常见，因为我看到的，至少大多数的SIMD指令变体等通常最多使用64位浮点数。'
- en: Okay。 So， I think it was more of a decision because of what hardware is currently
    used and was。 easier to translate from WebAssembly to a real hardware CPU。 Okay。
    And， well。 it is a coincidence actually here that F64 is the data type supported
    by JavaScript。 Okay。 But JavaScript， for example， does not support I64。 Okay。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以，我认为这更多是因为当前使用的硬件的决定，更容易将WebAssembly转换为真实硬件CPU。好的。而且，实际上这里有个巧合，F64是JavaScript支持的数据类型。好的。但JavaScript，例如，不支持I64。好的。
- en: There's no way of directly supporting in JavaScript 64-bit integers。 Okay。 Because
    in JavaScript everything is actually a float。 Okay。 64-bit float in practice。
    Okay。 Okay。 Let's just mention here on our stack。 What is a stack machine？
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，没有直接支持64位整数的方法。好的。因为在JavaScript中，一切实际上都是浮点数。好的。64位浮点数在实际中。好的。好的。我们在这里提一下我们的栈。什么是栈机器？
- en: Let's start discussing what a stack is。 Okay。 A stack is a data structure。 Okay。
    If you've taken a data structure course in the past， this should probably be very，
    very， familiar。 So a stack is just a collection where all the elements are inserted
    and removed from the。 same place。 Okay。 So if we think of it as a stock， for example。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始讨论栈是什么。好的。栈是一种数据结构。好的。如果你以前上过数据结构课程，这应该是非常非常熟悉的。因此，栈只是一个集合，所有元素都是从同一个地方插入和移除的。好的。如果我们把它想象成一个库存，例如。
- en: here in our illustration stack of pancakes， whenever you want to add a pancake。
    you put it on the top。 Okay。 And whenever you want to remove it。 you remove the
    one that is most out of the top。 So we say that this data structure works using
    a LIFO policy or you pronounce it LIFO。 Not really sure。 Last in， first out， way。
    Okay。 Sometimes if I pronounce words a little bit strange。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的插图中，像一堆煎饼一样，每当你想添加一个煎饼时，你就把它放在顶部。好的。而每当你想移除它时，你就移除最上面的那个。所以我们说这个数据结构使用LIFO策略，或者你可以发音为LIFO。不太确定。后进先出，方式。好的。有时候我发音有点奇怪。
- en: just have in mind that my native language， is Spanish。 So many of these words
    I only see them reading。 So sometimes I don't necessarily know how they pronounce
    it。 I just pronounce them as I imagine。 Okay。 But it's not necessarily the correct
    way。 Okay。 So this is how the evaluation of all computations actually take place
    in WebAssembly。 Okay。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我的母语是西班牙语。因此，很多单词我只是通过阅读才见过。所以有时候我不一定知道它们的发音。我只是按照我想象的方式发音。好的。但这不一定是正确的方式。好的。这就是所有计算在WebAssembly中实际进行的评估方式。好的。
- en: So for example， if I want to add two numbers， let's say that I want to add a
    seven and， five。 Okay。 These are the steps that I need to do。 Okay。 As mentioned
    over here。 So I want to add seven plus five。 So what do I do？ I push first the
    seven and the stack。 Then I push the five on the stack。 Okay。 So now we have a
    stack if we want to imagine it going from the bottom growing upwards。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，如果我想加两个数字，假设我想加七和五。好的。这是我需要做的步骤。好的。如这里提到的。我想加七加五。那么我该怎么做？我先把七压入栈中。然后把五压入栈中。好的。所以现在我们有一个栈，如果想象的话，它是从底部向上生长的。
- en: Okay。 We got a seven and then upwards we got a five。 And then when we do the
    add。 the add actually involves popping the two elements on the top， of the stack。
    Okay。 We pop them。 which means we remove them。 We apply the operation， in this
    case the addition。 We get the result and we place the result， we push it into
    the stack again。 Okay。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们得到了七，然后在上面是五。当我们进行加法时，实际上涉及到弹出栈顶的两个元素。好的。我们弹出它们，这意味着我们移除它们。我们执行操作，在这个例子中是加法。我们得到结果，然后把结果压回栈中。好的。
- en: So this is described here， but we have a better illustration just down over
    here。 Okay。 So this probably is a little bit easier to understand。 So there we
    go。 And step number one。 we push the seven。 Okay。 Step number two， we push the
    five。 So as you can see here。 we got the five and the seven。 Okay。 The five is
    the top， the top of the stack。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里有描述，但我们在下面有一个更好的插图。好的。所以这可能更容易理解。那么，第一步。我们压入七。好的。第二步，我们压入五。所以如你所见，我们得到了五和七。好的。五在最上面，栈的顶部。
- en: The seven is just underneath the top。 And then we do a pop here。 Now the order
    of the pops。 I mean you can only do the pop with whatever is there。 Okay。 But
    we're doing two pops。 An important thing that you need to understand is that we
    pop the first element and this。 is going to be the second operand in the operation。
    Okay。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 七就在顶部的下面。然后我们在这里执行一个弹出操作。现在弹出的顺序。我是说你只能弹出栈中现有的元素。好的。但我们进行两个弹出。你需要理解的一件重要事情是，我们弹出第一个元素，这将是操作中的第二个操作数。好的。
- en: I mean at this point it really doesn't matter because in the example we're doing
    addition。 But when you do operations that are not commutative like subtraction
    and division， the ordering。 which things actually are carry out is very， very
    important。 Now the easiest thing here to remember is that if I want for example
    to subtract two， numbers， okay。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我是说，在这一点上其实并不重要，因为在我们做的例子中我们是在加法。但当你做一些不是可交换的操作，比如减法和除法时，顺序是非常非常重要的。现在这里最简单的记住的一点是，如果我想减去两个数字，好的。
- en: I push the elements in that and the same ordering which I think that's。 subtraction
    is going to be taking place。 So for example， if instead of adding seven plus five。
    I want to do seven minus five， I， still push them in the same order。 You push
    the seven。 push the five and when it pops， even though the second operand is going，
    to be popped first， okay。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我将元素按相同的顺序推入，并且我认为这将会进行减法。所以例如，如果我想进行七减五，而不是七加五，我仍然按相同的顺序推入。你推入七，推入五，尽管第二个操作数将首先被弹出，好的。
- en: it's going to be used in the correct place。 Okay。 So as you can see here in
    the illustration， okay。 we pop the first element and this is， going to be the
    second operand and we pop the one that was in the bottom here and that's。 going
    to be the first operand and then we carry out the operation， seven plus five or。
    whatever operation it was and we push the result into the stack。 Okay。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 它将被用于正确的位置。好的。所以如您在插图中所见，好的。我们弹出了第一个元素，这将是第二个操作数，然后我们弹出了底部的元素，那将是第一个操作数，然后我们执行运算，七加五或者无论它是什么运算，然后将结果推入栈中。好的。
- en: So we're going to do the same thing here。 So we're going to do the same thing
    here。 So we're going to do the same thing here。 So we're going to do the same
    thing here。 So we're going to do the same thing here。 So we're going to do the
    same thing here。 So we're going to do the same thing here。 So we're going to do
    the same thing here。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。
- en: So we're going to do the same thing here。 So we're going to do the same thing
    here。 So we're going to do the same thing here。 So we're going to do the same
    thing here。 So we're going to do the same thing here。 So we're going to do the
    same thing here。 So we're going to do the same thing here。 So we're going to do
    the same thing here。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。
- en: So we're going to do the same thing here。 So we're going to do the same thing
    here。 So we're going to do the same thing here。 So we're going to do the same
    thing here。 So we're going to do the same thing here。 So we're going to do the
    same thing here。 So we're going to do the same thing here。 So we're going to do
    the same thing here。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。
- en: So we're going to do the same thing here。 So we're going to do the same thing
    here。 So we're going to do the same thing here。 So we're going to do the same
    thing here。 So we're going to do the same thing here。 So we're going to do the
    same thing here。 So we're going to do the same thing here。 So we're going to do
    the same thing here。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。所以我们在这里要做同样的事情。
- en: So we need to prefix the type of data that we're pushing and that we're popping。
    So we always need to provide if this is a 932， a 964， or a 932 or a 564。 Typically。
    most of the examples that we're going to see， we're only using always one single
    data type。 But it is possible to do conversions between the data types。 But at
    this moment。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们需要前缀化我们正在推送和弹出的数据类型。所以我们总是需要提供这是`932`、`964`、`932`还是`564`。通常情况下，我们将要看到的大多数例子中，我们只会使用一种数据类型。但是在数据类型之间进行转换是可能的。但在此时。
- en: we're not going to be doing that。 But it is possible if it's required。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会这样做。但是如果需要，这是可能的。
- en: '![](img/86495766b190929aba361b4772d72632_24.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_24.png)'
- en: So let's have a look at a complete example here。 There is in the what directory。
    There is an examples。what file。 So let's open that one。 We can close this now
    and we can now shut down our server。 So open the terminal that currently has your
    server and just type control C to abort it。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们来看一个完整的例子。这里有一个`what`目录。里面有一个`examples.what`文件。所以让我们打开它。现在可以关闭这个，然后我们可以关闭我们的服务器。所以打开当前运行服务器的终端，输入控制+C来中止它。
- en: And I don't think we're going to be using that one again。 So we can send it
    to the garbage。 And we currently only have this other terminal currently here。
    So we're going to change our directory in a moment。 But let's open here the wet
    folder。 And there's only one file there。 Examples。what。 So this is a complete
    full example of what。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们不会再使用那个。所以我们可以把它扔掉。目前我们这里只有这个终端。所以我们很快会改变目录。但让我们打开这里的wet文件夹。那里只有一个文件，Examples.what。所以这是一个完整的what示例。
- en: of a wet source file。 WebAssembly text formats。 Do you get to see it in colors
    or is everything in the same color？
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 个wet源文件。WebAssembly文本格式。你能看到颜色吗，还是所有内容都是同一种颜色？
- en: If you want to see it in color， just go to the extensions icon over here。 And
    the extensions called WebAssembly。 Okay。 Type WebAssembly there。 And it's the
    very first option here。 I currently have it installed and thanks to that we get
    to see it in color here。 Okay。 But probably makes sense that you also get the
    support for syntax highlight。 Okay。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到颜色，只需点击这边的扩展图标。这个扩展叫做WebAssembly。好的，在那里输入WebAssembly。这是第一个选项。我目前已安装它，得益于此，我们在这里可以看到颜色。好的。但你可能也应该获得语法高亮的支持。好的。
- en: We live in an area where we do have syntax highlights so we should use it whenever
    possible。 I remember when I was studying my undergrad degree。 In the very first
    semester I had a classmate that actually， we were programming at that time。 It
    was Pascal what we were learning。 And we were using Turbo Pascal at that time
    and didn't have syntax highlight。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在一个有语法高亮的环境中，所以我们应该尽可能使用它。我记得我本科时的学习经历。在第一学期，我有一个同班同学，那时我们正在编程。我们学习的是Pascal，使用的是Turbo
    Pascal，当时并没有语法高亮。
- en: Once again， remember I'm talking about the mid 1980s。 Okay。 Syntech highlight
    was at least available in the boardland products like Turbo C and Turbo Pascal
    until almost the beginning of the 1990s。 But before that everything appeared exactly
    in the editor in one single color。 Okay。 So I remember that he was working in
    his final project for CS1 and suddenly everything stopped working。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，我说的是1980年代中期。好的。语法高亮至少在Turbo C和Turbo Pascal等Borland产品中可用，直到90年代初。但在此之前，编辑器中的所有内容都是一种颜色。好的。我记得他在做CS1的最终项目时，突然一切停止工作。
- en: He started getting a lot of errors。 And because he actually mistakenly deleted
    the closing symbols or symbols that were required for a block comment。 Okay。 And
    it was very easy to do that。 I mean it's just the line that he accidentally deleted。
    But because you don't see the colors you always see it was actually the same。
    Suddenly things stopped working and it took him about， I don't know， three。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 他开始出现很多错误。因为他错误地删除了闭合符号或块注释所需的符号。好的。这很容易做到。我是说他不小心删除的就是那一行。但因为你看不到颜色，总是感觉是一样的。突然之间事情就停止工作了，他花了大约，我不知道，三。
- en: four hours to actually see the error。 And he was really getting very， very upset。
    Okay。 And until somebody said， oh you forgot to close this comment。 And once again
    it wasn't that he hadn't closed it originally。 It was that he accidentally deleted
    the symbol that was used to close the block。 Okay。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 他花了四个小时才发现错误。他真的非常，非常沮丧。好的。直到有人说，哦，你忘了关闭这个注释。再一次，并不是说他最初没有关闭，而是他不小心删除了用于关闭块的符号。好的。
- en: So once again this is a situation that could have been avoided if we had syntax
    highlight。 So this is a program notice here。 It starts with an opening parentheses
    and we have here a module。 Everything in WebAssembly， every program that we write
    in WebAssembly or that is produced is inside a module。 Okay。 The module can have
    several things。 Okay。 I'm really omitting a lot of information but WebAssembly
    modules inside。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，再一次，这是一种可以避免的情况，如果我们有语法高亮就好了。这是一个程序通知。它以一个左括号开始，这里有一个模块。在WebAssembly中，我们编写的每个程序或生成的内容都在一个模块内。好的。模块可以包含多个内容。好的。我省略了很多信息，但WebAssembly模块就在里面。
- en: they can have one big memory object， okay， which can be used for any kind of
    information that you want to store as a big array of bytes。 Okay。 You have tables
    that allow you to have pointers to functions and so on。 These are used for implementing，
    for example， pointers to functions in languages like C or virtual functions like
    are supported in object-oriented languages like C++。 You don't need to use them
    and we're not going to use them here。 Okay。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以有一个大的内存对象，好的，可以用于存储你想作为字节大数组的任何信息。好的。你有表，可以让你指向函数等等。这些用于实现，例如，在 C 语言中指向函数的指针或在
    C++ 等面向对象语言中支持的虚拟函数。你不需要使用它们，我们在这里也不打算使用。好的。
- en: But they are available to provide that functionality。 You can have functions。
    you can have global variables， you have a question？ [ Inaudible ]， Yes？ [ Inaudible
    ]， Yeah。 exactly。 Yes， notice that we're not providing an explicit name of the
    module。 not in the declaration line number one。 It is the name of the module is
    the name of the file with the Wasm extension。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们可用来提供该功能。你可以有函数，可以有全局变量，有问题吗？[听不清]，是吗？[听不清]，对，没错。是的，注意我们没有提供模块的显式名称。没有在声明的第一行中。模块的名称是具有
    Wasm 扩展名的文件名称。
- en: Remember here it's a WAD extension because we're using the textual format。 Okay。
    So here because this is probably the most interesting part， we're just defining
    one function。 Notice here once again it starts with an opening parenthesis here
    and this one is closing it。 The closing parenthesis that we have here in line
    22 is the one that corresponds to the module。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这里是 WAD 扩展，因为我们使用的是文本格式。好的。所以这里因为这可能是最有趣的部分，我们仅定义一个函数。注意这里再次，它以一个左括号开始，这里是关闭它的右括号。我们在第
    22 行的右括号对应于模块。
- en: Okay。 Remember this is the expression format。 Okay。 So here we have several。
    we can call these directives。 We have an export。 This is the name that is going
    to be available for external tools。 Okay。 So any external tool that wants to use
    this Wasm module once it's converted into Wasm will be able to use the name that
    we are exporting。 If we don't export it， it's private to the module。 Okay。 Actually
    the name of the local。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。记住这是表达式格式。好的。在这里我们有几个，我们可以称之为指令。我们有一个导出。这是将对外工具可用的名称。好的。任何想要使用这个 Wasm 模块的外部工具，一旦转换为
    Wasm，就能使用我们导出的名称。如果我们不导出，它对模块是私有的。好的。实际上是局部的名称。
- en: locally here in line number 10， I'm using the same name， A-V-G。 but just notice
    that these local names that we use inside our WebAssembly Text Format code have
    to start with a dollar sign。 Okay。 So you can see it here。 The name of the function，
    if you wanted to use it locally。 strictly this part wasn't really required because
    I never call it from within this code。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 10 行这里，我使用相同的名称，A-V-G。但请注意，我们在 WebAssembly 文本格式代码中使用的这些局部名称必须以美元符号开头。好的。所以你可以在这里看到。如果你想在本地使用它，函数的名称。严格来说，这部分并不是必需的，因为我从未在这个代码中调用它。
- en: within another function here。 Okay。 So if I needed to call it， I would use this
    name。 but it's only available local here。 Okay。 Because I exported here。 this
    allows other tools to actually call this code， whatever it's required。 Here we
    define the parameters。 Okay。 Notice that I'm using here this is actually Python。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里是另一个函数。好的。如果我需要调用它，我会使用这个名称。但它仅在这里是局部可用的。好的。因为我在这里导出了它。这允许其他工具实际上调用这段代码，无论需要什么。在这里我们定义参数。好的。注意我在这里使用的实际上是
    Python。
- en: but using some type annotations。 Okay。 Just to explain what it is。 It's saying
    here A is a float。 B is a float， and it returns a float。 Okay。 So I'm putting
    over here。 So A and B are F64 data types。 variables of this data type， they're
    parameters。 Okay。 They're considered inputs。 And the output。 the output is a，
    notice here it says result。 We're telling that at the very end of the execution
    of this function。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用了一些类型注解。好的。只是为了说明这是什么。这里说明 A 是一个浮点数，B 是一个浮点数，并且它返回一个浮点数。好的。所以我把它放在这里。A 和
    B 是 F64 数据类型。这些数据类型的变量是参数。好的。它们被视为输入。而输出，注意这里说的是结果。我们在函数执行的最后告诉这个信息。
- en: there should be in the top of the stack one only item and that item has to be
    an F64。 Okay。 If there are more elements， this actually produces a validation
    error。 Okay。 So we have to be very careful that if we push elements into the stack。
    at some point we take them back， and that we only leave if this function is actually
    returning a result。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 栈顶应该只有一个项，并且该项必须是 F64。如果有多个元素，这将产生验证错误。因此，我们必须非常小心，如果我们将元素推入栈中，在某个时刻我们将它们取回，并且我们只在此函数返回结果时才留下。
- en: we only leave one result in the top of the stack。 Okay。 The function does not
    require to return anything if we want to。 Okay。 That would be an equivalent to
    a void function in other languages。 And if that's the case。 you need to leave
    the stack empty without any elements in the top of the stack。 Okay。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只在栈顶留下一个结果。好的。如果我们想的话，函数不要求返回任何内容。好的。这将相当于其他语言中的 void 函数。如果是这样，你需要在栈顶不留下任何元素。
- en: And here is the code， what you see here in this sort of pinkish color。 Okay。
    So you do a local get a， so what does this do？ It reads the variable a， the parameter
    a。 and pushes it into the top of the stack。 And then we do the same thing with
    b。 So currently in the stack we have a and b， we have in the bottom we have b。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码，你看到的这种粉红色。好的。所以你进行一个本地获取 a，那么这会做什么？它读取变量 a，参数 a，并将其推入栈顶。然后我们对 b 做同样的事情。所以目前在栈中我们有
    a 和 b，底部是 b。
- en: and then we have the value of a in the top of the stack。 We do an F64 add here
    in line number 17。 And when we do that， we pop to top elements in the top of the
    stack。 From the top of the stack。 we do the operation in this case addition， and
    we place the result in the stack again。 Okay。 And upon， so then in a， in a， in
    a push operation。 Okay。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在栈顶有 a 的值。在第 17 行我们进行一个 F64 的加法。当我们这样做时，我们从栈顶弹出两个元素。在栈顶进行的操作是加法，并将结果再次放入栈中。好的。在推送操作中。
- en: And then we push the value to on the top of the stack， and now we do a div。
    Okay。 And as I explained in the order in which the elements were actually pushed。
    this is how the division is going to be carried out。 Okay。 So the division is
    going to divide the result of the add by two。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将值推送到栈顶，现在我们进行除法。好的。如我所解释的，元素推送的顺序就是执行除法的方式。所以除法将把加法的结果除以二。
- en: Because those are the two values in top of the stack。 Those are divided。 and
    the result is placed on the top of the stack。 Okay。 And we leave the top of the
    stack with that value。 That's what is going to be returned。 Okay。 There is a return
    instruction that you could use if you want it。 Okay。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因为栈顶的两个值将被除以，结果将放在栈顶。好的。我们将以该值离开栈顶。这就是将要返回的内容。好的。如果你想，可以使用返回指令。
- en: But it's not really required if it's a very last instruction in your function。
    Okay。 Yes。 It doesn't， it doesn't have any artificial limitation。 Okay。 I mean，
    everything in life has a limit。 Okay。 So I can't really say， oh yeah， you can
    use all your memory in the stack。 But there's no limitation initially。 Okay。 Now
    remember that this code here once it gets translated to。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果这是函数中的最后一条指令，则并不真正需要。好的。是的。它没有任何人为的限制。好的。我是说，生活中的一切都有极限。好的。因此，我不能真的说，你可以在栈中使用所有的内存。但最初没有限制。好的。现在记住，这段代码一旦被翻译成。
- en: to Wasm。 The runtime environment is typically going to do a just in time compilation
    of the web assembly。 So that it gets translated from this web assembly binary
    format into， once again， this can be。 done in several ways。 But the， the JIT or
    just in time compiler takes the。 the code and translated into native machine，
    code in your platform。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Wasm，运行时环境通常会对 WebAssembly 进行即时编译。因此，它将从这种 WebAssembly 二进制格式转换为，这可以通过多种方式完成。但
    JIT 或即时编译器将代码转换为你平台上的本机机器代码。
- en: whatever platform is where you're actually running this code。 So most of our
    real hardware CPUs that we use are typically register based。 They're not stack
    based。 So this means that we'll need to use some registers and some additional
    memory in case not everything。 fits。 But in general， all that part is actually
    sold by the implementer of， of the runtime system。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 不论你实际运行此代码的平台是什么，我们所使用的大多数真实硬件 CPU 通常是基于寄存器的，而不是基于栈的。这意味着我们需要使用一些寄存器和额外的内存，以防并非所有内容都适合。但总体而言，这部分实际上是由运行时系统的实现者提供的。
- en: Okay。 So we don't really need to， to put any limitations。 I haven't read anywhere
    that says that there is a limit to how many elements you can put in。 the stack。
    But in practice， I've seen that you usually don't need more than four or five
    elements in the。 stack at the same time。 Yeah。 Exactly。 Yeah。 Just in case you
    didn't listen。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以我们不需要施加任何限制。我没有看到任何地方说有对堆栈中可以放置的元素数量的限制。但实际上，我看到你通常不需要同时放置超过四个或五个元素。是的。正是如此。以防你没听到。
- en: the observation that he does is that the specification and。 the way that the
    virtual machine works is， as a stack machine。 Okay。 But once this trippical gets
    translated using the just in time compiler， once again， this。 really depends on
    how it's implemented by the runtime system。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 他观察到的是，规范和虚拟机的工作方式是作为堆栈机器。好的。但是一旦这个典型的被即时编译器翻译，这又取决于运行时系统的实现方式。
- en: Typically needs to convert this same code into the instruction set of a register
    computer。 Okay。 For example， when you run this in your， most of you probably using
    an x86 base machine， some。 of you， if you're using a recent version of Mac OS，
    probably you're using M1。 So when we actually loaded Pyodiode， it translated into
    the corresponding native instruction set。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通常需要将相同的代码转换为寄存器计算机的指令集。好的。例如，当你在你的大多数人可能使用的x86基础机器上运行这个时，如果你使用的是最近版本的Mac OS，可能你正在使用M1。所以当我们实际加载Pyodiode时，它被翻译为相应的本地指令集。
- en: And most of the CPUs used in hardware currently are typically register based。
    Okay。 But once again。 that translation happens automatically。 You don't really
    need to be aware of it。 Yes。 [inaudible]。 That you could use？ What？ [inaudible]，
    Oh， yes， of course。 Yeah。 [inaudible]， Yeah。 You need to just check if there is
    an implementation of the application。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 目前大多数硬件中使用的CPU通常是基于寄存器的。好的。但是，再次强调，这种翻译是自动发生的。你不需要特别关注。是的。[听不见]。你能使用什么？什么？[听不见]，哦，是的，当然。是的。[听不见]，是的。你只需要检查应用程序是否有实现。
- en: So implementation of the WebAssembly runtime system in some fashion。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 所以以某种方式实现WebAssembly运行时系统。
- en: '![](img/86495766b190929aba361b4772d72632_26.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_26.png)'
- en: Okay。 And if that's a case， of course it is able in microcontrollers。 Okay。
    Like Raspberry Pi or？
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。如果是这种情况，当然在微控制器中是可以的。好的。像树莓派或者？
- en: '[inaudible]， Yeah， exactly。 Yes。 WebAssembly， one of the use cases it has is
    working for devices。 small devices that you use in typical， Internet of things
    kind of things。 Kind of stuff。 Okay。 Yeah。 Okay。 But once again， you need to check
    and see if there is that support for that particular hardware。 that you''re using。
    Okay。 But if there is， of course you can use it。 Yes。'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[听不见]，是的，正是如此。是的。WebAssembly的一个应用案例是为设备工作。适用于典型的物联网小设备。没错。是的。但是，再次强调，你需要检查一下是否支持你所使用的特定硬件。好的。如果支持，当然可以使用。是的。'
- en: There was a question over here。 [inaudible]， It actually does。 If you see。 we
    actually push these two elements。 Those got popped with the add。 Then we push
    another element。 And the diff does two pops and a single push。 So at the end if
    you look at the stack。 the stack is going to only have one element。 And it is
    consistent with this directive that says it should be a 64-bit floating point
    in。
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个问题。[听不见]，实际上确实有。如果你看，我们实际上推送了这两个元素。然后被加法弹出了。接着我们又推送了一个元素。差异做了两个弹出和一个推送。因此，最终如果你看堆栈，堆栈中只会有一个元素。这与该指令一致，表示它应该是一个64位浮点数。
- en: the resulting stack。 Okay。 It is required。 If it's not， you actually get a validation
    error。 Okay。 There is before your code is actually executed， there is a face called
    validation。 We usually don't talk a lot about it， but it's part of the security
    of the system。 So one of the things that it does is make sure that the stack is
    being used in a consistent。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 结果堆栈。好的。是必需的。如果没有，你实际上会得到一个验证错误。好的。在你的代码真正执行之前，有一个叫做验证的阶段。我们通常不多谈，但这是系统安全的一部分。所以它做的事情之一是确保堆栈的一致使用。
- en: fashion。 So if you try to do， for example， a pop when there is no elements there，
    okay。 or you finish， your function and you said that this is only going to return
    one result and you have。 for， example， two values in the stack。 That actually
    produces a violation in the validation。 Yes。 [inaudible]， You get， I don't remember
    if they call it a trap。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你尝试做一个 pop，而那里没有元素，好的。或者你结束了你的函数，并且你说这只会返回一个结果，而你在堆栈中有两个值。这实际上会导致验证中的违规。是的。[听不清]，我不记得他们是否叫它一个陷阱。
- en: There is some kind of runtime exception being produced。 Okay。 Once again。 you
    can always check the documentation to see all those particular issues and I'll。
    show you where it is in a moment。 Okay。 Yes。 [inaudible]， Yeah。 [inaudible]， Yeah。
    [inaudible]。 Yeah。 [inaudible]， Yeah。 [inaudible]， No。 There is a stack per every
    block。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正在产生某种运行时异常。好的。再一次。你总是可以查看文档，看看所有这些特定的问题，我会在一会儿告诉你在哪里。好的，是的。[听不清]，是的。[听不清]，是的。[听不清]。是的。[听不清]，是的。[听不清]，不。每个块都有一个堆栈。
- en: A function creates a block but there are other instructions。 There is one actually
    called block but also there are loops and there's ifs that create。 blocks and
    each of those have their individual stack independent of any other stack that
    might。 be there。 Okay。 There is no shared stack among blocks。 Yeah。 That's right。
    Okay。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数创建一个块，但还有其他指令。实际上有一个叫做块的指令，但也有循环和 if 语句创建。块，而每个块都有其独立于其他任何堆栈的独立堆栈。好的。在块之间没有共享堆栈。是的，没错。好的。
- en: So just to use this， the way that we're going to be using this is as follows。
    Okay。 Let's go here。 We need to change to the directory for wet。 Okay。 Once again，
    you can use this instruction。 We have it here。 We're here in still in section
    4。4。 Okay。 So you can just copy paste this one。 This doesn't really matter what
    directory you are。 It will take you to wet。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 所以使用这个的方法如下。好的。我们需要切换到 wet 的目录。好的。再一次，你可以使用这个指令。我们在这里。我们还在第 4.4 节。好的。你可以直接复制粘贴这一条。这其实不管你在什么目录，它都会带你到
    wet。
- en: If you know how to navigate within the terminal， you can just go upwards to
    this directory and。 then go down to wet。 Okay。 But whatever way you do it。 it
    is important that you are in the wet directory。 Okay。 The wet directory。 if we
    check here the contents， sell us。 We only have the example of wet。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道如何在终端中导航，你可以向上到这个目录，然后再到 wet。好的。但无论你怎么做，重要的是你在 wet 目录中。好的。我们检查一下 wet 目录的内容，只包含
    wet 的示例。
- en: And this is consistent to what we see here with the explorer。 Okay。 So the first
    thing that we need to do is convert the wet sort file into binary wasm。 Okay。
    So in order to do that， we have a tool called wet to wasm。 Remember， very important。
    If the system says that it doesn't find this particular command， is that you did
    not execute。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在探索者这里看到的一致。好的。我们需要做的第一件事是将湿排序文件转换为二进制 wasm。好的。为了做到这一点，我们有一个工具叫做 wet to
    wasm。记住，这非常重要。如果系统提示找不到这个特定的命令，那是因为你没有执行。
- en: the source， PyCon 2022 instruction at the very beginning when you started， when
    you open。 your terminal。 Okay。 You can just try it。 Just type wet to wasm。 Okay。
    And if you see command。find。 here it did find it but didn't do anything。 Okay。
    But if you get an error。 remember you need to go back to section 2。2 and remember
    to execute。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: source，PyCon 2022 指令在你开始时，打开你的终端。好的。你可以试试。只需输入 wet to wasm。好的。如果你看到命令。find。这里找到了，但什么也没做。好的。但是如果你得到一个错误。记住你需要回到第
    2.2 节并记得执行。
- en: or open a terminal and execute at wherever the terminal opens。 This command
    source， PyCon 2022。 Remember， if you don't do that， you won't have access to any
    of the commands that we're。 going to be using at this very moment。 Okay。 So with
    everything's fine。 we should be able just to type here wet to wasm。 And we just
    indicate here that it's the examples。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 或者打开终端并在终端打开的地方执行。这条命令是 source，PyCon 2022。记住，如果你不这样做，你将无法访问我们现在要使用的任何命令。好的。所以一切正常。我们应该能够在这里输入
    wet to wasm。我们只需在这里指明这是示例。
- en: watt file that we need to translate。 Okay。 You can think of this being sort
    of like a compiler。 Technically is what we would call an assembler because it's
    going to translate assembly code。 in text format into the corresponding binary
    code。 Okay。 WebAssembly， the name is a little bit。 I wouldn't say confusing but
    it goes a little bit against， what typically assembly is。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要翻译的 watt 文件。好的。你可以把它想象成一种编译器。从技术上讲，我们称之为汇编器，因为它将文本格式的汇编代码转换为相应的二进制代码。好的。WebAssembly
    这个名字有点……我不会说混淆，但它与通常的汇编语言有些不一致。
- en: Assembly should always or at least was always considered to be a text format。
    Okay。 So we talk about WebAssembly and when we run WebAssembly， we're usually
    talking about something。 that is in a binary form。 Okay。 So this might be a little
    bit confusing at first but just have in mind what we're discussing。 at every point
    and hopefully that shouldn't confuse us too much afterwards。 So wet to wasm。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言应该总是，或者至少曾经被认为是一种文本格式。好的。所以我们讨论 WebAssembly，当我们运行 WebAssembly 时，通常是在谈论某种以二进制形式存在的东西。好的。虽然这一开始可能有点混乱，但请记住我们在讨论的每一点，希望这不会在之后让我们感到太困惑。所以从
    watt 到 wasm。
- en: Translate a watt file which is what we have into a wasm file。 So if we list
    the current directory now， we get that now we have the wasm file。 Okay。 So if
    you try to open it here in the editor， we'll tell you this is a binary file。 It
    cannot open it。 Okay。 So once you have the wasm， you can do something like this。
    You can run it。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们手中的 watt 文件转换为 wasm 文件。因此，如果我们现在列出当前目录，我们会发现现在有了 wasm 文件。好的。如果你尝试在编辑器中打开它，我们会告诉你这是一个二进制文件，无法打开。好的。一旦你有了
    wasm，你可以做这样的事情。你可以运行它。
- en: We have a utility called wasm3。 And here this is also explain a little bit downwards
    over here。 It's wasm3。 We need to use this option REPL followed by the name of
    the wasm file。 Okay。 So REPL opens a read of alprincklup。 So it's an interactive
    prompt here that we're going to be able to use to test our code。 So we just put
    it there。 It's double dash REPL。 And the file is called examples that it's the
    wasm file that we want to run here。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为 wasm3 的工具。这里也稍微解释了一下。它是 wasm3。我们需要使用这个选项 REPL，后面跟着 wasm 文件的名称。好的。REPL
    打开一个可读的交互提示符。这里是一个互动提示符，我们可以用来测试我们的代码。所以我们把它放在那儿。它是双连字符 REPL。文件名是 examples，这是我们想要运行的
    wasm 文件。
- en: Okay。 Just a quick note， wasm3 is an interpreter。 This is not a just-in-time
    compiler。 Okay。 But for testing purposes， it works perfectly well for what we
    need here。 Okay。 So here we have the prompt。 And now what we need to do is call
    our function using the exported name。 Excuse me， it's a VEG2。 Okay。 And you provide
    just separating these by spaces the arguments that are expected here。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。简单提醒一下，wasm3 是一个解释器。这不是一个即时编译器。好的。但出于测试目的，它非常适合我们在这里的需求。好的。这里我们有提示符。现在我们需要使用导出名称调用我们的函数。对不起，是
    VEG2。好的。你只需用空格分隔提供预期的参数。
- en: So this is going to compute the average of two numbers。 So let's say that we
    give it a 5 and a 10。 You can include a decimal point and some decimal fractions
    if you want to。 Okay。 But you need to provide the two arguments that are required。
    Okay。 For a and b。 The 5 is going to be a and the 10 is going to be b as expected。
    And you press enter。 Okay。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这将计算两个数字的平均值。那么假设我们给它 5 和 10。如果你愿意，可以包括小数点和一些小数部分。好的。但你需要提供所需的两个参数。好的。对于 a 和
    b，5 将是 a，10 将是 b，按预期。然后你按回车。好的。
- en: And if everything is fine， you should see something like this。 Okay。 I mean。
    so far we hadn't really modified the code。 So we would expect this to work without
    any issues。 Okay。 So this is the average two function working to exit wasm3， to
    exit this prompt just type。 control c or control d。 Okay。 So let's have a look
    at exercise b。 Okay。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该看到这样的结果。好的。我的意思是，到目前为止，我们并没有真正修改代码。因此我们期待这能顺利运行。好的。这是平均两个函数工作，退出 wasm3，退出这个提示符只需输入
    control c 或 control d。好的。让我们看看练习 b。好的。
- en: Exercise b says add to the wet example wet file the file the wet file that we
    were looking， at。 A new function called avg3。 So we're going to look at the new
    function。 Okay。 So we're going to look at the new function。 Example wet file the
    file that we were looking at a new function called avg3。 It's going to do the
    same thing but instead of receiving three instead of receiving two， arguments。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 练习b要求将新的函数avg3添加到我们查看的wet示例文件中。所以我们将查看新的函数。好的。所以我们将查看新的函数。查看的wet示例文件中的新函数avg3。它将做相同的事情，但不是接收三个，而是接收两个参数。
- en: it's going to receive three arguments。 Okay。 It's going to compute the average
    of three three integer numbers。 Okay。 So。 Just in case here's a link to the corresponding
    operations。 Okay。 And you can see some individual things or notice individual
    particularities of these instructions。 following the corresponding links。 Okay。
    So these are instructions that we need to use to solve this one。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 它将接收三个参数。好的。它将计算三个整数的平均值。好的。所以。以防万一，这里有一个指向相应操作的链接。好的。你可以看到一些单独的内容或注意这些指令的个别特性。跟随相应的链接。好的。所以这些是我们需要用来解决这个问题的指令。
- en: Okay。 So this is probably very simple。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以这可能非常简单。
- en: '![](img/86495766b190929aba361b4772d72632_28.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_28.png)'
- en: Okay。 We can use this one here as our model。 Okay。 So we would typically do
    something like this。 I'm going to do with you this example。 This is avg3。 Okay。
    And we need to use an export。 Export not export。 Export instruction here with
    the name that we're going to use which is avg3。 And we're going to use param。
    Okay。 And we need to provide here three parameters。 Okay。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们可以将这个作为我们的模型。好的。我们通常会这样做。我将和你一起做这个示例。这是avg3。好的。我们需要使用一个导出。不是导出。这里需要导出指令，名称是avg3。我们将使用参数。好的。我们需要提供三个参数。好的。
- en: Let's copy this， paste this to do this quickly。 This is the first one is going
    to be called A。 the second one is going to be called B， and， the third one is
    going to call C。 Remember。 they need to start these local names and they need
    to start with a dollar sign。 Okay。 It's not optional。 It's part of the notation。
    Okay。 So。 How do we solve this？
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们复制这个，粘贴以快速完成。第一个将被称为A。第二个将被称为B，第三个将被称为C。记住。它们需要以这些局部名称开始，并且需要以美元符号开头。好的。这不是可选的。这是符号的一部分。好的。那么。我们该如何解决这个问题？
- en: How do we obtain the average of these three numbers？ What do we need to do？
    Yes。 Okay。 Okay。 Yeah。 Okay。 And then you can see the variable。 Okay。 Okay。 Yeah。
    And then you can find。 Okay。 Yes。 So here we need to push。 Remember we can only
    add two elements at the time。 Okay。 So we can。 in this case the addition doesn't
    really matter the order in which you want， to do it。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何获得这三个数字的平均值？我们需要做什么？是的。好的。好的。是的。然后你可以看到变量。好的。好的。是的。然后你可以找到。好的。是的。所以在这里我们需要推送。记住，我们每次只能加两个元素。好的。因此，在这种情况下，加法的顺序实际上并不重要。
- en: We can push A and B into the stack and then do the addition and that leaves
    the result。 Okay。 In the top of the stack， then we can push the C and we call
    add again and that would add。 the previous result of the addition plus C。 Okay。
    And puts that in the stack。 And then finally we push a three and do the division。
    Okay。 And once again。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将A和B推入栈中，然后进行加法，这样就留下了结果。好的。在栈的顶部，然后我们可以推C，再次调用加法，这样就会加上之前的加法结果加C。好的。并把它放入栈中。最后我们推一个三并进行除法。好的。再一次。
- en: remember because addition is commutative， the order in which we do the。 additions
    is really not important to the final result。 Okay。 So let's start here by adding
    first A and B。 Look， we'll get here we have these two。 Okay。 What instruction
    we use to add？ F64。 F64。 Add， okay。 So that adds the two top elements。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，因为加法是交换的，我们进行加法的顺序对最终结果实际上并不重要。好的。那么我们从这里开始，先加A和B。看，我们这里有这两个。好的。我们使用什么指令来加？F64。F64。加，好的。那么这将加上两个顶部元素。
- en: Pops the two top elements and pushes the result back。 Okay。 Then let's load
    or push into the stack C。 Then what do we do？ We add again， yes。 F64 add。 Okay。
    Then we divide by three。 Notice that at this point we have the addition of A plus
    B plus C。 Okay。 We got the three numbers added and that's in the top of the stack。
    Okay。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出两个顶部元素并将结果推回。好的。然后让我们加载或推送C到栈中。接下来我们该做什么？我们再次加，是的。F64加。好的。然后我们除以三。注意到此时我们得到了A加B加C的结果。好的。我们已经把这三个数字加起来，这在栈的顶部。好的。
- en: That's currently what we have in the top of the stack。 So to divide by three，
    what do we do？
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们当前在栈顶的内容。那么，如何除以三呢？
- en: We push using F64 const。 We push a three and we finally call div to do the division。
    Okay。 So just a quick mention here in Git part you don't need to save your files
    automatically。 Once you do a modification to a file it actually gets automatically
    saved。 Okay。 I usually instinctively always press control C or command C。 Okay。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用F64 const进行推送。我们推送一个三，然后最终调用div进行除法。好的。在Git部分这里简单提一下，你不需要自动保存文件。对文件进行修改后，它会自动保存。好的。我通常本能地总是按control
    C或command C。好的。
- en: But strictly speaking it's not really required。 Okay。 You can check that out。
    And okay。 So here at the terminal what do we need to do？ Wet to Wasm。 Okay。 This
    is exactly the same command because we're modifying the same file here。 And oops。
    Oh。 I missed something here。 Anybody notice what I was missing？ The result。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 但严格来说，这并不是必需的。好的。你可以检查一下。那么在终端我们需要做什么？Wet to Wasm。好的。这是完全相同的命令，因为我们在修改同一个文件。哦，哎呀。我漏掉了一些东西。有人注意到我漏掉了什么吗？结果。
- en: This is why we're getting a validation error because I did not say that it was
    going to。 return something。 So here we need to add F64。 This is the expected result
    in F64。 Okay。 The code is correct but I needed to declare that I'm requiring here
    to leave always an。 F64 on the top of the stack once we finish here。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们收到验证错误的原因，因为我没有说它会返回某个值。因此这里我们需要添加F64。这是在F64中的预期结果。好的。代码是正确的，但我需要声明我要求在我们结束时始终在栈顶留下一个F64。
- en: '![](img/86495766b190929aba361b4772d72632_30.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_30.png)'
- en: Okay。 So there we go。 Notice here that we get here a type mismatch。 This is
    where the error that we got here。 It was expecting。 This means the square brackets。
    empty square brackets。 I was expecting an empty stack but I got a stack with an
    F64。 Okay。 This is a validation error。 Okay。 Done by the translator。 And we call
    it again。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。所以我们来看看。注意到我们这里有类型不匹配。这个是我们得到错误的地方。它是期望的。这意味着空方括号。我本来期望一个空栈，但我得到了一个有F64的栈。好的。这是一个验证错误。好的。由翻译器造成的。我们再次调用它。
- en: And we call Wasm 3 again with the REPL option here。 Okay。 How do I test it？
    Well， we call AVG3。 There are three examples that we can use here with 1， 2 and
    3 or with 14。5。 I mean。 you can use whatever data values you want to check。 Okay。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用REPL选项调用Wasm 3。好的。我该如何测试呢？我们调用AVG3。这里有三个示例，可以使用1、2和3或者14.5。我的意思是，你可以使用任何想要检查的数据值。好的。
- en: '![](img/86495766b190929aba361b4772d72632_32.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_32.png)'
- en: But here are three possibilities if you don't want to think on any test cases。
    So if we put just 1。 2， 3， the average of 1， 2， 3 is 2。 Okay。 But you can check
    it out with the other examples as well。 Okay。 Any questions？ Once again， remember
    what we're doing here is hand coding WebAssembly。 Okay。 This is not the typical
    way that you use WebAssembly。 Okay。 But once again。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你不想考虑任何测试用例，这里有三个选项。所以如果我们只放1、2、3，1、2、3的平均值是2。好的。但你也可以用其他示例检查一下。好的。有问题吗？再一次，请记住我们在这里做的是手动编码WebAssembly。好的。这不是使用WebAssembly的典型方式。好的，但再说一次。
- en: I consider it very educational to do it。 Okay。 Because if you do it。 you're
    more or less understanding how this is supposed to work。 But then we're going
    to see higher level tools to actually get this done automatically。 Okay。 I think
    it's a good moment to take a break。 Okay。 So let's， what do you think？
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这样做非常有教育意义。好的。因为如果你这么做，你或多或少会理解它的工作原理。但随后我们会看到更高级的工具来自动完成这个任务。好的。我觉得现在是个休息的好时机。好的，你觉得怎么样？
- en: 15 minutes is it enough or do you want more？ Yeah。 15 minutes。 Okay。 So if you'd
    like。 let's continue here at 10 to 11。 Okay。 Sure。 Thank you very much for being
    back here。 Okay。 So let's continue。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 15分钟够吗，还是想要更多？是的，15分钟。好的。如果你愿意，我们就继续，在10点到11点之间。好的，当然。非常感谢你再次回来。好的。我们继续。
- en: '![](img/86495766b190929aba361b4772d72632_34.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_34.png)'
- en: And let's go with exercise C。 I'm going to give you a few minutes to solve this
    problem， here。 Just like we did with the previous function， A， V， G， three， here
    we need to create a new。 function called file to sell。 Okay。 Here's the name。
    This one only takes one parameter。 Okay。 And you need to implement this formula
    here。 So hopefully with what we've seen so far。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始练习 C。我会给你几分钟来解决这个问题，就像我们之前处理的函数 A、V、G 一样，这里我们需要创建一个新的函数，叫做 file to sell。好的。这个函数只接受一个参数。好的。你需要实现这个公式。希望到目前为止我们所学的能够帮助你。
- en: you should be able to carry out this， convert， this formula into the corresponding
    instructions in the WebAssembly text format。 Okay。 And here we have a few examples
    that you can use。 Okay。 So once again。 try to solve this by your own。 Okay。 If
    you need any help， you can ask me。 And I'll give you five minutes to see if you
    can solve it in that time。 Okay。 Okay。 [BLANK_AUDIO]。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够将这个，转换，将这个公式转换成相应的 WebAssembly 文本格式指令。好的。这里有一些你可以使用的示例。好的。再一次，尝试自己解决这个问题。好的。如果你需要任何帮助，可以问我。我会给你五分钟，看看你能否在这段时间内解决它。好的。好的。[空音频]。
- en: '[BLANK_AUDIO]， [BLANK_AUDIO]， [BLANK_AUDIO]， [BLANK_AUDIO]， [BLANK_AUDIO]，
    [BLANK_AUDIO]。 [BLANK_AUDIO]， [BLANK_AUDIO]， [BLANK_AUDIO]， [BLANK_AUDIO]， [BLANK_AUDIO]，
    [BLANK_AUDIO]。 [BLANK_AUDIO]， [BLANK_AUDIO]， Great， okay。 [BLANK_AUDIO]， [BLANK_AUDIO]，
    [BLANK_AUDIO]。 [BLANK_AUDIO]， [BLANK_AUDIO]， [BLANK_AUDIO]， Can I take a picture
    of you？ \>\> Yeah。'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[空音频]， [空音频]， [空音频]， [空音频]， [空音频]， [空音频]。 [空音频]， [空音频]， [空音频]， [空音频]， [空音频]，
    [空音频]。 [空音频]， [空音频]， 很好，可以。 [空音频]， [空音频]， [空音频]。 [空音频]， [空音频]， [空音频]， 我可以给你拍张照片吗？
    \>\> 可以。'
- en: \>\> Everybody okay？ Just wait for the camera， let's do one here and then over
    here， okay？ So waving。 yay， thank you。 Over here， okay， wave， yes， thank you。
    Excuse me？ \>\> Don't be so filthy。 \>\> Yeah。 sure， it's a good idea。 Let's see
    how many can fit here。 Okay， just wait for the photo。 Okay。 thank you。 [BLANK_AUDIO]，
    Awesome。 Okay， how many finished？ Okay， well， great。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: \>\> 大家还好吗？等一下相机，让我们在这里拍一张，然后再拍一张，好吗？所以挥手。耶，谢谢。在这里，好，挥手，是的，谢谢。打扰一下？\>\> 别这么肮脏。
    \>\> 是的，当然，这是个好主意。看看这里可以容纳多少人。好的，等一下拍照。好的。谢谢。[空音频]，太棒了。好的，有多少人完成了？好的，那很好。
- en: Any questions with this last exercise？ No？ Yeah。 [BLANK_AUDIO]， Yeah。 [BLANK_AUDIO]。
    There are several instructions that allow you to manipulate the stack。 In those
    cases。 you can have local variables。 And that's the easiest thing。 I mean。 if
    you need to put something in a place that you'll later put it。
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 关于最后这个练习有问题吗？没有？是的。[空音频]，是的。[空音频]。有几条指令可以让你操作栈。在这些情况下，你可以有局部变量。这是最简单的事情。我的意思是，如果你需要把某个东西放在一个地方，稍后再用它。
- en: just put it in a variable like you do in most languages at the end。 But once
    again。 it is always much more efficient if you can do all the operations only
    in the stack。 Okay。 but if you can， you can always use additional memory to process
    whatever you need。 Okay？ Okay。 let's go to， next section， we're now going to select
    the set of， going to section number five。 Okay？
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在大多数语言中最后那样把它放在一个变量里。但是再一次，如果你能在栈中完成所有操作，那会更高效。好的。但是如果可以，你总是可以使用额外的内存来处理你需要的任何东西。好的？好的。让我们进入下一部分，我们现在要选择第五部分。好的？
- en: This is the， basically， the last half of our presentation here。 Okay， as I explained
    before。 what assembly， as the， a couple of last exercises that we did， in which
    we wrote the WebAssembly。 text format code， that's typically not the way that
    you should use WebAssembly。 Okay。 WebAssembly really isn't， I mean， you can do
    it， but it's really not designed for coding it by hand。
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是我们演示的最后一部分。好的，正如我之前解释的，什么是汇编，作为我们做的最后几个练习之一，我们编写的 WebAssembly 文本格式代码，这通常不是你应该使用
    WebAssembly 的方式。好的。WebAssembly 实际上并不是，意思是，你可以这样做，但它真的不是为了手动编写而设计的。
- en: Okay？ So what do you do？ Well， you use， you typically use a tool to somehow
    convert or produce this WebAssembly text code。 or the binary format or whatever。
    Okay？ So in practice。 typically you would start from a high-level language like
    C， like C++， like Rust， like Go。 If you think about it， these are languages that
    are typically much more performant， okay？
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？那么你是做什么的？嗯，你使用，通常会使用某种工具来转换或生成这个 WebAssembly 文本代码，或者是二进制格式之类的。好吧？所以实际上，通常你会从高级语言开始，比如
    C、C++、Rust、Go。如果你考虑一下，这些语言通常性能更好，好吗？
- en: They're used to write code that typically has to be executed faster than what
    you typically do in Python or in JavaScript or some other。 languages are typically
    interpreted。 So， most of the time， once again。 if you want to use WebAssembly，
    even if you， at some point， use Python。 typically you would use some other language
    to produce the WebAssembly， okay？
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 它们用于编写通常需要比在Python或JavaScript或其他语言中更快执行的代码。大多数时候，再次强调，如果你想使用WebAssembly，即使在某些时候使用Python，通常你会使用其他语言来生成WebAssembly，好吗？
- en: There is not currently a compiler that translates Python code directly into
    WebAssembly， okay？
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 目前没有将Python代码直接翻译为WebAssembly的编译器，好吗？
- en: Typically you use a lower-level language to actually do that， okay？ And once
    again。 even if you start with C or Rust， the advantage is that if you're producing
    WebAssembly。 your code will be more portable than if you just compile it directly
    into native code， okay？
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你会使用一种较低级的语言来做到这一点，好吗？再一次，即使你从C或Rust开始，优势在于如果你正在生成WebAssembly，你的代码将比直接编译为本地代码更具可移植性，好吗？
- en: So that's the most common use case。 So in this section here。 what we're going
    to do is we're going to see how to write our own compiler， okay？
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是最常见的用例。在这一部分，我们将看到如何编写自己的编译器，好吗？
- en: So we're going to write that tool that translates some code in some language。
    We're going to see what language it is into WebAssembly， okay？ Now， originally。
    when I was designing this particular tutorial， I thought of implementing an esoteric
    language that is called。 "rainfuck"， okay？ That's its name， I'm sorry， I don't
    really like to use these， these。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将编写一个工具，将某种语言中的一些代码翻译为WebAssembly，好吗？现在，最初，当我设计这个特定的教程时，我考虑实现一种叫做“rainfuck”的冷门语言，抱歉，这就是它的名字，我并不太喜欢使用这些。
- en: '"explicatives"， okay？ And I did during my Easter vacations。 I actually did
    a prototype and it did work， but I thought it was more complicated than really
    was worth。 So instead of that， I decided to go for a language that is called "forth"。
    I don''t know if anybody has used or heard of even about "forth"， okay？'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: “解释性”，好吧？在我复活节假期期间，我确实做了一个原型，它确实工作了，但我觉得它比实际值得的复杂。因此，我决定选择一种叫“forth”的语言。我不知道是否有人使用过或听说过“forth”，好吧？
- en: '"forth" appeared somewhere in the 1970s， and the advantage of "forth" is that
    it''s semantic is very similar to WebAssembly。 It''s a stack-based language， okay？
    So you push elements in the stack and then you pop them and do operations and
    push the result back。'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: “forth”出现在1970年代，优点是它的语义与WebAssembly非常相似。这是一个基于栈的语言，好吗？所以你将元素推入栈中，然后弹出它们并执行操作，然后将结果推回去。
- en: So the translation of the code in "forth" to WebAssembly is very straightforward，
    okay？
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 所以将“forth”中的代码翻译成WebAssembly是非常直接的，好吗？
- en: So the language is going to seem a little bit strange at first。 if you've ever
    used a stack-based language， but you have to be aware that they're not that uncommon。
    I mean， WebAssembly is stack-based， but also the virtual machines are stack-based。
    The Java virtual machine is stack-based。 The common language infrastructure， excuse
    me。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 所以语言起初可能会显得有些奇怪，如果你曾使用过基于栈的语言，但你必须意识到它们并不罕见。我是说，WebAssembly是基于栈的，虚拟机也是基于栈的。Java虚拟机是基于栈的。通用语言基础设施，抱歉。
- en: that is used in the Darnat technology is also stack-based。 A language is like
    PostScript。 which you use to， I mean， typically send information to a printer，
    a laser printer and so on。 It also works with a language， and that language is
    also stack-based， okay？
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 用于Darnat技术的语言也是基于栈的。像PostScript这样的语言，通常用于将信息发送到打印机，激光打印机等。它也使用一种语言，而那种语言也是基于栈的，好吗？
- en: So this use of stack is really not that uncommon。 Most of the time we don't
    deal with it directly。 okay， but it is there。 But this language actually does
    expose a lot of the semantics of using a stack-based architecture。 And the language
    that we're going to implement here is not "forth"。 I mean。 "forth" is not a big
    language。 It's fairly small， but we're going to be working with an even smaller
    language。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这种栈的使用其实并不罕见。大多数情况下我们并不会直接处理它，好吧，但它确实存在。但这个语言实际上暴露了使用基于栈架构的许多语义。而我们要在这里实现的语言并不是“forth”。我的意思是，“forth”不是一种大语言。它相对较小，但我们要处理的语言甚至更小。
- en: okay， in a call here "chicky-forth"， okay？ Where "chicky" is in Spanish。 it's
    sort of an informal word to indicate something that is tiny or that is small，
    okay？
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在这里调用“chicky-forth”，明白了吗？其中“chicky”是西班牙语。它是一种非正式的词，表示某物微小或小的东西，明白了吗？
- en: '"chicky" comes from the word "chikit-ton" or "chikit-ton" or something tiny，
    something small。 And I used this name because everything， all other names were
    already taken。 I mean， I said， "Well。 is there a tiny "forth" and yes， there was
    an implementation tiny "forth"。 Is there a "microforth" and yes， there''s a "microforth"。
    Is there a "mini-forth"？ Yeah。'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: “chicky”来自“chikit-ton”这个词，或者说“chikit-ton”，或者某种微小的东西。我使用这个名字是因为其他所有名字都已经被占用了。我的意思是，我想，"好吧，是否有一个微小的‘forth’，而且确实有一个微小的‘forth’的实现。是否有一个‘microforth’，是的，还有一个‘microforth’。是否有一个‘mini-forth’？是的。
- en: all these things I have to do with "forth" and something small。 all these names
    seem to be already used。 Okay， so I said， "Well。 let's combine something in Spanish
    and surely the name is not going to be taken。"。 And that's exactly what happened
    here。 So this is why it's called "chicky-forth"， okay？
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些事与“forth”和一些小东西有关。这些名字似乎都已被使用。所以我说，“好吧。让我们结合一些西班牙语的东西，肯定这个名字不会被占用。”而这正是发生的事情。所以这就是为什么叫“chicky-forth”，明白了吗？
- en: But it's a very small subset of the "forth"。 And of course。 I took some additional
    liberties to make this work in a way that I found interesting， okay？
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只是“forth”的一个非常小的子集。当然，我采取了一些额外的自由，使其以我认为有趣的方式工作，明白了吗？
- en: So it is a subset of "forth" and many of the things that I'm going to say are
    true for "forth"。 but not everything， okay？ So "chicky-forth" works as typically
    you would expect。 Let's have a look directly here in this example。 I usually include
    a lot of explanations here。 just in case at some point in the future you want
    to review them。
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它是“forth”的一个子集，我接下来要说的许多内容对“forth”也是适用的，但并不是所有的，明白了吗？所以“chicky-forth”的工作方式正如你所期待的那样。让我们直接看看这个例子。我通常在这里包含很多解释，以防将来你想要复习它们。
- en: You have the full context to understand what's happening， okay？
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你有充分的上下文来理解发生了什么，明白了吗？
- en: But I'm not going to spend a lot of time reading what's there， okay？
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 但我不打算花太多时间阅读那里有什么，明白了吗？
- en: But you can read it on your own if you find it interesting or amusing or relevant。
    So here's an example of a "chicky-forth" program， okay？ So whenever you find a
    number here。 for example the one you push it into the stack， okay？ Just see a
    number， push it into the stack。 When you see an operation， for example here the
    plus， well， you do what is expected to do。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你觉得有趣、好玩或相关，你可以自己阅读。所以这是一个“chicky-forth”程序的示例，明白了吗？每当你看到这里的数字，例如你将其推入堆栈，明白了吗？只需看到一个数字，推入堆栈。当你看到一个操作，例如加法，好吧，你就按照预期的方式进行。
- en: which is do two pop operations， do the plus operation and push the result back
    into the stack， okay？
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是进行两次弹出操作，进行加法操作并将结果推回堆栈，明白了吗？
- en: So here， as you can see， we are evaluating one plus two， okay？ And the result，
    which is three。 is placed in the top of the stack， okay？ And then we do three
    plus four， okay？
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这里，如你所见，我们在评估一加二，明白了吗？结果，也就是三，被放在堆栈的顶部，明白了吗？然后我们进行三加四，明白了吗？
- en: And seven is placed in the top of the stack。 And then we do a star， in this
    case we take the seven。 we pop the seven， we pop the three， which were currently
    in the stack。 the result of the previous two add operations。 And we multiply it
    so we get a 21。 And the dot。 the final dot， is that it takes the element in the
    top of the stack and prints it。 Okay？
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 七被放在堆栈的顶部。然后我们进行乘法，在这种情况下，我们取出七，我们弹出七，我们弹出三，当前在堆栈中。前两个加法操作的结果。我们将其相乘，因此得到21。最后的点，是将堆栈顶部的元素取出并打印出来。明白了吗？
- en: So this is going to print a 21 at the end， okay？ Okay？ So as you might imagine
    here。 this is exactly the same thing as in Python， this instruction over here，
    okay？
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 所以最后将打印21，明白了吗？所以如你所想，这正是与Python中相同的东西，这里的指令，明白了吗？
- en: So it adds one plus two， three plus four， multiplies those two values and prints
    the result。 which is 21， okay？ So that's a general way in which Chicky fourth
    and fourth in general works， okay？
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它添加了一加二，三加四，将这两个值相乘并打印结果。结果是21，明白了吗？所以这就是“Chicky forth”一般工作的方式，明白了吗？
- en: So let's add some additional things that Chicky fourth is going to do。 Well。
    to start off something that is very important。 The input is just going to be a
    file that contains these stacks。 We're going to use the split， the Python split
    operation to separate what fourth calls words， okay？
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些Chicky fourth要做的额外内容。首先，有一点非常重要。输入将只是一个包含这些堆栈的文件。我们将使用split，Python的split操作来分隔fourth所称的单词，明白吗？
- en: Every single element that is delimited by spaces is a word， okay？ A number like
    one is a word。 plus is a word， okay？ The dot is a word， okay？ So sometimes we
    need comments。 So in order to represent comments， we're going to use parentheses，
    okay？ So we open a parentheses。 this means this is a start of a comment until
    we find the closing parentheses。
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个由空格分隔的元素都是一个词，明白吗？像“one”这样的数字也是一个词。“plus”也是一个词，明白吗？句号也是一个词，明白吗？所以有时我们需要注释。为了表示注释，我们将使用括号，明白吗？所以我们打开一个括号，这意味着这是注释的开始，直到我们找到闭合的括号。
- en: That's where the comment ends， okay？ And these comments are just going to be
    eliminated， okay？
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是注释结束的地方，明白吗？这些注释会被消除，明白吗？
- en: It's just for convenience for us to write some meaningful information that might
    make sense to us later on when we inspect the code again and never remember what
    we did before。 And well， the comments hopefully help us to understand what we
    were thinking， okay？
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是为了方便我们写一些有意义的信息，可能在我们再次检查代码时对我们有用，而我们又记不得之前做了什么。希望这些注释能帮助我们理解我们的思考，明白了吗？
- en: Just have in mind， okay？ For this to work， there needs to be spaces before or
    after the parentheses。 okay？ Because we're just going to split it here， so we're
    assuming that there exists spaces between the different elements that we want
    to exist in the program in general and here in comments。
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，明白吗？为了使其工作，在括号前后需要有空格，明白吗？因为我们只是会在这里进行拆分，所以我们假设不同元素之间存在空格，这些元素通常在程序和注释中存在。
- en: Just make sure that the parentheses you do not put it together without any spaces
    next to any other elements。 okay？ We're going to be representing variables and
    in general。 a variable is any word that starts with a letter and follows is followed
    by zero or more letters or digits。 okay？ So like very similar like any other language，
    this is how we're going to represent variables。
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 只需确保括号旁边没有任何元素紧挨着放置在一起，没有空格，明白吗？我们将表示变量，通常，变量是任何以字母开头并且后面跟着零个或多个字母或数字的词，明白吗？所以像任何其他语言一样，这就是我们将表示变量的方式。
- en: And if the variable appears by itself， this means that we want to read the value
    of the variable。 okay？ So if my program says X， that means that I'm going to read
    the value of X， okay？
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量单独出现，这意味着我们想读取该变量的值，明白吗？所以如果我的程序说X，这意味着我要读取X的值，明白吗？
- en: And what does it mean to read the value of X？ It means that we get the value
    of that variable and we push it into the stack。 okay？ When we want to do a write
    operation， in this case we want to update or set or assign a variable。 we're just
    going to use the name of the variable followed immediately and placed together
    without any spaces with an exclamation mark。 okay？ So if we have X， we're reading
    the value of X。
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 那么读取X的值是什么意思？这意味着我们获取该变量的值并将其推入堆栈，明白吗？当我们想执行写操作时，在这种情况下，我们想更新、设置或赋值一个变量。我们将仅使用变量的名称，后面紧接着没有空格的感叹号，明白吗？所以如果我们有X，我们就是在读取X的值。
- en: which means take the value of that variable and place it in the top of the stack。
    do a push operation。 But when you find X followed by an exclamation mark。 I think
    you typically call it a bang there， okay？ I don't know if most of you call it
    that way。 but I've heard that that's the term that you use here or at least many
    people in the states use it。
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着获取该变量的值并将其放在堆栈的顶部。执行推送操作。但是当你找到X后面跟着一个感叹号时，我想你通常称之为bang，明白吗？我不知道你们大多数人是否这样称呼，但我听说这是你们在这里使用的术语，或者至少很多美国人这样称呼。
- en: So if you find X bang or X followed by an exclamation mark。 it means take the
    value that is in the top of the stack and copy it or pop it and copy that value
    to that value。 okay？ So we have getting and setting of our variables， okay？
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你找到X bang或X后面跟着一个感叹号，意味着获取堆栈顶部的值并将其复制或弹出并复制该值，明白吗？所以我们有变量的获取和设置，明白吗？
- en: And look at this example that we have here。 So what's happening here in the
    first line。 we are pushing a one， a two and then a plus， so we have a three in
    the top of the stack。 And then we do X bang， this what it does is that it pops
    the three in top of the stack and copies it to the variable X。 okay？ Once again，
    we do that set operation because we have an exclamation mark。
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们这里的这个例子。那么在第一行发生了什么？我们推入一个一，一个二，然后加法，所以栈顶有一个三。然后我们做 X bang，这个操作会从栈顶弹出三并复制到变量
    X 中，明白吗？再一次，我们做这个设置操作，因为我们有一个感叹号。
- en: What happens in the next line？ In line number two。 Here we read the value of
    X the first time and we push into the stack and then we read it again and push
    into the stack and then we do a plus。 So at the end we are adding three plus three，
    that gives us six and with a dot we print it， okay？
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行会发生什么？在第二行。这次我们第一次读取 X 的值并推入栈中，然后我们再次读取并推入栈中，然后我们做加法。所以最后我们加三加三，得出六，然后用点号打印出来，明白吗？
- en: So this little program would print a six， okay， using a variable。 Just a quick
    mention here。 it is valid。 I mean， you don't need， as you continue the program。
    you don't need to declare variables here， okay？ And actually any variable that
    hasn't been set before。 I mean， if you have a variable that you're reading it
    but you didn't place any value before that。
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个小程序将打印一个六，明白吗，使用一个变量。这里简单提一下，这是有效的。我是说，在你继续程序的过程中，你不需要在这里声明变量，明白吗？实际上任何之前没有设置的变量。我是说，如果你有一个正在读取的变量，但之前没有赋值。
- en: by default it has a zero， okay？ So in any moment you can just introduce a variable
    and if you read it without setting it before。 you have a zero there， okay， by
    default， okay？ So that's the use of variables in Chicky fourth。 We got these instructions
    for input and output。 Okay， we already saw the dot by itself。 this one pops an
    integer value from the top of the stack and prints it， okay？
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它是零，明白吗？所以在任何时刻，你可以引入一个变量，如果你在之前没有设置它，你就会得到一个零，明白吗，默认情况下，明白吗？这就是 Chicky
    fourth 中变量的用法。我们有输入和输出的指令。好吧，我们已经看到点号本身了。这个指令从栈顶弹出一个整数值并打印出来，明白吗？
- en: And something that I didn't mention before， it adds a single space afterwards，
    okay？
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 还有我之前没有提到的，它在后面添加一个空格，明白吗？
- en: So this allows us to actually have several numbers and print them using just
    a dot because they're going to be placed together。 We just add a space so that
    not everything gets all placed in just one single big string， okay？
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够使用点号打印几个数字，因为它们将一起放置。我们只需添加一个空格，以便不把所有内容都放在一个大字符串中，明白吗？
- en: So we add here a space immediately after we do a print here， okay？ Then we have
    an emit。 emit actually， what it does is similar to the dot。 it's going to pop
    a value from the top of the stack。 But instead of printing that number。 it's going
    to consider that number， the character code of whatever value we have。
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在打印之后，我们这里添加了一个空格，明白吗？然后我们有一个 emit。emit 实际上做的事情与点号相似。它会从栈顶弹出一个值。但不是打印那个数字，而是考虑那个数字，即我们所拥有的任何值的字符编码。
- en: And display the corresponding character， okay？ Now， you can think of in terms
    of ASCII。 the American standard code for information interchange。 so let's say
    that we have a 65 in the top of the stack。 That 65 is the character code for the
    capital letter A， okay？ So if I have a 65 and I use emit。
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 并显示相应的字符，明白吗？现在，你可以考虑 ASCII。美国信息交换标准代码。假设我们在栈顶有一个 65。那个 65 是大写字母 A 的字符编码，明白吗？所以如果我有一个
    65 并使用 emit。
- en: what I get is an A displayed， okay， the character A。 Technically speaking。 we
    can talk about ASCII characters， okay？ But strictly it's a Unicode character。
    so it's a Unicode code point that you're placing there， okay？
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到的是显示的 A，明白吗，字符 A。从技术上讲，我们可以谈论 ASCII 字符，明白吗？但严格来说，它是一个 Unicode 字符。所以你放在那里的是一个
    Unicode 码点，明白吗？
- en: So remember that ASCII is actually a subset of Unicode。 The first 128 characters
    of Unicode are the same character codes for ASCII， okay？
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 所以要记住，ASCII 实际上是 Unicode 的一个子集。Unicode 的前 128 个字符与 ASCII 的字符编码相同，明白吗？
- en: So you can think in terms of ASCII， but it's really much more。 It's Unicode
    code points that we really have here， okay？ So it is valid to actually use。 for
    example， if I want a Euro sign or want some sort of emoji。 or if I know the character
    code of that one， we can place that number and do the emit。
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以考虑 ASCII，但它实际上更复杂。这里真正有的是 Unicode 码点，明白吗？所以实际上是有效的使用。例如，如果我想要一个欧元符号或某种表情符号，或者如果我知道那个字符的编码，我们可以放那个数字并进行
    emit。
- en: and it will display that corresponding value， okay？ The corresponding character。
    NL represents a new line， a new line actually prints or advances to the next line，
    okay？ By default。 that doesn't happen， so we need to explicitly put it。 And notice
    here that the new line is actually equivalent to these two words together， okay？
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 它会显示相应的值，好的？对应的字符。NL表示换行，换行实际上是打印或移动到下一行，好的？默认情况下，这不会发生，所以我们需要显式地放置它。注意，这里的换行实际上等同于这两个词组合在一起，好的？
- en: So we have a new 10， which is the character code for the new line， okay？
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们有一个新的10，这是换行的字符代码，好的？
- en: And emit would actually print it， okay？ So actually new line。 this is really
    not a new operation per se， it's just the combination of these two， okay？
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 而发射实际上会打印它，好的？所以实际上换行。这并不算是一个新的操作，它只是这两个的组合，好的？
- en: And we also have input， input will read from the standard input and integer。
    And it reads from the keyboard technically， I mean it's a standard input。 so technically
    it could be redirected if you want it。 But well。 it takes that value and whatever
    is read is placed on top of the stack， okay？
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有输入，输入将从标准输入和整数中读取。技术上来说，它是从键盘读取的，我是说它是标准输入。所以技术上来说，如果你想，它可以被重定向。但好吧，它获取那个值，读取的内容会放置在栈顶，好的？
- en: If you want to later on copy it to a variable， we'll just use the variable bang
    operation that we saw a moment ago。 okay？ So that's a general description of our
    compiler。 Let's see how we write it， okay？
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在稍后将其复制到变量中，我们将使用刚才看到的变量叹号操作，好的？所以这就是我们编译器的总体描述。让我们看看怎么写它，好的？
- en: The current version of the compiler is about 170 lines of code。 I mean it's
    not huge， okay？
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的编译器大约有170行代码。我是说，这并不庞大，好的？
- en: But it's fairly tiny if you think of it， what all that it actually does， okay？
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你考虑一下，实际上它非常小，好的？
- en: So I'm not going to go line by line what it is， let's just look at the parts
    that are more interesting。 Okay， so the code is actually available here。 If you
    go back to your workspace。 let's close the file that we had here。
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我不会逐行说明它是什么，让我们看看更有趣的部分。好的，代码实际上在这里可用。如果你回到你的工作区，关闭我们之前的文件。
- en: '![](img/86495766b190929aba361b4772d72632_36.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_36.png)'
- en: And let's go to the fourth directory and let's look at the chicky fourth file，
    chicky fourth dot。 p-y。 Okay， as you can see actually a lot of what we have here
    are actually comments or document strings。 okay？ So the code is really small，
    okay？ So let me just show you some parts that are relevant for us to understand
    the compiler。 I have some strings here as symbolic constants， okay？
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去第四个目录，看看chicky fourth文件，chicky fourth.dot.py。好的，正如你所看到的，这里很多内容实际上是注释或文档字符串，好的？所以代码真的很小，好的？让我给你展示一些对我们理解编译器相关的部分。我这里有一些字符串作为符号常量，好的？
- en: The first one is a multi-line string that has what we need to have at the beginning
    of every module that I'm going to be producing。 okay？ My compiler is going to
    be producing。 As you can see at the very beginning it has a comment saying chicky
    fourth compiler。
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是多行字符串，包含我在每个要生成的模块开头需要的内容，好的？我的编译器将会生成这个。如你所见，它在最开始有一条注释，说明是chicky fourth编译器。
- en: I think I didn't necessarily mention it， but anything that starts with two columns
    is a comment。 in WebAssembly， okay？ WebAssembly text format， okay？ So here's our
    module， here's where it starts。 We are going to import three functions， okay？
    Import here。 what it means is that this function is defined somewhere else。
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我并没有特别提到，但在WebAssembly中，任何以两个冒号开头的都是注释，好的？WebAssembly文本格式，好的？所以这是我们的模块，这里是开始的地方。我们将导入三个函数，好的？这里的导入意味着这个函数在其他地方定义。
- en: I'm going to be able to call it from my WebAssembly code here， okay？
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我将能够从我的WebAssembly代码中调用它，好的？
- en: And as you can see these happen to be the input output functions， okay？ We have
    emit。 input and print， okay？ These are functions。 You can see this is。 you can
    think of it as being the signature of the function。 If it takes parameters。 it's
    going to tell me so。 And if it returns something。
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这些恰好是输入输出函数，好的？我们有发射、输入和打印，好的？这些是函数。你可以把这看作是函数的签名。如果它接受参数，它会告诉我。所以如果它返回某些东西。
- en: it's going to have a result as expression here， saying that it's going to result
    in something。 Okay。 notice that we're just using here i32， so it's going to only
    work with 32-bit integers， okay？
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在这里作为表达式产生一个结果，表示它将产生某种结果。好的。注意我们这里只使用 i32，因此它只会与 32 位整数一起工作，好的？
- en: And here we start the declaration of our function， okay？
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们开始声明我们的函数，好的？
- en: Notice that I'm only placing here its export directive。 I'm saying that I'm
    going to export our function as a dunder， well it's not dunder。 it's just an underscore，
    underscore start。 Okay， this is the name of my function and this is where the
    execution of the function is going to begin。 okay？ We're going to use that name，
    the underscore start to indicate in our Python code that we want to execute this。
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我这里只放置了它的导出指令。我在说我要将我们的函数导出为一个 dunder，实际上并不是 dunder，只是一个下划线，_start。好的，这是我的函数名称，也是函数执行将要开始的地方。好的？我们将使用这个名称，_start
    来指示在我们的 Python 代码中，我们希望执行这个。
- en: all this function。 And in line number 32， notice here that we have here just
    two closing parentheses。 This is one and this is the second one。 The first one
    actually closes the function and the last one closes the module。 okay？ So every
    program that I produce here in my compiler has to start with these several lines
    of instructions。 and has to end with these two couple of closing parentheses，
    okay？
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数。在第 32 行，注意这里我们只有两个闭合括号。这是一个，这是第二个。第一个实际上关闭函数，最后一个关闭模块。好的？因此，我在编译器中产生的每个程序必须以这些几行指令开始，并以这两个闭合括号结束，好的？
- en: So this is something that has to happen here。 And in line number 35， we have
    a dictionary here。 okay？ And this dictionary is the mapping between the words
    of our cheeky-forth programs。 and the corresponding instruction or instructions
    in WebAssembly， okay？
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一件必须在这里发生的事情。在第 35 行，我们有一个字典，好的？这个字典是我们 cheeky-forth 程序中的单词与 WebAssembly
    中相应指令或指令的映射，好的？
- en: In WebAssembly it takes form。 So in line 36 you can see that for doing a multiplication，
    okay？
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebAssembly 中它采取了形式。所以在第 36 行，你可以看到为了进行乘法，好的？
- en: We have the key in this dictionary is the star， okay？
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，关键是星号，好的？
- en: It means that whenever I find a star I need to convert this into the i32。mool
    instruction in WebAssembly text form， okay？ It's actually contained within square
    brackets。 It's a list， what we have associated to each value， because we can have
    several instructions。 As you can see， for example， in line 41 we got the nl word，
    okay？
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每当我找到一个星号时，我需要将其转换为 WebAssembly 文本形式的 i32.mool 指令，好的？它实际上包含在方括号内。这是一个列表，我们为每个值关联的内容，因为我们可以有多个指令。如你所见，例如，在第
    41 行我们得到了 nl 单词，好的？
- en: And this one actually gets converted into two WebAssembly instructions。 The
    first one is i32 const 10， which pushes a 10 to the top of a stack。 And then a
    call to emit。 okay？ Call emit will call the emit function that is defined somewhere
    else。 which is available here thanks to the important instructions that we did
    before， okay？
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个会被转换成两个 WebAssembly 指令。第一个是 i32 const 10，它将 10 推送到栈顶。然后是一个 emit 的调用。好的？调用
    emit 将调用在其他地方定义的 emit 函数，由于我们之前的重要指令，它在这里是可用的，好的？
- en: So notice here we already have implemented the star， the plus， the dot， the
    period。 the emit input and nl instructions here， okay？ So that's what our compiler
    currently is able to do。 Plus some additional functionality that is actually provided
    later on。 That has to do with things like accessing variables and so on， which
    is not here。
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 所以注意这里我们已经实现了星号、加号、点、句点、emit 输入和 nl 指令，好的？所以这就是我们编译器目前能够做到的。加上一些实际上在后面提供的额外功能。这与访问变量等事情有关，而这些在这里并不存在。
- en: But those are special because they work a little bit different。 They're a little
    bit more elaborate。 okay？ So let's go to the very end of our code。
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些是特别的，因为它们的工作方式有点不同。它们稍微复杂一些。好的？那么让我们看看代码的最后部分。
- en: '![](img/86495766b190929aba361b4772d72632_38.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_38.png)'
- en: We have the main， and this is actually designed so that you can just read the
    main and have a general idea of how this works。 okay？ So any moment， remember，
    if you want to see the implementation of any of these functions。 just， I think，
    if you tap， if you press control， and then just click with your mouse on the name。
    it will take you to the definition or use command， I think， if you're using a
    Mac， okay？
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有main，这实际上是为了让你可以只阅读main，并对其工作原理有一个大致的了解，明白了吗？所以任何时候，记住，如果你想查看这些函数中的任何一个的实现。只需，我认为，如果你按下控制键，然后用鼠标点击名称。它将带你到定义，或者如果你使用的是Mac，使用命令键，明白了吗？
- en: So if you want to see， for example， how checkards works or how it's implemented
    or remove comments or whatever。 just press command or control。 And then you hover
    over of the name and as you can see there's sort of a link there。 So， for example，
    here remove comments， if I press command and then click over here。 it takes me
    to the definition of the corresponding function， okay？ So， I mean。
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你想看看，比如说，checkards是如何工作的，或者它是如何实现的，或者删除注释之类的。只需按下命令键或控制键。然后将鼠标悬停在名称上，正如你所看到的，那里有一个链接。因此，比如说，在这里删除注释，如果我按下命令，然后点击这里。它会带我到相应函数的定义，明白了吗？
- en: this is a standard visual studio code behavior， okay？
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这是标准的Visual Studio Code行为，明白了吗？
- en: So this is a fast way that you can see the implementation。 But the general thing
    that it's doing is pretty obvious， hopefully， I hope。 by the names that I'm using
    here in the different instructions。 So， in line 153。 we check the arguments。 This
    program is going to be run as a script in the command line。
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是你可以快速查看实现的一种方式。但它所做的总体事情是相当明显的，希望我希望。通过我在不同指令中使用的名称。因此，在第153行。我们检查参数。这个程序将作为脚本在命令行中运行。
- en: in the terminal。 So checkards is just going to verify that I've sent one command
    line argument that is the name of the file that I'm。 the cheeky fourth file that
    I'm compiling， okay？ If it's not。 it just produces an error and ends the program。
    Line 154 takes from this argument。 Rv， remember。 is the vector of arguments。 It's
    just a list that contains the arguments in the command line。 Okay。
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端。所以checkards只是要验证我是否发送了一个命令行参数，也就是我正在编译的文件的名称，也就是那个调皮的第四个文件，明白了吗？如果没有，它就会产生一个错误并结束程序。第154行取自这个参数。Rv，记住，是参数的向量。它只是一个包含命令行中参数的列表，明白了吗？
- en: so in index one， this is where the name of the cheeky fourth file should be
    found。 Okay。 so I just put it here in this variable called full source name。 This
    is the name。 includes any directories if that's part of the path of the file。
    All this is included here。 So full source name is the full name of our cheeky
    fourth source program， okay？
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引一中，这里应该找到那个“调皮的第四个文件”的名称。好的。所以我把它放在一个叫做full source name的变量里。这是名称，包括任何目录，如果那是文件路径的一部分。所有这些都包含在这里。所以full
    source name是我们调皮的第四个源程序的完整名称，明白了吗？
- en: Then we do this thing called read words。 Read words。 actually what it does is
    that it reads the contents of the corresponding file。 If the file is actually
    there and it's found and it can be opened， it gets open。 And then as I mentioned
    before， it uses the split operation， the Python split over a string。
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们做一件叫做读取单词的事情。读取单词。实际上它的作用是读取相应文件的内容。如果文件确实存在并且可以打开，那么它就会被打开。如我之前提到的，它使用字符串的分割操作，即Python的split。
- en: and it returns a list of all the individual words， okay？ Remember。 these words
    are just things that are separated by spaces or new lines or whatever， okay？
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个包含所有单个单词的列表，明白了吗？记住。这些单词只是通过空格或换行符或其他方式分隔的东西，明白了吗？
- en: So this variable in line 155， called words， contains all the words of our program，
    okay？
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在第155行，这个叫做words的变量包含了我们程序的所有单词，明白了吗？
- en: Separated as individual strings now， okay？ There's a list of strings representing
    the single words in our program。 In line 156， remove comments looks for words
    that actually represent or is an individual word that starts with an opening parentheses。
    So when it finds it， it knows that everything that follows should be ignored until
    it finds the corresponding closing parentheses。 Okay， so remove words， remove
    comments， excuse me， does what you might imagine。
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在作为单独的字符串分隔，明白了吗？这是一个表示我们程序中单词的字符串列表。在第156行，remove comments寻找那些实际上表示或是以开放括号开头的单独单词。因此，当它找到时，它知道接下来的所有内容都应该被忽略，直到找到对应的闭合括号。好的，所以remove
    words，抱歉，remove comments做了你可能想象的事情。
- en: It actually eliminates the comments from our words， okay？ So at this point。
    we only have the code that we really care about in of our cheeky-forged input。
    Result is a local variable here that starts as an empty list。 Okay。 this is where
    I'm going to be putting all the instructions that are going to go as part of my
    output once we start generating it。
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上会从我们的文本中消除注释，明白吗？所以在这一点上，我们只保留我们真正关心的代码在我们那个调皮的伪造输入中。结果是一个局部变量，从一个空列表开始。好的，这里是我将放置所有将在生成输出时使用的指令的地方。
- en: okay？ So it will include all the instructions。 The part that goes at the beginning
    at the end of my what source file and then all the individual instructions that
    we need to place。 So they get appended using， well， append， okay？ So this is a
    nor a new list。
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 明白吗？所以它将包括所有的指令。我的源文件开头和结尾的部分，然后是我们需要放置的所有单独指令。所以它们使用 append 追加，明白吗？所以这不是一个新列表。
- en: So we start here by appending everything that goes at the beginning。 Okay。 remember
    we saw this multi-line string that contained all the initial declarations that
    have to go in a what source file at the very beginning。 okay？ Then in line 159，
    this specific instruction， this function， well。 if we look at it from the nested
    part， first this function is called。
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们从这里开始，添加所有位于开头的内容。明白吗？记得我们看到这个包含所有初始声明的多行字符串，它必须放在一个源文件的最开头，明白吗？然后在第 159
    行，这个特定的指令，这个函数，好吧。如果我们从嵌套部分来看，首先这个函数被调用。
- en: This is going to look for all the variables that are used in the program， okay？
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这将查找程序中使用的所有变量，明白吗？
- en: So it just looks and see which variables are used and they can be used in two
    ways。 It can be used just the name of the variable。 If you remember， if the variable
    appears by itself。 it means that we should detect or whenever we use it。 it's
    just read the value of the variable and push that value into the top of the stack。
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它只会查看哪些变量被使用，并且可以以两种方式使用。可以仅使用变量的名称。如果你记得，变量单独出现时，意味着我们应该检测或者无论何时使用它。它只是读取变量的值并将该值推送到栈顶。
- en: Or we find a variable name followed by a bang symbol， the exclamation mark，
    okay？ And in that case。 we know that we need to set that value。 But at the end，
    it doesn't really matter how we use it。 As long as we use a variable， we need
    to find it， so find_vars just returns me。 I think it's a list of all the variables
    that are used in the program in any fashion， okay？
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们找到一个变量名后面跟着一个感叹号，也就是叹号，明白吗？在这种情况下，我们知道需要设置那个值。但最后，实际上我们怎么使用它并不重要。只要我们使用一个变量，就需要找到它，所以
    find_vars 只会返回我。我认为这是一个包含程序中以任何方式使用的所有变量的列表，明白吗？
- en: And then once we found them， we declare them， okay？ And the declare_vars， actually。
    if we look at the implementation here of the declare_vars， okay？ It uses this
    instruction here。 local， followed by the name of the variable， starting with a
    $ sign， okay？
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦我们找到了它们，就声明它们，明白吗？而 declare_vars 实际上。如果我们查看 declare_vars 的实现，明白吗？它使用这个指令。local，后面跟着变量的名称，以
    $ 符号开头，明白吗？
- en: Because all local names in WebAssembly have to start with a $ sign。 But here
    we put the name of the variable， okay？ And we declare it as an i32 and place everything
    within these parentheses。 okay？ The opening and closing here。 And there's this
    other variable。 it's actually named constant indentation。 It's just a string with
    four spaces， okay？
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有 WebAssembly 中的局部名称都必须以 $ 符号开头。但在这里我们放入变量的名称，明白吗？我们将其声明为 i32，并将所有内容放在这些括号内，明白吗？开括号和闭括号在这里。而另一个变量实际上叫做常量缩进。它只是一个包含四个空格的字符串，明白吗？
- en: This is just for legibility's sake， okay？ Strictly speaking， it's not really
    required。 but it makes our code a little bit easier to understand， okay？
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是为了可读性，明白吗？严格来说，这并不是必需的，但它让我们的代码更容易理解，明白吗？
- en: It's just had some nice looking indentation there， okay？
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是有一些不错的缩进，明白吗？
- en: So this declares all the variables that appear。 Any variable declared here has
    a default value of zero。 so we don't need it even to initialize it， okay？ Automatically。
    these local variables all have an initial value of zero， okay？ So as we mentioned
    before。 if we happen to use a variable without assigning any previous value to
    it， by default。
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这声明了所有出现的变量。这里声明的任何变量都有一个默认值为零。所以我们甚至不需要初始化它，明白吗？这些局部变量自动都有一个初始值为零，明白吗？所以如前所述，如果我们碰巧使用一个变量而没有给它赋值，默认情况下。
- en: it's a zero that we get there， okay？ Let's go back here。 So the clear virus
    is the one that actually adds any variable declarations that are required here。
    And then this is really the core of our compiler。 It's called code generation。
    This is really where all the code generation actually happens， okay？
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的是一个零，明白吗？让我们回到这里。所以清除变量是实际添加所需的任何变量声明的地方。然后这实际上是我们编译器的核心。它被称为代码生成。这才是真正发生所有代码生成的地方，明白了吗？
- en: Let's have a look at it because it is interesting and relevant。 Okay？
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下，因为这很有趣且相关。好吗？
- en: So the code generation function takes where the result is going to be placed
    and all the words of our program that we're going to consider here for translation。
    We just do a four， okay？ We iterate over all the words， each iteration。 each individual
    word is called word， okay？ And these are the things that I'm considering here。
    First of all， if the word is a number， okay？ If the。
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 所以代码生成函数接收结果将放置的位置以及我们将考虑用于翻译的程序中的所有词。我们只是做一个循环，明白吗？我们遍历所有的词，每次迭代，每个单独的词称为词，明白了吗？这些是我在考虑的事情。首先，如果这个词是一个数字，明白了吗？
- en: here the word that we're currently analyzing happens to be a number。 we just
    push it here using this instruction that we use in the past， i32。comst。 And then
    the。 whatever the word is， okay？ So if we find a five， if we find a three。 if
    we find a forty-two in our input， in our input， a tricky fourth source program。
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们分析的这个词恰好是一个数字。我们只需使用过去使用的这个指令i32.const将其推入这里。然后是无论这个词是什么，明白吗？所以如果我们在输入中找到一个五，如果我们找到一个三，如果我们在输入的复杂Forth源程序中找到四十二。
- en: we just push it into the stack， okay？ Using the i32 constant instruction。 If
    the word that we're currently processing belongs to any of the keys of the operation
    dictionary。 remember the operation dictionary is this one here。 So if any of the
    words is a star， a plus， a dot。 an emit， an input， an L， any of those， okay？ If
    it's any of those。
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将其推入栈中，明白吗？使用i32常量指令。如果我们当前处理的词属于操作字典的任何键。记住操作字典就是这个。所以如果任何词是星号、加号、点、发射、输入、L，任何这些，明白了吗？如果是其中任何一个。
- en: what we're gonna do is that we're just gonna place the associated statements
    that we have in the dictionary。 and we're gonna just put them in the result， okay？
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是将字典中相关的语句放在一起，然后将它们放入结果中，明白了吗？
- en: We use another internal for because it might be several， and this is just done
    too。 And practice just to make sure that we add the indentation to each individual
    statement here， okay？
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用另一个内部循环，因为可能有多个，这样做只是为了确保我们对每个单独的语句添加缩进，明白了吗？
- en: If we find a variable， just a variable， plain variable to read， not to set，
    okay？
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到一个变量，仅仅是一个变量，简单的变量来读取，而不是设置，明白了吗？
- en: The variable that instruction just gets translated into a local get with the
    name of the variable and the dollar sign at the beginning。 And this is the other
    case when we have variables that end in a bank operation， okay？
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 那个指令中的变量会被转换成一个局部获取，变量的名称前面加上美元符号。还有另一种情况是，当我们有以银行操作结尾的变量时，明白了吗？
- en: So here's the exclamation mark at the very end of the word。 And if the rest
    of the word。 the things that go before the bank are a valid variable name， then
    we convert that into a set， okay？
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里是词末尾的感叹号。如果词的其余部分，也就是在银行之前的内容是有效的变量名称，那么我们将其转换为设置，明白了吗？
- en: So get and set， this local get and local set are responsible for， in the case
    of get。 reading the value of a variable and pushing it into the top of stack，
    and set does the opposite。 which is take the top of the value of the stack， set
    and copies it into the variable， okay？
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 所以获取和设置，这个局部获取和局部设置负责在获取的情况下，读取变量的值并将其推入栈顶，而设置则做相反的操作，即取出栈顶的值，将其设置并复制到变量中，明白了吗？
- en: So we got the two things that we want to do with variables。 which is read those
    values and then update them， okay？ Or assigning them。 which is what the set operation
    does in WebAssembly。 And here remember it corresponds in Chickyforth when you
    use an exclamation mark， okay？
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们想对变量做的两件事是读取这些值，然后更新它们，明白了吗？或者分配它们。这就是WebAssembly中的设置操作所做的。这里要记住的是，当你在Chickyforth中使用感叹号时，它是对应的，明白了吗？
- en: If none of these actually went in， it means that we found a word that we don't
    know what it is。 and if it's not something that we want， which it isn't， we just
    throw an exception。 a raise an exception here， okay？ Once again， this example。
    this compiler is fairly simple to a really full-blown compiler。
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些都没有进入，意味着我们发现了一个我们不知道是什么的单词。如果它不是我们想要的，而它确实不是，我们只需抛出一个异常，抛出一个异常，明白吗？再次强调，这个例子，这个编译器相对于真正的完整编译器来说是相当简单的。
- en: I've been teaching compiler construction for 20 years at my university。 So typically
    building a compiler is something that we take a full semester to do， okay？
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的大学教授编译器构建已有20年了。所以通常构建一个编译器是我们需要花一个完整学期来完成的，明白吗？
- en: And we have to do lexical analysis and syntactic analysis， semantic analysis。
    and then we do code generation and optimizations and stuff。 So all that takes
    a lot of time， okay？
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要进行词法分析、句法分析、语义分析。然后我们进行代码生成和优化等等。这一切都需要花费很多时间，明白吗？
- en: But now， well， in just around 150 lines of code， we see a full working compiler。
    Because once again。 the language that we're really compiling is very， very simple，
    okay？ The essence really。 if you want to think of what does it do is that it takes
    the name of a file， it reads a file。 it uses a split to separate the individual
    words， and then looks at each word and says， okay。
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，只需大约150行代码，我们就能看到一个完整的工作编译器。因为我们真正编译的语言非常简单，明白吗？本质上，如果你想知道它是做什么的，就是读取一个文件名，读取文件，使用split来分隔单独的单词，然后查看每个单词，明白吗？
- en: what do we need to do with this word， okay？ And most of the words can actually
    be translated thanks to this dictionary called operation。 okay？ So that's a general
    overview of our compiler， okay？ And yes， we need to， in the produce code。 we need
    to put something at the beginning and then at the end。 So at the end we have something
    that is a complete full-valued WebAssembly text file， okay？
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对这个单词做什么，明白吗？大多数单词实际上可以通过一个叫做operation的字典进行翻译，明白吗？所以这就是我们编译器的一般概述，明白吗？是的，我们需要在生成的代码中放入一些东西，在开始和结束时。所以最后我们有一个完整的WebAssembly文本文件，明白吗？
- en: At the end， if we follow once again， go back to the description here in the
    main， what's happening。 okay？ We were looking here at code generation， okay？ Once
    we've finished code generation。 we just add what goes at the very end of the two
    closing parentheses that were in the string。 We put that in result， okay？ And
    then we do this magical function called join。 Okay。
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们再次回到描述这里，发生了什么，明白吗？我们在这里查看代码生成，明白吗？一旦我们完成了代码生成，我们只需在字符串中的两个闭合括号的结尾添加内容。我们将其放入结果中，明白吗？然后我们调用这个神奇的函数，叫做join，明白吗？
- en: we're joining all the strings together， just separating each string with a new
    line， okay？
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有字符串连接在一起，只需用换行符分隔每个字符串，明白吗？
- en: I don't know if you've used join in other languages。 but Python actually has
    the object and the arguments switched in the opposite order in which you typically
    find the join operation in most other languages。 okay？ Most languages typically
    you have an object， which is a list。 and over the list you do the join and just
    tell it。
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你是否在其他语言中使用过join，但Python实际上将对象和参数的顺序与大多数其他语言中的join操作是相反的，明白吗？大多数语言通常你有一个对象，就是一个列表，然后在这个列表上执行join，并告诉它。
- en: I use this string to separate these individual lines， but for some reason， the
    --， \>\> [INAUDIBLE]。 \>\> Yes， but in other object-oriented languages， I don't
    remember， for example。 JavaScript has a join， but if it does， typically is the
    method is associated to the list。 and the argument is the string that is going
    to be used to --， \>\> [INAUDIBLE]。
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用这个字符串来分隔这些单独的行，但出于某种原因，--， \>\> [听不清]。 \>\> 是的，但在其他面向对象的语言中，我不记得，例如，JavaScript有一个join，但如果有，通常是该方法与列表关联，而参数是用于--的字符串，
    \>\> [听不清]。
- en: \>\> I think it wasn't really that difficult to do it the other way around。
    but for some reason they decided， I really don't know if it was a widow who decided
    to do it this way。 but once again， if you're using Python only， it's not a big
    issue because you already know this。 but I find it sometimes confusing because
    in other languages I'm expecting to use it。
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: \>\> 我认为反过来做并不太难，但出于某种原因他们决定这样做，我真的不知道是不是某个开发者决定这样做，但再次强调，如果你只使用Python，这并不是个大问题，因为你已经知道这一点。但我有时感到困惑，因为在其他语言中我期望使用它。
- en: The arguments in the other way， okay， but it's just a comment there， okay？
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的顺序相反，明白吗，但这只是一个评论，明白吗？
- en: It really doesn't really have to be in a certain way， okay？ Here in line 163，
    163。 we separate -- we extract the extension of the file that was provided in
    the command line arguments。 okay？ So if my file was called hellworld。4th， the
    fourth extension we're going to use is a four followed by TH。 okay？ That's a fourth
    extension。 We eliminate the dot and the extension。
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的不需要以某种特定方式呈现，好吗？在第 163 行，我们分离——提取了在命令行参数中提供的文件的扩展名。好吧？所以如果我的文件叫做 hellworld。4th，第四个扩展名是一个四，后面跟着
    TH。好吧？那就是第四个扩展名。我们消除点和扩展名。
- en: and now we have the full name without extension of our input file。 and we use
    that file name for two things。 We're going to create a what file in our file directory
    as part of our local file system and corresponding WASM。 And this WASM here， this
    actually calls， if we look at the implementations right here。 calls a function
    called WAT2Wasm， which does exactly the same thing as a WAT2Wasm utility that
    we use from the command line。
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到了输入文件的完整名称，没有扩展名。我们用这个文件名做两件事。我们将创建一个 WAT 文件，放在我们的文件目录中，作为我们本地文件系统的一部分，以及相应的
    WASM。而这里的 WASM，如果我们查看这里的实现，实际上调用了一个名为 WAT2Wasm 的函数，它与我们从命令行使用的 WAT2Wasm 实用程序做的事情完全相同。
- en: okay？ These happen to have the same name， but the one that we use in the command
    line was part of this webit tools that you can use from the command line。 This
    WAT2Wasm is part of a package called WASM， okay？ WAT2Wasmr Python， okay。 which
    is another runtime system for WebAssembly， and this one particularly well runs
    with Python。 okay？ But the general idea is the same。 It converts， in this case，
    what is contained in a string。
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？这些恰好有相同的名称，但我们在命令行中使用的那个是来自这个可以在命令行中使用的 webit 工具。这个 WAT2Wasm 是一个叫做 WASM 的包的一部分，好吗？WAT2Wasmr
    Python，好吧。这是 WebAssembly 的另一个运行时系统，而这个特别适合与 Python 一起使用。好吗？但是总体思路是相同的。它转换的是，具体来说，是字符串中包含的内容。
- en: It's converted into a binary object， okay？ Which we then in line 148， write
    it into a file， okay？
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 它被转换为二进制对象，好吗？我们在第 148 行将其写入一个文件，好的？
- en: So I'm writing these two files， the WAT2Wasm file。 Strictly speaking。 we could
    omit the WAT file because this was created just as an intermediate thing。 but
    actually we don't really need it once we used it to create the WASM file， okay？
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我正在写这两个文件，WAT2Wasm 文件。严格来说，我们可以省略 WAT 文件，因为它只是作为一个中间文件创建的。但实际上，一旦我们用它创建了 WASM
    文件，就不再需要它，好的？
- en: But because it's useful and educational， we can have the WAT file and we can
    open an editor and see what it has known。 Especially when we're doing the development，
    it's very useful for debugging purposes and see if we did everything correctly。
    okay？ So this is why we're creating these two files， yes？ \>\> [inaudible]。 \>\>
    You need to use special tools to actually do that， okay？ So just for example。
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 但因为它很有用且具有教育意义，我们可以有 WAT 文件，并且可以打开编辑器查看它所包含的内容。特别是在开发过程中，这对于调试非常有用，可以查看我们是否做对了一切。好吗？所以这就是我们创建这两个文件的原因，是吧？
    \>\> [听不清]。 \>\> 你需要使用特殊工具来实际完成这项工作，好吗？所以只是举个例子。
- en: I mean if you want to look at it now， I'm currently still here at the WAT directory。
    and I wasn't really prepared for this， but let's see if I remember。 There is a
    utility available here that is called WASM， I think it's WASM object。 Object dump。
    it's called， OBG dump。 Where here， you can use for example the option -D。
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意思是，如果你想现在查看，我目前仍在 WAT 目录中。我并没有真正为此做好准备，但让我们看看我是否还记得。这里有一个可用的工具叫做 WASM，我认为它是
    WASM 对象。对象转储。它被称为 OBG 转储。在这里，你可以使用例如选项 -D。
- en: this one disassembles and then you specify here your WASM file。 And this one
    will generate the disassembled code of whatever you have here， okay？
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这个会反汇编，然后你在这里指定你的 WASM 文件。这个将生成你在这里的任何内容的反汇编代码，好的？
- en: This is not in the notes， okay， but just write it down if you find this amusing
    or interesting。 Here it actually displays the disassembly。 As you can see， it's
    basically the same instructions。 but the rest of it is not using the names of
    our parameters。 and even the constants as you can see are actually in Exedesimal。
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这在笔记中没有提到，好吧，但如果你觉得这有趣或引人入胜，就把它写下来。这里实际上显示了反汇编。正如你所见，它基本上是相同的指令。但是其余部分并没有使用我们参数的名称。甚至你可以看到常量实际上是十六进制的。
- en: so they might be a little bit complicated to understand。 But here。 these are
    the Exedesimal equivalent bytecodes you can call them， okay。 for the program that
    we have here， okay？ So this is a way of inspecting your binary file if you want
    to。 okay？ Once again， you can't， or you shouldn't really open WASM files in an
    editor。
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 所以理解起来可能会有点复杂。但是这里。这些是你可以称之为Exedesimal等价字节码，好的？针对我们这里的程序，好的？所以这是检查你的二进制文件的一种方式，如果你想的话。好的？再一次，你不能，或者说你真的不应该在编辑器中打开WASM文件。
- en: but there are tools that allow you to inspect it like this one here。 Okay， the
    WASM -D。 this allows you to do a disassembly， so you can see the corresponding
    code。 As you can see。 this one here represents the AVG2 function， and this one
    is the AVG3 one， okay？
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 但有工具允许你像这样检查它，比如这里的WASM-D。这个工具允许你进行反汇编，所以你可以看到相应的代码。正如你所见。这部分代表AVG2函数，这部分是AVG3函数，好的？
- en: And it has the same instructions that we have here， plus it adds some， for example。
    we didn't put an explicit end， but here it's actually added。 And instead of using
    the option -D。 you can use the option -X， and this one gives you the disposition
    of the different sections that the WASM file has。 okay？ It has a section for types，
    a section for functions， a section for exports。
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 它有与我们这里相同的指令，并且增加了一些，例如。我们没有明确地放一个结束，但这里实际上加上了。并且不用选项-D，你可以使用选项-X，而这个选项给你WASM文件不同部分的分布情况。好的？它有一个类型部分，一个函数部分，一个导出部分。
- en: and then a section for code， okay？ So this one allows us to see more in detail
    the corresponding sections that are available。 okay？ So this utility is WASM -OBJ
    dump， okay？ If you want to look at what's in the WASM file， okay？
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是一个代码部分，好的？所以这个部分让我们能够更详细地查看可用的相应部分。好的？所以这个工具是WASM-OBJ dump，好的？如果你想查看WASM文件中的内容，好的？
- en: Once again， if you try to open it， I mean you can try it， open the WASM file。
    you get this message saying the file is not displayable in the editor because
    it's either binary or users and support in text encoding。 okay？ Do you want to
    open it anyway？ Well， let's say yes， okay？ Use the text editor， and okay。 it doesn't
    really look like anything useful， okay？ As you can see。
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，如果你试着打开它，我是说你可以试试，打开WASM文件。你会看到这个消息，提示文件无法在编辑器中显示，因为它是二进制文件或用户不支持文本编码。好的？你想还是打开它吗？好吧，假设我们说是，好的？用文本编辑器，好的。它看起来并没有什么有用的，好的？如你所见。
- en: something interesting that is available there is that it contains the name。
    you can see the name of our exported functions， ABG2 and ABG3， here they are。
    [ Inaudible ]， Yeah。 and another interesting thing is it has a magic number at
    the beginning， okay？ It starts with。 don't remember what's the very beginning
    here。 It's probably easier to look here at using an ordinary x dump。
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的地方，它包含了名称。你可以看到我们导出的函数的名称，ABG2和ABG3，它们在这里。[听不清]，是的。还有另一个有趣的事情是它在开头有一个魔法数字，好的？它以……开始。记不清这里的开头是什么。用普通的x
    dump来看可能更容易。
- en: Let's see if this works。 Okay， this x dump just places all the contents。 and
    you can see here the magic number at the beginning of this file is zero。 which
    is this representative is stopped。 And here we have 6173 and 6D， these are excitimal
    numbers。 They correspond to the letters AS and M。 This is how we can see that
    this is actually a binary as in WebAssembly text file。
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是否有效。好的，这个x dump仅仅是列出了所有内容。你可以在这里看到这个文件开头的魔法数字是零。这是这个代表性的停止。这里我们有6173和6D，这些是excital数字。它们对应于字母AS和M。这是我们可以看到这是一个WebAssembly文本文件的二进制方式。
- en: okay？ So this is using a standard Unix or Linux utility call x dump just to
    see the content of the files。 Okay， notice that x dumps allow us to see an excitimal
    all the corresponding bytes that are in part。 So this is useful when you have
    a binary file， okay？
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 好的？所以这是使用标准的Unix或Linux工具x dump，仅仅是为了查看文件的内容。好的，请注意x dump允许我们查看所有相应字节的excital。这在你有一个二进制文件时很有用，好的？
- en: But it doesn't really give us a lot of information。 It just， well， it's not
    immediately obvious。 but it contains all the byte encoding for the instructions，
    and here's the magic number。 and as you can see here， this is the magic number。
    And as you can see here。 this is a section of the exports， okay？ That in the previous
    output that we had here， export to。
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 但它并没有给我们很多信息。它只是，嗯，没那么明显。但它包含了所有指令的字节编码，而这里就是魔法数字。正如你所看到的，这就是魔法数字。正如你所看到的。这是导出部分，好的？在我们之前的输出中，导出到。
- en: it has a bg2 and 3， which we can see that they're actually here， okay？ And，
    well。 the rest is obviously valid information， but an interesting thing here is
    that the WebAssembly binary files that we can take here are fairly small。 So I
    don't know if you've seen， for example， if you use any compiler for C or C++ or
    Go or Rust。 in C and C++ typically， an executable binary file is with all the
    information that it requires。
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个bg2和3，我们可以看到它们实际上在这里，好吗？而且，剩下的显然是有效信息，但有趣的是，我们可以在这里获取的WebAssembly二进制文件相当小。所以我不知道你是否见过，比如说，如果你使用任何C、C++、Go或Rust的编译器。在C和C++中，通常，一个可执行的二进制文件包含所有所需的信息。
- en: So it parses typically a few hundred or maybe tens of thousands of kilobytes，
    excuse me， big， okay？
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它通常解析几百或几万千字节，抱歉，比较大，好吗？
- en: So you might have a hello world in its， I don't know， just to say number， 80，000
    bytes wide or big。 your corresponding file， okay？ WebAssembly is very， very， very
    small。 and this is very useful when you're transporting or sending your files
    between a server and a client。 So it's really your files to be very small， okay？
    Because it's very big， of course。
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可能有一个hello world，它，我不知道，随便说说，80,000字节宽或大。你的相应文件，好吗？WebAssembly非常，非常，非常小。这在你在服务器和客户端之间传输或发送文件时非常有用。所以你希望你的文件非常小，好吗？因为如果非常大，当然。
- en: it's going to take much more bandwidth to actually get it there where you want
    to。 So WebAssembly is really compact and small format and that's very useful as
    it is， okay？
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 它将需要更多的带宽才能把它送到你想要的地方。所以WebAssembly确实是一个紧凑小巧的格式，这非常有用，是的，好吗？
- en: So going back， let's see where we're going。 We should be able， at this point。
    here's the description of what we explained a moment ago。 There's this thing that
    we need to see in order to run our code， remember。 WebAssembly needs a hosting
    environment to run。 The examples that we saw a moment ago using Wasm3。
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 所以回到之前的内容，我们来看我们要去的地方。此时我们应该能够看到这里是我们刚才解释的内容的描述。我们需要看到这个以运行我们的代码，请记住。WebAssembly需要一个托管环境来运行。我们刚才看到的例子使用的是Wasm3。
- en: that was a runtime environment， that actually is an interpreter。 that allows
    us to see our code running。 But we're now going to be integrating it using this
    Python package called Wasmir。 okay？ Wasmir has all the functionality to do most
    of the things that you would expect to process WebAssembly text files and binary
    files。 okay？ It allows you to take a WebAssembly， a WAT file， a WebAssembly text
    format。
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个运行时环境，实际上是一个解释器。它允许我们看到我们的代码运行。但是我们现在要使用一个叫做Wasmir的Python包进行集成。好的？Wasmir具有处理WebAssembly文本文件和二进制文件的大多数功能，正如你所期待的那样。好的？它允许你在Python程序中使用WebAssembly，一个WAT文件，即WebAssembly文本格式。
- en: and it converts into Wasm to the binary format。 It can take an already compiled
    Wasm file in binary form。 it can actually take it， translate it， convert it。 get
    the module converted into an instance that it's called， and execute that， okay？
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 它将Wasm转换为二进制格式。它可以接受已经编译的Wasm文件的二进制形式。它实际上可以接受、翻译、转换。将模块转换为实例并执行它，好吗？
- en: Within a Python program， okay？ So this is a really interesting part of how this
    is integrated。 And in order to see that there is this program here， I'm not going
    to look at it in too much detail。 But this one is in this program called Execute。py。
    It has all the functionality。 Let's open it here quickly。 Where am I？ Oh， here
    we are。 Let's close this。 And let's open here。
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个Python程序中，好的？所以这是关于如何集成的一个非常有趣的部分。为了看到这一点，这里有一个程序，我不会详细查看。但这个程序叫做Execute.py。它有所有的功能。让我们快速打开它。我在哪儿？哦，我们到了。让我们关闭这个。然后让我们在这里打开。
- en: Execute。py。 So here， if you go to the very end， okay？ This is what the main
    function does here。 Just as we did in the previous program， it checks that the
    number of arguments are correct。 Here we're expecting to receive a Wasm file，
    okay？ If it is， we create an instance。 This create instance just encapsulates
    all the logic that is required。 Here it is。
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Execute.py。所以在这里，如果你到最后，好的？这就是主函数在这里做的事情。就像我们在之前的程序中一样，它检查参数的数量是否正确。这里我们期望接收到一个Wasm文件，好吗？如果是，我们创建一个实例。这个创建实例封装了所需的所有逻辑。就在这里。
- en: This actually uses extensively a lot of functionality provided by Wasmir。 So
    if you really want to go and see how all this works， check the Wasmir documentation。
    It needs to create several objects， a storer object， an instance， a module， and
    so on。 So I'm putting everything here just together so that it just works。
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上大量使用了 Wasmir 提供的功能。因此，如果你真的想了解这一切是如何工作的，可以查看 Wasmir 文档。它需要创建多个对象，包括存储对象、实例、模块等等。所以我把所有东西放在一起，这样它就能正常工作。
- en: As long as you send a file name there in line number 54。 a file name that is
    actually a valid Wasm file， okay？ It will be able to read it， to instantiate it。
    and to do just-in-time compilation and everything that is required。 Notice here
    that we're using this operation called engine。get， okay？
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你在第 54 行发送一个文件名，一个实际上是有效的 Wasm 文件的文件名，好的？它就能够读取、实例化并进行即时编译以及所需的所有操作。注意，我们在这里使用的这个操作叫做
    engine.get，好的？
- en: This is the just-in-time compilation， okay？ And at the end we return this instance
    object that contains all the information。 Now another thing that is important
    here is that it calls this make import object。 which is a function that is just
    over here。 And the interesting part here is that it contains the code that we
    imported from our WebAssembly modules。 okay？ Remember， at the very beginning of
    what we're going to be producing。
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是即时编译，好的？最后我们返回包含所有信息的实例对象。现在这里还有一个重要的事情，就是它调用了这个 make import object 的函数。这个函数就在这里。这里有趣的部分是，它包含我们从
    WebAssembly 模块导入的代码，好的？记住，在我们要生成的内容一开始。
- en: we had three import instructions。 And these are the functions that are going
    to be called whenever we do a call to the corresponding function。 okay？ So here
    we have the emit， the input and the print instructions。 These are Python instructions。
    As you can see， for example， the print is very simple。 We receive here an integer。
    We use actually annotations here so that the tool knows what we are expecting
    to send as input and to produce as output。
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个导入指令。这些是每当我们调用相应函数时将被调用的函数，好的？在这里我们有 emit、input 和 print 指令。这些都是 Python
    指令。正如你所看到的，例如，print 是非常简单的。我们在这里接收一个整数。我们实际上使用注解，这样工具就知道我们期望发送的输入和产生的输出。
- en: But here we receive here an integer and we just use standard print。 Actually
    this function is called underscore print because otherwise what I enter into a
    conflict with a predefined function called print。 We just print the value of X
    which is an integer and we put it at the end just instead of a standard new line
    which is what typically ends our print instruction。 We're ending with a space
    here， okay？ For the input we use the input instruction and we call int。
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这里，我们接收到一个整数，我们只使用标准打印。实际上这个函数被称为 underscore print，因为否则我输入的内容会与一个叫做 print
    的预定义函数发生冲突。我们只打印整数 X 的值，并将其放在末尾，而不是标准的新行，这通常结束我们的打印指令。我们在这里以空格结束，好的？对于输入，我们使用输入指令并调用
    int。
- en: If this happens to produce an exception， a value error exception， we just return
    a zero， okay？
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这导致产生异常，即值错误异常，我们只需返回零，好的？
- en: So the input doesn't crash， okay？ If you put anything that is not a valid integer。
    it just returns a zero， okay？ And here we have the emit which is very similar
    to print。 We just convert X which is an integer into its corresponding character。
    So we use the CHR which is a standard function in Python that takes an integer
    value and converts it into a string that contains。
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 因此输入不会崩溃，好的？如果你输入任何不是有效整数的内容，它只会返回零，好的？在这里我们有 emit，它与 print 非常相似。我们只需将整数 X 转换为其对应的字符。因此我们使用
    CHR，这是 Python 中的标准函数，可以将整数值转换为包含该字符的字符串。
- en: the corresponding character of that code point， okay？
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码点的对应字符，好的？
- en: And in the case of the end we don't add a space， we just keep the cursor where
    it is， okay？
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束的情况下，我们不添加空格，只需保持光标在当前位置，好的？
- en: So with all that in mind we should be able to see how this can work。 So in order
    to make it work we need to change first to this directory called fourth， okay？
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 所以考虑到这些，我们应该能够看到这如何工作。因此，为了使其工作，我们需要首先切换到名为 fourth 的目录，好的？
- en: Once again remember you can change it， here's the command if you want to change
    it from anywhere in your current system。 So you can use that one there， it's a
    CD instruction。 Or you can。 if you know how to navigate here in Linux you can
    go to the correct directory。 You can change the prime directory and then go to
    the directory you want， okay？
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 再次记住，你可以更改它，这里是命令，如果你想在当前系统的任何地方进行更改。你可以在那里使用那个，它是CD指令。或者如果你知道如何在Linux中导航，你可以去正确的目录。你可以更改主目录，然后去你想要的目录，好的？
- en: And here in the fourth， so in order to run the compiler， the compiler is called
    "chicky fourth"。 okay？ You just put the name。 Remember here the "chicky fourth"
    actually has a hash bang at the beginning and it has execution permission so we
    can just execute it like this。
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四个，为了运行编译器，编译器叫做“chicky fourth”。好的？你只需输入名称。记住这里的“chicky fourth”实际上在开头有一个哈希标记，并且具有执行权限，所以我们可以像这样执行它。
- en: okay？ 。slash and then the name， okay？ It knows the operating system。 knows that
    we are able to run this program， okay？ And let's try it with first example which
    is called numbers。 okay？ This is a fourth program， let's quickly look at it。 Here's
    examples and here's numbers， okay？
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 好的？斜杠然后是名称，好的？它知道操作系统。知道我们能够运行这个程序，好的？让我们尝试第一个示例，称为数字。好的？这是第四个程序，让我们快速看看它。这是示例，这里是数字，好的？
- en: So we have a quick description of what this does。 As you can see it says "Add
    and multiply two user provided numbers"。 So here we start with these two emit
    instructions。 This actually just prints a greater than symbol and then a space
    so it looks like a prompt and then allows us the user to do an input and whatever
    his input is placed on top of the stack。 And with this we pop the stack and just
    copy this into the variable "x" and we do the same thing with "y"。
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们对这个程序的功能有一个简要描述。正如你所见，它说“添加和乘以两个用户提供的数字”。所以这里我们从这两个发出指令开始。它实际上只打印一个大于符号，然后是一个空格，看起来像一个提示，然后允许用户进行输入，无论他的输入是什么，都放在堆栈顶部。然后我们弹出堆栈，并将其复制到变量“x”中，对“y”也做同样的事。
- en: And then we have all this which will print actually the value of "x" plus the
    value of "y" and gives us a corresponding result。 okay？ So this is our first program。
    Remember this is fourth。 this is our input program that our compiler currently
    knows how to translate into WebAssembly。 Okay。 we run it， we shouldn't have any
    problems。 Notice here that it creates two files。
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有这些代码，它实际上会打印“x”的值加上“y”的值，并给我们相应的结果。好的？所以这是我们的第一个程序。记住这是第四个。这是我们的输入程序，当前我们的编译器知道如何将其转换为WebAssembly。好的。我们运行它，不应该有任何问题。注意这里它创建了两个文件。
- en: a "wasm" and a "what"， okay？ We can inspect with the editor the "what" file，
    okay？
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 一个“wasm”和一个“what”，好的？我们可以用编辑器检查“what”文件，好的？
- en: So we can open and see what it is， what we have here。 So now this is the code
    produced by the compiler。 Okay， as you can see it's quite a lot of code。 Our program
    was， original program was much shorter， it was actually just 14 lines of code。
    Okay。 but the corresponding "wat" code requires much more lines， okay？
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以打开并看看它是什么，我们在这里有什么。那么现在这是编译器生成的代码。好的，正如你所见，这段代码相当多。我们的程序，原始程序要短得多，实际上只有14行代码。好的。但是相应的“wat”代码需要更多的行，好的？
- en: But I mean at the end that's a point of actually writing a compiler so that
    we don't need to write all this by hand。 okay？ I mean that's why compilers were
    actually born。 Remember that when computer as an industry started all programming
    was done in machine code or in assembly language。 okay？ But then suddenly some
    people realized， well what if we had a program that we could write our code in
    a much longer way？
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我的意思是，最终写编译器的目的是让我们不需要手动编写所有这些。好的？我想这就是编译器的诞生原因。记住，当计算机作为一个行业开始时，所有编程都是用机器代码或汇编语言完成的。好的？但随后突然一些人意识到，如果我们有一个程序，可以用更长的方式编写我们的代码呢？
- en: And then write our code in a much higher level and then translate it into machine
    code or assembly。 okay？ That's exactly what we're doing here， okay？ So very powerful。
    the idea of getting something written in a certain notation。 translating it into
    something that the computer can understand more easily， okay？
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 然后以更高的层次编写我们的代码，然后将其翻译成机器代码或汇编。好的？这正是我们在这里做的，好的？非常强大。将某种符号写成某种形式，翻译成计算机更容易理解的东西，好的？
- en: So how do we run it？ Once again you can inspect all this with much more detail，
    okay？
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何运行它？再次你可以以更详细的方式检查所有这些，好的？
- en: This is exactly what we had in this program here translated into WebAssembly。
    So just to run it here， once again in the terminal we now run the execute script
    and we tell it where to find the Wasm file。 okay？ In this case it's also its place
    in the same place where the source file was。 So here we have Wasm and WAT。 We
    run the Wasm， okay？ The WAT was useful to create the Wasm。
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在这个程序中翻译为 WebAssembly 的内容。因此，为了在这里再次运行它，我们现在在终端中运行执行脚本，并告诉它在哪里找到 Wasm 文件，可以吗？在这种情况下，它也在与源文件相同的位置。所以这里我们有
    Wasm 和 WAT。我们运行 Wasm，可以吗？WAT 有助于创建 Wasm。
- en: And it's now running， okay？ So think of it， what's happening here。 We。 Wasm
    are this Python package that is the WebAssembly runtime， is able to read this
    file， okay？
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它正在运行，可以吗？所以想一想，这里发生了什么。我们。Wasm 是这个 WebAssembly 运行时的 Python 包，能够读取这个文件，可以吗？
- en: Which is this binary format。 It does a just in time translation of that file
    into the native platform。 whatever is running here in our Git pod workspace， okay？
    It gets translated。 this is actually an x86 computer。 So it gets translated into
    that native code based on registers and so on。 And once again， strictly speaking
    the Wasm code can't really interface with the rest of the world。
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个二进制格式。它将该文件即时翻译成本地平台。无论在我们的 Git pod 工作区中运行的是什么，可以吗？它被翻译了。这实际上是一个 x86 计算机。所以它被翻译成基于寄存器等的本地代码。再一次，严格来说，Wasm
    代码实际上不能与世界的其他部分接口。
- en: but because we have these imports， we're able to combine them functions that
    will do that job for us。 okay？ But notice that even though what we're looking
    at， what gets printed。 and in this moment it's actually expecting us to type something。
    all that is being done through Python。 But the order in which the things are done
    and the arithmetic operations like the addition and multiplication is going to
    be done。
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 但是因为我们有这些导入，我们能够组合它们的函数来为我们完成这个工作，可以吗？但请注意，尽管我们正在查看的内容，打印的内容。在这个时刻，它实际上期望我们输入一些内容。所有这些操作都是通过
    Python 完成的。但是这些事情的执行顺序和加法、乘法等算术操作将会执行。
- en: all that is done through the native code that was translated from the WebAssembly
    binary code， okay？
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 所有操作都是通过从 WebAssembly 二进制代码翻译而来的本地代码完成的，明白吗？
- en: So， I mean， there's a lot of stuff actually happening here， okay？
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我的意思是，这里实际上发生了很多事情，可以吗？
- en: But at the end it gives me just the illusion of everything working nicely together。
    So let's put。 I don't know， a 10 and let's put a minus 5， okay？ And these two
    lines 11 and 14。 these are the ones in charge of displaying what we have here，
    okay？ So as you can see。 it is working。 And we have a Hello World， okay？ We typically
    start with Hello World in many languages。
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 但最终它给我一种一切都很好地协同工作的错觉。那么我们放个 10，放个减 5，可以吗？这两行 11 和 14。是负责显示我们这里内容的，可以吗？所以你可以看到，它正在工作。我们有一个
    Hello World，可以吗？我们通常在很多语言中以 Hello World 开始。
- en: but here it's not that really interesting。 As you can see here， we start in
    line number four。 we start pushing a 72， what's that， 72？ It's the capital letter
    H， yes， exactly。 And we do an emit。 so that prints the H， okay？ And then we have
    101 emit， that would be the lowercase E， okay？
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里并不那么有趣。正如你所看到的，我们从第 4 行开始。我们开始推送 72，什么是 72？这是大写字母 H，是的，正是这样。然后我们发出 emit。所以打印
    H，可以吗？然后我们有 101 emit，那就是小写的 e，可以吗？
- en: And we emit it， okay？ And so on。 As you can see， putting messages here is pretty
    difficult。 pretty error prone， okay？ But it works， okay？ And at the end it has
    a new line。 So we can now try it out。 Okay， so we first need to compile it， we
    use a cheeky fourth compiler。 The file is in the examples directory and it's called
    Hello World dot fourth， okay？ Once again。
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发出它，可以吗？等等。正如你所看到的，这里放消息是相当困难的，容易出错，可以吗？但它有效，可以吗？最后它有一个新行。所以我们现在可以试试看。好的，我们首先需要编译它，我们使用一个调皮的
    fourth 编译器。文件在示例目录中，名为 Hello World dot fourth，可以吗？再一次。
- en: remember when we use cheeky fourth， this creates two files and here they are。
    One has the same。 they both have the same extension of the program that it compiled。
    The program that we see as input has a dot F4th extension， okay？
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们使用调皮的 fourth，这会创建两个文件，它们在这里。一个有相同的扩展名，它们都有编译后程序的相同扩展名。我们看到的输入程序有一个 .F4th
    扩展名，可以吗？
- en: And it produces two files with the same name but different extensions， Wasm
    and what？ Once again。 you can open the WAT to see what it has， so this is the
    Hello World。 As you can see。 it's pretty long， 37 lines of code。 Okay， and in
    order to run it， we use execute。 And we specify the directory from the file with
    extension， Wasm here in this case。
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 它会生成两个同名但不同扩展名的文件，Wasm 和什么？再一次，你可以打开 WAT 查看它的内容，所以这是 Hello World。如你所见，它相当长，共
    37 行代码。好的，为了运行它，我们使用 execute。并且我们指定带扩展名的文件所在的目录，这里是 Wasm。
- en: And it says Hello World， okay？ So it's working fine。 Okay。 I don't know if there
    are any questions so far？ Nope， okay。 Okay， now we're going to give you。 but basically
    there's only two exercises left， okay？
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 它说 Hello World，好的？所以运行得很好。好的，我不知道到目前为止有没有问题？没有，好的。好的，现在我们将给你。但基本上只剩下两个练习，好的？
- en: I'm going to give you some time so that you can solve them now。 Okay。 let's
    just quickly explain what you're supposed to do in both these exercises。 Okay。
    so exercise D which is section 5。5 of our tutorial notes。 Okay。 we're going to
    add a bunch of new operations， okay？ And this is fairly easy， okay？ So， for example。
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我会给你一些时间，让你现在解决它们。好的，让我们快速解释一下这两个练习你需要做什么。好的，练习 D 是我们教程笔记的第 5.5 节。好的，我们要添加一堆新操作，这相对简单，好的？例如。
- en: if we want to have support for minus， which we currently don't have， okay？ What
    are we going to do？
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要支持减法，而我们目前并不支持，明白了吗？我们该怎么办？
- en: We're going to add this word， the minus， to the dictionary called operation。
    And I'm giving you here so that you don't need to look it up。 This is the corresponding
    instruction that needs to be done whenever it finds a minus。 Okay。 so let me go
    here quickly。 You would go to the chicken fourth file。 Here it is。
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个词“减法”添加到名为操作的字典中。我给你这个，以便你不需要查找。这是找到减法时需要执行的相应指令。好的，所以让我快点过来。你会去鸡肉 forth
    文件。这里是。
- en: look for the operations dictionary， the operation dictionary， okay？
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 查找操作字典，操作字典，明白了吗？
- en: It doesn't really matter where you put it。 I'm going to put it here after the
    plus。 but it really doesn't really matter。 You put the name of the word， in this
    case it's the minus。 And inside a list you need to put a string with a corresponding
    WebAssembly instruction。 What's the corresponding WebAssembly instruction here？
    It's i32。sub。 Remember。
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 你放在哪里并不重要。我打算把它放在加法之后，但其实并不重要。你放入单词的名称，在这种情况下是减法。在列表中，你需要放入一个对应的 WebAssembly
    指令的字符串。这里对应的 WebAssembly 指令是什么？是 i32.sub。记住。
- en: I'm putting you there a link if you wanted to look at the documentation and
    see。 exactly how it works and variations of this instruction， okay？ But at this
    moment。 if you just use the instruction that I placed over there， that should
    do all the trick， okay？
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我给你一个链接，如果你想查看文档并了解它是如何工作的以及该指令的变体，好的？但此时，如果你只使用我放在那里的指令，就应该能完成所有工作，好的？
- en: So you can even copy-paste it if you prefer。 i32 sub， okay？
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你愿意，可以直接复制粘贴。i32 sub，明白了吗？
- en: And you need to do exactly the same thing there for all the instructions here，
    okay？ Which are。 we just did the minus， the slash， which does division。 And then
    we have equal， not equal， less than。 less or equal， greater than， greater or equal，
    okay？
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要对这里的所有指令做完全相同的事情，好的？我们刚才做了减法，斜杠，表示除法。然后我们有等于，不等于，小于，小于等于，大于，大于等于，好的？
- en: And please check out the corresponding instructions。 Some of them are not necessarily
    immediately obvious what they are， okay？ But I placed it here。 So you need to
    complete that dictionary so that it has all of them， okay？
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看相应的说明。有些内容不一定显而易见，好的？但我在这里放了它。所以你需要完成那个字典，使其包含所有内容，好的？
- en: And if everything works correctly， okay， you should be able to test it for this
    exercise that you can do。 So this exercise D using this file which is called operators。forth。
    Okay？
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，明白了吗？你应该能够测试这个练习。你可以用这个名为 operators.forth 的文件进行练习 D。明白了吗？
- en: So if we go and open that file， here it is， operators。forth。 Okay？ This one
    tests us everything。 okay？ The subtraction， the division， the equal operation，
    the not equal and so on。 And generate some values there， okay？ All these， these
    operations that are like equal and different and so on。 The way that this works
    is that， for example， here it's asking effects is equal to y。 If they are。
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我们去打开那个文件，这里是，operators.forth。明白吗？这个文件测试我们的一切，明白吗？减法，除法，相等操作，不相等，等等。并生成一些值，明白吗？所有这些，如相等和不同的操作。它的工作方式是，例如，这里询问“effects是否等于y”。如果它们是。
- en: it pushes a one in the top of the stack， the one indicating true， okay？ And
    if they're not equal。 it puts a zero indicating that it's false， meaning that
    they're not equal， okay？
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 它在堆栈顶部推入一个一，表示真，明白吗？如果它们不相等。它会放入一个零，表示假，意味着它们不相等，明白吗？
- en: So I take the expected values here that are produced。 add some additional values
    over here and do some limits。 So if you run this and everything is working fine，
    it says here that it prints。 everything is working fine。 If everything is working
    fine， okay？
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我在这里取预期的值，添加一些额外的值，并设置一些限制。所以如果你运行这个，一切正常，它会显示打印。所有一切正常。如果一切正常，明白吗？
- en: So if you did all your work correctly， it should print this。 If some of the
    characters are not correct， maybe you mistakenly did something else， okay？
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你所有的工作都做对了，它应该打印这个。如果某些字符不正确，也许你不小心做了别的，明白吗？
- en: If something is wrong， instead of looking at all these individual characters。
    you might see some characters change， okay？ So if it's not exactly this string。
    you need to check and see if you did something wrong。 Or if you get an error，
    okay？
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现问题，而不是查看所有这些单独的字符。你可能会看到一些字符改变，明白吗？所以如果它不是这个字符串。你需要检查一下，看是否做错了什么。或者如果你收到错误，明白吗？
- en: Something was missing there， okay？ So hopefully with that introduction。 you
    should be able to solve this one here。 And let's go directly with exercise E as
    well， okay？
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 那里缺少一些东西，明白吗？所以希望通过这个介绍，你应该能够解决这个。让我们直接进行练习E，明白吗？
- en: Exercise E， what we're gonna do is we're gonna add a do loop here， okay？
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 练习E，我们要在这里添加一个“do”循环，明白吗？
- en: Two words that actually correspond to like a while， a while loop in other languages。
    including Python， okay？ It basically works exactly like that， like a while in
    Python or in C。 Or in Java or any other language， okay？ So do indicate this word
    indicates a very start of our loop。 okay？ Then we expect a condition here。 The
    condition is just any cheeky fourth code that if the result in the top of the
    stack once the condition is evaluated is the value of zero。
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个词实际上对应于其他语言中的“while”循环，包括Python，明白吗？它的工作方式与Python或C中的“while”完全相同。或者在Java或其他任何语言中，明白吗？所以这个词表示我们循环的开始，明白吗？然后我们期望在这里有一个条件。条件只是任何狡猾的四代码，如果在条件评估后堆栈顶部的结果是零值。
- en: okay？ Zero remember represents a false value， okay？ If we have a zero on the
    top of the stack。 well we pop it。 If we find a zero， we go to the end of the loop，
    okay？
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 明白吗？零代表一个假值，明白吗？如果我们在堆栈顶部有一个零。那么我们弹出它。如果我们发现一个零，我们就跳到循环的末尾，明白吗？
- en: That means go to whatever instruction follows the loop word here， okay？
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着跳到循环词后面的指令，明白吗？
- en: So just like a while in other languages， okay？ We evaluate， if this is false，
    we end the loop。 Exactly the same thing happens here。 We evaluate the condition。
    If we get a zero on the top of the stack， we pop it。 And we go to the end of our
    do loop structure here， okay？ Or construct。 But if it's true。
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 所以就像其他语言中的“while”，明白吗？我们评估，如果这是假的，我们结束循环。这里的情况完全一样。我们评估条件。如果堆栈顶部是零，我们弹出它。然后跳到我们的“do”循环结构的末尾，明白吗？或者构造。但如果它是真的。
- en: and true means anything that is not zero， okay？ We go to whatever is after the
    question mark。 and we call it here the body。 We execute the body here as many
    times as we want， okay？
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 真实意味着任何不为零的值，明白吗？我们查看问号后面的内容，并称其为主体。我们可以执行主体多次，明白吗？
- en: So here's an example of how this is supposed to work， okay？ So we start here，
    x， we initialize it。 Remember this sets of value of x to whatever we have in the
    top of the stack。 which in this case is going to be a one。 We want to print all
    the numbers from one to ten。 each number in its own line。 Then here we start our
    loop， okay？ I'm using indentation。
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，说明这个应该如何工作，明白吗？所以我们从这里开始，x，初始化它。记住，这将x的值设置为堆栈顶部的值，在这种情况下是一个。我们想打印从一到十的所有数字。每个数字单独一行。然后在这里开始我们的循环，明白吗？我使用了缩进。
- en: not because it's required， just because it makes it simpler to understand。 We
    have this。 I'm asking here if x is less or equal to ten。 If it is。 these words
    here are going to leave a one in the top of the stack。 So we pop the stack。 and
    if it's true， we'll continue with what follows。 But if it's false。
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是因为这是必须的，只是因为这使得理解更简单。我们有这个。我在这里问x是否小于或等于十。如果是，这些词会在栈顶留下一个一。所以我们弹出栈。如果是真的，我们将继续后面的内容。但如果是假的。
- en: which means we had a zero here， it goes and executes。 continues executing whatever
    follows the loop instruction here。 Or the loop where， okay？
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们在这里有一个零，它会执行。继续执行循环指令后面的任何内容，或者循环在哪里，好吗？
- en: But if it's true， okay， I mean if it's false， it ends the loop， but if it's
    true， it does the body。 In this case， this body is these instructions。 We print
    the current value of x， okay。 and we print a new line。 In this last instruction，
    we add x plus one。 and then we assign the result to x， okay， using x bang here。
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果它是真的，好吗，我是说如果它是假的，它就结束循环，但如果是真的，它就执行主体。在这种情况下，这个主体就是这些指令。我们打印当前的x值，好吗。并且我们打印一个新行。在最后一条指令中，我们加上x加一。然后我们将结果赋值给x，好吗，使用x
    bang在这里。
- en: And we go again to the beginning and ask if our current value of x is still
    less or equal to ten。 okay？ So this prints one， two， three， four until the ten，
    okay？
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次回到开始，问我们的当前值x是否仍然小于或等于十，好吗？所以这会打印一、二、三、四，直到十，好吗？
- en: So once we add this instruction here， you notice that we're not going to add
    an if instruction。 If。 believe it or not， can be simulated using a do with a little
    bit of imagination。 Probably not as simple as to use a standard if instruction，
    but if you think of it， the do loop。 even though this is similar， even though
    this is supposed to be repeated through terms。
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在这里添加这个指令，你会注意到我们不会添加if指令。信不信由你，可以用do模拟。如果你想想看，do循环。尽管这很相似，尽管这应该通过术语来重复。
- en: you can guarantee that it only does the condition once。 and then set another
    variable so it doesn't go in again， okay？ So the do loop。 even in a primitive
    way， can actually support some kind of if， uh， construct， okay？
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以保证它只执行一次条件，然后设置另一个变量，以免再次进入，好吗？所以do循环，甚至在原始的方式中，实际上可以支持某种if构造，好吗？
- en: Once we add the do loop here， just as an interesting fact here。 the cheeky fourth
    language is converted into something we compare scientists call Turing complete
    language。 okay？ And in general， this is CS jargon to say that our program or language
    actually is able to do the same thing that a Turing machine can do。 okay？ So we
    basically have a full programming language here available that can do some pretty
    neat stuff。
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在这里添加do循环，作为一个有趣的事实，顽皮的第四语言被转换为我们比较科学家所称的图灵完备语言，好吗？一般来说，这个计算机科学术语表示我们的程序或语言实际上能够做图灵机能够做的事情，好吗？所以我们基本上在这里有一个完整的编程语言，可以做一些相当不错的事情。
- en: okay？ And the good news for us is that the do and the loop and the question
    mark are really straightforward to implement。 Not going to explain exactly how
    they do it， okay？ If you have that kind of curiosity。 check out here the links
    of these instructions block loop and branch。 which are the ones that we need to
    use。 But notice here。
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？对我们来说好消息是do和loop以及问号的实现非常简单。不会详细解释他们是如何做到的，好吗？如果你有那种好奇心，可以查看这里这些指令的链接，块、循环和分支。这些是我们需要使用的。但注意这里。
- en: you're going to change the operation dictionary just like in the previous exercise。
    and when you find a do， okay， you put a list with these two instructions， okay，
    as strings。 When you find a question mark， okay， the associated text or code in
    this case is these two instructions。 And finally， the loop， when you find the
    loop as a word in the cheeky fourth program。
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你将像在之前的练习中那样更改操作字典。当你找到一个do时，好吗，你放一个包含这两个指令的列表，好吗，作为字符串。当你找到一个问号时，好吗，相关的文本或代码在这种情况下就是这两个指令。最后，循环，当你在顽皮的第四程序中找到loop这个词。
- en: you convert it into these three instructions in the corresponding -- well， in
    the list。 each one in as individual string， okay？ And the rest is actually --
    the compiler actually knows how to produce or generate all this code directly。
    as long as it's in the dictionary in the way that I just described， okay？ So once
    you have that。 you should be able -- well， just a quick note over here。
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 你将其转换为这三个指令，分别以个体字符串的形式列出，好吗？其余的实际上是编译器知道如何直接生成所有这些代码。只要按照我刚才描述的方式在字典中就可以了，好吗？所以一旦你有了这个，你应该能够——嗯，这里稍微提一下。
- en: and this is something that was mentioned a moment ago。 The do loop actually
    introduces a new stack。 which is independent of the stack that was actually available
    before the do loop started， okay？
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是刚才提到的一点。do 循环实际上引入了一个新的堆栈，它独立于 do 循环开始之前可用的堆栈，好吗？
- en: So you have to understand that you start with a brand -- when you have a do。
    you start with a brand new empty stack， okay？ And you have to make sure that at
    the end。 the stack is empty， okay？ When you finish your code， okay， you have a
    condition， you have a body。 At the end of the body， you have to make sure， and
    at the end of the condition as well。
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你必须明白，开始时你有一个全新的空堆栈，好吗？你必须确保在最后，堆栈是空的，好吗？当你完成你的代码时，你有一个条件，有一个主体。在主体的末尾，你必须确保，而在条件的末尾也是如此。
- en: you have to make sure that the stack has no elements there， okay？
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须确保堆栈中没有元素，好吗？
- en: The example that we just saw a moment ago guarantees that that's how it works，
    okay？
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的例子保证了就是这样工作的，好吗？
- en: So most of the time it should make sense to make it work that way， but if it
    doesn't。 you'll get a validation error， okay？ So just mention that。 So， yes？ \>\>
    [INAUDIBLE]， \>\> Yeah。 in this case， you need to use div_s because for integers，
    you can have two interpretations。 They can be signed or unsigned。 In the case
    of floating point numbers， they are always signed， okay？
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 所以大多数时候，这样工作是有意义的，但如果不这样，你会收到验证错误，好吗？所以提一下。所以，是的？ \>\> [听不清]， \>\> 是的。在这种情况下，你需要使用
    div_s，因为对于整数，你可以有两种解释。它们可以是有符号或无符号。在浮点数的情况下，它们总是有符号的，好吗？
- en: But integer numbers can have or not signed。 So you have two versions there。
    There is a div_s for signed values and a div_u for unsigned， okay？
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 但是整数可以有或没有符号。所以你有两个版本。对于有符号值，有一个 div_s，对于无符号值，有一个 div_u，好吗？
- en: And this is one of the reasons that I actually place explicitly the instruction，
    okay？
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是我显式放置指令的原因之一，好吗？
- en: Because these are some of those things that are not necessarily obvious， immediately
    obvious， okay？
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些是一些不一定立刻显而易见的事情，好吗？
- en: So yes， use div_s and this actually happens as well when you use less than or
    lesser equal。 You need to specify you're using the signed version or the unsigned，
    okay？
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，是的，使用 div_s，当你使用小于或小于等于时，这种情况也会发生。你需要指定使用有符号版本或无符号版本，好吗？
- en: Because it's a different instruction depending if you want to consider or not
    your integers with or not a sign。 okay？ So once again， here you just need to add
    these， associate these words in the dictionary。 in the operation dictionary with
    these instructions， okay？ And if everything is fine。 you should be able to run
    these remaining three programs， okay？ One to ten， dot fourth。
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个不同的指令，取决于你是否要考虑有符号或无符号的整数，好吗？所以再次重申，这里你只需将这些词与这些指令关联在字典中的操作字典中，好吗？如果一切正常，你应该能够运行这剩下的三个程序，好吗？从一到十，dot
    fourth。
- en: triangle dot fourth and pow two dot fourth， okay？ Just in the case of triangle
    and pow。 I actually tested this code with my students a couple of days ago。 And
    the media question is what am I supposed to input in these two programs？
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: triangle dot fourth 和 pow two dot fourth，好吗？在 triangle 和 pow 的情况下，我几天前实际和我的学生测试过这段代码。媒体问题是，我应该在这两个程序中输入什么？
- en: So trying for these last two programs， try any value between five and twenty
    and see what happens。 okay？ I'll be with you in just a moment， okay？ So do these
    two exercises。 test it finally at the end with these three examples， okay？ And
    if everything works。 you're all done， okay？ I'll be here just to answer in general
    any questions that you might have。
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这最后两个程序中，尝试输入五到二十之间的任何值，看看会发生什么。好吧？我马上就会跟你在一起，好吗？所以做这两个练习。最后用这三个例子来测试一下，好吗？如果一切正常，你就完成了，好吗？我会在这里回答你可能有的任何问题。
- en: but just let me tell you what's available here in the next section。 These are
    some books I've actually read completely。 This one。 this is really short book
    and read a few chapters， not all of it。 but this is a very nice book if you want
    to have a really technical in-depth overview of WebAssembly。
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我告诉你接下来有哪些可用的资源。这是我实际完整阅读过的一些书。这一本。这是一本非常简短的书，我读了几章，不是全部。但如果你想对 WebAssembly
    有一个非常技术性和深入的概述，这是一本非常好的书。
- en: okay？ Both are available through the Aurelius media site， okay？ But they're
    also available on paper。 I think。 And some additional resources， okay？ So check
    them out if you want to。 to see a little bit more in-depth any of the things that
    we've described so far。 And remember。 the notes are full of links to Wasmir and
    to all the technologies that we mentioned。
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？两者都可以通过 Aurelius 媒体网站获取，好的？但它们也可以以纸质形式获取。我想。还有一些额外的资源，好的？如果你想了解更多，去看看这些资源。记住，笔记中有很多指向
    Wasmir 和我们提到的所有技术的链接。
- en: So in any moment， if you want to learn more about that， just follow the link，
    okay？
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 所以任何时候，如果你想了解更多，可以跟随这个链接，好的？
- en: So please work on these and basically that's all the material that I'm going
    to be presenting。 So we have here until 12。30， if you have time and want to face
    these exercises。 I've seen some people that needed to leave a little bit early。
    But I hope you can try it because it's really interesting to see the final results
    of the full compiler working。
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 所以请在这些练习上努力，基本上这就是我将要介绍的所有材料。我们在这里有时间到 12:30，如果你有时间并想尝试这些练习。我见过一些人需要提前离开。但我希望你能尝试一下，因为看到完整编译器工作的最终结果真的很有趣。
- en: okay？ And remember that at the end this is typically the use case that we have
    most of the time on WebAssembly。 We got a higher level language， in this case，
    Chickyforth， producing WebAssembly， that we call from。 in this case， a runtime
    system which happens to be Python， okay？ So here we're using Chickyforth。 but
    in practice this could be produced， the Wasm file could have been produced by
    a C compiler。
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？记住，通常这是我们在 WebAssembly 上最常见的用例。我们有一种高级语言，在这种情况下是 Chickyforth，生成 WebAssembly，然后从中调用。在这种情况下，是运行时系统，恰好是
    Python，明白了吗？所以在这里我们使用的是 Chickyforth，但实际上这个 Wasm 文件也可以由 C 编译器生成。
- en: a C++ compiler， a Rust， a Go， et cetera。 There are many plenty of languages
    that you can use。 but at the end you typically write it in a higher level language
    and let the compiler do translation。 okay？ So what we're doing here is writing
    our own compiler so that we can see how this process is done。 I hope you find
    interesting and amusing a little compiler。 I mean it's fairly simple。
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 C++ 编译器，一个 Rust，一个 Go，等等。有很多语言可以使用。但最后你通常是在一种高级语言中编写代码，让编译器进行翻译。好的？所以我们在这里所做的是编写我们自己的编译器，以便看到这个过程是如何完成的。我希望你能觉得这个小编译器有趣和有趣。我的意思是它相当简单。
- en: fairly straightforward， but it actually does produce a complete WebAssembly
    output， okay。 that we can actually run。 Okay， so please carry on with these exercises
    if you do have time and I'll be here answering any questions that you might have
    at this point。
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上相当简单，但它确实能生成完整的 WebAssembly 输出，好的。我们实际上可以运行它。好吧，如果你有时间，请继续进行这些练习，我会在这里回答你可能有的任何问题。
- en: okay？ So I think for recording purposes that would be， oh， okay， thank you very
    much。
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 好吗？所以我认为出于记录目的，这将是，哦，好的，非常感谢。
- en: '![](img/86495766b190929aba361b4772d72632_40.png)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86495766b190929aba361b4772d72632_40.png)'
- en: '[APPLAUSE]。'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]。'
