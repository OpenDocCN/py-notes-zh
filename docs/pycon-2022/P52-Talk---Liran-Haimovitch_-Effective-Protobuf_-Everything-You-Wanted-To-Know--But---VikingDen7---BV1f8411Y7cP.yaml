- en: P52：Talk - Liran Haimovitch_ Effective Protobuf_ Everything You Wanted To Know,
    But - VikingDen7 - BV1f8411Y7cP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P52：演讲 - Liran Haimovitch_ 有效的 Protobuf_ 你想知道的一切，但 - VikingDen7 - BV1f8411Y7cP
- en: Hello， everyone。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大家好。
- en: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_1.png)'
- en: Welcome to what's this？ Our 415 talks。 Hopefully， you've had some awesome talks
    so far。 This next talk is by Lidon Heimovich。 Is that really good？ CTO， co-founder
    of Rookout。 As you can see， a broad experience with cyber security。 He's here
    to talk to us about Protobuf。 All right？ I'll leave it to him。 Thank you。 [APPLAUSE]，
    Hey， everyone。 It's great to be here。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到这个是什么？我们的 415 次演讲。希望到目前为止你们已经听到了很棒的演讲。接下来的演讲是由 Lidon Heimovich 主讲。真不错吗？Rookout
    的首席技术官和联合创始人。正如你所看到的，他在网络安全方面有广泛的经验。他在这里与我们讨论 Protobuf。好吧？我把时间留给他。谢谢。[掌声]，大家好。很高兴来到这里。
- en: It's actually my second time speaking at PyCon。 I got to be at Cleveland three
    years ago just before the pandemic hit。 I'm wondering how many of you were at
    PyCon at Cleveland， the show of hand？ Oh， nice。 A lot of people。 I'm not sure
    if you've seen me there or not。 but it's awesome to see all of you here again。
    Conferences have been missing， at least for me。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我第二次在 PyCon 演讲。三年前我在克利夫兰参加会议，就在疫情爆发前。我想知道有多少人在克利夫兰的 PyCon 上举过手？哦，太好了。很多人。我不确定你们是否见过我，但能再次见到大家真的很棒。对我来说，会议是缺失的。
- en: Today， I'm going to be talking about Protobuf and about serialization in general，
    what it， is。 why do we need it， and how do we make the most of it， some considerations。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我将讨论 Protobuf 以及一般的序列化，是什么，它的必要性，以及如何充分利用它，注意事项。
- en: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_3.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_3.png)'
- en: Before we dive into things， I just want to quickly introduce myself。 My name
    is Lidon Heimovich。 I'm the CTO and co-founder of Rookout， which I'm going to
    mention later on。 I spend the most of my time today focusing on various run times
    and how they operate in。 cloud environments。 Python is definitely one of them
    when I spend the most time on。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论之前，我想快速介绍一下自己。我叫 Lidon Heimovich。我是 Rookout 的首席技术官和联合创始人，稍后我会提到这一点。我今天大部分时间都在关注各种运行时及其在云环境中的操作。Python
    绝对是我花费最多时间的一个。
- en: as well as the JVM node， which I'm spending a significant amount of time understanding
    how they run and how to。 make the most of them in cloud。 It could be net is in
    serverless environments。 Spend most of that in the context of observability of
    how can you understand what's going on。 with the applications。 How can we instrument
    them and how can we get high quality data from them easily。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以及 JVM 节点，我花了很多时间理解它们的运行方式以及如何在云环境中充分利用它们。它可能是在无服务器环境中的网络。在观察性上下文中花费大部分时间，如何理解应用程序中发生了什么。我们如何对它们进行监测，以及如何轻松获得高质量的数据。
- en: I'm very curious to know how things walk behind the scenes， which might help
    explain。 some of the things we're going to do with Protobuf later on。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常好奇幕后运作的方式，这可能有助于解释稍后我们将与 Protobuf 一起做的一些事情。
- en: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_5.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_5.png)'
- en: Before we dive into serialization， all of that fancy stuff， I want you to take
    a look。 at this for a second。 The reason I started with the Hello World application
    for Python is because this is probably。 the first， last， and only application
    you've ever seen without variables。 Whenever we want to do anything meaningful
    in software engineering， we want to run a significant。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论序列化之前，我希望你们先看一下这个。之所以从 Python 的 Hello World 应用开始，是因为这可能是你见过的第一个、最后一个，也是唯一一个没有变量的应用。每当我们想在软件工程中做一些有意义的事情时，我们都希望能够执行某个重要操作。
- en: program of any kind， we must have variables。 The reason for that is that variables
    are how we manage data within our code。 The dictionary definition are that variables
    are how we label， store， and manipulate information。 in high level computer languages。
    Essentially anything we want to read from the user。 anything we want to write
    as an output， anything we want to process in any way， kind， or form。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型的程序，我们必须有变量。原因在于变量是我们在代码中管理数据的方式。字典的定义是变量是我们如何标记、存储和处理信息的。在高级计算机语言中，本质上，任何我们想从用户那里读取的东西，任何我们想作为输出写入的东西，以及任何我们想以任何方式、任何形式处理的东西。
- en: we're going to use a variable to， do that。 Obviously。 behind the things the
    Python interpreter doesn't really care so much about our variables。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用变量来做到这一点。显然，在幕后，Python 解释器并不太关心我们的变量。
- en: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_7.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_7.png)'
- en: What happens is that there's a CPU running our code， some level， and the Python
    interpreter。 or any other runtime of any kind you'll be using allocates memory
    or uses the memory within。 the machine。 I'm not going to dive in too much about
    virtual versus physical memory and all of that。 But the interpreter uses the application's
    memory to store and manage your variables。 If you say。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是，有一个CPU在运行我们的代码，某种层级上，Python解释器或任何你使用的运行时都会分配内存或使用机器内的内存。我不会深入讨论虚拟内存与物理内存及其相关内容。但解释器使用应用程序的内存来存储和管理你的变量。如果你说。
- en: for instance， create a statement that x equals 5， then the Python interpreter，
    has two tasks to do。 The first， it has to find some of the memory where x is going
    to reside。 So that from now on。 whenever x is referred to， that's going to be
    used。 It's going to put 5 in that memory address。 If later on you're going to
    do x equals 7， then it's going to go to the same address。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，创建一个语句，使x等于5，那么Python解释器就有两个任务要完成。第一个，它必须找到一些内存，x将要驻留在其中。从现在起，每当提到x时，都将使用这个地址。它会将5放入那个内存地址。如果稍后你要做x等于7，那么它将去同一个地址。
- en: and update to 7。 If you go ahead and read x， then it's going to read from that
    memory address。 Now。 the reason I'm starting with variables is because just like
    variables are the key。 to how we write computer preplications， what comes next？
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 并更新为7。如果你继续读取x，那么它将从那个内存地址读取。现在，我之所以从变量开始，是因为变量是我们编写计算机程序的关键。那么接下来会是什么呢？
- en: What happens when we want our application to communicate with other applications？
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要让我们的应用程序与其他应用程序通信时，会发生什么？
- en: Maybe we want to communicate over the network to send a request somewhere。 Maybe
    we want to store some piece of data on file or on disk or even in a database for。
    this application or for another application to read some time in memory。 Now，
    to do that。 we need to extract our information。 We need to take that information。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们想通过网络进行通信，发送请求到某个地方。也许我们想把一些数据存储在文件、磁盘上，或者甚至在数据库中，以便该应用程序或另一个应用程序在某个时候从内存中读取。现在，为此我们需要提取我们的信息。我们需要提取这些信息。
- en: We've given to the Python interpreter that it's stored somewhere in memory。
    We need to get it back in a way that we can transfer because we don't really know
    what's。 going on within that memory。 Essentially， that's what serialization is
    all about。 Serialization is about taking our information from the memory and creating
    it into a stream。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经给了Python解释器，它存储在内存中的某个地方。我们需要以某种方式将其取回，因为我们并不知道内存中发生了什么。基本上，这就是序列化的核心。序列化就是将我们在内存中的信息提取出来并创建成一个流。
- en: of bytes or a buffer， if you will。 So we get， I know， 100 bytes or 5K。 It doesn't
    matter。 We get some amount of bytes that represents the information we want in
    a clear and usable。 manner that we can then save to the database， save to the
    disk， send over the network so。 that we can someone else， another application
    or even our application in the future， can。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列字节或缓冲区。我们得到了，我知道，100字节或5K。无论如何，我们得到了某种数量的字节，以清晰和可用的方式表示我们想要的信息，然后可以将其保存到数据库，保存到磁盘，或者通过网络发送。这样，我们可以让其他应用程序，或者甚至是我们自己未来的应用程序，能够。
- en: read that information and use it。 Now， there are quite a few ways。 quite a few
    considerations as you're thinking of serialization。 First and foremost。 I want
    to tell you， don't write your own。 Whatever you do， whatever you need。 chances
    are you don't want to write your own。 There are tons of useful serialization out
    there。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 读取这些信息并加以利用。现在，在考虑序列化时，有很多种方式和考虑因素。首先，我想告诉你，不要自己编写。无论你做什么，无论你需要什么，你可能都不想自己编写。外面有很多有用的序列化方法。
- en: Each with their pros and cons， chances are that whatever you're going to write
    yourself。 is going to have more cons than pros。 So please， unless you're expert
    in that， don't write your own。 Choose one that's already there。 Now， there are
    a few things to keep in mind as you're choosing your serialization engine。 First，
    you need to think about do you want it to be portable or not。 Now。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都有其优缺点，你可能自己写的东西会有更多缺点而非优点。所以请你，除非你是专家，不要自己编写。选择一个已经存在的。现在，在你选择序列化引擎时，有一些事情需要记住。首先，你需要考虑你想要它可移植还是不可移植。
- en: there are many elements in portability。 In portability。 can I read this buffer
    I've created in another application？ Can I read it in another runtime。 such as
    a， can I move it from Python to Java or to JavaScript？
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可移植性有许多因素。在可移植性方面。我能在另一个应用程序中读取我创建的这个缓冲区吗？我能在另一个运行时中读取它吗，比如，我能把它从Python移到Java或JavaScript吗？
- en: Can I use it in a different operating system or a different CPU architecture
    or anything， like that？
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我能在不同的操作系统或不同的CPU架构上使用它吗？
- en: Or will this data only be useful within the context it was provided？
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 或者这些数据只在提供的上下文中有用？
- en: In the various levels of portability with various limitations。 And obviously，
    of course。 we all want our code to be portable because why not？
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的可移植性层面上有各种限制。当然，我们都希望我们的代码是可移植的，因为为什么不呢？
- en: We want our code to be portable and want our data to be portable。 The thing
    is。 if you give up on portability， you can often make a variety of shortcuts that。
    make things easier for you。 Well， if you do go for portability。 things can get
    tougher along the way。 Second， you need to decide if you're looking for dynamically
    typed or statically typed。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望代码可移植，数据也要可移植。问题是，如果你放弃可移植性，你通常可以采取各种捷径，让事情变得更简单。如果你追求可移植性，事情在过程中可能会变得更困难。其次，你需要决定是选择动态类型还是静态类型。
- en: or a serialization。 Now， the reason for that， again， just like you do it for
    Python。 Python recently introduced， typing。 But even so， we often create small
    programs。 we just want to write something quick and dirty。 We can go do without
    typing， whatever walks walks。 it's easy。 But later on， these programs grow， as
    code bases grow。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 或者序列化。原因再次如同你为Python所做的。Python最近引入了类型。但即便如此，我们经常创建小程序。我们只想写些快速且简单的东西。我们可以在没有类型的情况下去做，走一步算一步，简单易行。但后来这些程序会增长，代码库也会扩大。
- en: as our consumers for the data we're， generating， we often want static typing
    so that both a machine can verify the correctness。 of the data and also as a form
    of documentation。 So it's going to be easier for people for other engineers to
    understand or for future。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们生成数据的消费者，我们通常希望有静态类型，这样机器可以验证数据的正确性，也作为一种文档形式。因此，这会使其他工程师或未来的人更容易理解。
- en: chefs to understand what the data is。 And last but not least。 we have to choose
    between textual and binary。 Textual usually made for humans。 It's going to make
    your serialization much easier to read。 So when you get that stream of bytes。
    chances are you'll be able to glance at it and get， some sense of what's going
    on。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 厨师们要理解数据的含义。最后但并非最不重要的是，我们必须在文本和二进制之间做出选择。文本通常是为人类设计的。这将使你的序列化更容易阅读。因此，当你获得那串字节流时，你很可能能够快速浏览并大致了解发生了什么。
- en: what's the data that you've extracted， and what does， it mean。 But if you go
    binary。 chances are it's going to be much harder for you to understand what's，
    going on。 But you get this huge benefit that binary is usually better for machines。
    So performance is usually going to be better if you go with binary format。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你提取的数据是什么，它意味着什么。但是如果你选择二进制， chances are你会很难理解发生了什么。但你会得到一个巨大的好处，二进制通常对机器更好。因此，如果选择二进制格式，性能通常会更好。
- en: So let's take a look at a few popular frameworks that you might be familiar
    with that you can。 think of besides a protobuf， obviously。 So first， JSON， JavaScript
    Object Notation。 How many of you are familiar with JSON？ That's pretty much everyone。
    So I'm not going to talk too much about JSON， but it's pretty much the standard
    on the web， today。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们看看几个你可能熟悉的流行框架，除了protobuf，显然的。首先是JSON，JavaScript对象表示法。你们有多少人熟悉JSON？几乎每个人都知道。所以我不会多说JSON，但它几乎是今天网络上的标准。
- en: As I'm sure you know， it's very portable。 It's very textual。 So you can very
    easily read it by eye。 And because it's so widely adopted， chances are that even
    though it's textual， you're going。 to get some decent performance in every runtime
    you choose， let alone Python， because it's。 going to be great。 On the other hand，
    we have Pickle。 How many of you are familiar with Pickle？ Oh。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你知道它非常可移植，且非常文本化。所以你可以很容易地用肉眼读取。而且因为它被广泛采用，尽管是文本化的， chances are即便如此，你在每个运行时中都会获得相当不错的性能，更不用说Python了，因为它会表现得很出色。另一方面，我们有Pickle。你们有多少人熟悉Pickle？哦。
- en: pretty good。 So Pickle is a built-in package within the Python standard library。
    It allows you to serialize any Python object with a single line of code and read
    it later， on。 It has decent performance。 Pickle's biggest disadvantage is portability。
    Besides not being able to read it outside of Python， even within Python， you might
    find。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 还不错。因此，Pickle是Python标准库中的一个内置包。它允许你用一行代码序列化任何Python对象，并在稍后读取。它的性能相当不错。Pickle的最大缺点是可移植性。除了无法在Python外读取外，即使在Python内部，你可能也会发现。
- en: it difficult to serialize an object if your application has changed or other
    elements have， changed。 So it's something to keep in mind。 But if you're looking
    for something weak and dirty just to get started。 Pickle can be， a great option
    for short-term serialization。 And last but not least。 we have Protobuf， which
    is pretty much the topic of what we've， discussed today。 And at Rookout。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序或其他元素发生了变化，序列化对象会变得困难。因此这是一件需要牢记的事情。但如果你只是在寻找一些简单粗暴的东西来入门，Pickle可以是短期序列化的不错选择。最后但并非最不重要的是，我们有Protobuf，这几乎就是我们今天讨论的主题。在Rookout。
- en: I think it's one of the most popular serialization platforms we use。 We use
    it for multiple purposes。 And there are a few reasons for that。 First is that
    Python is -- Protobuf is highly portable。 I think that's one of my favorite options
    about it。 There are about 20 languages today that support -- 20 platforms today
    that support Protobuf。 It's super important for many use cases。 Protobuf offers
    static typing。 which makes it easy to document whatever it is you're trying， to
    serialize。 Make it very clear what you're serializing and how it should be written
    and read。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这是我们使用的最受欢迎的序列化平台之一。我们将其用于多个目的，原因有几个。首先是Python -- Protobuf是高度可移植的。我认为这是我最喜欢的选择之一。目前大约有20种语言支持Protobuf。这对许多使用案例来说非常重要。Protobuf提供静态类型，这使得记录你要序列化的内容变得简单明了。非常清楚你在序列化什么以及如何编写和读取。
- en: And it has amazing performance， both due to the static typing and its binary
    nature。 Protobuf has amazing performance in pretty much all runtime， Python， obviously。
    One of them。 There is great back-hood and forward compatibility， so you can add
    fields， you can remove fields。 Everything is pretty much going to keep going。
    It's pretty long boilerplate。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这在性能上非常出色，既得益于静态类型，又得益于其二进制特性。Protobuf在几乎所有运行时中表现优异，显然，Python也是其中之一。它们其中之一。具有很好的向后和向前兼容性，因此你可以添加字段，也可以移除字段。一切基本上都会继续进行。这有点冗长的样板代码。
- en: That's obviously something that's of key importance because when you're serializing
    stuff， there。 are often a lot of boilerplate involved。 You have to take all the
    information that you have in memory and kind of set it up for。 the serialization
    algorithm to take its hold。 And Protobuf is very good at making it easy to do
    using a lot of auto-generated code。 I'm going to touch on that in a bit。 Protobuf
    is very time-tested。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一个关键的重要性，因为在序列化内容时，常常涉及大量的样板代码。你需要将内存中所有的信息整理好，以便序列化算法能够接手。而Protobuf在利用大量自动生成的代码方面非常出色。我稍后会提到这一点。Protobuf经过了长时间的考验。
- en: It's been around for 20 years now， which was actually -- Google started using
    it internally。 in 2002， open-source it a few years later。 And today。 Protobuf
    3 is the main version everybody's using。 And that has been also around for quite
    a few years。 And there is a great community。 Obviously， nothing compares to JSON。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 它已经存在了20年，实际上 -- Google在2002年开始内部使用它，几年后将其开源。如今，Protobuf 3是大家使用的主要版本，而且已经存在了相当多的年份。并且有一个很好的社区。显然，没有什么能与JSON相提并论。
- en: but it's a pretty great community。 I think it's the most vibrant community for
    any binary serializer out there。 So those are kind of what do I like about Protobuf。
    Now。 before you jump into using Protobuf for everything， a few things you want
    to keep。 in mind for when you're not two years Protobuf。 First， Protobuf is less
    appropriate。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是一个相当不错的社区。我认为这是任何二进制序列化器中最活跃的社区。因此，这些就是我喜欢Protobuf的原因。现在，在你开始全面使用Protobuf之前，有一些事情需要注意，尤其是在你还没有熟悉Protobuf的情况下。首先，Protobuf在某些情况下不太适用。
- en: If you do want to read yourself， the output， the output is going to be binary。
    It's going to be very hard to read by I。 It's not textual， don't go for it。 And
    also keep in mind that if you're working with Protobuf， you need a spec。 The same
    message can mean different things using different specs。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实想自己读取输出，输出将是二进制的。它将非常难以阅读。它不是文本的，不要尝试。同时请记住，如果你在使用 Protobuf，你需要一个规格。同一消息在使用不同规格时可能意味着不同的东西。
- en: So it's very important to have the static typing of the message to be able to
    read it。 Make sure that if your messages get too big， essentially above a few
    megabytes， then the。 serializer hasn't been optimized for that， and you can get
    some pretty bad performance。 And last but not least， if you're dealing with data
    that has dedicated serialization， algorithms。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，消息的静态类型非常重要，以便能够读取它。如果你的消息变得太大，基本上超过几兆字节，那么序列化器可能没有针对这一点进行优化，你可能会遇到相当糟糕的性能。最后但同样重要的是，如果你处理的数据有专用的序列化算法。
- en: obviously information metrics says audio， video， images， all of that of。 their
    own dedicated serialization formats。 It's better to use those rather than using
    some generic general purpose algorithm。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，信息指标表示音频、视频、图像，这些都有各自专用的序列化格式。使用这些格式会更好，而不是使用一些通用的通用算法。
- en: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_9.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_9.png)'
- en: So let's do a quick three slides overview of what is Protobuf and how to use
    it。 So this is what。 as I mentioned， Protobuf is using static typing， and you
    start out by， creating a protocol。 in our case example， Protob， which allows you
    to define whatever， data you're trying to serialize。 You start by defining your
    header， the syntax in our case， Protobuf3， and then you create。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下什么是 Protobuf 以及如何使用它。所以这就是我提到的，Protobuf 使用静态类型，你从创建一个协议开始。在我们的案例中，Protob，允许你定义任何你想序列化的数据。你首先定义你的头部，语法在我们这个案例中是
    Protobuf3，然后你创建。
- en: as many messages as you want。 Or it's a very simple message。 User， it has two
    fields。 One is the name， the other is email， both of them are strings。 And there
    are field numbers here。 one and two。 Now the reason Protobuf asks you to specify
    the field numbers is that field numbers are。 how the messages are encoded and
    are critical for for them backwards compatibility。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建任意多的消息。或者这是一条非常简单的消息。用户，它有两个字段。一个是姓名，另一个是电子邮件，它们都是字符串。而这里有字段编号，一个和二。现在
    Protobuf 要求你指定字段编号的原因是，字段编号是消息编码的方式，并且对它们的向后兼容性至关重要。
- en: And so Protobuf takes the Python approach of explicit is better than implicit
    and asks。 you to define the field it is so they don't change over time and that
    it's very clear for。 you that you can manage that。 So once we've got our file，
    we use the Protobuf compiler， Protosy。 to build our Python files， that you can
    use it。 Protobuf is compilers for pretty much every operating system out there。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Protobuf 采用了 Python 的明确优于隐式的方法，要求你定义字段，以便它们不会随时间而改变，这对你来说非常明确，你可以管理它。因此，一旦我们得到了文件，我们使用
    Protobuf 编译器，Protosy，来构建我们的 Python 文件，以便你可以使用它。Protobuf 几乎支持每个操作系统的编译器。
- en: You can see the command lines for installing it for a few of the more common
    ones。 And then you just write it， Protosy， Python out into the current folder，
    create our protofy。 Now we have it。 It's very， very， very easy。 All we do is we
    can import。 For example。 our new class essentially Python has created a class。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到安装它的一些更常见的命令行。然后你只需编写 Protosy，将 Python 输出到当前文件夹，创建我们的 protofy。现在我们有了。这非常，非常，非常简单。我们所做的就是可以导入。例如。我们的新类本质上是
    Python 创建的一个类。
- en: Protosy has created a class called user to represent our user message。 We import
    it。 We create an object。 We can set the name and the email of the object。 And
    then we just serialize it into a buffer using buffer serialized to swing。 We can
    print it out if we want。 As I mentioned， very， very， very light on boilerplate。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Protosy 创建了一个名为 user 的类，以表示我们的用户消息。我们导入它。我们创建一个对象。我们可以设置对象的姓名和电子邮件。然后我们只需使用
    buffer serialized to swing 将其序列化到缓冲区。如果我们愿意，可以打印出来。正如我提到的，非常，非常，非常少的样板代码。
- en: How do we read this message？ It's also fairly easily。 We create an object。 We
    pass it from the string。 And then we can exit it there。 The Python class attributes
    as the fields of the message that we've just read。 Very， very。 very easy to get
    started with。 Very easy to do some pretty impressive stuff。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何读取这条消息？这也非常简单。我们创建一个对象。我们从字符串传递它。然后我们可以在那儿输出。Python 类属性作为我们刚刚读取的消息的字段。非常，非常。非常容易入门。非常容易做一些相当令人印象深刻的事情。
- en: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_11.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_11.png)'
- en: Now there are a few fancier things you can do with Protobuf that I'm going to
    touch upon。 very briefly。 First regarding primitives， I've shown you string primitives。
    Protobuf also has buffers， bullions， integers， and floats。 So you can serialize
    pretty much all the common stuff。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 Protobuf 你可以做一些更复杂的事情，我会非常简要地提及。首先关于原始数据类型，我给你展示了字符串原始数据类型。Protobuf 还拥有缓冲区、布尔值、整数和浮点数。所以你几乎可以序列化所有常见的数据。
- en: And obviously you can also nest messages into other messages so that you can
    create more。 complex objects as you see fit。 Protobuf is a few advanced keywords
    for more advanced use cases。 Include repeated， which allows you to make any field
    into a list so that instead of having。 just zero or one instances of the field，
    you can have as many as you want。 You can add one off。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你还可以将消息嵌套到其他消息中，以便根据需要创建更复杂的对象。Protobuf 有一些高级关键字，用于更高级的用例。包括重复，这允许你将任何字段变成列表，这样你不仅可以有零个或一个字段实例，而可以有任意多个。你可以添加一个。
- en: which allows you to specify that only one of multiple fields can， exist within
    the same message。 kind of like a union if you're familiar with it。 Reserved allows
    you to specify that the field number shouldn't be used。 whether for backward，
    or for compatibility。 And enum allows you to just for syntactic sugar a kind of
    number。 given names to numbers。 And last but not least， Protobuf has its own version
    of dictionaries。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你指定同一消息中只能存在多个字段中的一个，类似于你熟悉的联合。保留字段允许你指定字段编号不应被使用，无论是为了向后兼容还是其他兼容性。而枚举则提供了一种语法糖，给数字赋予名称。最后但同样重要的是，Protobuf
    还有自己版本的字典。
- en: which is called， maps， and you can use to serialize those relevant objects。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为映射，你可以用它来序列化那些相关对象。
- en: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_13.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_13.png)'
- en: Now why do we need Protobuf to look at what have we been doing with it？
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们为什么需要 Protobuf 来看看我们一直在做什么呢？
- en: So I'm not sure how many of you are familiar with what we do， but Protobuf is
    essentially。 a form of a live debugger or production debugger。 We allow you to
    set a non-breaking breakpoint in any line of code within your application。 and
    once that line of code is hit， we take a snapshot of the state of the application。
    all the local variables， the stack trace， and then we transmit it in the background
    so。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我不确定你们中有多少人熟悉我们的工作，但 Protobuf 本质上是一种实时调试器或生产调试器。我们允许你在应用程序中的任何代码行设置一个非破坏性断点。一旦该代码行被触发，我们将应用程序的状态快照，包括所有局部变量、堆栈跟踪，然后在后台传输。
- en: that you can see the state of the application and get a debugger like experience，
    even if。 the pure application is running in the cloud。 Now this is where we're
    using Protobuf first and foremost from day one。 We use Protobuf to serialize the
    state of the application， so we take all your local， variables。 we take everything
    you have， and kind of put it into a structure for Protobuf。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到应用程序的状态，并获得类似调试器的体验，即使纯应用程序在云中运行。现在，这就是我们从第一天开始使用 Protobuf 的原因。我们使用 Protobuf
    来序列化应用程序的状态，所以我们将你所有的局部变量、所有你拥有的内容放入一个 Protobuf 的结构中。
- en: So how did we go about creating a Protobuf message that couldn't represent a
    variable？
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们是如何创建一个不能表示变量的 Protobuf 消息的呢？
- en: We started out by creating a message， obviously a message named a variable。
    We added an enum to it。 These enums allow us to say what's the type of the variable。
    Is it a non？ Is it an int？
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一条消息，显然这条消息被命名为变量。我们为它添加了一个枚举。这些枚举允许我们指定变量的类型。它是一个非类型？还是一个整型？
- en: Is it a long double binary string， whatever？ Obviously there are about 30 different
    types that we have to describe different objects。 including types names， and objects
    and so on。 And then we add actual fields。 So we have one field which is the type
    which allows us to see it。 And we have a union。 one for each value。 So we have
    an integer， we have a long， we have a double。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个长双精度二进制字符串，还是其他？显然，我们需要描述不同对象的类型大约有30种，包括类型名称和对象等等。然后我们添加实际字段。所以我们有一个字段是类型，允许我们看到它。我们有一个联合，每个值对应一个字段。所以我们有一个整数，一个长整型，一个双精度。
- en: We have a binary and a long。 So if I were to serialize a non， the type would
    be zero。 and there wouldn't be a value， because non is always non。 If I were to
    serialize an int。 the type would be one， and the value would be within field。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个二进制和一个长整型。所以如果我序列化一个非类型，类型将是零。并且不会有值，因为非类型总是非的。如果我序列化一个整型，类型将是一个，值将位于字段中。
- en: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_15.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_15.png)'
- en: number 11， which is the value of an int。 And that works。 That pretty much works。
    You can set a break point on any line of code you want。 You can see the data。
    Everyone is happy。 But we wanted to take it to the next step。 Because if you think
    about it。 once you look at the local variables， there's going to be， one variable。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第11个，代表一个int的值。这是有效的。这基本上是可行的。你可以在任何代码行设置断点。你可以看到数据。大家都很满意。但我们想把它提升到一个新的步骤。因为仔细想想，一旦你查看局部变量，就会出现一个变量。
- en: and that might have an attribute that goes to another variable， and another，
    variable。 and another variable。 And where do you stop？ So in our original POC，
    we started at about level five。 We got to five level of objects and stop there。
    But then one of our customers came by and asked us to go down 20 levels deep。
    Now obviously this is an expanding tree， so the amount of data grows exponentially。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会有一个属性指向另一个变量，再到另一个变量，以及另一个变量。那么你在哪里停止？在我们最初的POC中，我们从大约五层开始。我们到达了五层对象并停在那里。但后来我们的一个客户过来要求我们深入20层。显然，这是一个扩展树，因此数据量会呈指数增长。
- en: And getting a tree 20 levels deep can be pretty then expensive。 In memory， in
    CPU， in latency。 And so we found ourselves trying to balance it。 And the one that
    we do give our customers some level of control。 do you want bigger snapshots，
    that might take a little longer？
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 而获取20层深的树可能会变得相当昂贵。在内存、CPU和延迟方面。因此，我们发现自己在试图平衡这一点。而我们给客户提供了一定程度的控制。你想要更大的快照，可能会花费更长时间吗？
- en: Or do you want smaller snapshots that take a little faster？ Obviously they want
    both。 They want big snapshots that are very， very quick。 And so we wanted to do
    better。 We wanted to increase our performance， especially for larger snapshots
    that contain a lot of， data。 So like any optimization project， it's very important
    to define what you want to optimize， for。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 还是说你想要更小的快照，稍微快一些？显然，他们想要两者。他们想要既大又非常快的快照。因此，我们想做得更好。我们想提高性能，尤其是对于包含大量数据的大快照。所以像任何优化项目一样，明确你想优化的目标非常重要。
- en: So we decided first and foremost we want to optimize for latency。 Because that's
    how we're slowing down on stopping the application。 Second。 we're optimizing for
    message size， because as I mentioned， those were getting。 some pretty big messages
    over 100 megabytes。 Protobuf is very inefficient for that。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们首先决定要优化延迟。因为这就是我们在停止应用程序时减慢速度的原因。其次，我们在优化消息大小，因为如我所提到的，消息变得相当大，超过100兆字节。Protobuf对此非常低效。
- en: It can get messy to transmit them。 So we wanted to reduce the message size。
    And also as a side note。 we wanted to reduce the CPU utilization and reduce the
    number of， allocations。 So the first optimization we've done was asking serialization。
    We do the very bare minimum in a synchronous manner。 We only copy the primitives。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 传输它们可能会变得混乱。因此，我们想减少消息大小。另外作为旁注，我们想减少CPU利用率并减少分配数量。因此，我们进行的第一次优化是请求序列化。我们以同步方式做了最基本的操作。我们只复制原始类型。
- en: capture the immutable data structures and copy mutable data structures， such
    as least in dictionary。 And then we do everything else in the background。 The
    immutable data copying， packaging。 managing all our metadata， and the final serialization，
    to bytes。 All of that can happen in the background as the application continues
    to move forward。 Second。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获不可变的数据结构并复制可变的数据结构，例如字典中的最少内容。然后我们在后台处理其他所有内容。不可变数据的复制、打包、管理所有元数据，以及最终序列化为字节。所有这些可以在应用程序继续前进的过程中在后台完成。其次。
- en: we've seen that what takes the most amount of data， amount of size， within those。
    100 megabytes of messages， is strings。 Because an integer would probably take
    a handful of bytes。 maybe two bytes， maybe six bytes， but it's not going to be
    much bigger than that。 Strings can be dozens， hundreds， and even thousands of
    bytes。 And they repeat themselves。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现，在那些100兆字节的消息中，占据最大数据量的是字符串。因为一个整数可能只占用几字节，可能是两字节，可能是六字节，但不会大于此。字符串可以占用数十、数百甚至数千字节，而且它们会重复出现。
- en: It's not just the string variables themselves， which can often be， you can have
    multiple variables。 that are actually the same value。 But think about the attribute
    names or the type names。 If you have the same object a thousand times， you're
    going to capture its type a thousand， times。 For each of its attributes， you're
    going to capture the string of the attribute a thousand， times。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅是字符串变量本身，实际上可以有多个变量具有相同的值。但想想属性名称或类型名称。如果你有相同的对象一千次，你将捕获其类型一千次。对于每个属性，你将捕获属性字符串一千次。
- en: So why not deduplicate that？ Whenever you encounter the string the first time，
    give it a number。 The next time you encounter the same string， just give it the
    same number。 And then in the background， you also serialize this entire dictionary，
    so that it can be， apprised。 Now， I wanted to just briefly about protocol encoding，
    but I'm not sure。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么不去重呢？每当你第一次遇到字符串时，给它一个编号。下次你遇到相同的字符串时，给它相同的编号。然后在后台，你还将序列化这个整个字典，以便可以进行评估。现在，我想简单谈谈协议编码，但我不确定。
- en: So protocol fuses the variant approach for serializing numbers。 The most important
    thing I want you to take， the numbers take a different number of bytes。 If the
    number is shorter， if the number up to 127 are going to take one byte。 Then number
    above that are going to take two bytes or three bytes rather than having the。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，协议融合了变体方法用于序列化数字。我希望你能明白，数字占用不同的字节数。如果数字较短，数字在127以内将占用一个字节。超过这个数字将占用两个字节或三个字节，而不是将。
- en: fixed number of bytes。 So it's very， very， very important to stick with smaller
    numbers。 especially where it， comes to fields。 Now protocol fuses key value encoding。
    which essentially means that if you think of our， previous message user。 then
    it's going to be key for name， then the value for name， which， was León Hamovitch。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 固定字节数。因此坚持使用更小的数字非常非常非常重要，尤其是在字段方面。现在协议融合了键值编码。这意味着如果你考虑我们之前的消息用户。然后它将是名称的键，值为名称，即**莱昂·哈莫维奇**。
- en: Then there's going to be the key for email and then the value of my email。 And
    keys are a big part of a ham of a message， especially for smaller fields。 And
    by the way。 the keys are built。 They are also built as variants。 They are calculated
    as the field number shifted by three times， bit old with the wire type。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将会是电子邮件的键，然后是我电子邮件的值。键是消息的重要组成部分，尤其是对于较小的字段。顺便提一下，键是构建的。它们也作为变体构建。它们的计算方式是字段编号右移三次，位与线类型进行相加。
- en: And so we essentially get four bits for the field numbers。 This means that field
    numbers one through 15 are encoded as one byte。 Everything above that is encoded
    at two bytes or if you go crazy three bytes。 So my third tip for you is make sure
    that any field ID you're using often resides in。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们基本上为字段编号获取四个比特。这意味着字段编号从1到15编码为一个字节。超过这个的则编码为两个字节，或者如果你想疯狂的话，编码为三个字节。所以我给你的第三个建议是，确保你使用的任何字段ID经常处于。
- en: the range of one to 15。 It's going to save you a whole lot of memory and make
    processing faster。 Now in one of the things we've seen at that point， we've had
    about 40 to 50 different。 field numbers。 And some of our most useful fields resided
    outside of the one to 15。 So the next thing we've done was work very， very hard
    to reduce the number of fields we've。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 1到15的范围内。这将节省大量内存并加快处理速度。现在在我们看到的其中一件事情中，我们有大约40到50个不同的字段编号。我们一些最有用的字段位于1到15之外。因此我们接下来的工作是非常努力地减少字段数量。
- en: been using。 Now I want to mention this is something that's going to break up
    structure to a certain degree。 And we've decided it's worth it for us。 We're taking
    it to the extreme。 We want to make it as fast as possible。 Even if it's going
    to make the code a bit messier。 That's not always the case。 That's not always
    good。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直在使用。现在我想提到的是，这在某种程度上会打破结构。我们决定这样做是值得的。我们将其推向极限。我们希望尽可能快。即使这会让代码有点凌乱。这并不总是如此。这并不总是好事。
- en: Many cases you can suffer with the extra performance impact to make the code
    clean。 So one of the things we've done was to merge fields。 If you have multiple
    fields where there are very small values， whether it's Boolean or。 small numbers
    by themselves， you can merge them。 For instance， we had two fields。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，为了让代码更清晰，你可能会承受额外的性能影响。因此，我们所做的一件事是合并字段。如果你有多个字段，其中有非常小的值，无论是布尔值还是小数字本身，你都可以合并它们。例如，我们有两个字段。
- en: One of them was an enum that you remember that holds a type。 And another was
    a Boolean flag。 So we merged them。 We've shifted one of them， left， added a bitwise
    all。 And we've saved one field。 which is awesome。 We've done a lot of work around
    reusing fields。 For instance， if you remember。 we had field number 11 that was
    an int， field number 12， that was along。 Now， as I mentioned。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个是你记得的枚举，它表示一个类型。另一个是布尔标志。因此我们合并了它们。我们移动了其中一个，添加了位运算，并节省了一个字段。这真是太棒了。我们在重用字段方面做了很多工作。例如，如果你记得，我们有字段11是一个整型，字段12是一个长整型。现在，正如我提到的。
- en: a protobuf encodes numbers based on their size， not based on their type。 So
    we can just use the same field for a number without spending too much around it。
    Now as we got more aggressive， we've seen that each message we create adds its
    own key， header。 adds its own header， which adds additional processing， additional
    size。 And also。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf根据数字的大小而不是类型来编码数字。因此，我们可以只使用同一个字段来表示数字，而不需要过多的处理。随着我们变得更加积极，我们发现每创建一个消息都会添加自己的键和头部，增加额外的处理和大小。
- en: if you see the implementation of how lists are made， so lists for complex types。
    are repeated key value sets。 So you're adding the key time and time and time again。
    On the other hand， if you're using a list of numbers， then essentially the length
    is。 encoded only once。 And then they just add the values one by one。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看列表的实现，复杂类型的列表是重复的键值对集合。因此，你一次又一次地添加键。另一方面，如果你使用的是数字列表，那么长度仅编码一次，然后它们逐个添加值。
- en: So we've seen that each message we add caused a significantly in performance。
    And so to manage that。 we've figured out how can we use less messages， how can
    we avoid， creating messages。 And we found that there are only four complex types
    that really justify messages。 Everything else we can walk around and keep a flutter
    structure that is much more efficient。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，每添加一个消息都会显著影响性能。因此，为了管理这一点，我们找到了如何使用更少的消息，如何避免创建消息。我们发现，只有四种复杂类型真正需要消息。其他一切我们都可以绕过，保持一个更有效的扁平结构。
- en: to encode。 And last but not least is the one-off， which I've mentioned。 Now
    one-off allows you to say that only one-off thing is。 Now if you remember。 I've
    shown you that we created a message for a string。 And the reason for that is that
    with only one-off， you can only have one field。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 编码。最后但同样重要的是一次性（one-off），我之前提到过。一次性允许你声明仅有的一个一次性事物。如果你还记得，我给你展示了我们为一个字符串创建的消息。这样做的原因是，使用一次性时，你只能有一个字段。
- en: So if you want that field to have essentially multiple attributes， you need
    to wrap it with。 a message。 And as we mentioned， wrapping with a message is bad。
    So I was--and also as another side note， one-off doesn't allow you to add repeated
    to the。 attribute。 And again， you have to walk around that by adding a message。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望那个字段具备多个属性，你需要用消息将其包装起来。正如我们提到的，用消息包装是不可取的。因此，我还想提一下，一次性不允许你向属性添加重复项。再次，你必须通过添加消息来解决这个问题。
- en: So originally we had one-off where a lot of the values were。 And after that
    we removed the one-off。 we created a flat structure。 And after using fields aggressively
    and merging them。 we actually got to the point that only， field 6 to 12 are used
    to contain the values of the variables。 One through five are used for the metadata。
    And actually everything else is reserved for future use。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们有一个一次性，其中包含了许多值。之后，我们移除了一次性，创建了一个扁平结构。在积极使用字段并将它们合并后，我们实际上只使用了字段6到12来保存变量的值。1到5用于元数据，而其他一切则保留供将来使用。
- en: So this is how it does。 And those are pretty much average messages。 And we got
    some pretty nice performance boot。 We got the latency of serialization down by
    40%。 We got size down almost 50%。 And if I were to show you larger messages of
    harder being about thermal。 you would be， seeing even more dramatic results。 I
    feel that's not fair。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作方式。这些基本上是平均水平的消息。我们获得了一些相当不错的性能提升。我们将序列化的延迟降低了40%。大小几乎减少了50%。如果我向你展示更大的消息，结果会更加显著。我觉得这样不太公平。
- en: But that was one of our purposes。 Now before I finish this， I don't want to
    mention one thing。 which I didn't touch upon， because this talk was mostly focused
    around protobuf in general。 There is a C extension for protobuf that can be used
    within Python。 Now this is something we couldn't use because our code runs within
    other pre-press processes。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但这也是我们的目的之一。现在在我结束之前，我想提到一件事。这个我没有涉及，因为这次演讲主要集中在protobuf上。protobuf有一个C扩展，可以在Python中使用。现在这是我们无法使用的，因为我们的代码运行在其他印前处理过程中。
- en: And we don't want to add in native extension that can cause slow problems in
    some cases。 But if you're running protobuf in your own application and you're
    just looking for some。 simple extra performance boost， you can， by simply adding
    an environment variable， you。 could instruct protobuf to use the native extension。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想添加可能在某些情况下导致慢问题的本机扩展。但如果你在自己的应用程序中运行protobuf，并且只是想寻找一些简单的性能提升，你可以通过简单地添加一个环境变量，指示protobuf使用本机扩展。
- en: And that's going to use C code instead of Python code for the serialization。
    So we're going to get some nice performance out of it。 It's going to be the same
    message size。 but things can often be faster in many use cases。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这将使用C代码而不是Python代码进行序列化。因此我们将获得不错的性能。消息大小将保持不变，但在许多使用情况下，处理速度往往更快。
- en: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_17.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_17.png)'
- en: \>\> So， all right。 Thank you， Bidan。 You have any questions for him？ You can，
    yes， thank you。 \>\> [APPLAUSE]， [APPLAUSE]。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: \>\> 好吧。谢谢你，Bidan。你有任何问题要问他吗？可以，好的，谢谢。\>\> [掌声]，[掌声]。
- en: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_19.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9453570b8809d4c68f1e6b4f3398cf1c_19.png)'
