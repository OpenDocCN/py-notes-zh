- en: P67：Talk - Pandy Knight_ Managing the Test Data Nightmare - VikingDen7 - BV1f8411Y7cP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P67：演讲 - Pandy Knight_ 管理测试数据噩梦 - VikingDen7 - BV1f8411Y7cP
- en: Okay， so this is the second to last talk， so enjoy it。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这是倒数第二个演讲，所以请好好享受。
- en: '![](img/bb7342e61e6eabcf34bd076d3d280a67_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb7342e61e6eabcf34bd076d3d280a67_1.png)'
- en: It's going to be great。 Our next talk is Managing the Test Data Nightmare by
    Pandy Knight。 so go ahead and give him， a round of applause。 Thank you， Mason。
    Thank you。 Also。 Mason is pretty awesome。 Go follow him on Twitter。 He does amazing
    things。 So hello， everyone。 Thanks for joining my talk today。 My name is Pandy
    Knight and I am the Automation Panda。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会很棒。我们的下一个演讲是由 Pandy Knight 主讲的《管理测试数据噩梦》。请给他热烈的掌声。谢谢，Mason。谢谢。此外，Mason 非常棒。快去关注他的
    Twitter。他做了很多了不起的事情。那么大家好。感谢你们今天参加我的演讲。我叫 Pandy Knight，我是自动化熊猫。
- en: It's been three years since our last in-person picon。 It's hard to believe。
    Since it's important to make human connections， I'd like to share a little bit
    about myself。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 自上次面对面的聚会已经过去三年了。真让人难以置信。由于建立人际关系很重要，我想分享一点关于我自己的事情。
- en: '![](img/bb7342e61e6eabcf34bd076d3d280a67_3.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb7342e61e6eabcf34bd076d3d280a67_3.png)'
- en: So my wife and I have this adorable French bulldog puppy。 Her name is Suki。
    She is super cute and I miss her so very much。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我和我的妻子有一只可爱的法国斗牛犬小狗。她的名字叫 Suki。她超级可爱，我非常想念她。
- en: '![](img/bb7342e61e6eabcf34bd076d3d280a67_5.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb7342e61e6eabcf34bd076d3d280a67_5.png)'
- en: This is my car。 I drive a 1970 Volkswagen Beetle。 Yes。 So when I say this is
    my car。 I mean that this is my primary driver。 This is not a toy。 This is not
    something I pull out for shows。 This is what I drive to get groceries and stuff。
    I'm restoring the inside。 The exterior is already pretty baller and I dropped
    a whole new engine in this bad boy。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的车。我开的是一辆1970年的大众甲壳虫。没错。所以当我说这是我的车时，我是说这是我的主要代步工具。这不是玩具。这不是我拿出来参加展会的东西。这是我用来买菜和其他事情的车。我正在恢复内饰。外观已经相当不错，我还为这辆车换了一个全新的发动机。
- en: So about me where I work， I work as a developer advocate at Apple Tools， where
    I help people。 get the most value out of their test automation， hence automation
    panda。 Apple Tools provides automated visual testing tools。 So what does automated
    visual testing mean？
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我工作的地方，我在 Apple Tools 担任开发者倡导者，帮助人们充分利用他们的测试自动化，因此被称为自动化熊猫。Apple Tools 提供自动化视觉测试工具。那么，自动化视觉测试是什么意思呢？
- en: Take a look at this picture。 Can you spot the differences？
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这张图片。你能找到不同之处吗？
- en: '![](img/bb7342e61e6eabcf34bd076d3d280a67_7.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb7342e61e6eabcf34bd076d3d280a67_7.png)'
- en: Apple Tools can。 There it goes。 There are 10 differences in here。 This is what
    visual AI does。 You might think， well， that's cool， but how is it useful？
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Apple Tools 可以。它来了。这里有10个不同之处。这就是视觉 AI 的作用。你可能会想，嗯，那挺酷的，但它有什么用呢？
- en: This is a game changer for testing your web and mobile apps。 Think about all
    the changes you make。 Oh， did a button disappear？ Did this label go bad？ Boom，
    we can find it for you。 At Apple Tools。 I'm also director of Test Automation University，
    which provides free courses。 on testing and automation topics。 Personally， I've
    developed four courses for TAU。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是测试网页和移动应用程序的游戏规则改变者。想想你所做的所有更改。哦，按钮消失了吗？这个标签坏了吗？砰，我们可以为你找到它。在 Apple Tools。我还是测试自动化大学的主任，提供免费的测试和自动化课程。就我个人而言，我为
    TAU 开发了四门课程。
- en: even before I joined Apple Tools， three， of which cover Python。 Woo！ Python
    for testing is amazing。 All righty。 So let's get down to the nitty gritty。 One
    of the toughest challenges in testing any software product is handling the test
    data。 Now when I say test data， quote unquote， I'm referring to multiple things。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我加入 Apple Tools 之前，其中三门涵盖 Python。哇！用于测试的 Python 真是太棒了。好的。那么让我们深入探讨一下。测试任何软件产品时，最棘手的挑战之一就是处理测试数据。现在当我说测试数据时，我指的是多种东西。
- en: Test data includes both the actual data inside the product under test， as well
    as the data。 values used by test cases。 As testers， we shouldn't underestimate
    the work to handle test data properly。 Good data is just as important as good
    tests and good automation。 So in this talk。 we will dive deep into the connection
    between product data and test case， data。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 测试数据包括被测试产品内部的实际数据以及测试用例所用的数据值。作为测试人员，我们不应低估正确处理测试数据的工作。良好的数据与良好的测试和良好的自动化同样重要。因此，在本次演讲中，我们将深入探讨产品数据与测试用例数据之间的联系。
- en: We will learn how to pick the right strategies for handling both， including
    how to avoid data。 collisions when testing。 By the end， you'll know how to manage
    the test data nightmare for your own test projects。 whether you're testing a Django
    app， a Flask app， some other Python project， or something。 written in a completely
    different language。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何选择正确的策略来处理这两者，包括如何在测试时避免数据冲突。到最后，你将知道如何管理自己测试项目中的测试数据噩梦，无论你是在测试Django应用、Flask应用、其他Python项目，还是其他用完全不同语言编写的东西。
- en: '![](img/bb7342e61e6eabcf34bd076d3d280a67_9.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb7342e61e6eabcf34bd076d3d280a67_9.png)'
- en: Let's learn。 Let's say we have an application for a bank to provide loans。 The
    bank could configure this application from any different types of loans， such
    as。 a home mortgage loan， a car purchase， or a student loan。 All the information，
    whoops， whoa。 there we go。 All the information the bank needs to provide the loans
    is stored in data in the database。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习一下。假设我们有一个银行贷款申请的应用。银行可以从不同类型的贷款中配置此应用，例如：房屋抵押贷款、汽车购买或学生贷款。所有信息，哎呀，哦，来了。银行提供贷款所需的所有信息都存储在数据库中的数据里。
- en: It's part of the system。 Each loan product is different。 It comes in with its
    own rate， maturity。 and payment schedule。 The bank must also store information
    about borrowers， funding curves。 profitability targets， all that stuff。 It's fairly
    complicated。 It requires that all data already be present in the system as a prerequisite。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它是系统的一部分。每种贷款产品都是不同的。它有自己独特的利率、到期时间和还款计划。银行还必须存储有关借款人、资金曲线、盈利目标等所有信息。这相当复杂。它要求所有数据在系统中已存在作为先决条件。
- en: We could write a simple test case to exercise the basic application behavior。
    A scenario for creating a new loan application starts with， given the Chrome browser
    is open。 and the page MyLoneApp。com is loaded。 When the user creates a new loan
    for the home mortgage。 and the user enters all their personal， identification
    information。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个简单的测试用例来验证基本应用行为。创建新贷款申请的场景从打开Chrome浏览器开始，并加载页面MyLoneApp.com。当用户为房屋抵押贷款创建新贷款时，用户输入所有个人身份信息。
- en: and the user submits the application， then the page displays a。 success message
    with a reference number， and the application is sent to the bank。 Or so we hope。
    Now bear in mind， a real loan application will probably have several pages of
    information。 but let's keep our example simple for here today。 I know it's a Sunday
    afternoon， a picon。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 用户提交申请后，页面会显示成功消息和参考号码，申请将发送到银行。或者我们希望如此。请记住，真实的贷款申请可能会有好几页信息，但今天我们先保持简单。我知道今天是周日下午，有点忙。
- en: We're all here， which is awesome。 This test creates and submits a new home mortgage
    loan application for the user。 We can all agree on that。 Now there are many test
    data points in this scenario。 Most apparently。 there's the user's personal information。
    There's the type of loan。 The record of the loan application sent to the bank。
    The reference number shown to the user。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都在这里，这太棒了。此测试为用户创建并提交了新的房屋抵押贷款申请。我们都能对此达成一致。现在这个场景中有很多测试数据点。显而易见，有用户的个人信息。贷款类型。发送到银行的贷款申请记录。显示给用户的参考号码。
- en: Furthermore， the URL is configuration info， and the browser is arguably a type
    of test， input。 Test data is everywhere in this short simple scenario。 The data
    is inextricable from the test。 Without specific data， this test would be meaningless。
    Everybody with me？ Yeah， good。 Unfortunately。 the term test data is ambiguous。
    We've applied it to both the product data in the loan web app。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，URL是配置信息，浏览器可以说是一种测试输入。测试数据在这个简短简单的场景中无处不在。这些数据与测试不可分割。没有特定的数据，这个测试将毫无意义。大家都跟上了吗？好，太好了。不幸的是，测试数据这个术语是模糊的。我们将其应用于贷款网页应用中的产品数据。
- en: as well as to the various， pieces of test case data that make even the most
    basic test work。 Product data refers to real data living in the software system。
    For the loan web app。 product data includes all the bank's product configurations
    and lending， information。 Test case data， however， refers to data used to define
    test cases。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以及各种测试用例数据，这些数据使得即使是最基本的测试也能正常工作。产品数据指的是软件系统中真实存在的数据。对于贷款网页应用，产品数据包括银行的所有产品配置和借贷信息。然而，测试用例数据指的是用于定义测试用例的数据。
- en: It may include values to enter into the product under test， inputs controlling
    how the testing。 is performed， or records to retrieve from the product。 In the
    latter case。 test case data is a reflection of product data。 Its values refer
    to entities existing in the product data。 The two types of test data are separate
    but connected。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能包括在被测试产品中输入的值、控制测试如何进行的输入，或者从产品中检索的记录。在后者的情况下，测试用例数据是产品数据的反映。它的值指向存在于产品数据中的实体。这两种类型的测试数据是分开的，但又是相互连接的。
- en: Singing these two types of data is important to avoid confusion。 The dependency
    of test case data on product data can be brittle。 For example。 consider our test
    case step to create a new loan application for a home， mortgage。 This step works
    as long as the bank's web app is configured for home mortgages。 However。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 区分这两种数据类型很重要，以避免混淆。测试用例数据对产品数据的依赖可能是脆弱的。例如，考虑我们测试用例的步骤，以创建一个家庭抵押贷款的新申请。只要银行的网页应用程序配置为家庭抵押贷款，这一步就能正常工作。然而。
- en: the product data could be changed at any time， just like product code。 But if
    the specifics of a home mortgage loan change， what if the loan is no longer called。
    a "home mortgage loan" but a "personal residential loan"？ That would make the
    test case break。 Compounding breakages calls nightmares for test management。 So
    how should we manage test data？
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 产品数据可能随时变化，就像产品代码一样。但如果家庭抵押贷款的具体内容发生变化，那么如果贷款不再称为“家庭抵押贷款”，而是“个人住宅贷款”呢？这会导致测试用例失效。频繁的失效为测试管理带来了噩梦。那么我们应该如何管理测试数据呢？
- en: For feature testing， test data is just as important as test cases and test code。
    How do we handle both product data and test case data appropriately？
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于功能测试，测试数据与测试用例和测试代码同样重要。我们如何适当地处理产品数据和测试用例数据呢？
- en: Are there strategies we can use to avoid brittle dependencies？
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用哪些策略来避免脆弱的依赖关系？
- en: '![](img/bb7342e61e6eabcf34bd076d3d280a67_11.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb7342e61e6eabcf34bd076d3d280a67_11.png)'
- en: In this talk， we'll explore multiple ways to handle both product data and test
    case data。 Unfortunately， there's no universal or perfect solutions out there。
    But you can avoid nightmares by picking strategies that work well for your needs。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次讲座中，我们将探索多种处理产品数据和测试用例数据的方法。不幸的是，市面上没有通用或完美的解决方案。但你可以通过选择适合你需求的策略来避免噩梦。
- en: '![](img/bb7342e61e6eabcf34bd076d3d280a67_13.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb7342e61e6eabcf34bd076d3d280a67_13.png)'
- en: Let's start with product data。 As stated previously。 product data is any live
    data in the product or system under test。 In simplest terms。 it's everything in
    the database。 It can include user accounts， administration settings。 product customizations，
    records， created by users， files uploaded by users， so on and so forth。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从产品数据开始。正如之前所述，产品数据是测试中的任何实时数据。简单来说，就是数据库中的一切。它可以包括用户账户、管理设置、产品自定义、用户创建的记录、用户上传的文件等等。
- en: For that example， loan application we were talking about， product data would
    include。 things like the user accounts。 The loan product settings， the loan applications。
    and the behind the scenes bank data。 Data must be present in a product as a prerequisite
    for most testing。 There are two primary ways to get that data in the system。 On
    one hand。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论的贷款申请示例中，产品数据将包括诸如用户账户、贷款产品设置、贷款申请以及后台银行数据等内容。数据必须在产品中存在，作为大多数测试的先决条件。将数据导入系统主要有两种方法。一方面。
- en: you can set up the data before running your tests。 This would be static data
    creation。 For example。 a loan web app could be set up with a set of preregistered
    users and a， collection of loan types。 Test cases， whether they are manual or
    automated， can presume that this static data is already。 in the system and simply
    refer to it。 Static data preparation is a good strategy for complicated data or
    for data that is slow。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在运行测试之前设置数据。这将是静态数据创建。例如，一个贷款网页应用程序可以配置一组预注册的用户和一系列贷款类型。测试用例，无论是手动还是自动，都可以假设这静态数据已经在系统中，并简单地引用它。静态数据准备是处理复杂数据或速度较慢的数据的好策略。
- en: to create dynamically。 For example， user accounts may need email verification。
    so it might be easier for automated， tests to simply use a set of preregistered
    users。 People run faster if they can simply reference existing data instead of
    creating new data each。 time。 However， static data must be maintained。 Any changes
    to static data could impact tests too。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 动态创建数据。例如，用户账户可能需要电子邮件验证，因此自动化测试可能更容易使用一组预注册的用户。如果人们可以简单地引用现有数据，而不是每次都创建新数据，他们的速度会更快。然而，静态数据必须得到维护。对静态数据的任何更改也可能影响测试。
- en: Static data may also become stale over time as data formats are updated or if
    data is time。 sensitive like a time series。 On the other hand， you could set up
    data during test execution。 This would be what we call dynamic data creation。
    In the example loan test case。 the loan application document is dynamically created。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据格式的更新，静态数据也可能随着时间而变得过时，或者如果数据是时间敏感的，比如时间序列。另一方面，你可以在测试执行期间设置数据。这就是我们所说的动态数据创建。在示例贷款测试案例中，贷款申请文档是动态创建的。
- en: The test does not reference an existing loan application。 It creates a new one。
    Dynamically created records avoid the brittleness of hard references to static
    data。 It can also be used exclusively by the current test case， protecting them
    from interruptions。 by other test cases。 The main downside of dynamic data prep
    is the execution time。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 测试并不引用现有的贷款申请。它创建一个新的。动态创建的记录避免了对静态数据的硬引用带来的脆弱性。它还可以被当前的测试案例独占使用，保护它们不被其他测试案例的干扰。动态数据准备的主要缺点是执行时间。
- en: It does slow down your tests。 Dynamically created data is essentially disposable
    too。 so it should be cleaned up eventually。 Which strategy is best？ Typically。
    testing requires both strategies together。 Data that is slow to set up or considered
    immutable should use static data preparation。 while data that is quick and easy
    to set up should use dynamic data preparation。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实会降低测试速度。动态创建的数据本质上是一次性的，因此最终应该清理。哪种策略最好？通常，测试需要两种策略结合使用。设置缓慢或被视为不可变的数据应使用静态数据准备，而快速且易于设置的数据应使用动态数据准备。
- en: When I develop test solutions， I prefer to create as much data as possible dynamically。
    per test case to try to preserve test case independence。 When a test creates the
    data。 it needs dynamically。 It will be the only one referring to it。 And there
    is a much lower risk of collisions。 These two data prep strategies are a bit complicated
    when implementing them。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开发测试解决方案时，我更倾向于根据测试案例尽可能动态地创建数据，以尝试保持测试案例的独立性。当测试动态创建所需数据时，它将是唯一引用它的测试案例。而且碰撞的风险要小得多。这两种数据准备策略在实施时有点复杂。
- en: Data prep really depends upon the test case that you are doing。 For example。
    with that loan test case， we had to create a new record for that instance。 However。
    static data prep has a few general strategies that are independent of the test，
    cases that use them。 The simplest data prep strategy is manual configuration。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数据准备确实取决于你正在进行的测试案例。例如，在那个贷款测试案例中，我们需要为该实例创建一个新记录。然而，静态数据准备有一些与使用它们的测试案例无关的一般策略。最简单的数据准备策略是手动配置。
- en: How many people have done this in their systems before？ Yeah， yeah， I know。
    That's exactly what it sounds like。 Testers log into the system and manually create
    whatever records they need to be in。 the system。 That can include creating users，
    configuring settings， and saving records。 The nice thing about manual configuration
    is that it's low tech。 Anyone can do it。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 之前有多少人在他们的系统中做过这个？是的，我知道。这听起来就是这样。测试人员登录系统并手动创建他们需要存在于系统中的记录。这可能包括创建用户、配置设置和保存记录。手动配置的好处在于它的技术要求低，任何人都可以做到。
- en: You don't need fancy or complicated tools。 However， manual configuration is
    slow。 It does not scale well for large systems or large test environments。 Furthermore。
    manually configured systems can easily fall into disrepair without any automated。
    mechanisms for maintenance。 Better strategy might be automated configuration。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要花哨或复杂的工具。然而，手动配置速度较慢。在大型系统或大型测试环境中，它的扩展性不好。此外，手动配置的系统很容易因缺乏自动化维护机制而陷入失修。更好的策略可能是自动配置。
- en: Rather than manually setting up everything， automated tools can create the desired
    data。 This could be accomplished in many ways。 Reusing UI interactions from tests，
    calling REST APIs。 or even possibly using tools like， Puppet or Chef。 Automation
    could generate data deterministically or randomly。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化工具可以创建所需的数据，而不是手动设置一切。这可以通过多种方式实现，例如重用测试中的用户界面交互、调用 REST API，甚至可能使用像 Puppet
    或 Chef 这样的工具。自动化可以以确定性或随机的方式生成数据。
- en: The main benefit of automation is the ability to create fresh data at any time。
    Automation can also clean data like scrubbing private fields or updating time
    sensitive， fields。 Unfortunately， automated configuration is not a free lunch。
    It requires extra skills and the automation code must be maintained。 If you want
    a shortcut。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化的主要好处是能够随时创建新数据。自动化还可以清理数据，比如清除私人字段或更新时间敏感字段。不幸的是，自动化配置并不是免费的午餐。它需要额外的技能，自动化代码必须进行维护。如果你想要捷径。
- en: you could try to clone the database。 Cloning databases is easier than ever with
    cloud management tools。 You can maintain one database in a golden state and create
    a copy before running tests。 Once testing is complete， the copy could be destroyed。
    Granular cleanup would not be necessary。 Database clones make it easy to copy
    all data at once without worrying about any damage。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试克隆数据库。使用云管理工具，克隆数据库比以往任何时候都更容易。你可以将一个数据库保持在黄金状态，并在运行测试之前创建一个副本。一旦测试完成，副本可以被销毁。无需细致的清理。数据库克隆使得一次性复制所有数据变得简单，而无需担心任何损坏。
- en: that rogue testing could cause。 However， databases can have a lot of data。 so
    cloning large ones may not be practical。 Clones may also need extra refinement
    to scrub special fields and hook them up properly into。 your systems。 Finally，
    if managing real data is too much of a hassle。 then you can mock your endpoints。
    This will completely remove dependencies on databases and even services。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能导致的恶意测试。然而，数据库可能包含大量数据，因此克隆大型数据库可能不太实际。克隆可能还需要额外的精细化，以清理特殊字段并将其正确连接到你的系统中。最后，如果管理真实数据过于麻烦，你可以模拟你的端点。这将完全消除对数据库甚至服务的依赖。
- en: All data returned by the MOCs will be deterministic too。 yielding consistent
    results for your functional， tests。 But MOCs are not always a good solution。 They
    often require a lot of extra effort to set up， and MOC data can make tests overlook。
    the unprecedented real world variations。 MOCs also mean that tests will not truly
    be end-to-end in coverage。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: MOCs返回的所有数据也是确定性的，为你的功能测试提供一致的结果。但MOCs并不总是一个好的解决方案。它们通常需要大量额外的设置工作，而MOC数据可能使测试忽视前所未有的现实世界变化。MOCs还意味着测试在覆盖范围上不会真正实现端到端。
- en: These strategies can also work together。 For example。 you could use automated
    scripts to configure product data in a golden database。 and then you could make
    clones of that database。 In another example， in a large testing environment。 you
    could choose to mock some endpoints while， using real data for others。 Many times。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些策略也可以协同工作。例如，你可以使用自动化脚本在黄金数据库中配置产品数据，然后克隆该数据库。在另一个例子中，在大型测试环境中，你可以选择模拟某些端点，同时为其他端点使用真实数据。很多时候。
- en: we want to use production or production-like data in our systems to mirror the
    real world。 Unfortunately， production data has things like personally identifiable
    information in， it。 and it's not always safe to share。 Many things might be like
    credit card numbers or Social Security numbers that must be kept。 private。 Generating
    data synthetically is a great way to avoid those roadblocks。 For example。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在系统中使用生产或类生产数据，以反映现实世界。不幸的是，生产数据中包含诸如个人身份信息等内容，且不总是安全共享。许多内容可能是信用卡号码或社会安全号码，必须保持私密。合成生成数据是避免这些障碍的绝佳方式。例如。
- en: Redo AI is an awesome tool that generates synthetic data that is statistically，
    accurate。 privacy protected， and safe to share。 You can use Redo AI with any of
    these static data prep strategies。 There are multiple factors that should be considered
    when deciding the best strategy for。 static data prep。 How big is your data？ If
    it's small。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Redo AI是一个出色的工具，能够生成统计上准确、保护隐私并且安全共享的合成数据。你可以将Redo AI与任何静态数据准备策略结合使用。在决定最佳静态数据准备策略时，有多个因素需要考虑。你的数据有多大？如果数据量很小。
- en: manual configuration can probably be sufficient。 Chubbled law。 But if it's large。
    then automation may be required。 Fresh does the data need to be。 If data is time
    sensitive。 then automation will be needed to keep it up to date。 How frequently
    will the data need to be updated？ Again， automation can help for frequent updates。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 手动配置可能足够。但如果数据量很大，可能需要自动化。数据需要有多新鲜？如果数据对时间敏感，那么需要自动化来保持数据更新。这些数据需要多频繁地更新？同样，自动化可以帮助频繁更新。
- en: and synthetic data generation tools like Redo， AI really shine here。 How difficult
    will it be to try advanced tricks like mocking or cloning databases？
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 像Redo和AI这样的合成数据生成工具在这里真正大放异彩。尝试像模拟或克隆数据库这样的高级技巧会有多难？
- en: This may be especially difficult for old or legacy systems。 Is there any bureaucracy
    in the way of automated solutions？ Hey， company Red tape happens。 Not every organization
    has efficient or even healthy culture。 Bureaucracy can stone wall advanced solutions
    that need extra support。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于旧系统或遗留系统可能尤其困难。是否存在任何官僚主义阻碍自动化解决方案？嘿，公司的红 tape 是存在的。并不是每个组织都有高效甚至健康的文化。官僚主义可能会阻碍需要额外支持的先进解决方案。
- en: Do folks have the skills required for automation， database administration， or
    MOCs？
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 大家有没有自动化、数据库管理或 MOCs 所需的技能？
- en: Skill level may be a barrier at first， but with training and learning， you can
    overcome。 any of those limitations。 And finally， what about the cost？ Each data
    prep strategy has a cost。 There should be a cost-benefit analysis done when your
    team is deciding。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 技能水平可能一开始是个障碍，但通过培训和学习，你可以克服这些限制。最后，成本问题呢？每种数据准备策略都有其成本。当你的团队在决策时，应该进行成本效益分析。
- en: '![](img/bb7342e61e6eabcf34bd076d3d280a67_15.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb7342e61e6eabcf34bd076d3d280a67_15.png)'
- en: So that's how to handle product data。 Everybody still with me？ Still with？ Yeah，
    whoo！ Awesome。 awesome。 I love seeing everybody here。 This is so cool。 So what
    about test case data？
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是处理产品数据的方法。大家还跟得上吗？还在吗？耶，太棒了！我喜欢看到大家在这里。这真酷。那么，测试用例数据呢？
- en: Only halfway through。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还没到一半。
- en: '![](img/bb7342e61e6eabcf34bd076d3d280a67_17.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb7342e61e6eabcf34bd076d3d280a67_17.png)'
- en: Let's look at test case data next。 Test case data is inherently part of test
    cases。 Let's revisit that example test case from earlier。 As we saw before。 there
    are multiple bits of test data throughout the steps of this short， scenario。 They
    represent different types of test case data。 So， look at the first step。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来看看测试用例数据。测试用例数据本质上是测试用例的一部分。让我们重新审视之前的示例测试用例。如前所见，这个简短场景的步骤中有多个测试数据位。它们代表不同类型的测试用例数据。那么，看看第一步。
- en: Given the Chrome browser is open。 Chrome browser is test data because it specifies
    the type of web browser in which to load the。 app。 This is what we call a test
    control input。 It directs how tests will run rather than specifying anything about
    future behavior。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 Chrome 浏览器已经打开。Chrome 浏览器是测试数据，因为它指定了加载应用程序的网络浏览器类型。这就是我们所说的测试控制输入。它指导测试的运行方式，而不是指定任何关于未来行为的内容。
- en: Theoretically， this test should run the same on any browser， but the steps dictate
    that。 the test should run on Chrome。 That's the best practice， don't do this。
    Test control input should not be hard coded in the test automation code。 Instead。
    they should be passed into automation as inputs。 That way， tests can easily be
    retargeted。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，这个测试在任何浏览器上都应该运行相同，但步骤规定测试应该在 Chrome 上运行。这是最佳实践，不要这样做。测试控制输入不应在测试自动化代码中硬编码，而应该作为输入传递给自动化。这样，测试可以轻松重新定位。
- en: There's a few ways to do this。 Simplest way would be to create a flat file with
    input values。 I recommend using a format like JSON or YAML because they're easy
    to write， easy to read。 and easy for programming languages to parse。 They can
    also have line by line diffs。 Test automation code can read the file before any
    tests start， and it can inject input values。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以做到这一点。最简单的方法是创建一个包含输入值的平面文件。我推荐使用像 JSON 或 YAML 这样的格式，因为它们易于编写、易于阅读，并且易于编程语言解析。它们也可以有逐行差异。测试自动化代码可以在任何测试开始之前读取文件，并可以注入输入值。
- en: as appropriate。 For example， using this JSON file。 automation could read the
    browser type and construct。 a web driver instance or playwright page for Chrome
    for each test。 The path for the input file would need to be hard coded into the
    automation， but it。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用这个 JSON 文件，自动化可以读取浏览器类型，并为每个测试构建 Chrome 的网页驱动实例或 playwright 页面。输入文件的路径需要硬编码到自动化中，但它。
- en: could be as simple as standard file name in the current directory。 Another way
    to handle input is using environment variables。 Test could set variables from
    a system shell or profile， and automation could read those。 variables by name。
    This can be useful for integrations with continuous integration servers or Docker
    containers。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以是当前目录中的标准文件名。处理输入的另一种方法是使用环境变量。测试可以从系统 shell 或配置文件中设置变量，自动化可以按名称读取这些变量。这对于与持续集成服务器或
    Docker 容器的集成很有用。
- en: However， it can be a little more dangerous because anyone could change the variable
    values。 Again。 automation would read them in before any test run and handle them
    appropriately。 Let's remove that hard coded step for browser type from the test
    scenario。 Test can be handled as an automation level concern。 Next。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这可能会有些危险，因为任何人都可以更改变量值。再说一次，自动化会在任何测试运行之前读取它们并适当处理它们。让我们从测试场景中移除那个硬编码的浏览器类型步骤。测试可以作为自动化级别的关注点来处理。接下来。
- en: let's look at a second type of test case data。 Notice how the URL here is hard
    coded。 This is also not a good practice。 Don't do this in the real world。 Typically
    development teams host multiple instances of products under development， like。
    a developer environment or a staging environment or a test environment。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第二种类型的测试用例数据。注意这里的URL是硬编码的。这也不是一个好习惯。不要在现实中这样做。通常，开发团队会在开发过程中托管多个产品实例，如开发环境、暂存环境或测试环境。
- en: Using configuration information like this limits where tests can run。 Any information
    about a product's configuration is called configuration metadata。 This can include
    things like URLs， usernames， passwords， and possibly other descriptors。 There's
    a few ways to handle config metadata。 You can use flat files or environment variables
    like for test control inputs。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的配置信息限制了测试的运行地点。关于产品配置的任何信息称为配置元数据。这可以包括URL、用户名、密码以及可能的其他描述符。有几种方法来处理配置元数据。你可以使用平面文件或环境变量作为测试控制输入。
- en: However， I do recommend using flat files and I also recommend separating test
    control inputs。 from configuration metadata。 Creating input to refer to the target
    configuration and store multiple configurations in the configuration。 metadata
    files。 That way testers can change those one or a few simple inputs to target
    any configuration。 And they won't need to change multiple configuration fields
    regularly。 If you want to be fancy。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我确实推荐使用平面文件，同时也建议将测试控制输入与配置元数据分开。创建输入以引用目标配置，并在配置元数据文件中存储多个配置。这样，测试人员只需更改一个或几个简单输入即可针对任何配置。并且他们不需要定期更改多个配置字段。如果你想要更复杂一些。
- en: you could create a web service to provide config metadata， something。 like Azure
    Key Vault or whatever the AWS thing is。 But you don't really need to do that unless
    you want to go big or you need to keep your。 passwords and secrets safe。 So it
    may be overkill。 Either way。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个网络服务来提供配置元数据，比如Azure Key Vault或AWS的其他服务。但除非你想要扩大规模或需要保持密码和秘密安全，否则你真的不需要这样做。所以这可能有些过度。无论如何。
- en: the test case step can be rewritten to refer more generically to the web app。
    Automation can select the target environment using the inputs and config metadata。
    By the way。 did anybody see that YAML shirt from CircleCI？ That was pretty funny，
    wasn't it？ Alright。 The remaining pieces of test case data all fall into the category
    called test case values。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例步骤可以重写，更一般地引用网络应用。自动化可以使用输入和配置元数据选择目标环境。顺便问一下，有人看到CircleCI的YAML T恤了吗？那真有趣，不是吗？好了，剩下的测试用例数据都属于称为测试用例值的类别。
- en: These values pertain directly to the behavior exercised by the test， not to
    any configuration。 factor。 Even in this classification， guess what？ There are
    subtypes。 First kind of test case data is a literal value。 These are values that
    are hard coded in the test。 In this example， the table of personal info contains
    literal values。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值直接与测试中所执行的行为相关，而不是与任何配置因素相关。即使在这种分类中，猜猜看？还有子类型。第一种测试用例数据是字面值。这些值在测试中是硬编码的。在这个例子中，个人信息表包含字面值。
- en: Literals are simple to use and they provide specification by example。 People
    should also be independent of any statically created product data。 They should
    be values that can be safely originated by the test case。 The literals in this
    info table will be entered as input values into the web app。 Theoretically。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 字面值使用简单，它们通过示例提供规范。人们应该独立于任何静态创建的产品数据。它们应该是可以安全地由测试用例生成的值。这个信息表中的字面值将作为输入值输入到网络应用中。从理论上讲。
- en: they could be any values。 The second kind of test case value is an output reference。
    These are values that are typically retrieved from the product under test。 They
    are the outputs generated by exercising a behavior。 In this example test。 the
    reference number can be scraped from the success page and verified， for correct
    format。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以是任何值。第二种测试用例值是输出引用。这些值通常是从被测试的产品中检索的。它们是通过执行某种行为生成的输出。在这个示例测试中，引用编号可以从成功页面抓取并验证其正确格式。
- en: The loan application can be retrieved from the web app's back end to verify
    that it was。 correctly submitted。 These values cannot be literals because they
    originate from the product。 That must refer to them by reference and retrieve
    their values from the product。 As a side note。 this test dynamically creates the
    loan application。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从网络应用的后端检索贷款申请，以验证其是否被正确提交。这些值不能是字面量，因为它们源于产品。必须通过引用来引用它们，并从产品中检索其值。顺便提一下，此测试动态创建贷款申请。
- en: The third and final kind of test case value is the trickiest。 The input reference。
    At first。 these values may look like literals。 However， input references are values
    that directly refer to product data。 While personal info like name and address
    are created dynamically by the test case， the。 name of the loan type refers to
    the loan configuration in your application。 Thus。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种也是最后一种测试用例值是最棘手的。输入引用。起初，这些值可能看起来像字面量。然而，输入引用是直接指向产品数据的值。当个人信息如姓名和地址由测试用例动态创建时，贷款类型的名称指的是应用中的贷款配置。因此。
- en: this test has an input dependency。 It must specify the type of loan and that
    loan type must already exist in the product。 data。 The simplest way to write this
    test is to simply hard code the reference。 That's what's done here。 The name home
    mortgage refers to the name of the loan type in the web app。 Automation can use
    that name when selecting the loan type like from a button or a drop-down。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试具有输入依赖性。它必须指定贷款类型，并且该贷款类型必须已经在产品数据中存在。编写此测试的最简单方法是直接硬编码引用。这就是这里所做的。名称“住房抵押贷款”指的是网络应用中贷款类型的名称。自动化可以在从按钮或下拉菜单中选择贷款类型时使用该名称。
- en: Hard code references make it easy to write tests， but they require statically
    prepped data。 to exist in the system。 References also become hard to maintain
    when the product data changes or when the same test。 must run against different
    configurations with different names。 One way to avoid the pain of static data
    is to dynamically create these records or configurations。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 硬编码引用使得编写测试变得简单，但它们需要在系统中存在静态预备数据。当产品数据发生变化，或者相同的测试必须针对不同名称的不同配置运行时，引用也会变得难以维护。避免静态数据带来的痛苦的一种方法是动态创建这些记录或配置。
- en: If the test calls the back end to create a new loan product named home mortgage
    for， each test run。 then static pre-prepped isn't needed。 However， we already
    know the pain points of dynamic prep。 So in this case， let's say dynamically creating
    a new loan type is just too slow。 A robust solution could be what we call data
    discovery。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试调用后端为每次测试运行创建一个名为“住房抵押贷款”的新贷款产品，那么就不需要静态预先准备的数据。然而，我们已经知道动态准备的痛点。那么在这种情况下，假设动态创建新的贷款类型就是太慢了。一个稳健的解决方案可以被称为数据发现。
- en: Let's say the target web app is already configured with multiple acceptable
    loan types。 Instead of hard coding the names of the desired loan type， the test
    could describe the loan。 type and then use automation to search the web app's
    configuration to find a loan type。 matching the desired criteria。 For example，
    if different regions of a bank have different names for this type of loan。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设目标网络应用已经配置了多种可接受的贷款类型。测试可以描述贷款类型，而不是硬编码所需贷款类型的名称，然后使用自动化搜索网络应用的配置，以找到符合所需标准的贷款类型。例如，如果银行的不同地区对这种贷款类型有不同的名称。
- en: the discovery mechanism could look into the config for a satisfactory home mortgage
    loan。 type and return the specific name for whatever region you're in。 Discovery
    enables tests to search existing product data for required records instead。 of
    hard coding those records。 Discovery makes tests more resilient to changes in
    product data。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 发现机制可以查看配置，寻找满意的住房抵押贷款类型，并返回你所在地区的特定名称。发现使得测试能够搜索现有产品数据以获取所需记录，而不是硬编码这些记录。发现使测试对产品数据的变化更加弹性。
- en: It's great when testing multiple environments with ever-socially differences
    between them。 However。 it does require extra coding and it may be overkill for
    small projects。 Whoo！ Who's still with me？
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个环境中测试时，能够处理彼此之间的社会差异是很棒的。然而，这确实需要额外的编码，并且对于小项目可能显得过于复杂。谁还在跟我呢？
- en: I'm not sure I'm still with me。 Where are you， Pikachu？ Let's get them。 That's
    a lot of information about test case data。 Right？ Here's summary。 Test control
    input directs how tests will be run， not what behavior is covered。 They should
    be supplied via flat files or environment variables。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定我是否还跟得上。你在哪里，皮卡丘？让我们抓住它们。这是一大堆关于测试用例数据的信息，对吧？这是总结：测试控制输入指导测试将如何运行，而不是涵盖什么行为。它们应通过平面文件或环境变量提供。
- en: Configuration metadata describe product configuration for the target environment。
    They should be supplied via config files or service API calls。 In test case values。
    direct the behavior covered by the test。 They may be literals， output references。
    or input references。 And input references may be hard coded or discovered。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 配置元数据描述目标环境的产品配置。它们应通过配置文件或服务API调用提供。在测试用例值中，直接指导测试所涵盖的行为。它们可以是字面量、输出引用或输入引用。输入引用可以是硬编码或被发现的。
- en: You want to take a picture of a slide and take this one。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你想拍一张幻灯片的照片，就拍这一张吧。
- en: '![](img/bb7342e61e6eabcf34bd076d3d280a67_19.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb7342e61e6eabcf34bd076d3d280a67_19.png)'
- en: Here's your chance。 Whoo！ So at this point， you're probably thinking， "Wow。
    that's a ton of information， especially， for a Sunday afternoon at PyCon。"， That's
    it， right？
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的机会。谁还在？此时你可能在想：“哇，这真是一大堆信息，尤其是在PyCon的一个星期日下午。”没错，对吧？
- en: We're done。 We're good。 Time for Q&A。 Well， frightfully， nightmares not over
    yet。 There's one more problem to address。 Collisions。 Collisions can happen whenever
    multiple actors operate on shared resources。 For example， they could happen whenever
    multiple testers simultaneously access the system or。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了。我们很好。是时候进行问答了。嗯，可怕的是，噩梦还没有结束。还有一个问题需要解决：冲突。当多个参与者在共享资源上操作时，可能会发生冲突。例如，当多个测试者同时访问系统时，就可能会发生。
- en: '![](img/bb7342e61e6eabcf34bd076d3d280a67_21.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb7342e61e6eabcf34bd076d3d280a67_21.png)'
- en: when automated tests run in parallel。 Additional considerations apply。 First
    and foremost。 isolate your test environments。 Please isolate your test environments。
    Prevent external actors from interrupting。 If you have a shared test environment。
    block people from using it while tests are running， or run off hours or something。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当自动化测试并行运行时，额外的考虑事项适用。首先也是最重要的，孤立你的测试环境。请孤立你的测试环境。防止外部参与者打扰。如果你有共享的测试环境，在测试运行时阻止人们使用它，或者在非工作时间运行等。
- en: If you're containerized， great。 Run containers by yourself。 Don't let anybody
    touch them。 Try to get it things as isolated as much as possible。 Second， treat
    any shared data as immutable。 When I say immutable， I mean constant， not changing。
    Nobody can go in there and tweak it。 If tests run in parallel against the test
    environment， they may have to use the same， product data。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用容器，太好了。自己运行容器。不要让任何人接触它们。尽量使其尽可能孤立。其次，将任何共享数据视为不可变。当我说不可变时，我是指恒定，不可更改。没有人可以进去修改。如果测试在测试环境中并行运行，它们可能需要使用相同的产品数据。
- en: Or if an application has multiple components， certain components may be difficult
    to isolate。 for testing。 So treat any shared data as constant so one thing can't
    mess up another。 Third and finally， use dynamic data prep as much as possible。
    Tests can't collide on data they don't share。 Keep statically prepared product
    data to a minimum。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序有多个组件，某些组件可能很难进行隔离进行测试。因此，将任何共享数据视为常量，以防止一个事物干扰另一个事物。第三，尽可能多地使用动态数据准备。测试在它们不共享的数据上无法发生冲突。将静态准备的产品数据保持在最低限度。
- en: You will need it， but keep it minimal。 Statically created data is more likely
    to become shared data and shared data is more。 likely to cause collisions。 Boom！
    We made it。 We covered lots of information today。 So again。 I would say here's
    your money shot for a slide。 There's two types of test data， product data。 test
    case data。 Product data can be static or dynamic。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你会需要它，但要保持最小化。静态创建的数据更可能成为共享数据，而共享数据更可能导致冲突。哇！我们做到了。今天我们覆盖了很多信息。因此，我会说这是你幻灯片上的关键内容。有两种类型的测试数据：产品数据和测试用例数据。产品数据可以是静态的或动态的。
- en: Test case data either controls how tests run or reflect the product data。 Handle
    your references and share data carefully。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例数据控制测试运行方式或反映产品数据。请小心处理引用并分享数据。
- en: '![](img/bb7342e61e6eabcf34bd076d3d280a67_23.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb7342e61e6eabcf34bd076d3d280a67_23.png)'
- en: And overall， if there's one message you take away other than Pokemon is awesome，
    choose。 the best strategy to defeat your nightmares。 Every product is different，
    every team is different。 Take the strategies I shared in this talk as suggestions。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，如果你从中得到的一个信息是除了宝可梦很棒之外，那就是选择。打败你噩梦的最佳策略。每个产品都是不同的，每个团队也是不同的。把我在这次演讲中分享的策略作为建议吧。
- en: '![](img/bb7342e61e6eabcf34bd076d3d280a67_25.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb7342e61e6eabcf34bd076d3d280a67_25.png)'
- en: So thank you again for listening to my talk。 Again。 my name is Pandy Knight
    and I'm the Automation Panda。 Be sure to check out my blog and follow me on Twitter
    and I hope you enjoy the rest of， PyCon 2022。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所以再次感谢你聆听我的演讲。再次，我的名字是潘迪·奈特（Pandy Knight），我是一名自动化熊猫（Automation Panda）。一定要查看我的博客并在推特上关注我，希望你享受剩下的2022年PyCon。
- en: '![](img/bb7342e61e6eabcf34bd076d3d280a67_27.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb7342e61e6eabcf34bd076d3d280a67_27.png)'
- en: '[APPLAUSE]。'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]。'
