- en: P44：Talk - Jessica Temporal_ Let's talk about JWT - VikingDen7 - BV1f8411Y7cP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'm super happy to be here。
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f356ac2853ed923b3e15746d71ff0c34_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/f356ac2853ed923b3e15746d71ff0c34_2.png)'
  prefs: []
  type: TYPE_IMG
- en: And in case you don't know me yet， let me introduce myself。 Hi， I'm Jess and
    Peral。 Well， Jessica。 but you can call me Jess。 My pronouns are she and her。 and
    I work as a senior developer advocate at ROT Zero。 If you don't know what ROT
    Zero is。 not a problem， we are an identity platform， so we。
  prefs: []
  type: TYPE_NORMAL
- en: make it as easy as possible for you to implement authentication on your applications
    so that。 you can focus on the fun stuff that you want to do for your users， right？
    We are going to do that。 I'm also an instructor at Data Bootcamp and McKinsey
    Learning。 I'm Brazilian and I have the first podcast about data science in Brazil
    called Pizza， Judas。
  prefs: []
  type: TYPE_NORMAL
- en: My last project that I just created is called Gitfishes and is a collection
    of Git study， cards。 If you don't know what I'm doing， check it out。 Also you
    may find me on most social networks under the handle of Justin Peral。 so if you，
    are shy and you want to ask questions right here， you can find me on Twitter later。
    Cool。 but enough about me。 And a little disclaimer before we get started。
  prefs: []
  type: TYPE_NORMAL
- en: So I come from Brazil and I know for a fact that most countries that don't speak
    English。 as a first language prefer to call Jason Webtokans JWT。 But if you come
    from an English-to-speak country， you might hear the word "chat。"。 So I'm going
    to be using those two terms along the presentation， so just get used to that。
  prefs: []
  type: TYPE_NORMAL
- en: It's a little weird， I might be honest。 The first time I ever heard about this，
    I was like， "Oh。 interesting。 Something new。"， But anyways， you're going to get
    used to it along this presentation。 So it is impossible to start talking about
    Jason Webtokans without mentioning the amazing。 effort there was made to create
    a collection of standards and specifications that is known。
  prefs: []
  type: TYPE_NORMAL
- en: as the Jose specification。 Jose stands for Jason Object Signing and Encryption。
    and it brings light to many things that we， need to work with Jason Webtokans
    and other objects that we might need while working on。 the web。 So part of the
    Jose specification is the IFC。 the request for comments 7519 that is commonly，
    known as the JWT specification。
  prefs: []
  type: TYPE_NORMAL
- en: And that's going to be our main focus for today。 Let's discuss it。 So a JWT
    or a Jason Webtokan usually is a standardized string that represents some information。
    So it conveys some meaning depending on context。 But let's take a closer look。
    So we have three words。 Jason， which means how are we going to structure the information
    that we want to pass from。
  prefs: []
  type: TYPE_NORMAL
- en: 1。8 to 1。 The web is the part where everything happens， where we make this information
    go from one。 point to another。 And the curious thing is it is a very space-constranded
    environment。 So we need to be mindful of the information we are carrying along
    these points。 And the last part。 the token， as a friend of mine likes to say，
    it usually is a unique。
  prefs: []
  type: TYPE_NORMAL
- en: identifier that conveys some meaning。 So if you never seen a Jason Webtokan
    before。 for those that are new to it， I introduce you， to your first Jason Webtokan。
    At a first glance。 this gigantic string looks like a random sequence of characters
    and numbers。 but actually it has a structure。 So usually a Jason Webtokan has
    three parts。
  prefs: []
  type: TYPE_NORMAL
- en: The header that's the beginning of my string， the payload that is right in the
    middle is。 also known as the body。 And this signature is the last part。 one of
    the most coolest ones if I do say so myself。 So the header。 you usually have the
    information about the token。 So what token it is， the token ID。
  prefs: []
  type: TYPE_NORMAL
- en: and what type of algorithm was used for signing the， token。 It is a Jason object。
    and if you're a Pythonista， you probably know that it looks like a dictionary，
    right？
  prefs: []
  type: TYPE_NORMAL
- en: And this Jason object is then turning into a base 64 string so that we can make
    the first。 part of our token。 Then we have the payload。 And the payload carries
    information about a given resource。 In a logging scenario， this means resource
    is my user。 So for example。 here I have information about me in a scenario that
    I was picturing it。
  prefs: []
  type: TYPE_NORMAL
- en: So I have the name of the user。 I have what it prefers to be called。 I have
    the sub。 which is the subject of the token。 And in this case， it would be the
    user ID and so on。 The cool thing about the payload is that it also has the information
    about when the token， expires。 So you also have that in there。 It is one of the
    steps that you do for verifying a token。
  prefs: []
  type: TYPE_NORMAL
- en: It is also basic， for encoded。 And you can take that and decode it anywhere。
    So there is one very important thing about the payload that they have there because
    they。 are a little bit different from the signature。 It is that each key value
    pair here is what we call claims。 And there are actually three types of claims。
    So the first type of claims are the reserved claims。
  prefs: []
  type: TYPE_NORMAL
- en: These claims came from the job specification。 So they are very important because
    these are the claims like the expiration date where。 you can check if a token
    is expired or not。 They have information on who issued that token。 And my info，
    this is just an example。 And the second type we have are the public claims。 They
    are standardized in our way by IANA， one of the organizations on the internet。
  prefs: []
  type: TYPE_NORMAL
- en: And the public claims are made to carry the most common information we usually
    share when。 using a token。 So for example， if you were to give the information
    of the first name of the user and the last。 name， IANA has a standard that says，
    oh， we are not going to call it first name。 We are going to call it given name。
    And we are not going to call it last name。
  prefs: []
  type: TYPE_NORMAL
- en: but we are going to call family name and so， on。 There is a long list。 The idea
    is to provide a way for interoperability between systems to happen。 So everybody
    would be speaking， well， the same language。 And the last type of claims that we
    have are the private claims。
  prefs: []
  type: TYPE_NORMAL
- en: And they are the coolest because the private claims are supposed to be anything
    that you， want。 anything that your systems need for properly functioning。 So as
    long as you keep a valid JSON object， you can put anything there， anything really。
    But there is a caveat。 First， the more information you put on the JSON I've token。
  prefs: []
  type: TYPE_NORMAL
- en: the bigger the output string， you're going to have to pass along in the request
    that you make。 So be mindful of the data you put in there。 Keep only the relevant
    data is a general advice。 The second one is because both of the header and the
    payload are only base 64 encoded， we。 don't put sensitive data in the token。 Well，
    because anybody that has an internet connection could Google up how to decode
    a。
  prefs: []
  type: TYPE_NORMAL
- en: base 64 string。 It doesn't even have to code。 And they could get a hold of that
    data。 So we don't want that to happen。 We don't want the data to be publicly available
    if it is sensitive。 Now you know about the header and the payload。 Let's talk
    about the signature。 And the signature is really special because the signature
    takes the header and the payload。
  prefs: []
  type: TYPE_NORMAL
- en: to happen。 And depending on the algorithm， a secret or eight。 And the interesting
    thing is right here I have a symmetrical algorithm that's HMAC， to 156。 It only
    takes a secret。 But you may notice that my secrets is your 256-bit secret。 Not
    that safe。 In real life you would have something like this。 A random string that
    is generated has a lot of characters to make everybody's lives a。
  prefs: []
  type: TYPE_NORMAL
- en: little bit safer。 So we take the header and the payload together with the secret
    and a key for signing the token。 Now speaking of algorithms， we have two types。
    The first one takes the secret。 is the first one is the symmetrical algorithm。
    And you can think of a secret。 You don't want to share that with everybody， right？
  prefs: []
  type: TYPE_NORMAL
- en: So the secret is surely between the party that signs the token and the party
    that needs。 to verify the token。 But there is a second type of algorithms。 That's
    the one that I like the most。 The asymmetrical ones。 Because the asymmetrical
    algorithms takes a pair of two keys。 For one for signing， the private key and
    one for verifying the token。 The public key。
  prefs: []
  type: TYPE_NORMAL
- en: And you can keep the private key safe and secure and don't have to share it
    with anyone。 and you shouldn't。 And you can publish the public key well so that
    anybody could verify the token that。 you signed to make sure that it was really
    you。 If you were implementing on web application for example。 and if you were
    using R0 for example， R0 would create the tokens for you and you could get the
    public key from a well-known。
  prefs: []
  type: TYPE_NORMAL
- en: end point so that you could validate that the token came from R0。 You could
    also validate whether or not this token was tampered with。 Because the signature
    allows us to do that。 Because the only person that should be able to sign the
    token is the person that is holding。 the secret or the private key。 You can obtain
    your data a little bit safer。 Now speaking of keys。
  prefs: []
  type: TYPE_NORMAL
- en: there is a format for you to share your keys alone。 And if you are following
    open-d。 So it has a bunch of information there because key pairs are bound by
    mathematical properties。 that you don't need to know if you don't want to or if
    you don't want to interested in。 cryptography。 So well， it is up to you。 And most
    of the packages and libraries that we use today。
  prefs: []
  type: TYPE_NORMAL
- en: they support getting this key， from this end point so that you can actually
    use it without having to know what each of。 this part means。 But there are two
    important things that you need to notice here。 We know what algorithm usually
    this key is used for。 And we know the key ID because you can have more than one
    public key for users depending。
  prefs: []
  type: TYPE_NORMAL
- en: on how your systems are set up。 And let's see some code， right？ Because I like
    to code in Python。 don't you？ Well， there are a few libraries that you can use
    to handle JWTs in Python。 My favorite one is PyJWT。 I'm a little biased。 And it
    does all the cool stuff。 So the first thing you want to do is install PyJWT with
    a cryptography dependency on your。
  prefs: []
  type: TYPE_NORMAL
- en: Python environment。 And then you can just import JWT on your Python console
    and give it a token。 And it is going to do its magic for us。 So the first thing
    I'm going to do is actually import my JWT module。 After that， I can copy the token，
    put in a variable for me to use as a string。 And then the easiest part comes。
    We call the JWT。code method。 And you pass it on the token。
  prefs: []
  type: TYPE_NORMAL
- en: the secrets， and the algorithms。 Now， these are the things that you know the
    secrets and you know the algorithms。 Once the code method does its magic， you
    are going to be able to retrieve the payload of， a token。 That means the verification
    process was well done， was successful。 And of course。 now I know every little
    thing that leads to know about this token。 I know the secrets。
  prefs: []
  type: TYPE_NORMAL
- en: I know the algorithms。 And once I pass it along to the method， I can see the
    resulting there。 And it comes as a dictionary。 So you can save that into a variable
    and use that on your applications whichever way you。 want。 But let's say， for
    example， that somebody told you the secrets， but they forgot to tell。 which algorithm
    was used for the token。 So that is the way actually you can find that out。
  prefs: []
  type: TYPE_NORMAL
- en: And it's using the method get unverified header。 It also gives back a dictionary。
    So I did the same process。 I imported JWT。 I put my token in there。 And then I
    use the method get unverified header pass along the token。 I do a lot of typos
    when I'm coding。 And then I can get the header。 After that。
  prefs: []
  type: TYPE_NORMAL
- en: I can see the header。 It is also a dictionary。 So I can put that into a variable
    so that I can use on my code。 So you don't have to actually know beforehand what
    was the algorithm used。 And then I put that header data because， well， what better
    name。 And then I call again JWT。decode pass along the token pass along the key。
    Well， in this case。
  prefs: []
  type: TYPE_NORMAL
- en: a secret because the algorithm is still HS 256。 And please don't use that secret。
    It's not the good one。 And then pass along the algorithms in the format of accessing
    the dictionary data。 And there you go。 After that， we are going to be able to
    get once again my dictionary of the payload。 This means that everything was successful
    on verifying the token。 Now let's see。
  prefs: []
  type: TYPE_NORMAL
- en: You are not successful。 Something goes wrong。 What should you do？ Well， I have
    an answer for that。 JWT， PyTWT actually gives you all the exceptions it raises
    when something goes wrong。 So if。 for example， you get an expire signature， it
    will show you an expire signature。 And you being the good Python instead of the
    good developer that you are， you are going。
  prefs: []
  type: TYPE_NORMAL
- en: to want to try and use that exception to treat it， to maybe log the error。 So
    I did that try except when my coding， the try， then did I accept？
  prefs: []
  type: TYPE_NORMAL
- en: I know this is a possible error。 I put error in there。 And then I can use that
    information to log what went wrong because well， you want to。 keep track of these
    things， right？ Now there I'm just printing so you might fill up that because it's
    just an example。 When in my systems I would be logging it out。 And then I can
    use a string that I know and I can find that information on my logs。
  prefs: []
  type: TYPE_NORMAL
- en: And there you go。 After I run that， I'm able to see that， well。 it didn't move
    up in my face anymore。 The last part I want to show you in code is that is a possibility
    that you are not using。 a symmetrical algorithm like the examples I just showed
    you。 So you can either request a key or you can load the key yourself from your
    machine。 In this case。
  prefs: []
  type: TYPE_NORMAL
- en: this example talking that I have， I created it using an SSH key so I can， load
    that in using PyGwT。 And after I load that in， I can use it with read because
    I want a string of it。 And then I can use the serialization module of PyGwT to
    load any type of key that you might， have。 For example， this is an SSH one but
    you're going to see that we have other methods in， there。
  prefs: []
  type: TYPE_NORMAL
- en: Like for example， the PIM type of keys。 And I'm going to load my SSH public
    key because I want to verify the token。 I pass it along as a byte string so I
    encode it。 And then I can use that back again with my deco method。 Now keep in
    mind if you are using your service as out zero as an example， you would have to。
    make a request for the well known end point to get the key and you need the well
    known。
  prefs: []
  type: TYPE_NORMAL
- en: end point and the key ID for that。 And that is our way to do that。 I linked
    that information in the description of this slide。 This is going to be available
    to you so you can check it out。 And then again。 I put along the algorithm that
    I'm using。 And if everything goes well。
  prefs: []
  type: TYPE_NORMAL
- en: you should be able to see the payload data。 There you go。 Awesome。 So now you're
    wondering， okay。 I know everything that is to know about JWT's。 I know how they
    came to life。 I know what the payload and the header are。 I know that I have a
    lot of algorithms that I can use。 Two types of them。 I know I have claims and
    so on。 Where do I find JWT's in the wild？
  prefs: []
  type: TYPE_NORMAL
- en: Where do they live？ How do they feed？ So the first time I think of JWT's。 and
    the first time that I actually saw one was actually， making requests to protected
    APIs。 So when you are talking about protected APIs， you're going to think about
    access tokens。 So let's say you want to make a request to a protected API， you
    need an access token。
  prefs: []
  type: TYPE_NORMAL
- en: to access the protected routes。 So the access token is going to have all of
    the information that you need for dealing。 with that API。 Now， access tokens doesn't
    necessarily need to be JWT's。 but there is a new IFC in the， block that came out
    last year。 It was authored by Vittario Betache。 a zero-spitzpo architect that
    outlines how JWT as an access， token should behave。
  prefs: []
  type: TYPE_NORMAL
- en: So that information needs to have how the information must be structured and
    so on。 It's a very interesting read。 If you are curious， you should check it out。
    The other type of JWT's you may find the wild are the ID tokens， and they are
    the coolest。 in the world。 Because they carry information after the user did their
    logging， for example。
  prefs: []
  type: TYPE_NORMAL
- en: So that way your front end doesn't have to make an extra request to get， for
    example。 the user profile。 It is going to be able to have that information in
    there。 Also。 because we're talking about tokens， you may have heard of refresh
    tokens。 You fresh tokens are not JWT's， that's why I'm not going to be speaking
    about it。
  prefs: []
  type: TYPE_NORMAL
- en: Maybe in a new talk。 So now that you know how you can use that， JWT's， how they
    work。 how they come to life， how you can structure the information， you may be
    wondering， "Well。 this seems a little， bit dangerous。 There's going to be information
    in there。 How do I。 I don't know， be safer with it？"， Well， I have a few tips
    for you。
  prefs: []
  type: TYPE_NORMAL
- en: So don't store your JWT's in local storage。 That's a bad idea because it opens
    you up for a type of attack known as XSS attack。 And we don't want to do that。
    Because once JWT's are out there， you cannot call them back。 It is a hassle。 So
    don't start that in local storage。 If you need to start somewhere for verification
    process， you may do it in memory。
  prefs: []
  type: TYPE_NORMAL
- en: That's the best idea。 The other tip is we don't verify JWT's in the front end。
    As well。 let's say you have a JWT that was signed using a symmetrical algorithm。
    You would need to have the key phrase for translating the token for verifying
    the signature。 And we don't want to have that in the front end because anybody
    could go inspect the element。
  prefs: []
  type: TYPE_NORMAL
- en: on your page and get that information。 And we don't want to do that。 The last
    one。 and I cannot stress this enough， me being an ex-data scientist， well， it's。
    your data science at heart， don't put sensitive data in the payload of your token。
    It's a bad idea because once again， anybody can inspect your web application and
    get。
  prefs: []
  type: TYPE_NORMAL
- en: a hold of that token。 And then your sensitive data is going to be out there。
    So it's not a good idea to put that in the token。 Finally。 I want to give you
    some tools to help you out。 Because I know JWT's may be hard。 I made this talk
    thinking of me a few years back that I wanted this content and I didn't， find
    any。
  prefs: []
  type: TYPE_NORMAL
- en: I had to figure out by myself。 So the first one I'm going to tell you is JWT。io。
    This was made by OutZero。 It's going to help you debug your access tokens。 And
    it's going to make your life easier。 You can check out writing browser the information
    of your token。 Now be mindful while you're facing the token because if it is a
    real production token， it's。
  prefs: []
  type: TYPE_NORMAL
- en: not a good idea。 But JWT。io is a safe environment where you can check out your
    token if you need to。 And we don't start the tokens for ourselves。 So it's safer。
    The other one is you may need more information about JWT's because you are very
    curious about， it。 So we actually made a handbook with a few examples and use
    cases of JWT's and I encourage。
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f356ac2853ed923b3e15746d71ff0c34_4.png)'
  prefs: []
  type: TYPE_IMG
- en: you to read it。 And that was it。 I don't know if you have time for my questions。
    but you may find me on， again， on most social， networks under the handle JAS。
    And my slides are on that link， as I。com/JWT， if you want to check out all the
    links。 That's it。 [APPLAUSE]， We don't take questions as part of the presentation。
  prefs: []
  type: TYPE_NORMAL
- en: but please come forward and ask Jessica directly， if you have any questions
    or just by the--。 \>\> A zero booth。 We own the line 600。 Thank you。 \>\> Thank
    you。 \>\> See you。 [APPLAUSE]， [APPLAUSE]。
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f356ac2853ed923b3e15746d71ff0c34_6.png)'
  prefs: []
  type: TYPE_IMG
