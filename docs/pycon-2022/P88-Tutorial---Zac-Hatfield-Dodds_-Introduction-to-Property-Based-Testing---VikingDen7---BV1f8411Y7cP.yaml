- en: P88：Tutorial - Zac Hatfield-Dodds_ Introduction to Property Based Testing -
    VikingDen7 - BV1f8411Y7cP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So let's jump into it。 Thank you all for coming。 I know this tutorial hasn't
    been up for terribly。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a2a8090e0ca721c225298b1c97c51f4_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: '![](img/8a2a8090e0ca721c225298b1c97c51f4_2.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: long。 In fact， I was asked to deliver it last week when someone else had visa
    trouble getting。 into the country for the conference。 So without further ado，
    my name is Zach Hatfield-Dods。 I'm the maintainer of Python's leading library
    for property-based testing and also on the。 PyTest core team， which you may have
    heard of。 And I'm going to walk you through how I think。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: about property-based testing and how I think you can apply it in your code bases。
    And so。 the tutorial or workshop is basically in four parts。 Before the break，
    I'm going to walk。 through what is property-based testing anyway and show you
    some examples。 Then part two。 still before the break， we're going to look at how
    you describe test data using hypothesis。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: and I'll get into what that means in part one。 Then at 10。30 between two and
    three， we're。 going to take our coffee break。 We'll come back at 11 and start
    talking about what I。 call test tactics， like design patterns for property-based
    tests and then round the workshop。 by talking about the practicalities in part
    four， the kind of stuff that you need to know。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: to actually apply it in your open source projects or at work。 How does configuration
    work？ What's。 the update schedule like？ How does it interoperate with other libraries，
    that kind of thing？
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Sound good？ Awesome。 I love an engaged class。 So property-based testing， one-on-one。
    I will。 have a slides link up in half an hour or so。 So， I kind of want to start
    with， well， what。 is testing anyway？ Would I tell you it's property-based testing？
    What do I mean by testing？ Testing。 for me is the art and science of running your
    code and then checking that it did the right。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: thing or sometimes just checking that it didn't do the wrong thing。 In Python，
    that means usually。 that we run the code and if it didn't raise an exception，
    then it's good。 And if it gave。 us the result we expected， that's even better。
    There's a whole lot of tools and techniques。 which are really useful for writing
    correct code or having high productivity on a software。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: engineering team which are not testing。 I think all these things are great，
    putting assertions。 in your code， using a type checker if that's appropriate to
    the situation， linters， peer。 code review， drinking coffee or perhaps even getting
    off sleep if you're a real wild guy。 But they're not testing， so I'm not discussing
    them further today。 And then there are a thousand。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: taxonomies of different kinds of tests。 One that I find useful is just the list
    here。 So。 we've got unit tests which typically tests something pretty small。 There's
    integration。 tests that are exactly the same as unit tests but with a bigger unit。
    We've got snapshot tests。 where you run your software and save the output so that
    you can check that future runs with。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 各种类型测试的分类。我觉得有用的一种只是这里的列表。所以，我们有单元测试，通常测试一些相当小的内容。还有集成测试，它们与单元测试完全相同，只是单位更大。我们有快照测试，你运行软件并保存输出，以便可以检查未来的运行结果。
- en: an updated version produce the same output。 This is useful because you can't
    really check。 correctness using a snapshot test。 There's parameterized tests。
    We have a list of possible。 inputs and maybe they're corresponding outputs and
    you run those through。 So you just throw。 random software and see if it crashes。
    And then what we're talking about today， property。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的版本产生相同的输出。这很有用，因为你无法通过快照测试来检查正确性。我们有参数化测试。我们有可能的输入列表，也许还有相应的输出，然后将这些输入运行。因此，你只需扔出随机软件，看它是否崩溃。然后我们今天讨论的是，属性。
- en: based tests and as an extension that I'm barely going to talk about at all，
    stateful model。 based tests。 I'm going to be doing a few examples。 So my friend
    David who started the project。 says every time someone uses a reversing a list
    twice gives you the same list to demonstrate。 property based testing I take a
    drink。 This isn't a drinking game， I just hate bad examples。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 基于状态的测试，以及我几乎不会谈到的扩展，即有状态模型测试。我会做几个例子。我的朋友大卫启动这个项目，他说每次有人对列表进行两次反转，得到的结果都是同一个列表，以此来演示属性基础测试，我就会喝一口。这并不是一个喝酒游戏，我只是讨厌糟糕的例子。
- en: Let's make our founding and most common example a non generalizable property
    of a function。 that's almost impossible to get wrong。 What could possibly go wrong
    with that？ So in。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把最常见的例子设定为一个几乎不可能出错的函数的非可推广属性。这有什么可能出错的呢？所以在。
- en: '![](img/8a2a8090e0ca721c225298b1c97c51f4_4.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a2a8090e0ca721c225298b1c97c51f4_4.png)'
- en: difference to my friend David we're going to be talking about sorting。 Now these
    are。 kind of classic unit tests。 We say that if we sort the list one， one， two，
    three， we expect。 to get the list one， two， three。 Let's just pretend here that
    Python doesn't have a sorted。 function yet。 So we're kind of having to implement
    that for ourselves。 And we can also test that。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的朋友大卫要讨论排序。现在这些都是经典的单元测试。我们说如果我们对列表一，一，二，三进行排序，我们期望得到列表一，二，三。假设这里 Python 还没有
    `sorted` 函数。因此，我们必须自己实现这个功能。我们也可以进行测试。
- en: if we sort a list of floating point， there's 3。0， 2。0， 1。0， we should get 1。0，
    2。0， 3。0。 and we can also sort strings， not just numbers。 We can sort lists of
    anything that can be， compared。 And so if we sort base a we should get a， b， c。
    All make sense？ A parameterized。 test might look a little like this。 We just supply
    a list of the arguments and the corresponding。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对浮点列表进行排序，比如 3.0，2.0，1.0，我们应该得到 1.0，2.0，3.0。我们也可以排序字符串，而不仅仅是数字。我们可以排序任何可以比较的列表。因此，如果我们排序
    a，我们应该得到 a，b，c。都明白了吗？参数化测试可能看起来像这样。我们只需提供参数列表和相应的输出。
- en: expected result。 And so at this point， like honestly we haven't gained much
    at all by， going here。 And in fact we've lost our function names on the test，
    which describe what we're， actually doing。 But a parameterized test does make
    it cheesy to drop in another few cases， later。 If we discover that there was an
    edge case we weren't handling or we want to test。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果。因此在这个时刻，老实说，我们并没有通过这里得到太多。事实上，我们在测试中失去了函数名称，这些名称描述了我们实际在做的事情。但参数化测试确实让后续插入另几个案例变得简单。如果我们发现有一个边缘案例没有处理，或者我们想进行测试。
- en: empty lists or list of more elements， it's much easier just to drop them into
    a list here。 than to write a whole new test function。 And it's easier to be confident
    that the body。 of the test function is always the same because you've only got
    one test body。 But sometimes。 like to be honest， the problem is we're only testing
    short lists here because it's a pain。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 空列表或更多元素的列表，直接将它们放入列表中要简单得多，而不是编写一个全新的测试函数。而且你可以更有信心地认为测试函数的主体始终相同，因为你只有一个测试主体。但有时，老实说，问题是我们这里只测试短列表，因为这很麻烦。
- en: in the neck to write out really long examples。 So if we didn't have to write
    out the result。 by hand as well， that would be helpful for testing more complicated
    code。 And so in this。 case we're saying well if we already had a trusted sort
    function that we knew someone。 been implemented correctly， or maybe this is the
    version from before we did a bunch of。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写非常长的示例时。假如我们不必手动写出结果，那将对测试更复杂的代码有帮助。因此在这种情况下，我们说如果我们已经有一个可信的排序函数，我们知道有人实现得很正确，或者也许这是我们进行了一堆修改之前的版本。
- en: performance optimizations or a single threaded version or just the old version。
    This situation。 comes up more often than you'd expect where you actually have
    to do the function。 And in。 this case you can just come up with your inputs and
    then check that you get the same result。 from each of those functions。 And then
    if you don't even have a trusted implementation。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化或单线程版本或仅仅是旧版本。这种情况比你想象的更常见，你实际上需要执行函数。在这种情况下，你只需设计输入，然后检查从每个函数得到的结果是否相同。如果你甚至没有一个可信的实现。
- en: there are still things you can check。 So this test says if we sort any of these
    input lists。 and then take the pairs out of the output， so the zeroth and first
    elements， the first， and second。 the second and third， then the preceding element
    should be less than or equal。 to the subsequent element。 This is just say the
    output from the sorted function must be， in order。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一些事情可以检查。因此，这个测试表明，如果我们对任何输入列表进行排序，然后从输出中取出成对的元素，比如第零个和第一个元素，第一个和第二个，第二个和第三个，那么前一个元素应该小于或等于后一个元素。这只是说，从排序函数输出的结果必须是有序的。
- en: And so we can check this kind of thing without even knowing how to sort something。
    I always stuff up edge cases if I'm doing quick check or quick sort or something。
    But this。 is not a complete test。 Does anyone have an idea as to why？ So it's
    just pairwise。 But。 we can be pretty confident that if the first element is less
    than the second and the second。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以在不知道如何排序的情况下检查这种情况。如果我在做快速检查或快速排序时，总是会搞错边缘情况。但是这并不是一个完整的测试。有没有人知道为什么？所以这只是成对的比较。但我们可以相当有信心，如果第一个元素小于第二个，而第二个。
- en: is less than the third then we're still in order。 The problem here is that if
    sorted was。 defined as return empty list this test would pass。 Or even if it was
    defined as return a。 list containing one two。 That's an ordered list。 So we'd
    want to add some extra assertions。 that say well we've got the same length of
    output and the same set of elements。 And to。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第三个元素小于前两个元素，那么我们仍然是有序的。这里的问题是，如果排序被定义为返回空列表，那么这个测试将会通过。或者即使它被定义为返回一个包含一和二的列表，那也是一个有序列表。因此我们需要添加一些额外的断言，来确认我们输出的长度相同，并且元素集合相同。
- en: be honest I think this is a good test for sorting。 But if you sort of had your
    enterprise software。 developer colleague from hell whose goal was just to get
    the test passed in nothing else。 because they like really strict test driven development。
    This test would still not be， enough。 Can anyone guess why？ So if you gave it
    the list one to one and sorted returned。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 坦率地说，我认为这是一个不错的排序测试。但是如果你的企业软件开发同事来自地狱，他们的目标只是让测试通过，而不考虑其他，因为他们喜欢严格的测试驱动开发。那么这个测试仍然不够。有人能猜到为什么吗？所以如果你给它列表一到一，排序返回。
- en: one to two this test would still pass。 Because you've got the same number of
    elements of。 the same set of elements but you've messed around with the duplicate
    elements。 So the。 mathematical definition of sorting is that sorting is the permutation
    of your input sequence。 such that it is in pairwise order。 And so this test is
    a complete test for sorting。 Any function。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一到二，这个测试仍然会通过。因为你有相同数量的元素，且元素集合相同，但你搞乱了重复元素。因此，排序的数学定义是对输入序列的排列，使其按成对顺序排列。因此，这个测试是排序的完整测试。任何函数。
- en: which passes this test is a correct sorting function。 The only problem is that
    checking。 every permutation is just super slow。 So we don't actually want to do
    that。 It's like cubic time。 in the length of the list。 We might instead check
    that the collections。counter that is the。 number of each distinct element we have
    is the same in the input as the output。 And so this is。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个测试的排序函数是正确的。唯一的问题是检查每一个排列实在是太慢了。所以我们实际上并不想那样做。这是与列表长度的立方时间成正比。我们可能会检查集合的计数器，即我们每个不同元素的数量在输入和输出中是相同的。因此这是。
- en: a fast efficient test which will catch any possible wrong sorting algorithm。
    And we've just。 discovered property based testing。 So this is a test and it's
    got two properties that we're checking。 The first is that the output is in order
    and the second is that we have the same elements that we。 start up with。 And any
    function which satisfies these two properties is a sorting function。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速高效的测试，能够捕捉到任何可能的错误排序算法。我们刚刚发现了基于属性的测试。所以这是一个测试，它有两个我们正在检查的属性。第一个是输出是有序的，第二个是我们有与开始时相同的元素。任何满足这两个属性的函数都是排序函数。
- en: That said， I think this is a fine test as well。 Your test doesn't have to catch
    every possible。 secretly evil input that is out to get you。 If it catches plausible
    mistakes， that is honestly。 all we need most of the time。 The other thing I'll
    say is that this is also a property。 This is。 the property that the two functions
    give equivalent outputs on the same input。 And that's a really。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我认为这也是一个很好的测试。你的测试不必捕捉到所有可能的秘密恶意输入。如果它捕捉到合理的错误，那 honestly 是我们大多数时候所需的。我要说的另一件事是，这也是一个属性。这个属性是两个函数在相同输入上给出等效输出。这真的是一个很好的。
- en: useful one。 We'll come back to that later。 So to extend this with hypothesis，
    we take exactly。 the same test body here。 But we're just kind of hand-waved。 Pightest
    parametrires something。 And it's your problem to come up with that。 The problem
    that hypothesis solves is precisely。 coming up with those inputs。 And so what
    we can do is we can give it the given decorator。 So。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的一个。我们稍后会再讨论这个。因此，要用假设扩展这一点，我们在这里采用完全相同的测试体。但是我们只是稍微手动调整了一下参数。这是你的问题，需要提出这个。假设解决的问题正是生成这些输入。因此，我们可以给它提供给定的装饰器。
- en: given an argument which is one of either lists of integers or floats or lists
    of strings。 And the hypothesis framework will then generate many random examples
    for you。 And in fact， it。 will generate a random example that makes that test
    fail。 Because we assumed that numbers could。 be compared and not a number is a
    special floating point value which comparison doesn't really work。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个参数，可以是整数或浮点数的列表，或者字符串的列表。假设框架将为你生成许多随机示例。实际上，它将生成一个随机示例使得该测试失败。因为我们假设数字可以进行比较，而
    NaN 是一种特殊的浮点值，其比较并不真正有效。
- en: '![](img/8a2a8090e0ca721c225298b1c97c51f4_6.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a2a8090e0ca721c225298b1c97c51f4_6.png)'
- en: on the way you expect。 But this test will pass again。 So to summarize this little
    introductory bet。 the advantage of property-based testing is that it。 helps us
    generate input data that we wouldn't have thought of otherwise。 And that's particularly。
    useful because the edge cases you didn't think of are precisely the ones that
    you're likely to。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 按照你预期的方式。但这个测试会再次通过。因此，总结一下这个简短的介绍，基于属性的测试的优势在于它帮助我们生成我们不会想到的输入数据。这尤其有用，因为你没有想到的边缘情况恰恰是你可能会遇到的。
- en: have bugs with。 And if I think of an edge case， when I go to write a test， I
    usually just go check。 that my code handles it too。 So we can check that the result
    is not wrong even when we don't know。 the correct answer or can't think of what
    the correct answer should be。 Or indeed， don't know。 how to get the correct answer。
    Yep？ It is very similar to fuzz testing。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想到一个边缘情况，当我去写测试时，我通常会去检查我的代码是否也处理它。因此，即使我们不知道正确答案或想不出正确答案应该是什么，或者确实不知道如何得到正确答案，我们也可以检查结果是否不错误。没错？这与模糊测试非常相似。
- en: The difference is essentially， that fuzz testing tends to deal with sort of
    random bytes。 So anything that can be represented in a， network packet or a file。
    Whereas property-based testing is much more structured。 So we want。 specifically
    lists of the things we've asked for rather than like any possible value。 But you。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于，模糊测试往往处理的是随机字节。所以任何可以在网络数据包或文件中表示的东西。而基于属性的测试则更加结构化。因此，我们具体想要我们请求的列表，而不是任何可能的值。但你有
    bug。
- en: could use hypothesis as a fuzz tester as well。 And the last thing that I find
    using a hypothesis。 which kind of surprised me when I started， is that often the
    bugs it finds are actually bugs in my。 understanding of what the code is meant
    to do， rather than bugs in the code per se。 You know。 that some library has a
    slightly different contract or semantics than I expected or that I didn't。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将Hypothesis用作模糊测试工具。而我发现使用Hypothesis的最后一件事，令我感到惊讶的是，它发现的错误实际上是我对代码应该执行什么的理解中的错误，而不是代码本身的错误。你知道的，一些库的合同或语义与我预期的略有不同，或者我没有意识到。
- en: actually understand the problem statement well enough to write a good test for
    it。 Because it's a lot， easier to kind of go well this input gives me oh it's
    that output。 Let me just paste that into the， test。 That's actually a lot easier
    on your understanding of the code than having to think。 what should always be
    true about my function。 And then the last thing I want to claim， though I。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Hypothesis能很好地理解问题陈述，以便为其编写良好的测试。因为这很容易，你可以说这个输入给了我那个输出。让我把它粘贴到测试中。实际上，这比思考“我的函数应该始终满足什么条件”要简单得多。最后我想声称的是，虽然我。
- en: haven't demonstrated it yet， is that you often don't even need assertions in
    your test。 If you。 start calling your code with like really weird but technically
    valid input values， you will get a。 lot of internal errors。 And so if you can't
    think of any properties， you actually don't need any。 properties。 It does not
    raise an exception on valid input is a perfectly fine property to test。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没有演示过的是，你在测试中往往甚至不需要断言。如果你开始用一些真的很奇怪但技术上有效的输入值来调用你的代码，你会得到很多内部错误。因此，如果你想不到任何属性，实际上你并不需要任何属性。对于有效输入不引发异常是一个完全合理的测试属性。
- en: And at least in my code it's embarrassingly effective。 So let's get set up on
    the notebook side of things。 We're not going to go through the exercises。 right
    now but I want to get us set up here。 So github。com/rsockles/testing-tutorial。
    And by your preference you can either install things locally as described and
    read me in here。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 至少在我的代码中，这种方法非常有效。所以让我们在笔记本那边做好准备。我们现在不会进行练习，但我想让我们在这里做好准备。所以github.com/rsockles/testing-tutorial。根据你的偏好，你可以按照这里描述的方式在本地安装东西。
- en: or you can just click on the links that will open a notebook for you in my binder
    with zero installation。 [pause]。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你也可以点击链接，这将为你在我的binder中打开一个笔记本，零安装。[暂停]。
- en: '![](img/8a2a8090e0ca721c225298b1c97c51f4_8.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a2a8090e0ca721c225298b1c97c51f4_8.png)'
- en: All right， so， having unlocked my video， there we are。 You may be familiar with
    the Hypothesis logo。 It's a dragonfly because dragonfly is hot and eat bugs。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，解锁我的视频后，我们来到了这里。你可能对Hypothesis的标志很熟悉。它是一个蜻蜓，因为蜻蜓很酷并且吃虫子。
- en: '![](img/8a2a8090e0ca721c225298b1c97c51f4_10.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a2a8090e0ca721c225298b1c97c51f4_10.png)'
- en: So with setup mostly in place， let's talk about part two before our break。 And
    this is how you can use Hypothesis to describe your data。 So I showed off this
    a little with the， given decorator and the。 isn't the floats。 But we're going
    to go through a little more。 Hypothesis。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在设置基本完成后，让我们在休息前谈谈第二部分。这是你如何使用Hypothesis来描述你的数据。因此，我稍微展示了一下，给定的装饰器和浮点数。但我们将更深入地探讨Hypothesis。
- en: uses what we call strategies to describe your data。 Similar libraries and other
    languages call。 these generators but of course naming things is hard and Python
    already has generators which。 are a completely different sort of thing。 So we
    had to call them something else。 And there are a couple of different kinds of
    strategies that you're going to see a lot of。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们所称的策略来描述你的数据。类似的库和其他语言称这些为生成器，但当然命名是困难的，而Python已经有生成器，它们是完全不同的东西。因此我们必须给它们取个其他的名字。你将看到几种不同类型的策略。
- en: The first is just strategies for what we call scalar values。 Things like， none，
    bullions。 numbers of various kinds， strings， date times， times zones， whatever
    you want。 Then we've got strategies for collections whether that's lists or dictionaries
    or topples and so on。 We can modify strategies with map or filter and look， we're
    going to get through all of this on。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是我们所称的标量值策略。像`None`、布尔值、各种类型的数字、字符串、日期时间、时区等等。然后我们有集合的策略，无论是列表、字典还是元组等等。我们可以通过映射或过滤来修改策略，看，我们将会涵盖所有这些内容。
- en: subsequent slides。 So I won't weed this one out for you。 I'm also going to show
    you some。 recipes that I hope are useful。 And then we'll end up with some exercises
    which take us through。 to the break at 10。30 which just focus on generating useful
    data rather than actually using them in。 order to test code。 So for those scalar
    values， the bottom line is like if you can describe what it。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 后续幻灯片。所以我不会为你挑出这个。我还会给你展示一些我希望有用的配方。然后我们将以一些练习结束，这些练习将带我们到10:30的休息，专注于生成有用的数据，而不是实际使用它们来测试代码。对于这些标量值，关键是，如果你能描述它。
- en: is that you want， you can generate it using hypothesis。 So we have built-in
    strategies for。 none and for bullions， for numbers。 Numbers all have a mid value
    and a max value argument which。 are optional。 So you can say not just give me
    any integer but give me any positive integer or give。 me a number between one
    and 10。 For strings， like all collections that have a minimum and a maximum。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要，可以使用假设生成它。所以我们有针对“无”和布尔值、数字的内置策略。所有数字都有一个中间值和一个最大值参数，这是可选的。所以你可以说，不仅仅是给我任何整数，而是给我任何正整数，或者给我一个在1到10之间的数字。对于字符串，像所有集合一样，它们都有最小值和最大值。
- en: size that you can set。 So you say I don't want the empty string or I want strings
    but only up to。 six characters because that's all my database supports。 You can
    also for some of these specify。 for example， which characters are valid。 So you
    only want ASCII characters or you'll all add。 Unicode characters or even match
    by regular expression。 Dates， times and time zones， I think。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置大小。所以你可以说我不想要空字符串，或者我想要字符串，但最多只能有六个字符，因为这就是我的数据库支持的。对于其中一些，你还可以指定有效的字符。例如，你只想要ASCII字符，或者你会添加Unicode字符，甚至通过正则表达式进行匹配。日期、时间和时区，我认为。
- en: speak for themselves and time zones will give you plenty of trouble when you're
    testing them。 And there's a bunch of other stuff which you'll find in a documentation
    when you eventually need it。 So here's a very simple test。 I mentioned before
    that does not raise an exception is a perfectly。 fine property to test。 And so
    in this test we're saying given any binary that is a bytes object。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 结果会不言而喻，而时区在测试时会给你带来很多麻烦。此外，还有很多其他内容，你在最终需要时会在文档中找到。因此，这里有一个非常简单的测试。我之前提到过，不会引发异常是一个完全合理的属性来测试。因此，在这个测试中，我们假设给定任何二进制数据，即字节对象。
- en: a binary string， if we call the is binary string function from the binary or
    not package。 it doesn't， crash。 This seems kind of like a reasonable test to me
    but it's shockingly effective。 And sure enough when we first wrote this a few
    years ago， it crashed with a Unicode decoder。 This has subsequently been fixed。
    There's no point testing open source code if you don't tell them。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从“二进制或不是”包中调用是二进制字符串函数，它不会崩溃。这似乎是一个合理的测试，但效果却惊人有效。果然，当我们几年前第一次编写这个时，它在使用Unicode解码器时崩溃了。这个问题后来已得到修复。如果不告诉他们，就没有必要测试开源代码。
- en: about the bugs and most people fix them very promptly。 But internally binary
    or not used a。 library or char deck which detects character encodings。 And in
    particular it will give you a。 dictionary with a couple of possibilities and then
    a confidence that it assigns to each possibility。 And it turns out that for some
    encodings it just checks a few bytes at the start of the string to。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人会很快修复它们。但是在内部，“二进制或不是”使用了一个库或字符检测工具，能够检测字符编码。特别是，它会给你一个字典，里面有几个可能性，以及分配给每个可能性的置信度。结果是，对于某些编码，它只检查字符串开头的几个字节。
- en: see whether the magic bytes indicating that it's in a particular encoding。 And
    then reports 100%。 confidence without any implication that you actually can decode
    that encoding。 But the binary or not， developers I think made the quite reasonable
    mistake in thinking that if they were told with。 100% confidence that a string
    in a particular encoding you could just call decode and didn't need。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 查看指示其处于特定编码的魔法字节。然后报告100%的置信度，但并不暗示你实际上可以解码该编码。不过在“二进制或不是”中，开发者们认为如果被告知某个字符串的特定编码的置信度为100%，就可以调用解码，而不需要考虑。
- en: to handle any error。 And so what we found here was that there wasn't so much
    that anybody had made。 a coding error as had misunderstood the semantics of the
    function。 So is this a bug？ I guess it's a。 bug and something crashes but it's
    not like we had a clear typo somewhere。 Let's look at the other。 one。 Mercurial
    is a version control system much like Git which had two and from UTF-8 binary
    encoding。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 处理任何错误。因此，我们发现这里并不是因为有人犯了编码错误，而是误解了函数的语义。那么这是个bug吗？我想这是个bug，并且某些东西崩溃了，但并不像我们在某处有明显的错字。让我们看看另一个。Mercurial是一个类似于Git的版本控制系统，具有两个和从UTF-8二进制编码。
- en: And so an obvious property we could test there is that given any binary string
    if we encoded two。 UTF-8 and then back from UTF-8 we should get the same string
    back。 And if we have。 from a two UTF-8 thing that should handle any binary string
    so this test should work。 it crashed too。 I'm not sure if the moral of this story
    should be hypothesis is great or。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个显而易见的属性是，给定任何二进制字符串，如果我们编码为两个UTF-8，然后再从UTF-8解码，我们应该得到相同的字符串。如果我们从两个UTF-8的东西开始，那应该能处理任何二进制字符串，因此这个测试应该有效，但它也崩溃了。我不确定这个故事的道德应该是假设很棒还是。
- en: Unicode is really hard but some combination of those two I think is there。 It
    of course has also。 been fixed。 And then another great one。 In the Python standard
    library we have date times and the。 date you tell package can parse date times。
    And so this is saying that if we have a date time and we。 format it as an ISO
    8601 formatted string so that's four digit year dash two digit month dash two。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode确实很难，但我认为这两者的某种组合是存在的。当然，它也已被修复。还有另一个很棒的。在Python标准库中，我们有日期时间，而dateutil包可以解析日期时间。因此，这意味着如果我们有一个日期时间，并将其格式化为ISO
    8601格式的字符串，即四位年份减去两位月份减去两。
- en: digit day a T and then the time then we should be able to parse that string
    and if we reformat the。 date time we get we should get the same string again。
    And it's just easy to start by generating a。 date time and formatting it than
    it is to start by constructing a string which exactly represents。 a valid date
    time format。 It turned out that this failed。 Paul Genssel is a friend of mine
    and it。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: digit day a T，然后时间，然后我们应该能够解析该字符串，如果我们重新格式化日期时间，我们应该得到同样的字符串。开始生成一个日期时间并格式化它比从头开始构造一个完全符合有效日期时间格式的字符串要简单得多。结果证明这失败了。保罗·根塞尔是我的朋友。
- en: turns out that this parser function failed if and only if you had a one digit
    year and the second。 equal to the year value。 Okay so it would swap the year with
    the month。 I don't think this would ever have been caught without hypothesis。
    I will admit I'm also not sure who this would have hurt if it had never been caught。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明这个解析函数只有在年份是一位数且第二个等于年份值时才会失败。好吧，它会将年份与月份交换。我认为如果没有假设，这一点永远不会被发现。我承认我也不确定如果没有被发现这会对谁造成伤害。
- en: But I think it is illustrative of the kind of thing that you can find with relatively
    simple tests。 So the point of this is not so much to tell you this bug is really
    important as very simple tests。 can find bugs that you never would have found
    by testing manually。 So having got the simplest。 possible data out of the way
    let's talk about collections。 Yep。 [inaudible]。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但我认为它说明了你可以通过相对简单的测试找到的那种事情。因此，这一点并不是要告诉你这个bug真的很重要，而是非常简单的测试可以发现你通过手动测试永远不会发现的bug。因此，处理完尽可能简单的数据后，让我们谈谈集合。是的。[听不清]。
- en: So for each of these we'll get to this under the practicality section but there's
    just a setting for。 how many you want。 By default it's about 100 random examples
    because that's a good trade off。 between like speed for unit tests but also reasonably
    rigorous。 So the list strategy as we saw way。 back in our sorting example the
    list strategy just takes a strategy for the elements of the list。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于每一个，我们会在实用性部分中讨论这一点，但有一个设置用于你想要多少个。默认情况下大约是100个随机示例，因为这是速度与单元测试之间的良好折中，同时也相对严谨。如我们在排序示例中看到的，列表策略只是为列表中的元素采取一种策略。
- en: That one's mandatory and then optionally you can give it size bounds and also
    specify whether。 you want to be unique and you can also give it a function by
    which it should be unique。 So for。 example allow any string and none of them should
    be the same as each other when they lower case。 You can also turn this into dictionaries，
    sets， iterables and so on and for those common cases。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 那个是强制性的，然后你可以选择性地给它大小范围，还可以指定是否希望它是唯一的，你也可以提供一个函数来确保它是唯一的。例如，允许任何字符串，且它们的低写形式都不相同。你还可以将其转换为字典、集合、可迭代对象等等，对于这些常见情况。
- en: we actually ship strategies for those directly。 The tuple strategy is a little
    different。 It's for a fixed length tuple where you provide a separate strategy
    for each index of the tuple。 So if you want a tuple for example of an integer
    and integer and a string you would use the。 tuple strategy and you would call
    it tuples integers integers text。 And there you are。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上会直接提供这些策略。元组策略有点不同。它是针对固定长度的元组，你需要为元组的每个索引提供一个单独的策略。所以如果你想要一个包含整数、整数和字符串的元组，你就会使用这个元组策略，并称之为`tuples
    integers integers text`。就这样。
- en: If you want a， variable length tuple you actually start with a list strategy
    and then turn it into a tuple later。 which we'll see on the next slide。 And then
    fixed dictionaries is just like tuples except also with。 dictionary keys。 So you
    can say I want a dictionary which always has the key A which should be an integer。
    and may or may not have the key B which is a string for example。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个可变长度的元组，你实际上是从一个列表策略开始的，然后再将其转换为元组，这将在下一个幻灯片中看到。然后固定字典就像元组，只是也有字典键。因此，你可以说我想要一个总是包含键A的字典，键A应该是一个整数，并且可能有或没有键B，键B是一个字符串，例如。
- en: So here's another pretty simple test。 We're saying given lists of floating point
    numbers。 with at least one element in them because you can't take the minimum
    of an empty list。 you just get a crash。 Then the minimum of the list should be
    less than or equal to the mean that。 is the average of the list which is then
    in turn less than or equal to the maximum of the list。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是另一个相当简单的测试。我们说给定至少包含一个元素的浮点数列表，因为你不能对一个空列表取最小值，否则会崩溃。然后，列表的最小值应该小于或等于平均值，也就是列表的平均数，接着又小于或等于列表的最大值。
- en: Will this test pass？ You're getting suspicious when I ask this question I like
    that。 [ Inaudible ]。 Yeah that's the extension。 If you think it's going to fail
    you've got to tell me why it's going to fail。 This is where I tell you that hypothesis
    is a great educational tool because it'll teach you。 about how Python works。 Pretty
    much。 Specifically it fails quickly when we get an overflow error。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试会通过吗？当我问这个问题时你开始怀疑了，我喜欢这样。[听不清]。是的，这是扩展。如果你认为它会失败，你必须告诉我为什么它会失败。这就是我告诉你假设是一个很好的教育工具，因为它会教你如何理解Python。基本上。特别是当我们遇到溢出错误时，它会快速失败。
- en: because internally mean might be implemented by adding up your list of floats
    and then dividing。 my length。 And in this case the result of dividing was too
    large to be represented as a floating point number。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在内部，平均值可能是通过将你的浮点数列表相加然后再除以长度来实现的。在这种情况下，除法的结果太大，无法表示为浮点数。
- en: '![](img/8a2a8090e0ca721c225298b1c97c51f4_12.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a2a8090e0ca721c225298b1c97c51f4_12.png)'
- en: So when I spoke about turning lists into tuples what I meant was using the map
    strategy。 So the map strategy you pass it any callable it could be a lambda it
    could be a function it。 could even be a class like the tuple class and it gives
    you a strategy which consists of getting。 a value from the earlier strategy calling
    that callable on it and then giving you the result。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当我谈到将列表转换为元组时，我指的是使用映射策略。映射策略你可以传入任何可调用对象，它可以是一个lambda，也可以是一个函数，甚至可以是像元组类这样的类，它给你一个策略，这个策略包括从早期策略中获取一个值，对它调用那个可调用对象，然后给你结果。
- en: So if you have lists of integers dot map tuple this will generate a variable
    length list of numbers。 and then call tuple on it to give you a variable length
    tuple。 Pretty simple or in the example here if you have integers and then you
    map。 str on it you will get maybe a minus sign and then a bunch of digits but
    as a string。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你有整数列表，`.map tuple`将生成一个可变长度的数字列表。然后在其上调用`tuple`可以得到一个可变长度的元组。相当简单，或者在这里的例子中，如果你有整数，然后你对它应用`str`，你可能会得到一个负号和一串数字，但作为字符串。
- en: Filter is kind of the corresponding strategy。 Filter is for where you have like
    some rare。 things that can be generated that you don't actually want。 So you just
    supply a function and if it。 returns a falsey value hypothesis will just like
    get another value for you behind the scenes。 So this is really useful for example
    if you want any number but not zero because you would have a。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器是相应的策略。过滤器适用于那些可以生成但你不想要的稀有东西。所以你只需提供一个函数，如果它返回一个假值，假设将在幕后为你获取另一个值。这在你想要任何数字但不想要零的情况下非常有用，因为你会有一个。
- en: zero division error for example。 That said if more than like 20 percent of your
    examples are。 being rejected this does start to have performance implications
    because you are in fact generating。 the earlier thing and then just throwing it
    away behind the scenes。 So if you reject more than。 like 80 or 90 percent hypothesis
    will actually start error out toward you like hey hey that filter。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如零除错误。也就是说，如果你被拒绝的示例超过20%，这开始对性能产生影响，因为你实际上是在生成早期的东西，然后在幕后扔掉它。因此，如果你拒绝超过80%或90%，假设实际上会开始向你报错，比如“嘿，嘿，那过滤器”。
- en: is a little strict。 See if you can find a way to use map for example to construct
    something which。 is usually valid。 So if you want a tuple of two integers in ascending
    order you've got kind of。 two ways to do it。 The way with filter is just to supply
    something like a lambda which just checks。 that it's what you want。 That the first
    element is less than or equal to the second element。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有点严格。看看你是否可以找到一种方法，比如使用map来构建通常有效的东西。如果你想要两个整数按升序排列的元组，你有两种方法。使用filter的方法是提供一个像lambda那样的东西，它只检查你想要的内容。第一个元素是否小于或等于第二个元素。
- en: The way with map would be to sort it and then turn it back into a tuple because
    sort of returns a list。 Does this make sense to people？ All right we're getting
    into the special strategies here。 Just is for where you have a value but you，
    want a strategy。 Just as a special strategy which only ever returns the particular
    argument that you， gave it。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用map的方法是先对其排序，然后再将其转换回元组，因为sort返回一个列表。这对大家来说有意义吗？好吧，我们正在进入特殊策略。just是指你有一个值，但你希望一个策略。just作为一种特殊策略，只返回你给出的特定参数。
- en: So for example if you ask for date times and you always want them to be in the
    UTC time zone。 which is nice for machine related things you can say time zones
    is just UTC。 It kind of reads。 like English。 Sampled from on the other hand it's
    where you want one of some particular range of。 possibilities so you're okay with
    having an inner join or an outer join but it has to be one of those。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你请求日期时间，并且总希望它们在UTC时区，这对与机器相关的事情很有帮助，你可以说时区就是UTC。它听起来像英语。另一方面，样本是你希望某个特定范围内的可能性，所以你可以接受内部连接或外部连接，但它必须是其中之一。
- en: Sampled from also works really well with the numbs。 If you have like a flag
    and。 where you can have read， write， execute or read， write or read， execute or
    read， write， execute。 Sampled from or behind the scenes just create all those
    combinations for you。 Another thing that we saw a while ago not sorted example
    was one of which is where you have two。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Sampled from也与numbs很好地配合。如果你有一个标志，可以有读、写、执行，或读、写，或读、执行，或读、写、执行。Sampled from在幕后会为你创建所有这些组合。我们不久前看到的另一件事是未排序的示例是两个。
- en: or more possible strategies and you would like a value of any one of them。 So
    behind the scenes if。 you have one of say integers or strings， hypothesis will
    choose what strategy to draw from and then。 get an example from that for you。
    Nothing is a little stranger it's kind of the empty set of。 strategies。 So if
    you have nothing the lists of nothing that will only ever generate the empty list。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更可能的策略，并且你希望其中任何一个的值。所以在幕后，如果你有一个比如整数或字符串，假设会选择哪个策略来提取，然后为你获取一个例子。没有的情况有点奇怪，这种策略的空集合。如果你有什么也没有，那么这个空列表只会生成空列表。
- en: If you have one of integers or nothing it will just always generate integers
    because there's。 nothing else to generate。 Thinking of strategies as sets of values
    kind of where you define your。 set as a construction is pretty useful except that
    you can't subtract them or take the intersection。 of complement and that's because
    if somebody has map called map on their strategy for example。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个整数或没有，它将始终生成整数，因为没有其他内容可以生成。将策略视为值的集合，相当于你定义的集合作为构造是非常有用的，除了你不能从中减去或取交集或补集，这也是因为如果有人对他们的策略调用了映射。
- en: map is allowed to have whatever side effects you like。 So we have a Django plugin
    which will。 ensure that the user model it generates is in the database for you
    and it's not quite clear what it。 would mean to subtract that strategy from a
    like we generating user strategy and take it out of the。 database when it wasn't
    there to start with。 Who here has ever written a custom class？
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 映射可以有你喜欢的任何副作用。因此我们有一个Django插件，它会确保生成的用户模型在数据库中，而不太清楚从生成用户策略中减去那个策略会意味着什么，以及当它一开始就不在数据库中时会怎么处理。这里有谁写过自定义类？
- en: Yeah you might want to generate some with hypothesis and so builds is the way
    to do that。 You give it， your class instance or for that minute anything else
    you can call and then strategies for the。 positional and keyword arguments。 That
    works pretty much how you would expect it。 Draws those。 positional keyword arguments
    from strategies to values and then calls your thinking returns。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你可能想用假设生成一些，所以构建就是实现这一点的方法。你提供你的类实例，或者在那一刻你可以调用的任何其他内容，然后是位置参数和关键字参数的策略。这几乎就是你所期望的那样工作。它从策略中提取那些位置和关键字参数，然后调用你的思维返回。
- en: whatever the return value is。 We'll cover builds in more detail later because
    it's got some nice。 type in front stuff as well。 If you have recursive data that
    also basically just works。 So on the bottom of the slide here I've defined my
    favorite JSON strategy which says JSON is。 defined recursively。 The base case
    is you can have none true or false a number or a string。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 无论返回值是什么。我们稍后会更详细地探讨构建，因为它有一些很不错的前置类型。如果你有递归数据，这基本上也能正常工作。因此在幻灯片底部，我定义了我最喜欢的JSON策略，它说JSON是递归定义的。基本情况是你可以没有、`true`或`false`，一个数字或一个字符串。
- en: Or you can have a list of JSON values or you can have a dictionary where the
    keys are strings。 and the values are JSON。 That's just the definition of JSON
    and that's how you write it with hypothesis。 You have a recursive strategy which
    is non-bullions or floats or strings and the extension is lists of。 that or dictionaries
    of text to that。 So that can generate any possible valid JSON。 In fact。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以有一个JSON值的列表，或者你可以有一个字典，其中键是字符串，值是JSON。这就是JSON的定义，这也是你如何用假设来写它。你有一个递归策略，即非布尔值、浮点数或字符串，扩展是这些的列表或文本到这些的字典。因此，这可以生成任何可能的有效JSON。事实上。
- en: because we haven't specified anything about NAND we might even go a little beyond
    the JSON spec。 If you have type annotations on things it's kind of nice if you
    don't have to retype out all the。 things that you've already typed annotated。
    So a hypothesis will actually read those type。 annotations for you and work out
    how to generate things from them。 So there's a from type strategy。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有指定任何关于NAND的内容，我们甚至可能会稍微超出JSON规范。如果你在某些东西上有类型注解，如果你不必重新输入所有已类型注解的内容，那就相当不错。因此假设实际上会为你读取这些类型注解，并计算如何从中生成东西。所以这里有一个来自类型的策略。
- en: where you can just hand it a type and it will give you a strategy for instances
    of that type。 And it's also integrated with builds。 So if your class has four
    arguments that it requires and。 you type annotated them you can just say build
    me an instance of this and it will go off and。 work out how to construct everything
    that your class needs in order to be built。 It's pretty cheap。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以简单地提供一个类型，它将为该类型的实例提供策略。它也与构建集成。因此，如果你的类需要四个参数并且你进行了类型注解，你只需说构建我这个的实例，它就会去计算构建你类所需的一切。这是相当便宜的。
- en: It's all memorized。 I certainly wouldn't think about the performance cost of
    it。 Oh no this is really designed as a time saver。 So it's designed to make your
    code a little more。 elegant but also it should be possible to extend it incrementally
    by hand。 So for example you can。 let builds infer three out of your four arguments
    and say oh age is an integer but really it better。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是记住的。我肯定不会考虑它的性能成本。哦不，这实际上是为了节省时间而设计的。因此，它旨在使你的代码更加优雅，但也应该能够手动逐步扩展。例如，你可以让构建推断出你四个参数中的三个，并说哦，年龄是一个整数，但实际上更好。
- en: be between say zero and 120。 And if you have a custom class where you have this
    kind of constraint。 you can also tell hypothesis about that so that everywhere
    else in your code base it will just。 be inferred with your particular strategy
    that you designed。 There are a couple of other things。 that work by inference。
    I mentioned the regular expression support。 If you want strings matching。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 介于零和120之间。如果你有一个自定义类，并且有这种约束，你也可以告诉假设关于这一点，以便在代码库的其他地方，它将根据你设计的特定策略进行推断。还有一些其他的东西，通过推断来工作。我提到过正则表达式的支持。如果你想要匹配某些字符串。
- en: some regular expression you can just tell hypothesis here's the regex pattern
    give me strings that match。 if you're using NumPy we've got from data type and
    some shape inference so you can pretty much。 just say here is my function signature
    throw a raise at it for me and if you're using Django。 there's from field and
    from model。 I actually like this as a general design pattern but a little bit。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 某些正则表达式，你可以告诉假设，给我匹配的字符串的正则表达式模式。如果你使用NumPy，我们从数据类型和某种形状推断中得到了支持，因此你几乎可以说，这是我的函数签名，为我抛出一个异常，如果你使用Django，则有字段和模型。我实际上喜欢这个作为一个通用设计模式，但有一点。
- en: of advice here while it is a useful design pattern which can save time and make
    testing a little easier。 to extend it into great。 The two important things are
    first you want to err on the side of guessing。 something very general。 You don't
    want to guess for example that an integer is always a positive。 integer or a float
    is always a finite float and excluding it because if you do that you've just。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些建议，尽管这是一个有用的设计模式，可以节省时间并使测试变得稍微容易一些。要将其扩展得很好，两个重要的事情是，首先你要倾向于猜测一些非常一般的内容。你不想猜测，例如，一个整数总是正整数，或者浮点数总是有限的浮点数，并因此将其排除，因为如果这样做，你就会。
- en: ruled out your tests ever discovering something using those edge cases。 So I
    tend to think that。 anything which we guess for someone else should be very general
    and if they want something more。 specific or restricted they should be responsible
    for writing that out explicitly。 And the second is it's kind of an awful user
    experience if you get most of the way through。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 排除了你的测试在使用那些边缘案例时发现的东西。所以我倾向于认为，任何我们为他人猜测的东西都应该是非常一般的，如果他们想要更具体或更限制的内容，他们应该负责明确写出来。第二，如果你走了大半天却发现大部分工作已经完成，这种用户体验实在糟糕。
- en: and then you realize that you just want to tweak this one argument like three
    layers down。 and to do so you suddenly have to throw out all of the ice inference
    and write it all out by hand。 In hypothesis we try to avoid that you should always
    be able to only specify the things you want to。 specify and let hypothesis get
    guess everything else for you。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你意识到你只是想调整这个参数，比如在三层深处。为了做到这一点，你突然不得不扔掉所有的推断，全部手动写出来。在假设中，我们努力避免这种情况，你应该始终能够仅指定你想要的内容，让假设为你猜测其他一切。
- en: '![](img/8a2a8090e0ca721c225298b1c97c51f4_14.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a2a8090e0ca721c225298b1c97c51f4_14.png)'
- en: This example is a somewhat more complicated test so we have some kind of Django
    model for a project。 maybe we're re-implemented juror for some reason and we have
    a user model and it's going to say。 like well give it any project with a collaborator
    limit somewhere between zero and 20 people。 and any list of up to 20 users if
    we just add each of those users in turn well if we're at。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是一个稍微复杂一点的测试，因此我们有某种Django模型用于一个项目。也许我们出于某种原因重新实现了陪审员，我们有一个用户模型，它会说，给任何项目一个协作限制，介于零到20人之间。并且任何最多包含20个用户的列表，如果我们依次添加每个用户，如果我们在。
- en: the collaboration limit then we expect to get a limit reached exception and
    that the user we just。 tried to add will not actually be on the project after
    that。 It'd be a little embarrassing if our。 validation raised an error after adding
    the user to the project over the limit and if we're not at。 the limit we should
    just be able to add add the user and then check that they're on the project。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们期望获得一个限制达到的异常，并且我们刚刚尝试添加的用户实际上不会在项目中。如果我们的验证在将用户添加到超出限制的项目后引发错误，那将有点尴尬；如果我们不在限制之内，我们应该可以添加用户，然后检查他们是否在项目中。
- en: This one will fail because we forgot to specify that users must be unique。 and
    so here we've got collaborators a at a。com and a at a。com。 and so while we've
    raised an error that we were at our collaborator limit the user we tried to add。
    is already on the project。 This probably isn't a bug but it does make me think
    maybe we want a。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个将失败，因为我们忘记指定用户必须是唯一的。在这里我们有collaborators a@a.com和a@a.com。所以尽管我们引发了一个错误，说明我们达到了协作者限制，但我们尝试添加的用户已经在项目中。这可能不是一个bug，但确实让我想到，或许我们想要一个。
- en: different flow if you're trying to add a user who's already on the project。
    So I'm like is this a bug？ I don't know but I'm glad I found it。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的流程，如果你尝试添加的用户已经在项目中。所以我在想这是个bug吗？我不知道，但我很高兴我发现了它。
- en: '![](img/8a2a8090e0ca721c225298b1c97c51f4_16.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a2a8090e0ca721c225298b1c97c51f4_16.png)'
- en: Racing through who feels that they're still with me at this point？ Most people
    okay。 If you have data that has internal dependencies like the example where we
    saw with。 tuples in order or things like you want a list and then an index into
    the list or a string and then。 a slice out of the string。 There are a couple of
    ways to do that。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 快速询问一下，谁觉得自己在这个时候仍然跟得上我？大多数人还好。如果你的数据有内部依赖关系，比如我们看到的示例，元组的顺序或你想要一个列表然后索引到列表中，或者一个字符串然后从字符串中切片。有几种方法可以做到这一点。
- en: Composite is the one that I recommend。 Composite is as shown here it gives you
    this magic。 first argument draw which you can use inside the function to draw
    a value from the strategy。 So you have a location strategy and you pick a factory
    from the available locations。 and then you pick a power level that's limited by
    something about the factory。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐复合。复合如这里所示，它为你提供这个魔法的第一个参数draw，你可以在函数内部使用它从策略中绘制一个值。因此，你有一个位置策略，你从可用位置中选择一个工厂，然后你选择一个受工厂某些限制的功率级别。
- en: I kind of like what I call the inner composite pattern because it lets you do
    all your expensive。 validation once instead of every time you draw a value。 But
    in this case we should probably also。 consider can we just literally have a function
    that returns a strategy？ Python is kind of nice。 like this you can just have functions
    which return things。 And this is generally a nice testing。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢我称之为内部复合模式的东西，因为它让你一次性做所有昂贵的验证，而不是每次绘制值时都要做。但是在这种情况下，我们可能还应该考虑，是否可以仅仅有一个返回策略的函数？Python在这方面挺不错的，你可以直接有返回值的函数。这通常是一个不错的测试。
- en: pattern you can have a utils file somewhere where you define a whole bunch of
    helpers specific to。 your code base or project and then just call them in your
    tests。 Kind of like pytest fixtures but。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在某个地方有一个工具文件，在那里你定义一堆特定于你代码库或项目的助手，然后在测试中调用它们。就像pytest固定装置那样，但。
- en: '![](img/8a2a8090e0ca721c225298b1c97c51f4_18.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a2a8090e0ca721c225298b1c97c51f4_18.png)'
- en: more explicit。 Data and miniscope over it's kind of like composite but you can
    draw values inside。 your test。 Very very flexible and powerful。 The downside is
    it's very very flexible and powerful。 If you can use composite prefer to do that
    instead。 Last bit of this one before we jump into the。 exercises is just where
    to look for these strategies。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 更明确。数据和微型作用域有点像复合，但你可以在其中绘制值。你的测试。非常灵活且强大。缺点是它非常灵活且强大。如果可以使用复合，建议优先这样做。在我们跳入练习之前，这一点是最后要注意的地方。
- en: So the first argument is the hypothesis dot strategies。 some module from hypothesis
    import strategies。 And this is all the core things which don't have。 dependencies
    outside the standard library。 Or in a few cases like the time zone strategy that。
    was added to the standard library in Python 3。9。 So if you're on earlier versions
    hypothesis will。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所以第一个参数是hypothesis的dot策略。来自hypothesis的一些模块导入策略。这是所有核心内容，没有超出标准库的依赖关系。或者在少数情况下，比如时区策略，它在Python
    3.9中添加到标准库中。所以如果你在早期版本，hypothesis将。
- en: require the zone info backboard and we'll install that automatically for you。
    There's also some。 extra strategies in hypothesis dot extra dot Django for example
    where we don't want to force。 everybody to install lumpy and pandas and Django
    just to use hypothesis but if you already have。 them installed you can just import
    the relevant support。 And then there's also a pile of third。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 需要区块信息的背板，我们会自动为您安装。这里还有一些额外的策略，比如在hypothesis.extra.Django中，我们并不想强迫每个人都安装lumpy、pandas和Django来使用hypothesis，但如果您已经安装了这些，可以直接导入相关支持。还有一堆第三方扩展。
- en: party extensions which I won't get into but there's a few dozen of them these
    days。 So let's jump into the exercises。 For this section we're going to go through
    to 10。30。 which is 45 minutes or so of exercises。 Just the describing data notebook。
    So the exercises in the。 repo we have four parts。 The first part I'm not actually
    planning to go through today but they're。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入讨论的派对扩展，现在有好几十个。因此，让我们开始练习。在这一部分，我们将进行到10:30，大约45分钟的练习。只需描述数据的笔记本。所以在这个库中，练习分为四个部分。第一部分我今天并不打算讨论，但它们是。
- en: there if you want to run through them later。 This was partly because for online
    tutorials。 I wasn't able to look over people's shoulder and help them so it was
    used for that extra material。 So we're looking at notebook two on the describing
    data one you should just be able to click the。 my button link and have it open
    there。 And the idea here is really to teach you a way of thinking。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想稍后运行它们。这部分是因为在线教程时，我无法在旁边帮助人，所以它用于额外的材料。因此，我们看的是描述数据的第二个笔记本，您应该能够点击我的按钮链接并在那里打开。这里的想法实际上是教您一种思维方式。
- en: about strategies and how to compose them。 That's what I think of them as a duct
    tape mindset right。 like if you can't fix it with duct tape the answer is just
    more duct tape。 If you can't。 generate the data with a strategy the answer is
    more strategies。 So without further ado let's jump。 into the exercises。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 关于策略和如何组合它们。我把它们视为一种胶带思维方式，如果您不能用胶带修复它，答案就是更多的胶带。如果您不能通过策略生成数据，答案就是更多的策略。所以事不宜迟，让我们开始练习。
- en: '![](img/8a2a8090e0ca721c225298b1c97c51f4_20.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a2a8090e0ca721c225298b1c97c51f4_20.png)'
- en: '[ Pause ]。'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[暂停]。'
- en: '![](img/8a2a8090e0ca721c225298b1c97c51f4_22.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a2a8090e0ca721c225298b1c97c51f4_22.png)'
- en: All right welcome back everybody。 I at least am feeling relaxed and refreshed。
    I stood up for a while hopefully the rest of you are ready for part three as well。
    This is the bit where I do a live demo。 What's the first rule of live demos？
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，欢迎大家回来。我至少感到放松和焕然一新。我站了一会儿，希望你们其他人也准备好进行第三部分。这是我进行现场演示的部分。现场演示的第一法则是什么？
- en: '![](img/8a2a8090e0ca721c225298b1c97c51f4_24.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a2a8090e0ca721c225298b1c97c51f4_24.png)'
- en: Yeah well we'll see if we're following the laws of live demos here。 So far what
    I've shown you is hypothesis as a tool to help you write better tests。 But when
    I came to PyCon a few years ago I bumped into a lot of people in the hallways。
    and some of them would say oh hypothesis like I use hypothesis that seems kind
    of cool。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们看看是否遵循现场演示的法则。到目前为止，我展示给您的hypothesis是一个帮助您编写更好测试的工具。但几年前我来到PyCon时，在走廊上遇到了很多人，其中一些人会说，哦，hypothesis，我用hypothesis，这似乎很酷。
- en: And I would get really excited and be like that's great。 What do you use it
    for？
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我会非常兴奋，并问：那这有什么用？
- en: They'd say oh well I wasn't quite sure how to use it on my code so don't use
    it。 And as everybody。 knows every good programmer knows every social problem has
    a technical solution。 That's a lie。 But the technical solution in this case is
    to have hypothesis actually， write test code for you。 So if you've installed hypothesis
    locally， which I don't seem to have done。 First law of live demos。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 他们会说，哦，我不太确定如何在我的代码中使用它，所以就不使用。大家都知道，每个好程序员都知道每个社会问题都有技术解决方案。这是个谎言。但在这种情况下，技术解决方案是让hypothesis实际上为您编写测试代码。所以如果您在本地安装了hypothesis，而我似乎还没有安装。这是现场演示的第一法则。
- en: I think I didn't activate the virtual environment。 If you install hypothesis
    add activate your virtual environment。 Did I just not press enter enough times？
    Okay let's ditch the scripted part and I'm going to do it completely live and
    try to remember what。 I was going to demonstrate。 Talk among yourselves for a
    minute。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我没有激活虚拟环境。如果您安装hypothesis，请激活您的虚拟环境。我是不是没有按足够多次回车？好吧，我们不按脚本部分，我将完全现场演示，试着记住我想展示的内容。请稍作讨论。
- en: '![](img/8a2a8090e0ca721c225298b1c97c51f4_26.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: Excellent we got here and hopefully subsequent runs will be faster。 So the hypothesis
    write command will write tests for you。 For example we might ask。 hypothesis to
    write it a test for the sorted built-in。 I'm just suspecting that my development
    version of hypothesis is broken so let's go。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: I swear my laptop isn't this slow。 Most of the time。 I shouldn't have tempted
    the demo gods that's my problem。 Okay let's just pretend that we have a live demo
    of the hypothesis go strider。 If you have a terminal or a notebook open you can
    hypothesis write various things。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: And you will get test functions out。 I'll come back to the demo once we've broken
    for exercises。 fix it and then show you after that。 So common test tactics。 If
    we had seen the ghost rider。 we would have seen that hypothesis can produce some
    of these tests for you。 I think of these as common properties that you might want
    to test。 That is properties which are。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: common to many different types or pieces of code that you might be working with。
    And then somewhat more situational but still useful。 So the common ones are what
    I call the。 fuzzing or just the doesn't raise an exception property。 In almost
    all cases we know that our。 code shouldn't raise an exception or maybe it should
    raise an exception sometimes but only。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: of a particular type。 That your request might have a not found error but it
    shouldn't have other。 kinds of errors。 There are also round trip properties。 For
    example if you save your data to the database。 and then you load it back in you
    expect to always have the same data。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Or if you serialize it and then， deserialize it。 You have equivalent functions
    which we saw in our first sorting example and then。 there are metamorphic properties
    which I'll talk to some of you later because they're particularly。 powerful but
    also quite domain specific。 Then there's situational ones like just checking that
    the。 output is reasonable。 That's what we ended up doing with the sorting example。
    There's various。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: mathematical properties and then there's stateful tests。 So I'll say again just
    calling your code。 works embarrassingly well because hypothesis will think of
    the edge cases that you didn't think of。 and therefore the test will find things
    that your ordinary tests haven't found yet。 Round trips。 Every codebase has them。
    If your codebase never loads or saves data or never reads or。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: writes anything you can replace your code with pass and you will have less bugs。
    And it will run。 very much faster。 This is what Haskell people call a pure function。
    Some round trips that your。 codebase is specifically likely to have save and load，
    encode， decode， send。 receive for anyone working， with networks， converting between
    data formats or sometimes logical inverses。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: For example if you， factorize something， multiplying the factors together should
    give you the original number。 So the reason I emphasize these is that especially
    the ones around loading and saving data are。 absolutely critical。 Being able to
    load and save data is the foundation of any application。 If you。 can't load or
    save data without messing it up you have fundamental problems。 But those data
    formats。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: also tend to be quite complicated。 They represent every edge case that your
    codebase can represent。 and therefore they are more likely to have weird edge
    case bugs than much of your code。 And the last thing is that especially input
    and output， learning and saving stuff。 tends to cross many abstraction layers。
    Often you will have a network involved。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: you will have a file， system， you will have operating system issues。 you will
    have questions about what file name is， valid or different operating。 And testing
    these using something like hypothesis can turn up those， really weird rare bugs。
    And the last reason they are important is if you save data and you miss。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: save data this is very hard to recover from。 So you want to find the bugs early。
    So property test。 your round trips。 Equivalent functions。 Some people might say
    but really Zach， how many times am I。 going to implement the exact same function
    in my codebase？ And you might think that you are not。 repeating yourself so you
    only have one copy。 But you can have simple things like varying the number。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: of threads you run a function in。 Or the old version from before you refacted
    it。 You should do the same thing as the new version after you refacted it。 Or
    sometimes you might have。 that if you call functions in different orders you expect
    to get the same result。 So that is a kind。 of equivalence that you can create
    for yourself。 And in some cases you might have functions which are。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: equivalent only on a subset of inputs。 For example you wrote a more general
    version of the function。 but on the inputs that the old version also handled it
    should do the same thing。 And you can test that。 Another general property is just
    to validate the output。 Are your numbers in the expected range？ Are your probabilities
    between zero and one？
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Is your string non-empty or does it have a null， character in the middle？
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: I prefer to write these as assertions in my code so they can get checked， at
    runtime as well。 That is more of a debate specific thing though。 Some people really
    don't。 like their code crashing in production and they would rather have a mistake
    in the data than a。 downtime incident。 That is basically a decision for you。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: And then there are the mathematical properties。 This is actually what property-based
    testing is named for。 There are sort of algebraic properties， for mathematics
    such as item potants where if you call a function on the result of a function。
    call you get no further changes。 Commutivity so a plus b equals b plus a。 So security
    and so on。 Honestly these are pretty rare in Python code but if you have them
    you might as well test them。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是数学属性。这实际上就是基于属性的测试所命名的内容。有一些代数属性，例如不变性，如果你对一个函数的结果调用一个函数，你不会得到进一步的变化。可交换性，所以
    a + b 等于 b + a。因此，安全性等等。老实说，这在 Python 代码中相当少见，但如果你有它们，最好也测试一下。
- en: And what we call model-based or stateful testing。 Very much time on and I don't
    have any exercises on this but I wanted to make you aware that it。 exists。 With
    stateful testing you define a state machine。 So what actions are available at
    each。 time step and hypothesis will then randomly explore sequences of actions
    for you。 So this is。 really useful where you're testing something like a library
    API where you can set it up so。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 还有我们称之为基于模型或状态的测试。我花了很多时间在这上面，但我没有任何练习，我只是想让你知道它的存在。使用状态测试时，你定义一个状态机。在每个时间步骤可用的操作是什么，假设将随机探索操作序列。因此，这在测试库
    API 等时非常有用，你可以设置它。
- en: that hypothesis can kind of act like the user and make a whole bunch of calls
    and sequence using。 the results from those calls as inputs to subsequent calls。
    As you might imagine this is very powerful。 It's also a little tricky to teach
    so that's a separate workshop that I'm not teaching today。 Last kind of common
    set of patterns is what we call metamorphic relations。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个假设可以像用户一样执行一系列调用，使用这些调用的结果作为后续调用的输入。你可以想象这非常强大。教授这个有点棘手，所以这是一个我今天不教授的单独工作坊。最后一种常见的模式集是我们称之为变形关系。
- en: The name comes out of academia so I'm sorry about that。 But the idea of a metamorphic
    relation is that， property-based testing lets you write tests where you don't
    necessarily know what the correct result。 from this input should be。 So you can
    still check the properties。 Metamorphic testing is what you。 can do when you don't
    even know how to judge whether the result was correct。 So what you do is you。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名称源于学术界，抱歉。不过，变形关系的想法是，基于属性的测试允许你编写测试，而你不一定知道这个输入的正确结果是什么。因此，你仍然可以检查属性。变形测试就是当你甚至不知道如何判断结果是否正确时你可以做的事情。所以你可以这样做。
- en: generate an input and you get the result and then you change the input in some
    way that you know。 and get the corresponding result and you compare something
    about those results。 So for example。 for some financial calculation you might
    not know exactly what the result should be from some input。 but you do know that
    if you double all of your inputs you should double all of your outputs。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个输入，你会得到结果，然后以某种方式改变输入，确保你知道的事情。接着得到相应的结果，并对这些结果进行比较。所以，例如，对于某些财务计算，你可能不知道某个输入的结果应该是什么，但你知道如果你将所有输入翻倍，输出也应该翻倍。
- en: And so you can generate your input， get the result， double your inputs， get
    the result and。 check that it was doubled。 This is especially useful for scientific
    code and engineering code。 where often we're running some kind of simulation or
    analysis precisely because we don't know what。 the answer should be。 But we often
    do know something about the invariances or kind of higher level。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以生成输入，得到结果，翻倍输入，得到结果，然后检查结果是否翻倍。这在科学代码和工程代码中尤其有用，因为我们经常运行某种模拟或分析，正因为我们不知道答案应该是什么。但我们往往知道一些关于不变性或更高层次的信息。
- en: constraints like conservation of energy for example。 So some common ones here，
    it's very popular in。 compiler testing。 This is the diagram。 You generate a random
    program。 compile it and call it with an， input and then you randomize every part
    of that program that wasn't executed and you recompile。 it and you probably trigger
    very different compiler optimizations。 And if they're all correct。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如能量守恒这样的约束。因此这里一些常见的约束在编译器测试中非常流行。这是图示。你生成一个随机程序，编译它，然后用输入调用它，然后随机化该程序中未执行的每一部分，重新编译它，可能会触发非常不同的编译器优化。如果它们都是正确的。
- en: compiler optimizations then you get the same result when you run that new program
    on the original。 input。 This is I think responsible for about 900 bugs in common
    compilers。 The last one is just if there are things that you can do which should
    have no effect。 checking that if you do them they have no effect is a metamorphic
    test。 You say if I call my。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: function and then do a no op， no changes。 But honestly， the high level message，
    if you have。 assertions and you check that your code doesn't raise unexpected
    exceptions on any valid input。 and you test your round trips， you are basically
    done。 So certainly when you go back to your work。 or other projects and you think
    about do I want to use hypothesis。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: don't worry about the fancy stuff， until after you've done all of this and then
    decide whether you want to do more。 At that point you will probably also have
    a good sense of is property-based testing valuable for。 your particular project。
    But of course， today we're going to do some more exercises。 So the exercises for
    part three are just the next notebook。 There's a couple of example functions。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: to write test for。 But if you have a simple function in your own code base that
    you'd like to work on。 or an open source thing， this is very much a kind of picker
    function。 try to identify the properties， and then write a simple property-based
    test。 Let's go。 I will circulate in a minute to assist， but right now I'm just
    going to unplug and see if I can get my demo working。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a2a8090e0ca721c225298b1c97c51f4_28.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: Okay， so I'll just interrupt the exercises briefly because I got my live demo
    working。 at least for the first step。 So the idea here is we have this hypothesis
    command and it turned。 out my laptop was really slow because it was low on battery。
    So it's plugged in now and should be。 working。 And so if you ask hypothesis to
    write a test for the sorted function， okay。
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: but I'm just sorry。 Then we hypothesis write sorted and we discover that。 hypothesis
    will actually write a test which includes the key and reverse arguments to sorted。
    And all of my tests just completely ignored reverse。 So they assume we were sorting
    in forward。 order， but we might also want to test that if we pass reverse equals
    true that the pairwise。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: ordering is in fact the other way around。 And so I finally go try to kind of
    useful for that。 By default it writes pi test style tests if you have pi test
    installed。 If you don't or if you ask。 for them it will write unit test style
    tests which just tests class。 Yep。 Here。 Ah。 that is the name of a function or
    a module。 Just anything that could be imported。 Yeah。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: so this is just like there is a built-in function called sorted。 If you wrote
    this for， well。 I mean we'll see in a moment， if we wrote a test that asked。litrolaval
    is equivalent to the。 eval built-in。 So literal of l is just like a val but only
    for python literals we get a test。 And so we can from asked import of val or import
    asked and then access the eval attribute on it。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: And then eval is just a python built-in。 So we go stragglers knows how to access
    those。 And we have a fairly simple test。 We get a result from literal of l， we
    get a result from。 revale and then we assert that they're equal。 This test also
    shows off some of the limitations of。 the ghost strider because if you look closely
    you'll notice that the arguments here and the。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后eval只是一个Python内置函数。所以我们去访问那些内容。我们有一个相当简单的测试。我们从字面值l中获得一个结果，从revale中获得一个结果，然后我们断言它们相等。这个测试还展示了一些Ghost
    Rider的局限性，因为如果你仔细看，你会注意到这里的参数和。
- en: arguments here share nothing in common because the argument names to literal
    of l is node or string。 and source for a val。 So in this case you can start with
    the code to make a few edits in order。 to actually have a useful test。 If this
    one passes it will only ever do so by coincidence and it's a。 very unlikely coincidence。
    If you want the sort of mathematical properties， for example。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的参数没有任何共同点，因为字面值l的参数名称是节点或字符串，而val的源也是如此。因此在这种情况下，你可以从代码开始做一些编辑，以便实际上有一个有用的测试。如果这个测试通过了，它只会是偶然的，而且这种偶然性非常不可能。如果你想要某种数学属性，例如。
- en: addition is associative and communicative and has an identity element which
    is zero。 Honestly this one is just showing off。 There's probably no real reason
    to use it in practice。 A more realistic test is that we just want to test something
    about， say， gzip compression。 And hypothesis will look in the gzip module， find
    the compressed function。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 加法是结合的和可交换的，并且有一个身份元素，即零。老实说，这个只是展示而已。在实际中大概没有真正的理由使用它。一个更现实的测试是我们只想测试关于，比如gzip压缩的某些内容。Hypothesis会查看gzip模块，找到压缩函数。
- en: and it will also find that there is a gzip。decompress function。 We're like，
    well， I bet if I。 compress something and then I decompress it I should get the
    thing back。 And so in this test。 what we need to do is specify that data is a
    binary string。 In this case the function doesn't。 have type annotations or hypothesis
    would have guessed for us。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 它还会发现有一个gzip.decompress函数。我们想，好吧，我打赌如果我压缩了一些东西，然后再解压缩它，我应该能得到原来的东西。因此在这个测试中，我们需要指定数据是一个二进制字符串。在这种情况下，函数没有类型注解，否则hypothesis会为我们猜测。
- en: And data is also such a nondescriptive， name that I'm not really comfortable
    guessing what data should be。 So in this case we'll just， leave a comment that
    says to do， this is your problem now。 This is hopefully still like a useful， starting
    point。 Yeah。 a scalar's going to like some template code。 Yep。 Hypothesis， right。
    MyModule。mySubModule。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 数据也是一个没有描述性的名称，我对数据应该是什么并不太确定。因此，在这种情况下，我们只会留下一个评论，说明这是你现在的问题。希望这仍然是一个有用的起点。是的，标量会像一些模板代码。没错，假设，对吧。MyModule.mySubModule。
- en: my function。 So it doesn't look from the root directory。 It looks at things
    that can import。 So you can often import things in the current module in the current
    directory， sorry。 So。 if you have myScript。py you can do myScript。whatever function。
    But you can also do， numpy。mattmull。 And it doesn't matter what directory you're
    in。 If you can import numpy and。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我的函数。所以它并不是从根目录开始查找。它查看可以导入的内容。所以你通常可以在当前目录的当前模块中导入东西，对不起。因此，如果你有myScript.py，你可以调用myScript.任意函数。但你也可以调用numpy.mattmull。而且你所在的目录并不重要。如果你能导入numpy并且。
- en: access the matmull attribute we'll write a test for that for you。 I have a list
    of regular expressions and format patterns。 Those are in the Hypothesis Ghost
    Rider Submodule。 Poor request， welcome to Expand the List。 You could， but honestly
    like it's not great for classes。 At the moment the Ghost Rider is。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 访问matmull属性，我们会为你写一个测试。我有一个正则表达式和格式模式的列表。这些在Hypothesis Ghost Rider子模块中。欢迎提交请求以扩展列表。你可以，但老实说，这对类来说不是很好。目前，Ghost
    Rider对函数来说。
- en: pretty good for functions and like okay-ish for classes because it will just
    like call your method。 You're like is that useful maybe？ But the real advantage
    of this I find is you can just point。 it in a module and you get a whole bunch
    of tests and I'll usually delete like 80% of them。 But the last 20% get me past
    the blank page problem when I open an editor and I'm like now what？
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 非常不错，对类来说还算可以，因为它会调用你的方法。你会想，这是有用的吗？但我发现它真正的优势是你可以指向一个模块，然后你会得到一堆测试，我通常会删除其中的80%。但最后20%帮我解决了打开编辑器时的空白页问题，我心想现在该怎么办？
- en: Well， I just pipe the Ghost Rider output into a file and then I know what I'm
    doing。 I go。 through and I delete all the tests that I don't think are useful
    and I look at the to-do comments。 and I'm like okay what strategy should this
    have？ And then I see what errors that raises and go。 Is this the test is wrong，
    the code is wrong。 It kind of lets you evolve rather than having to start from
    scratch。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我只是将 Ghost Rider 的输出管道到一个文件中，然后我知道自己在做什么。我会检查并删除所有我认为没用的测试，然后查看待办事项评论。然后我想，这个策略应该是什么？然后我查看产生的错误，想知道这是测试错了，还是代码错了。这种方式让你逐步演变，而不必从头开始。
- en: And like sometimes it just works and gives you a great test first off which
    is nice but I'm not。 going to pretend it happens every time。 Yep。 Yeah and part
    of this is sometimes the Ghost Rider。 will write something like oh I didn't realize
    I could do it that way。 So it's designed to get。 you started to teach you what
    the basics look like。 So worked example JSON it turns out is a little。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有时它会直接有效，给你一个很棒的测试，真不错，但我不会假装它每次都这样。是的，部分原因是，有时 Ghost Rider 会写出类似“哦，我没想到我可以那样做”的内容。它旨在帮助你入门，教你基本内容的样子。因此，工作示例
    JSON 的结果就是有点。
- en: more complicated than GZIP。 JSON in Python accepts all of these arguments。 We've
    got a。 allow-nans check circular encoder class default value inshore ASCII indentation
    the object。 That's nothing so we'll need to specify the object。 Object or object
    pairs， hook pass。 constant pass， float pass， in separator skip keys， sort keys。
    But then the body of the。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 比 GZIP 更复杂。Python 中的 JSON 接受所有这些参数。我们有允许 NAN、检查循环编码器、类的默认值、确保 ASCII、缩进对象。这没有什么，所以我们需要指定对象。对象或对象对、钩子传递、常量传递、浮点传递、分隔符跳过键、排序键。但测试的主体与我们之前的差不多。
- en: test is pretty much the same as we had for the other one。 We dump our value，
    dump our JSON object。 to some value which will be a string and then we JSON。loads
    that value and we'll get whatever the。 thing was back and then we insert the record。
    I cut this down a little just to ignore all of。 the arguments that I don't think
    we care about for the sake of this。 So we've just gone a little。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 测试基本上与我们之前的相同。我们转储我们的值，转储我们的 JSON 对象为某个值，这将是一个字符串，然后我们 JSON.loads 该值，将得到返回的内容，然后插入记录。为了忽略我认为我们不在乎的所有参数，我稍微简化了一下这个过程。
- en: shorter and we've dropped in my little recursive JSON strategy that I showed
    you early in the。 tutorial。 So we've got our base case which is the scalar values
    and our extended list editioners。 So let's actually just run this test and see
    what Pytest thinks of it。 Who thinks this will pass？
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 更短一些，我们在我早些时候展示的递归 JSON 策略中简化了。所以我们有基础案例，即标量值和扩展列表编辑器。那么我们实际运行这个测试，看看 Pytest
    对此的看法。谁认为这个测试会通过？
- en: Anyone else？ Three people think it'll pass？ No？ So let's see what we have here。
    Hypothesis tells us that we found two distinct failures and it's also kind enough
    to tell us。 what both of them were。 So in this case the first one is that if a
    loud NAN is true and the object is。 NAN then of course not a number is not equal
    to itself。 So we'll add a filter to ensure that the。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他人吗？三个人认为会通过？没有？那么我们看看这里有什么。假设告诉我们我们发现了两个不同的失败，并且也很友好地告诉我们这两者的具体情况。所以在这种情况下，第一个是如果允许
    NAN 为 true，而对象是 NAN，那么当然不是数字不等于它自己。所以我们将添加一个过滤器来确保。
- en: object we generate is equal to itself for the next version。 And the other error
    that we get if。 we scroll down is that out of range float values are not JSON
    compliant and our failing value there。 let me find it， is infinity。 And according
    to a strict reading of the JSON specification you're。 only allowed to have finite
    numbers。 And Python for reasons I believe involving back that compatibility。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成的对象在下一个版本中等于它自己。我们向下滚动时会得到的另一个错误是，超出范围的浮点值不符合 JSON 规范，而我们失败的值是无穷大。根据 JSON
    规范的严格解读，你只允许使用有限的数字。Python 由于与向后兼容性有关的原因，我认为是这样。
- en: calls the relevant argument a loud NAN but a loud NAN equals false also bans
    infinity。 So let's fix the test。 We'll say that a loud NAN is just always true
    instead of being any Boolean。 and we'll also add this assume。 Assume is a hypothesis
    function which acts exactly like a filter but。 it's inside your test function。
    So if you get to something where you're like well in order to make。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 相关参数称为允许 NAN，但允许 NAN 等于 false 也禁止无穷大。我们来修复这个测试。我们会说允许 NAN 只需始终为 true，而不是作为布尔值。我们还会添加这个
    assume。Assume 是一个假设函数，它的作用与过滤器完全相同，但它在你的测试函数内。所以如果你遇到某种情况，比如为了实现。
- en: this assertion this thing also has to be true you can just assume that it's
    true and if it isn't。 hypothesis we'll throw that test case away and give you
    a new one。 But in a way that doesn't mean。 it's a test failure it means that it
    was an invalid test case。 Exactly the same caveats as filter。 it's just filter。
    So who thinks of this test will pass？ Man you are all cynics now。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个断言这个事情也必须是真的，你可以假设它是真的，如果不是，我们会抛掉那个测试用例，给你一个新的。但从某种意义上说，这并不意味着这是一个测试失败，而是说这是一个无效的测试用例。和过滤器一样的警告。这只是过滤器。那么，谁认为这个测试会通过？你们现在都是怀疑论者。
- en: This is how it feels to work with hypothesis， you're doubting everything。 It
    still fails。 So our object now is a list containing one value which is the floating
    point value NAN。 I discovered this live on stage doing this demo at a Python conference
    a few years ago。 It turns lists have this performance optimization where in order
    to avoid really expensive deep。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用hypothesis工作的感觉，你在怀疑一切。它仍然失败。因此，我们的对象现在是一个包含一个值的列表，即浮点值NAN。我几年前在一个Python大会上现场演示时发现了这一点。事实证明，列表有这种性能优化，为了避免真正昂贵的深度。
- en: comparisons。 The first thing they will do is if two lists are the same list
    by identity so they're。 both just into the same thing and they're just equal。
    They are the same list so they're equal。 And then if you compare called list on
    it so it's not the same list this is the bit blue in my mind。 They then do the
    same trick to each of the respective elements。 So they go if the first element
    of。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 比较。首先他们会做的是，如果两个列表是通过身份相同的列表，那么它们都是指向同一个东西，它们就相等。它们是同一个列表，所以它们是相等的。然后，如果你在上面比较调用列表，所以这不是同一个列表，这是我脑海中的蓝色部分。他们然后对各自的元素做同样的把戏。所以他们会说如果第一个元素。
- en: list A is the first element of list B then we'll just consider them equal without
    doing a deep。 comparison。 And this works for everything in Python except not a
    number。 So there we go。 Who thinks that this test is going to pass？ So we've still
    just said we always allow NAN。 which is to say we allow infinity now because we're
    just saying allow N equals false so we'll never。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A是列表B的第一个元素，那么我们就认为它们是相等的，而不进行深度比较。这适用于Python中的所有内容，除了不是数字的情况。所以我们来了。谁认为这个测试会通过？所以我们仍然只是说我们总是允许NAN。也就是说，我们现在允许无穷大，因为我们只是说允许N等于false，所以我们永远不会。
- en: generate not a number in the first place。 Who thinks this test is going to pass？
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先生成一个不是数字的值。谁认为这个测试会通过？
- en: Who thinks it's going to fail？ One hand， two hands， three hands。 You're all
    more engaged earlier。 The passes。 So there we are。 And for fun I also mentioned
    NumPy support。 NumPy has a matmull function for those who like multiplying matrices
    together and hypothesis。 is perfectly happy to do fancy numerical stuff for you。
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 谁认为它会失败？一只手，两只手，三只手。你们都比之前更投入。结果通过了。所以我们在这里。为了好玩，我还提到了NumPy支持。NumPy有一个matmull函数，适合喜欢矩阵相乘的人，而hypothesis非常乐意为你做一些复杂的数值计算。
- en: I will explain the details of this to anyone who actually asked me for it。 For
    now thank you very much for watching my live demo and thank you to the demo gods
    for。 actually having it work。 Let's go back to exercises for another 15 minutes
    or so。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我会向任何实际询问我的人解释这个细节。现在非常感谢您观看我的现场演示，也感谢演示之神让它实际运行。让我们再回到练习大约15分钟。
- en: '![](img/8a2a8090e0ca721c225298b1c97c51f4_30.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a2a8090e0ca721c225298b1c97c51f4_30.png)'
- en: All right。 So it's about five past 12 which means we've got about 20 minutes
    left of this tutorial。 So before we wrap up I wanted to talk to you about the
    last part。 Bring it into practice where I've kind of shown you and hopefully you've
    gone through some exercises。 that make you more comfortable with writing strategies
    to generate data and also writing。
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在是12点05分，这意味着我们还有大约20分钟的教程时间。在结束之前，我想和你谈谈最后一部分。把它应用于实践，我已经给你展示了，希望你已经进行了一些练习，让你更熟悉生成数据的策略和编写。
- en: simple tests that use those strategies。 But if you're planning to apply this
    at work or in an。 open source project there's some other things you probably want
    to know as well。 For example。 how do you build a property based test suite？ Not
    just one test but how does this fit into a broader。 strategy。 I'm going to talk
    about hypothesis settings and profiles for those and some other。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些策略的简单测试。但如果你打算在工作或开源项目中应用这个，还有一些其他的事情你可能也想知道。例如，如何构建一个基于属性的测试套件？不仅仅是一个测试，而是它如何融入更广泛的策略中。我将谈论hypothesis的设置和配置文件以及其他一些内容。
- en: stuff which you'll see on those slides。 So the first thing I want to emphasize
    is that I definitely。 do not suggest that all of your tests should be property
    based tests。 In some code bases I've had。 literally one property based test。 I
    think black takes this approach。 There's just one test which。 says given any valid
    Python source file we should be able to format it。 Yep and it turns out that。
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: this has found quite a few bugs in black。 For most projects depending on what
    it's what kind of。 code you're writing somewhere between maybe 10% and 90% of
    your tests can be property based or at。 least that's what I am up with。 For other
    projects I have worked on things where I look at it and go。 hypothesis is not
    a good fit here。 And then you probably also want to write custom strategies for。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: your project。 Maybe you have a particular class where you use objects of this
    type all over your。 code base。 In that case I often end up with a sort of test
    strategies file that I can import。 from for everywhere else which means I only
    have to update my strategy definitions in one place。 if I change something about
    my code base。 And this is a much nicer workflow than sort of the。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: standard you have to write out all the examples by hand because it makes the
    work additive rather。 than multiplicative with a number of semantic tests that
    you want and a number of data edge cases that。 you have。 So a couple of patterns
    for that one is just have functions which return properties。 Maybe they use composite
    maybe they're just ordinary functions which return strategies。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The even simple assign your strategy to a global variable and import it from
    somewhere else。 That's totally allowed。 Sometimes the simple code is the best。
    And then I've mentioned I think。 before there's the register type strategy function。
    So if you have the custom type and your strategy， for it needs to take some constraints
    into account you can register that with hypothesis so that。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: whenever else we generate that type we'll do so respecting the constraints using
    that exact strategy。 that you provided。 I will confess I use a debugger sometimes
    and print debugging always。 The problem with print debugging with hypothesis is
    that you end up with like a thousand or at。 least a hundred times more prints
    than you expected。 So the hypothesis。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: note function is just print but， it only prints on the final example。 I was
    like better print debugging but still print debugging。 And there's also an event
    function。 If you want to sort of have aggregate statistics across。 all of your
    test runs you can get statistics which show you what proportion of the test cases
    we。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: tried exhibited whatever string you passed。 And so if you pass the hypothesis
    statistics like to。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a2a8090e0ca721c225298b1c97c51f4_32.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: pi test each test will output something like this。 So say while we were generating
    data it typically。 took between zero and 38 milliseconds to generate data which
    was about 55% of total runtime we had。 this many passing and failing examples。
    And in this case but the events that I had was just the length。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: of the very simple list input。 Obviously this could be whatever string you like。
    There we are。 And then during the shrink phase we were looking for a minimal failing
    example。 The test tended to be very quick。 We found one failure two examples。
    And yeah we found a middle。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a2a8090e0ca721c225298b1c97c51f4_34.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: example right off。 So settings。 Settings are set from code。 We don't look at
    any environment variables， but you guys can all write Python code。 If you want
    them set by environment variables you can write。 the code that checks the environment
    variable and then sets the set。 You can also set them as a。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: decorator in your test function which is sort of the quick and dirty approach
    but works well when。 you're interactively doing stuff。 And the pi test command
    line does kind of plug through into the。 settings。 The main settings you want
    to look at are there's a docs page with this。 I thought this。 read the docs but
    the two that you'll probably want for performance。 There's a deadline setting。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: which says what is the longest that this test should take。 By default that's
    about 200 milliseconds。 That tends to be plenty for most unit test kind of things
    but can be a little slow for tests that。 use Django and umpire pandas。 In that
    case like don't stress just turn up the deadline。 The idea。 here is it catches
    things which are surprisingly slow so that you're aware that this particular。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: test is much slower than you expected。 If you expect it to be slow you can just
    turn up the。 deadline or even disable it entirely。 And the other performance setting
    is max examples which is just。 how many test cases will hypothesis try your function
    on before it says yep looks like it's passing。 By default that's 100。 100 will
    obviously take 100 times longer than running on one example。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: and be 100 times faster but 100 times less rigorous than running on 10，000 examples。
    The reason it's 100 by default is that this seems to be a pretty good default
    for like unit。 test kind of workloads。 But if you've got a lot of hypothesis tests
    it might make sense to have。 like a nightly CI run where you turn that up a fair
    bit and just accept that it will take longer。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: in order to maybe find some more bugs。 Make sense？ Some people like deterministic
    tests。 That's reasonable hypothesis supports it。 That's basically all I wanted
    to say there。 My colleague Nelson L。H。 has written a nice blog post on this distinguishing
    between the kinds。 of tests where people run them just to find regressions。 They
    don't want to find bugs in general。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: They just want to know if this pull request broke anything。 And then the opposite
    style where you're writing tests because you want to see if there are any bugs。
    in your code。 And so you might actually want to run hypothesis with different
    settings for these。 two use cases so that you run it deterministically in CI and
    then for much longer and with a randomized。
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 他们只想知道这个拉取请求是否破坏了什么。然后是相反的风格，你写测试是因为想看看你的代码中是否有 bug。因此，你可能实际上想在这两种用例中使用不同的设置运行假设，以便在
    CI 中确定性运行，然后更长时间地随机运行。
- en: mode overnight so that you don't block someone's pull request on finding an
    existing bug but you。 still do find the existing bugs another time。 Random number
    generators。 Everybody hates testing。 phone which is flaky because of random number
    generators。 Hypothesis therefore will seed all。 the random number generators knows
    about it at the start of every test and restore the state at the。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 模式是过夜的，这样你就不会因为发现现有 bug 而阻塞某人的拉取请求，但你还是能在其他时间找到现有的 bug。随机数生成器。大家都讨厌由于随机数生成器导致的不稳定测试。因此，假设会在每个测试开始时对所有随机数生成器进行初始化，并在结束时恢复状态。
- en: end so we don't induce weird correlations for you。 You can call hypothesis register
    random。 to tell us about another random number like random dot random class that
    you have somewhere。 If there's a library that you use which doesn't currently
    do this for you。 tell me and I'll probably， just open a pull request for them。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 结束时我们不会为你引入奇怪的相关性。你可以调用假设注册随机数，告诉我们关于另一个随机数的信息，比如你某个地方有的 random.dot.random 类。如果你使用的某个库目前没有为你做到这一点，告诉我，我可能会为他们打开一个拉取请求。
- en: I mentioned everybody hates flaky tests。 Everybody also hates。 tests where you
    run the test and it fails and then you run the test again after making a small。
    change and it passes。 There you go。 Did I fix the bug or did the test just not
    fly to the error again？
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到过大家都讨厌不稳定的测试。大家也讨厌那种你运行测试时失败，然后在做了小改动后再次运行测试却通过的情况。这样就好了。我是修复了这个 bug，还是测试没有再次触发错误？
- en: Hypothesis gets around this in a couple of ways。 The first is that we actually
    save every failing。 example in a local little database in the dot hypothesis directory
    if you notice that。 So if you just rerun the test we will always start by replaying
    all of the failing examples that we。 found before to see whether or not they're
    still failing。 This means both that your debug cycle。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 假设通过几种方式解决了这个问题。第一，我们实际上会将每个失败的示例保存在一个本地的小数据库中，位于 .hypothesis 目录下。如果你注意到了这一点，所以如果你重新运行测试，我们将始终先重放之前找到的所有失败示例，以查看它们是否仍然失败。这意味着你的调试周期。
- en: should be faster。 If it takes a few minutes to find the example the first time
    it should still。 replay within seconds on every subsequent run and it also means
    you can be confident that if it。 doesn't come back it's because you've actually
    fixed the bug。 You can also add the @example decorator。 Do people do that in some
    of the exercises？
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 应该会更快。如果第一次找到示例花费几分钟，后续运行仍应在几秒钟内重放，这也意味着你可以放心，如果它不再出现，那是因为你确实修复了 bug。你还可以添加
    @example 装饰器。人们在某些练习中这样做吗？
- en: It's in the exercises further down。 This is just as。 well as having given supply
    strategies you can add an @example decorator with an exact value that。 you always
    want to test。 So in this case when you run give the test hypothesis and we'll
    try it on。 localhost then it will try it on example。com and then it will start
    randomly generating examples for you。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下面的练习中有。这不仅是提供策略，你可以添加一个带有确切值的 @example 装饰器，这是你始终想测试的。因此在这种情况下，当你运行给定测试时，假设会在
    localhost 上尝试，然后在 example.com 上尝试，接着会开始为你随机生成示例。
- en: If it fails in CI and you don't have the database handy。 hypothesis has a print
    blob setting which will default to true in CI and false locally。 Where we just
    print out this nasty base64 encoding thing in a decorator and use that as， database。
    So we'll replay based on that decorator。 This is kind of ugly but it does mean
    that if it。
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 CI 中失败，而你没有数据库可用，假设有一个打印 blob 设置，在 CI 中默认值为 true，而在本地为 false。我们就在装饰器中打印出这个可怕的
    base64 编码内容，并用它作为数据库。因此，我们会根据那个装饰器进行重放。这有点丑陋，但这意味着如果它。
- en: fails in CI you can still replay it locally and we think that's worth quite
    a lot of。 aggressive that's what it takes。 If you're working on a team where multiple
    people are running tests。 using a hypothesis you can just share the directory
    based database。 It kind of works in version control， though we don't recommend
    it or you can put it on a file share somewhere whatever else。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在CI中失败，你仍然可以在本地重放，我们认为这非常有价值。需要一些激进的东西。如果你在一个多人测试的团队中，使用假设，你可以共享目录基础的数据库。这在版本控制中有点作用，尽管我们不推荐，或者你可以把它放在某个文件共享上，随便什么地方。
- en: But given that this is just like a blob of bytes with you know bytes keys to
    a set of bytes values。 we would recommend using something like Redis like a proper
    network data store。 And so this example says we have sort of two settings profiles。
    We've got our CI profile。 where we're going to use the shared network database。
    Read them right to it including deleting。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 但鉴于这就像是一堆字节，带有字节键和一组字节值。我们推荐使用像Redis这样的真正网络数据存储。因此这个例子说我们有两种设置配置文件。我们有我们的CI配置文件，使用共享网络数据库。直接读取并删除。
- en: the stale examples from it。 And then we also have a dev profile for local development。
    where we can read and write to our local directory based database but we can also
    read but not write。 to the shared database。 And this means the workflow for reproducing
    a failure from CI consists of。 run the test locally。 And it will automatically
    pick up that failure for you and replay it。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 过时的示例。然后，我们还有一个开发配置文件用于本地开发，我们可以读取和写入本地目录的数据库，但我们也可以读取但不写入共享数据库。这意味着从CI重现故障的工作流程包括在本地运行测试。它会自动为你拾取这个故障并重放。
- en: I tend to think that's pretty cool if you've got the infrastructure set up。
    A few people asked me so when a hypothesis is generating random examples how does
    it choose。 the examples？ The answer is mostly just a big pile of heuristics which
    tend to find a lot of bugs。 but where that's not enough we also have this target
    function where you can sort of do an optimized。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我倾向于认为如果你有基础设施设置好，这很酷。几个人问我，假设生成随机示例时，它是如何选择这些示例的？答案主要就是一堆启发式规则，通常能找到很多bug，但当这还不够时，我们还有这个目标函数，可以进行一些优化。
- en: or a hill climbing search towards things。 So this is really useful for numeric
    things where。 your test is basically that if you calculate something you're within
    some error tolerance。 And so you can target that amount of error at a hypothesis
    will try variations on the things with。 the largest amount of error that it's
    found so far。 You can also just try things that。
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 或者是朝着某些事物的爬山搜索。因此，这对于数值的测试非常有用，你的测试基本上是如果你计算某个东西，你在某个误差容忍范围内。因此，你可以针对这个误差量，假设会尝试对迄今为止发现的误差最大的事物进行变体。你也可以尝试一些。
- en: don't themselves mean that your test is going to fail but seem like they might
    be correlated。 with failure。 Like the number of tasks in a queue or the compression
    ratio or maximum run time or。 something like that。 It's not that running for a
    long time means it's going to fail but it means。 that you're more likely to fail
    in some sense。 Coverage guided fuzzing for people who like fuzzers。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本身并不意味着你的测试会失败，但似乎与失败可能相关。比如队列中的任务数量、压缩比或最大运行时间，或者其他类似的东西。长时间运行并不意味着它会失败，但在某种意义上，它意味着更可能会失败。对于喜欢模糊测试的人，覆盖引导的模糊测试。
- en: just works。 You can plug a coverage guided fuzzer into the back of hypothesis
    and use that to run。 your property based tests using code coverage feedback。 A
    theorist's Google's take on this。 I think it's okay。 There are others。 My personal
    favorite is the one I built。 So hyperfuzz runs on test suites so instead of one
    function at a time it will dynamically allocate。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 它就是这么简单。你可以把一个覆盖引导的模糊测试器插入假设的后面，用它来运行你的基于属性的测试，使用代码覆盖反馈。这是理论家们对这一点的谷歌式理解。我觉得可以。还有其他的。我的个人最爱是我自己构建的那个。所以hyperfuzz运行在测试套件上，而不是一次一个函数，它会根据每个测试函数发现新覆盖的速度动态分配计算资源。
- en: the compute to each test function according to the rate at which it's discovering
    new coverage。 It's nice。 You can find me later and talk to me about it if you're
    interested。 Once you install hypothesis you might someday wish to update it when
    we fix bugs even hypothesis。 has a few bugs though it is well tested using hypothesis
    as you would hope。 But we also add a。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好。如果你有兴趣，稍后可以找我聊聊。一旦你安装了假设，可能有一天希望在我们修复bug时更新它，甚至假设本身也有一些bug，尽管使用假设进行了良好的测试，这也是你所希望的。但我们也添加了一个。
- en: lot of new features of course on the regular。 We also do continuous deployment
    so every pull。 request that gets merged to hypothesis is immediately released
    as a new version。 You are welcome to drink from the fire hose or you can pin your
    dependencies and update on whatever。 schedule works for your team。 So thanks very
    much for coming to the tutorial。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，常规更新了很多新功能。我们还进行持续部署，所以每个合并到hypothesis的拉取请求都会立即发布为新版本。你可以选择自由使用或者固定你的依赖项，并根据适合你团队的时间表进行更新。非常感谢你参加这个教程。
- en: I'm going to be around， for some Q&A then thanks very much。 Otherwise I think
    we've got about 10 minutes left so we'll do Q&A exercise if you wish and then。
    break the lunch。 [inaudible]， So it is fiddly enough to get this to work correctly
    that I haven't bothered because you。 typically have multiple tests。 If you say
    one each of your tests independently so pi test and。
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我会在这里待一会儿，进行问答，非常感谢。如果没有其他问题，我想我们还有大约10分钟，所以如果你愿意，我们可以进行问答练习，然后休息吃午饭。[听不清]，所以要让这个正常工作其实挺麻烦的，我也没去做，因为你通常有多个测试。如果你说每个测试都是独立的，比如pi
    test。
- en: whatever processes and you'll just spread your tests across multiple processes
    and parallel that way。 You could in principle do it but it's enough trouble that
    we just haven't bothered。 Great question。 So how do you apply it as your starting
    new project？ I would go back to that。 side where I said like assert father's round
    trips。 So I would make sure that I had good property。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是什么流程，你都可以将测试分布到多个进程中并并行执行。从原则上讲，这是可行的，但它足够麻烦，以至于我们就没有去做。非常好的问题。那么你如何在启动新项目时应用它？我会回到我提到的那一侧，像断言父类的回合旅行。所以我会确保我有良好的属性。
- en: based tests on my input and my output wherever I was loading or saving data。
    For new projects I would， probably try to think about like what is the class or
    the data type that represents the thing I load。 or save and make sure that whenever
    I change it I also update the strategy for generating instances。 of that and that
    would give me a lot of confidence that I can at least load and save data properly。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的输入和输出的基础上进行测试，无论我是在加载还是保存数据。对于新项目，我可能会考虑代表我加载或保存的对象的类或数据类型，并确保每当我更改它时，也更新生成实例的策略。这让我对能够至少正确加载和保存数据充满信心。
- en: I try to make sure that when I have things that all my functions expect that
    I would just。 assert that those were true or check that results were good sort
    of in the bodies of those functions。 and then just have hypothesis throw random
    inputs in a lot of things。 I think that's。 generically good advice for how to
    get started and then the more detailed stuff depends very。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我会尽量确保在所有函数期望的东西上进行断言，或者检查结果是否良好，通常是在这些函数的主体中。然后，让hypothesis在许多事物中随机输入。我认为这是开始的好建议，更详细的内容则因情况而异。
- en: much more on your particular project。 But as I said before if you have assertions
    in your code。 and you check your round trips with hypothesis you're in a good
    place and at that point if it's。 not obvious to you where to put another property
    based test maybe you don't need one。 Oh this is a good one。 So I'm the second
    leader of the hypothesis project。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这在你的特定项目中会有更多的应用。但正如我之前所说，如果你的代码中有断言，并且你用hypothesis检查你的回合旅行，那么你就处于一个良好的位置。如果你不清楚在哪里放置另一个基于属性的测试，也许你就不需要一个。哦，这是个好问题。所以我是hypothesis项目的第二负责人。
- en: The founder David Mkever was， in Switzerland and had quit his job and was moving
    back to England and realized that if he waited。 three weeks he would avoid getting
    taxed by two countries on all of that year's income。 So the first draft of hypothesis
    was written for tax reasons。 You wanted a project to learn Python and this seemed
    like an interesting project。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 创始人David Mkever在瑞士辞职，准备回到英国，他意识到如果他等三周，就可以避免在当年的所有收入上被两个国家征税。所以hypothesis的第一版是出于税务原因而写的。他想找一个学习Python的项目，这似乎是一个有趣的项目。
- en: I then found and got involved when a few years after that I was working as a
    research assistant。 and I had this nasty scientific data processing problem where
    I was also pretty bad at Python at。 the time。 So the script I'd written took 14
    hours to run on the real data set。 So I coded it up。 I'd run it on all the smaller
    stuff and it worked and I applied it to the big one and 14 hours later。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 几年后，我作为研究助理参与了一个项目，当时我面临一个棘手的科学数据处理问题，而我的Python水平也相当差。于是，我编写的脚本在真实数据集上运行了14小时。于是我进行了编码。我在所有较小的数据上运行了它，效果很好，但当我把它应用到大数据集时，14小时后才完成。
- en: it would crash。 And when you're debug edit run see the crash cycle takes 14
    hours it leaves you a。 lot of time for looking for better ways to test things。
    I eventually worked out the library we were。 using just would not deal with a
    space in a header。 So once I've written the hypothesis test which。 knew how to
    generate arrays and random comments it found it's like if you have a thing with
    one。
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: element and the comment is A space A your test fails。 Got it and at that point
    I was kind of hooked。 It really depends on the code that you're testing and the
    strategy you use。 I can't really say more。 than that。 Beyond the odds are often
    better than you would think because it turns out most failures。 can be reproduced
    with quite a small test case and that's why we think the shrinking or the example。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: minimization is really useful because it's so much easier to understand what's
    going on when all。 the extraneous detail is just not there。 But that same bug
    would trigger on a comment of any length。 that had any space in it。 And so the
    original example it found was probably like thousands of。 lines or at least hundreds
    of lines。 And if I think I might have turned up to like 100，000 examples。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: because I was just desperate and had 14 hours to kill。 And so at that point
    it's quite likely that。 it eventually stumbles across something which reproduces
    it and then hypothesis is very good at cutting。 that down to something which is
    also understandable by humans。 Yeah so how do you migrate an existing test suite？
    I think there are basically two approaches。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The first is I would always just write a new property based test for saving
    and loading data。 Or converting between two formats。 You're going to have something
    which is a round trip and round。 trips tend to be beautifully elegant properties
    to test and also find a whole pile of bugs。 The second thing is you can look for
    tests in your code base which are kind of like trying to be。
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: property based where you might have a pie test parameterized with a whole bunch
    of cases。 You。 might think， "Gee， I could probably work out what strategy would
    generate these and then maybe keep。 the interesting ones as the at-example decorators。"
    So we still keep checking those two。 At-example is great for regression tests。
    You can write the specific regression case that you。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: want to check for in the at-example decorator so it happens every time and then
    also check the。 more generally given case。 So the parameterized ones often kind
    of want to be property based in。 some sense or just like another unit test which
    seems to be making like a general claim with。 reference to one example。 Often
    you can think like， "How would I generalize this？"， [inaudible]。
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Yep， yep， you can supply some arguments with parameterized， others with hypothesis。
    others with fixtures， others with explicit calls， like hypothesis。 I do recommend
    using keyword。 arguments to given if you're going to mix them like this because
    if you do positionally it can。 get pretty confusing which argument is coming from
    where。 [inaudible]。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，是的，你可以用参数化提供一些参数，其他的用假设，其他的用夹具，还有一些用显式调用，比如假设。我确实建议在混合使用时使用关键字参数，因为如果用位置参数的话，可能会让人困惑，不知道哪个参数来自哪里。[听不清]。
- en: I don't think we have documentation related specifically to SQL alchemy or to
    fast API but。 PyDantic does have some level of hypothesis support natively and
    so there's a documentation page。 on their website about how to use it with hypothesis。
    That's where I would start。 [inaudible]， Okay。 so Chantana and I both work at
    Machine Learning Labs。 Testing Machine Learning Code is。
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们没有专门关于 SQL Alchemy 或 Fast API 的文档，但 PyDantic 确实在本地有一些对假设的支持，因此他们网站上有一页文档介绍如何将其与假设一起使用。这是我会开始的地方。[听不清]，好的。所以
    Chantana 和我都在机器学习实验室工作。测试机器学习代码是。
- en: notoriously difficult。 I like property based testing partly because it means
    I don't need to know。 what the model should do。 In one case， I could just know
    that if I randomize the weights。 it should perform worse。 In others， I can test
    not the whole model but that some gnarly numeric。 thing that I wrote gives me
    the same results as a simpler PyTorch implementation or a NumPy。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 知名的困难。我喜欢基于属性的测试，部分原因是这意味着我不需要知道模型应该如何运作。在某些情况下，我只需知道如果我随机化权重，它的表现应该会变差。在其他情况下，我可以测试并不是整个模型，而是我写的某些复杂的数字计算结果是否与更简单的
    PyTorch 实现或 NumPy 得到的结果相同。
- en: implementation。 Often we end up doing terrible things in the name of HyperGPU
    performance。 and it's reassuring to be able to run the mathematical code in NumPy
    and the awful gnarly kernel and。 check that they get the same results on all kinds
    of random inputs。 That's where I would start。 You can think of these as the equivalence
    property and then a metamorphic relation。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 实现。我们常常以提升 HyperGPU 性能的名义做出糟糕的事情，能在 NumPy 中运行数学代码和可怕的复杂内核并检查它们在各种随机输入下的结果是否相同，真是让人安心。这是我会开始的地方。你可以将这些视为等价属性，然后是一种变换关系。
- en: that if we mess up the model weights， performance should not improve。 [inaudible]，
    You could。 I haven't。 I don't think that's specific to machine learning anymore
    but yeah。 if you have something like a web API， there's a tool called schema thesis
    that a friend of mine。 wrote which will look at an open API or a swagger schema
    or a graphQL schema and automatically come。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们搞砸了模型权重，性能应该不会提升。[听不清]，你可以。我没这样做。我不认为这再特定于机器学习，但如果你有像 Web API 这样的东西，有个叫
    schema thesis 的工具是我一个朋友写的，它会查看一个开放 API、Swagger 架构或 GraphQL 架构，并自动生成。
- en: up with thousands of test cases for your API。 So if you're testing a web API。
    I would reach for that， rather than writing tests by hand。 If that's it then。
    thank you all so much for coming。 I hope you enjoyed the tutorial and enjoy lunch。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的 API 准备数千个测试用例。因此，如果你在测试一个 Web API，我建议使用这个工具，而不是手动编写测试。如果就这样，那么非常感谢大家的到来。我希望你们喜欢这个教程，并享用午餐。
- en: '![](img/8a2a8090e0ca721c225298b1c97c51f4_36.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a2a8090e0ca721c225298b1c97c51f4_36.png)'
