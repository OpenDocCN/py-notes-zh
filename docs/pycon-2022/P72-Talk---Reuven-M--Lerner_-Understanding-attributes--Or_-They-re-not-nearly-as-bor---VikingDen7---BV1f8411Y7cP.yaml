- en: P72：Talk - Reuven M. Lerner_ Understanding attributes (Or_ They're not nearly
    as bor - VikingDen7 - BV1f8411Y7cP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P72：演讲 - Reuven M. Lerner_ 理解属性（或者_ 他们并没有你想的那么无聊 - VikingDen7 - BV1f8411Y7cP
- en: Hello， welcome to the second session。 My name is Jonas。 I'll be the session
    chair for the。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大家好，欢迎来到第二个环节。我是Jonas。我将担任本环节的主席。
- en: '![](img/51690c84e071188052a7d3143161d01e_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51690c84e071188052a7d3143161d01e_1.png)'
- en: next three talks and introduce the speakers。 Make sure you come to the front
    if you're。 comfortable so you can see the slides。 Our first speaker in the session
    is a Reuben。 learner who will be talking about understanding attributes。 Allegedly
    they are not nearly as。 boring as you might think。 Take care of your own。 Okay，
    hi everyone。 Wow。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三场演讲将介绍演讲者。如果你觉得舒适，请走到前面，这样你可以看到幻灯片。我们这一环节的第一位演讲者是Reuben，他将讲解理解属性。据说它们并没有那么无聊。大家注意自己。好的，大家好。哇。
- en: it is so nice to see people in three dimensions。 You have no， idea。 Maybe you
    do。 Maybe you've been experiencing。 You might have heard there's a bit of a pandemic，
    going around。 In any event， my name is Reuben and I teach Python for a living。
    I've been， doing this since。 I've been in business since 1995。 I do corporate
    training。 I do video training， hybrid training。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 见到人们以三维形式出现真是太好了。你们没有想过吧？也许你们知道，也许你们已经经历过。你们可能听说过现在有一点疫情。无论如何，我的名字是Reuben，我以教授Python为生。自1995年起我就一直在这个行业。我做企业培训、视频培训和混合培训。
- en: I have this thing called weekly Python exercise。 I have books， pandas， workout，
    Python workout。 You're welcome to come to my booth， ask questions afterwards。
    and even get swag and a raffle on my books。 But let's get into the topic at hand。
    Let's。 assign to a variable。 Exciting， right？ So here I say X equals 100。 What's
    going on here？
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个叫每周Python练习的项目。我有书籍、pandas、Python练习。欢迎你们来我的展位，之后问我问题，甚至获得我的书籍的周边和抽奖。但让我们开始讨论当前的话题。让我们给一个变量赋值。激动吗？在这里我说X等于100。这到底发生了什么？
- en: I'll tell you what does not mean。 So many people who come from the C world and
    we have。 to sort of be nice to them， pity them。 But basically people from the
    C world sort of believe that。 when you say X equals five， what you're doing is
    you're taking a variable which is basically。 an alias to a memory location。 And
    you're saying I want to stick that value into that。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我告诉你这并不意味着什么。许多来自C语言世界的人，我们必须对他们表示善意，怜悯他们。基本上，来自C语言世界的人相信，当你说X等于5时，你实际上是在取一个变量，这基本上是一个内存位置的别名。你是在说我想把那个值放进去。
- en: memory location。 That's not how it works in Python。 This does not mean put the
    value of。 100 in the memory location called X。 What it does mean is the name X
    should now refer。 to the integer object 100。 A totally different kind of thing。
    And we can see this really， nicely。 For those of you who aren't familiar with
    it， the Python tutor site， Python tutor。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 内存位置。这在Python中并不是这样工作的。这并不意味着将100的值放入名为X的内存位置。它的意思是名称X现在应该指向整数对象100。这是完全不同的概念。我们可以很好地观察到这一点。对于不熟悉它的人来说，Python
    tutor网站是个好去处。
- en: dot com for Phillip wall。 Amazing， amazing stuff。 And we can see here on the
    left we have。 the variable X， the global variable X， and referring to an integer
    object 100。 So far， so good。 Let's get a little fancier。 Let's create a class，
    a do nothing class class， my， class pass。 And then I say X equals an instance
    of my class。 Now what I'm going to do is I'm。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: dot com给Phillip wall。惊人的，惊人的内容。在左侧我们看到变量X，全局变量X，指向整数对象100。到目前为止，一切顺利。让我们变得更高级一点。让我们创建一个什么都不做的类，类名为my
    class pass。然后我说X等于我的类的一个实例。现在我要做的是。
- en: going to say X dot Y equals 100。 What am I doing here？ I am not assigning to
    X。 I am。 assigning to X dot Y。 I am creating an attribute on X。 Y is not a variable。
    And it's very。 important to keep track of that and to understand that we have
    two totally separate storage。 systems in Python。 And here we see them that X refers
    to an instance of my class。 And in。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我要说X点Y等于100。我在这里做什么？我并不是在给X赋值。我是在给X点Y赋值。我在X上创建一个属性。Y不是一个变量。这一点非常重要，要记住并理解我们在Python中有两个完全独立的存储系统。在这里，我们看到X指向我的类的一个实例。
- en: that class we have the attribute Y with a value of 100。 Now every single object
    in Python。 has attributes。 Every single one。 And you can think of them as a private
    dictionary on， the object。 But instead of using square brackets， you're using
    a dot to either set or retrieve， them。 And the attribute does not exist in the
    variable。 So while we colloquially could。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个类中，我们有一个属性 Y，值为 100。现在，Python 中的每个对象都有属性。每一个。你可以将它们视为对象上的一个私有字典。但不是使用方括号，而是使用点来设置或检索它们。而属性并不存在于变量中。所以虽然我们可以口语上说。
- en: say yes X has an attribute Y。 Realistically X is the variable referring to that
    object。 and the object has the attribute Y。 So we can retrieve from attributes
    really easily。 I。 can say for example， sys dot version。 Right？ I have， I do import
    sys。 I've created the global。 variable sys which refers to a module object。 So
    sys is a variable and version is an attribute。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 说 X 有一个属性 Y。从现实角度来看，X 是指向那个对象的变量，而对象具有属性 Y。所以我们可以很容易地从属性中检索。我可以说，比如，`sys.version`。对吧？我已经导入了
    `sys`。我创建了全局变量 `sys`，它指向一个模块对象。所以 `sys` 是一个变量，而 `version` 是一个属性。
- en: on that variable。 And it gets me back the version of Python I'm running。 I can
    say stir。upper。 of ABC。 Stir is a global variable actually built in。 Right？ It's
    a variable that refers。 to the string class。 Upper is a method on that。 And then
    I can once I retrieve that method， object。 actually a function object， then I
    can use parentheses to invoke it and get back， a result。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个变量上。它让我获取我正在运行的 Python 版本。我可以说 `stir.upper`，ABC。`stir` 是一个全局变量，实际上是内置的。对吧？它是一个引用字符串类的变量。`upper`
    是这个类上的一个方法。然后我一旦检索到那个方法对象，实际上是一个函数对象，我就可以用括号来调用它并返回结果。
- en: And similarly I can say random dot random to zero to 100。 Random is a module。
    It is a method。 I get that method object back and I invoke it。 So far so good。
    Just like。 variables attributes can contain any Python object at all。 It can be
    data。 It can be a， function。 Absolutely anything can be in an attribute。 Just
    as absolutely anything can， be in a variable。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我可以说 `random.random` 返回 0 到 100。`random` 是一个模块。它是一个方法。我获取那个方法对象并调用它。到目前为止都很好。就像变量一样，属性可以包含任何
    Python 对象。它可以是数据，可以是一个函数。绝对任何东西都可以在属性中。就像绝对任何东西都可以在变量中。
- en: What if I want to set attributes？ Well with pretty rare exceptions typically。
    having to do with built ins that are written in C you can set any attribute on
    any object。 you want in Python。 So here assuming that I have an object that's
    not one of the built。 in types I can say x dot y equals 100。 And I will have added
    that attribute to the object。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想设置属性呢？好吧，通常情况下，除了与用 C 编写的内置类型有关的非常少数例外情况，你可以在 Python 中对任何对象设置任何属性。所以这里假设我有一个不是内置类型的对象，我可以说
    `x.y = 100`。我将会把那个属性添加到对象中。
- en: Or if the attribute already exists then I replace the previous version with
    the new， version。 And if that sounds a lot like a dictionary guess what it's a
    lot like a dictionary。 So。 some of you might remember the difficulty in paying
    that we had in upgrading Python 2， to Python 3。 Well I have an easier solution。
    Sys dot version equals 4。00。 There you go。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性已经存在，那么我用新版本替换之前的版本。如果这听起来很像字典，没错，它确实很像字典。所以，有些人可能还记得我们在将 Python 2 升级到 Python
    3 时遇到的困难。好吧，我有一个更简单的解决方案。`sys.version` 等于 4.00。这样就好了。
- en: I have now upgraded Python 4 with no paying whatsoever。 You see then I can set
    absolutely。 positively any value I want。 On absolutely positively any attribute
    I want。 On absolutely。 positively any object I want。 But you know why would I
    set version to be 4？ When if I， set it to 4。20 Elon Musk comes and buys Python。
    Okay we actually set attributes all the time。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在已经升级到 Python 4，完全没有支付。你看，我可以绝对、肯定地设置我想要的任何值。对任何属性，我想要的任何对象。但你知道我为什么要把版本设置为
    4 吗？如果我把它设置为 4.20，埃隆·马斯克就会来买 Python。好吧，我们实际上总是设置属性。
- en: All the time we don't think about it very much。 If I create a new class class
    person。 I'm going to have depth under in it。 What is under in it？ I'll tell you
    what it is。 It。 isn't the constructor method。 It's not creating a new object。
    After the new object has already。 been created， under in it is invoked to add
    attributes to the object。 That is the role。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是不会太多考虑。如果我创建一个新类 `class Person`，我将会有一个 `__init__` 方法。这个 `__init__` 是什么呢？我告诉你，它不是构造方法。它不是在创建新对象。新对象已经创建后，`__init__`
    被调用以添加属性到对象上。这就是它的角色。
- en: of under in it。 If you don't have attributes on your object， don't have under
    in it。 If。 you don't have attributes on your object and you've got other issues
    but let's not talk。 about that right now。 And then I get self a name。 So self
    is the instance。 It's the new。 instance that was just created。 And name is the
    parameter， the local variable that contains。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的对象没有属性，就不要使用 init。如果你对象没有属性，你还有其他问题，但现在先不谈这个。然后我给 self 一个 name。所以 self 是这个实例。它是刚刚创建的新实例。name
    是参数，包含的局部变量。
- en: the value。 And then what I do is I take that value name and assign to self that
    name。 And。 self of course is that new instance。 So I'm adding an attribute to
    that instance。 And。 now the object has it。 Now it's referred to here by self。
    But of course outside of the， method。 outside of under in it， that object is going
    to have a different name， a different， reference。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值。然后我做的是把那个值 name 赋给 self 的 name。自然而然，self 就是那个新实例。所以我在那个实例上添加了一个属性。现在对象拥有它。现在它在这里被
    self 引用。但当然在方法外，外部的 init，这个对象将会有一个不同的名称，一个不同的引用。
- en: a different variable。 For example， P1 and P2。 Now while under in it is wrong。
    we can see what's going on。 We have the global variable person which refers to
    the person， class。 And then inside of under in it， we have two local variables，
    self which refers。 to the person instance。 And we can see then that self has an
    attribute called name and。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不同的变量。例如，P1 和 P2。虽然在 init 中是错误的，但我们可以看到发生了什么。我们有全局变量 person，它指向 person 类。然后在
    init 中，我们有两个局部变量，self 指向那个 person 实例。我们可以看到，self 有一个名为 name 的属性和。
- en: its value is name one， which we got assigned to from that variable name one。
    Then when。 we return it， well here we go， we've got name and name one。 When we
    return it， P1 is。 referring to that instance， which still has the attribute name。
    And we have the value， name one。 Okay， not too bad， not too shabby。 Let's make
    this a little more interesting。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它的值是 name one，这是我们从变量 name one 赋值过来的。然后当我们返回时，好吧，我们得到了 name 和 name one。当我们返回时，P1
    是指向那个实例，它仍然有属性 name。而我们有的值是 name one。好吧，不错，不错。让我们让这个变得更有趣一些。
- en: What's missing from this program？ Well， let's assume that our， like that this
    is our startup's。 you know， crown jewels。 We， it's such a great program。 Be able
    to create a person like this。 Clearly we're going to go public pretty soon。 But，
    but my manager has come in and said。 I've spoken to our customers and they demand
    new functionality customers。 They want us to。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序缺少什么呢？好吧，让我们假设这是我们创业公司的，知道的，瑰宝。我们，这个程序实在太棒了。能够像这样创建一个人。显然，我们很快就会上市。但我的经理进来说。我跟我们的客户谈过，他们要求新的功能。客户希望我们。
- en: keep track of how many people we're creating in our virtual world， our virtual
    universe。 our metaverse if you will， to coin a phrase。 So let's keep track of
    the population as。 we add people there。 Okay， well how am I going to do that？
    Well， here's one idea。 I could。 use a global variable for that， right？ That's
    a fantastic idea。 It's not a fantastic idea。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪我们在虚拟世界、虚拟宇宙中创建了多少人，如果你愿意，可以称之为元宇宙。所以让我们在添加人时跟踪人口。好吧，我该怎么做呢？这里有一个想法。我可以为此使用一个全局变量，对吧？这是个绝妙的主意。其实这并不是一个绝妙的主意。
- en: So I'm going to say here population equals zero。 I'm going to create that global
    variable。 Then I'm going to create the class。 And here's what I'm going to do。
    Every single time I。 create a new instance， we're going to go through Dunder in
    it。 And so every single time I can。 add one to the population。 And so before I
    create my instances， I'm going to say before。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我在这里要说的是人口等于零。我将创建那个全局变量。然后我要创建这个类。接下来我要做的是，每次我创建一个新实例时，我们都会通过 Dunder init。每次我都可以给人口加一。因此，在我创建我的实例之前，我要说之前。
- en: population equals that。 And afterwards， I'm going to say population equals that。
    It's。 going to start at zero。 It's going to end at two。 It's going to be fantastic
    until it's， not。 Unbound local error。 I hope each of you has a favorite Python
    error。 Because this。 is my favorite one。 Because it confuses the heck out of all
    sorts of people。 Unbound local， error。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 人口等于那个。然后，我要说人口等于那个。它会从零开始。它将以二结束。这将是精彩的，直到它，不再是。未绑定的局部错误。我希望你们每个人都有一个最喜欢的 Python
    错误。因为这是我最喜欢的一个。因为它让各种人困惑不已。未绑定局部错误。
- en: What does that mean？ Well， binding is a way of saying assignment。 It basically，
    means， hey dummy。 you have a local variable that doesn't have a value。 But you're
    trying。 to retrieve that value anyway。 Well， wait， how can that be？ Because normally
    in Python， I mean。 look， in other languages， you can declare a variable and then
    not give it a value。 You。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么意思？好吧，绑定是一种赋值的方式。基本上，这意味着，嘿，傻瓜。你有一个没有值的局部变量。但你还是试图检索那个值。等一下，这怎么可能呢？因为在Python中，我的意思是。看，在其他语言中，你可以声明一个变量，然后不赋值。你。
- en: can end up with this sort of thing。 But in Python， we don't have declarations。
    Well， other than。 whoa， what an amazing language。 So basically， how can I have
    a variable that doesn't have， a value？
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会遇到这种情况。但在Python中，我们没有声明。除了。哇，真是一个惊人的语言。那么基本上，我怎么会有一个没有值的变量呢？
- en: And the answer is because it's local。 Because when I'm inside a dunder in it
    there。 I'm inside of a function。 And inside of a function， if I assign to a variable，
    that。 variable is local by definition。 Python keeps track of this and says， aha，
    you assigned a。 population， population is local。 But that's a compilation time。
    Then I run the function， and says。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是因为它是局部的。因为当我在一个dunder内时。我在一个函数内部。在函数内部，如果我给一个变量赋值，那么。这个变量根据定义是局部的。Python会跟踪这一点并说，啊哈，你赋值了一个。population，population是局部的。但这是编译时。然后我运行这个函数，并说。
- en: OK， I need one plus the current value of， oh my god， unbound local error。 So，
    what am I going to do？
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我需要一个加上当前值，哦，我的天，未绑定局部错误。那么，我要怎么做呢？
- en: Well， one possibility is to use global。 Not a good solution。 One， possibility
    is to use global。 And the global statement says， hey， Python， when you compile，
    this function。 don't record population as a local variable， pay no attention to
    that。 Instead。 assign to the global variable。 And indeed， that works。 I can say
    here population， equals zero。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，一个可能性是使用global。这不是一个好的解决方案。一个可能性是使用global。global语句说，嘿，Python，当你编译这个函数时。不要将population记录为局部变量，不要理会它。相反。赋值给全局变量。确实，这有效。我可以在这里说population，等于零。
- en: Here we'll get zero。 Here we'll get two。 All is good。 But it's not。 Because。
    you really shouldn't be using global variables unless you absolutely， positively
    have to。 And this is not so good。 But we have a better solution。 Remember， everything
    in Python is。 an object， including classes。 Every object has attributes。 We can
    set and retrieve attributes。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们会得到零。这里我们会得到二。一切都很好。但其实并不是。因为。除非你绝对，肯定需要，否则你真的不应该使用全局变量。这并不好。但我们有更好的解决方案。记住，Python中的一切都是。一个对象，包括类。每个对象都有属性。我们可以设置和检索属性。
- en: on every object。 So how about， how about it？ We set an attribute on the person
    class。 So here's what I'm going to do。 I'm going to take my class person。 And
    after I define， it。 then I'm going to add population to it。 Can I do that？ Absolutely，
    I can do that。 Don't do this。 But you can absolutely， positively do it。 And it
    will work。 As I like to say， unfortunately。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都有。所以怎么样呢，怎么样呢？我们在人员类上设置一个属性。那么，我要做的就是。我会拿我的类person。在我定义它之后，然后我会把population添加到它。可以这样做吗？当然可以，绝对可以。不要这样做。但你可以绝对，肯定地做到这一点。而且它会有效。正如我喜欢说的，不幸的是。
- en: this works。 Right？ Like， it will give you the right solution。 And here what
    we see is we。 can't talk about population anymore as a global variable。 Because
    it's not。 It's not。 a variable at all。 It's an attribute。 An attribute on person。
    But I think we can all agree。 This is pretty ugly。 Or， as we call it， the consulting
    industry。 An opportunity。 So first。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效。对吧？就像，它会给你正确的解决方案。在这里我们看到的是，我们。不能再将population视为全局变量。因为它不是。根本不是。它是一个属性。一个在person上的属性。但我认为我们都可以同意。这看起来相当丑陋。或者，正如我们所说的，咨询行业。一个机会。所以首先。
- en: we're creating the person class。 And then after we're done， we add the population
    attribute， to it。 This cannot possibly be the best way。 Well， I have a solution。
    The solution is quiz， time。 What will this code print？ So I took basically what
    I had here with a person class。 And I got rid of the population stuff。 And I added
    a few print statements。 So the question， is。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建人员类。然后在我们完成后，我们将population属性添加到它。这不可能是最好的方法。好吧，我有一个解决方案。解决方案是测验时间。这段代码将打印什么？所以我基本上拿了我这里的人员类。然后我去掉了population的内容。并添加了一些打印语句。那么问题是。
- en: what will be printed in what order？ And I am such a nice guy， I will give you
    a hint。 A will be printed first。 After that， you're kind of on your own。 All right，
    fine。 I'll。 reveal the answer。 The answer is A， B， D， E， C， C。 Okay。 Well， what's
    going on here？
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么将以什么顺序打印？而我是个好人，我会给你一个提示。A会首先打印。之后，你就得靠自己了。好吧，没问题，我会揭示答案。答案是A，B，D，E，C，C。那么这里发生了什么？
- en: Because that is not obvious to an awful lot of people。 I showed this too。 And
    I really。 enjoy showing this to people because it forces you to really think for
    a lot of these issues。 And it's not obvious to have any to do with classes。 So
    print A， done。 But many people。 especially those coming from statically compiled
    languages， say， well， okay， this print B here。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这对很多人来说并不明显。我也给他们展示过这个。我真的很喜欢给人们展示这个，因为它迫使你认真思考很多这些问题。而且这与类没有任何明显的关系。所以打印A，完成了。但许多人，特别是那些来自静态编译语言的人，会说，好吧，这里打印B。
- en: that's not going to run at all。 Or maybe it's going to run and then like they
    start trying。 to figure it out and it just sort of doesn't work。 But actually
    it's printed right away。 And then they say， oh， I get it。 A then B。 Obviously
    then we're going to print C next。 No。 we print D next。 We skip over C。 So something
    is going， something is very weird there。 And。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这根本不会运行。或者也许它会运行，然后他们开始尝试去搞清楚，但就是不工作。但实际上，它立刻被打印出来。然后他们说，哦，我明白了。A，然后B。显然我们接下来要打印C。不是的，我们接下来打印D。我们跳过C。所以有什么地方出错了，有点奇怪。
- en: it's not just if you're overseas。 So then we have D。 Then we have E。 And then
    finally。 we print C and we print it twice。 So what's going on？ And part of the
    reason why people。 get confused by this is that functions and classes look almost
    exactly the same。 So before。 this can happen， before we can have person invoked。
    And before we can then call Dunder， in it。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是你在海外的时候。所以接下来我们有D。然后我们有E。最后，我们打印C，并且打印两次。那么发生了什么？人们之所以困惑的部分原因是函数和类看起来几乎一模一样。所以在这之前，这能发生之前，我们需要有被调用的人。
- en: Dunder in it needs to be there。 Functions and classes look the same， but function
    bodies。 are not executed when we define the functions。 But class bodies need to
    execute when we define。 the class。 Otherwise there's no Dunder in it for us to
    call on our brand new object。 So what that means is that when I define a class
    is executed line by line by line。 But。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Dunder需要在那儿。函数和类看起来一样，但函数体在定义函数时并不会被执行。但类体在定义类时需要被执行。否则就没有Dunder可以在我们全新的对象上调用。那么这意味着当我定义一个类时，它是逐行执行的。
- en: wait a second。 In my class I had Dunder in it。 Shouldn't the body of Dunder
    in it run？ No。 because a function body does not run when you define it。 The function
    body only runs。 when you actually run it。 But there's something kind of weird
    going on here。 What about death？
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下。在我的类中，我有Dunder。难道Dunder的主体不应该运行吗？不，因为函数体在定义时不会运行。函数体只有在你实际运行时才会运行。但这里发生了一些奇怪的事情。那死亡呢？
- en: Death does two things。 It creates a new function object and it assigns that
    object to a variable。 that functions name。 But here death is defining Dunder in
    it， which is what？ It's an attribute。 It's an attribute。 Methods are attributes。
    And so Dunder in it is an attribute on the。 class just like the attribute we set
    before population。 This happens to be a function attribute。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 死亡做两件事。它创建一个新的函数对象，并把该对象分配给一个变量，也就是函数的名称。但在这里死亡定义了Dunder，它是什么？它是一个属性。它是一个属性。方法是属性。因此Dunder是在类上的一个属性，就像我们之前设置的人口属性。这恰好是一个函数属性。
- en: It wasn't integer。 In both cases attributes on the class we define them in different
    ways。 We use death to define it。 But something still doesn't make sense here。
    I've got in。 it as a class attribute。 How can it be that death is now defining
    an attribute when it。 usually defines a variable？ The reason is you can think
    of classes as fileless modules。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是整数。在这两种情况下，我们在类上的属性定义方式不同。我们用死亡来定义它。但这里还是有些不合理。我把它当作类属性。怎么可能死亡现在定义了一个属性，而通常是定义一个变量呢？原因是你可以把类看作无文件模块。
- en: Modules without a file。 Functions in a class body are class attributes。 Inside
    of the class。 they look like variables。 But outside the class， they look like
    attributes。 It's just like， modules。 When you define a function or a variable
    in a module file， inside of the file， that's a global。 But outside the file， I
    have it as an attribute on the module object that， I have defined。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 没有文件的模块。类体中的函数是类属性。在类内部，它们看起来像变量。但在类外部，它们看起来像属性。这就像模块。当你在模块文件中定义一个函数或变量时，在文件内部，这是一个全局变量。但在文件外部，我将其作为我定义的模块对象上的属性。
- en: that I've imported。 So any functions we define inside of a class aren't， variables。
    They're attributes。 Attributes on our class。 And any assignments we thus make。
    in a class don't create variables。 They create attributes also。 Which means I
    can go back。 to my person class from before。 And I can say population equals zero。
    Just like that。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经导入了。所以我们在类内部定义的任何函数都不是变量。它们是属性。我们类上的属性。因此我们在类中进行的任何赋值都不会创建变量。它们也会创建属性。这意味着我可以回到之前的
    person 类。我可以说 population 等于零。就这样。
- en: I'm not at all creating a variable。 It's not a global variable。 It's not a variable
    at， all。 It is an attribute。 Person。population。 By the way， sometimes people say，
    well， why。 don't we then call it person。population side of the class。 And the
    reason is that the name。 person is only defined after the class body has been
    run。 So you can't do that。 Some people。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是在创建一个变量。这不是一个全局变量。这根本不是一个变量。这是一个属性。Person.population。顺便说一句，有时候人们会问，为什么我们不把它称为类的
    person.population 方面呢？原因是，名称 person 只有在类体运行后才被定义。所以你不能这样做。有些人。
- en: look at this and they're like， oh， I've seen these before。 I come for a background
    in C++。 And we call these static variables。 And I say， please don't use obscene
    language in my classes。 But the thing is you shouldn't talk this way because it
    mixes things up。 Static variables。 are shared。 They're shared among the class
    and the instances。 But attributes are not shared。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 看这个，他们会想，哦，我以前见过这些。我有 C++ 的背景。我们称这些为静态变量。我会说，请不要在我的课上使用粗俗的语言。但问题是你不应该这样说，因为这会混淆概念。静态变量是共享的。它们在类和实例之间是共享的。但属性则不是共享的。
- en: The names are not shared。 They can all reference。 They can all point to the
    same object。 But。 an attribute only exists in the class。 Python does not have
    the idea of a shared attribute。 It just doesn't exist in language。 Well， let's
    see that。 Let's see that they're different。 So I'm going to add a little code
    here。 I'm going to say after we've created our two person。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 名称并不是共享的。它们可以全部引用。它们可以指向同一个对象。但是，属性只存在于类中。Python 没有共享属性的概念。它在语言中根本不存在。好吧，让我们看看。让我们看看它们是不同的。所以我将添加一点代码。我将说在我们创建了两个
    person 之后。
- en: objects， person。population。 And I'm going to show you。 We're not going to get
    anything。 from P1 and P2 population。 See， person population I get to， P1 population
    I get to， P2 population。 I get to。 Uh oh。 It worked。 And we got the same values。
    So maybe they are really shared。 Nope。 This is where I introduce what I call ICPO。
    The attribute look up path in Python。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对象，person.population。我将向你展示。我们不会从 P1 和 P2 的 population 中获得任何东西。看，person population
    我得到了，P1 population 我得到了，P2 population。我得到了。哎呀。它成功了。我们得到了相同的值。所以也许它们真的共享。不是的。这就是我介绍我称之为
    ICPO 的地方。Python 中的属性查找路径。
- en: Instance class parent object。 This is how Python looks for attributes all the
    time， all of。 the time。 And once you understand this， a whole lot of other things
    in Python start。 to make more sense。 So what is this ICPO rule？ First of all，
    Python looks on the object you。 actually talked about。 The instance itself and
    says， does this attribute exist here？ If， so， great。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实例类父对象。这就是 Python 一直在查找属性的方式，一直如此。而一旦你理解了这一点，Python 中许多其他事情就开始变得更有意义。那么这个 ICPO
    规则是什么呢？首先，Python 在你实际提到的对象上查找。实例本身，并询问，这个属性在这里存在吗？如果存在，那就太好了。
- en: We stop。 We have the value。 If not， we're not going to give up right away。 We
    go to the class。 Does the instance class have this attribute？ If so， great。 If
    not， we keep going to the parent。 We'll talk about that later， but we look it
    up at the parent。 And if not there， then an object。 the top of the class hierarchy。
    So let's walk through， this。 I say person。population。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们停止。我们有了值。如果没有，我们不会立刻放弃。我们去看类。实例类是否有这个属性？如果有，那就太好了。如果没有，我们继续去查找父类。我们稍后会谈到这个，但我们会在父类中查找。如果那里也没有，那么就是类层次结构的顶层对象。所以让我们一步步来看。我说
    person.population。
- en: Python turns to， I know it doesn't feel like an instance， but classes are objects。
    Unless their instances， does person have the attribute population？ The， answer
    is yes。 We get the value to end of story。 And then Python says， hey， P1， do you。
    have the attribute population？ And the answer is no。 But Python doesn't give up。
    It says， oh， I see。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Python转向，我知道它感觉不像一个实例，但类是对象。除非它们的实例，P1这个人有属性population吗？答案是有。我们得到这个值，故事结束。然后Python问，嘿，P1，你有属性population吗？答案是没有。但Python没有放弃。它说，哦，我明白了。
- en: Oh， I'll check on the class。 Does person P1's class have the attribute population？
    It does。 And we get the value back too。 I can also say P2。 Does P2 have it no？
    Does person， have it yes？
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，我会检查一下这个班级。P1这个人的类有属性population吗？有。我们也得到了值。我还可以说P2。P2有这个属性吗？没有。这个人，有吗？有。
- en: And we get it back。 Now I should note， this assumes we have not assigned an。
    attribute population to P1 or P2。 If you do that， all bets are off。 Because then
    it will。 find the attribute on the instance。 And it won't continue to the class。
    And you'll end。 up with a terrible， terrible situation。 Don't do that。 My CPO
    explains method lookup。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了结果。现在我应该指出，这假设我们没有给P1或P2分配属性population。如果你这么做，所有的赌注都没有了。因为那样它会在实例上找到属性。而不会继续到类。最后你会陷入一个糟糕、糟糕的境地。不要这么做。我的CPO解释了方法查找。
- en: It really does。 Because if now I have a new version of person， right？
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 确实有。因为如果我现在有一个新版本的人，对吧？
- en: And this version of person has a new method。 It has the greet method。 And so
    I can。 say P1 equals person name one， P2 equals person name two， nine， my two
    people。 Let's。 say hello to them。 P1。greet。 What happens here？ Python turns to
    P1 and says， does it。 have the attribute greet？ And the answer is no。 So it turns
    to the class。 Does person。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的人有一个新方法。它有greet方法。所以我可以说P1等于person name one，P2等于person name two，我的两个朋友。我们来给他们打个招呼。P1.greet。这里发生了什么？Python转向P1，问它是否有greet属性？答案是没有。于是它转向类。这个人。
- en: have the attribute greet？ The answer is yes。 We get back that method object
    and we execute， it。 And then we do the same thing here。 P2。 Does it have attribute
    greet？ No。 Does person， have it yes？
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有greet属性？答案是有。我们得到了那个方法对象并执行它。然后我们在这里做同样的事情。P2。它有greet属性吗？没有。这个人有吗？有。
- en: We get back the method object and we execute it。 And it works great。 The。 method
    here is defined as a class attribute。 But we access it via the instance。 Okay。
    Let's try a new class。 Right？ Our person object is such a roaring success。 My
    boss has come。 back to me and said， listen， we need something new。 We need an
    employee class。 And employees。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了方法对象并执行它。效果很好。这里的方法被定义为类属性。但我们通过实例访问它。好的。让我们试试一个新类。对吧？我们的person对象如此成功。我的老板回到我身边，说，听着，我们需要一些新东西。我们需要一个employee类。员工。
- en: are almost like people。 Sometimes employees even are people。 But that depends
    on the company。 you're working for。 So employees， unlike people， are created with
    two attributes。 Name and ID。 number。 Otherwise， they're the same as people。 So
    we have to have some distinction。 So what。 do I do？ I say do my boss listen。 I
    know exactly what I'm going to do。 Give me a month。 And my。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 员工几乎就像人一样。有时员工甚至是人。但这取决于你工作的公司。因此，员工与人不同，是通过两个属性创建的。名字和ID号码。否则，他们和人是一样的。所以我们必须有一些区别。那么，我该怎么办？我说我的老板在听。我知道我会做什么。给我一个月的时间。
- en: boss says， sounds great。 See in a month。 And I think， ha， I'm going to do this
    in five， minutes。 And I'll watch TikTok videos the rest of the month。 Perfect。
    So here I have， my person class。 And I now use the most powerful tool in a programmer's
    arsenal。 Copy paste。 And I define my employee class making a few slight adjustments。
    I add an assignment to。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 老板说，听起来不错。一个月后见。我想，哈，我打算在五分钟内搞定这个。然后这个月我就看TikTok视频。太好了。所以这里我有了我的person类。我现在使用程序员工具箱中最强大的工具。复制粘贴。我定义我的employee类，做一些轻微的调整。我增加了一个赋值。
- en: self ID number based on ID number。 And then I can create a new employee。 I call
    it E1， greet。 E2 greet。 And it's fantastic。 And I am feeling great about myself
    because now I。 have a whole month to improve my ridiculous dances。 My boss come
    back a month later。 And。 as bosses always do in software companies wants to inspect
    my code。 Looks at my code， and says。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 根据ID号码生成自我ID号码。然后我可以创建一个新员工。我叫它E1，greet。E2，greet。太棒了。我觉得自己棒极了，因为现在我有整整一个月来改善我的舞蹈。我的老板一个月后回来。像所有软件公司老板一样，想检查我的代码。看看我的代码，说。
- en: why am I spending so much money on Python training and conferences for you when。
    all you did was copy and paste。 Why didn't you use inheritance？ I say， inheritance。
    Right。 Give me another month。 I promise it'll be better。 Sounds good。 Boss walks
    away。 I'll see。 in a month。 So let's try this again， except with inheritance。
    What do I do here？ I put。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我花这么多钱在 Python 培训和会议上，而你所做的只是复制和粘贴？你为什么不使用继承？我说，继承。对吧。再给我一个月。我保证会更好。听起来不错。老板走开了。一个月后见。所以我们再试一次，只不过使用继承。我该怎么做？我放。
- en: person in parentheses after employee。 This says， employee is a person。 Employee
    inherits。 from person。 What does that really do？ It inserts person into the ICPO
    search。 It means。 now that if we don't find an attribute on the class， we will
    look for it in the class as， parent。 If we don't find an attribute， a method basically，
    an employee， we will look， for it in person。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 employee 后面加上 person 的括号。这表示，employee 是一个 person。Employee 继承自 person。这到底意味着什么？它将
    person 插入到 ICPO 搜索中。这意味着，现在如果我们在类中找不到属性，我们将作为父类进行查找。如果我们在 employee 中找不到属性，基本上是一个方法，我们会在
    person 中查找。
- en: And sure enough now， I call E1。greet。 What happens？ Python says， does E1， have
    greet？
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 结果果然，现在我调用 E1.greet。发生了什么？Python 说，E1 有 greet 吗？
- en: The answer is no。 Does this class employee have greet？ The answer is yes。 End，
    of search。 We have accomplished nothing at all through our inheritance。 So yes，
    we inherit， from person。 but we're not taking advantage of it。 So let's take advantage
    of it now。 Let's， use inheritance。 And we can take advantage of it because the
    greet method is exactly the。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的。这类员工有 greet 吗？答案是肯定的。搜索结束。我们通过继承并没有取得任何成果。所以是的，我们从个人那里继承，但我们并没有利用它。所以现在让我们利用它。让我们使用继承。我们可以利用它，因为
    greet 方法正是如此。
- en: same in both person and employee。 So we can get rid of it in employee。 And so
    I say here。 class employee， just like before， except I've gotten rid of the greet
    method。 And now when。 I call greet， what happens？ Python asks E1。 Do you have
    an attribute greet？ The answer is， no。 It asks the class employee， do you have
    the attribute greet？ The answer is no。 So we。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 person 和 employee 中是相同的。因此我们可以在 employee 中去掉它。所以我在这里说。class employee，跟以前一样，只是我去掉了
    greet 方法。现在当我调用 greet 时，发生了什么？Python 问 E1。你有属性 greet 吗？答案是，否。它问 class employee，你有属性
    greet 吗？答案是否。所以我们。
- en: go to the parent。 Do you have the attribute greet？ The answer is yes。 We get
    back the method。 we run it， all is good。 And the same thing happens with E2。 So
    a lot of people look at。 this code and they say， oh， inheritance sounds great。
    And then they say wait。 We can improve。 this code even more。 Because name， I'm
    setting name and employee。 I can also set name， why。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 去父类。你有属性 greet 吗？答案是肯定的。我们得到了方法。我们运行它，一切都很好。E2 也发生了同样的事情。因此，很多人看到这段代码时说，哦，继承听起来很棒。然后他们说等等。我们可以进一步改进这段代码。因为
    name，我设置 name 和 employee。我也可以设置 name，为什么？
- en: am I setting name and employee and also setting it in person？ I can just get
    rid of it in employee。 And all will be great。 So here I have name being passed
    in and nothing having to do with。 name because I am an optimistic person and I
    assume that person will take care of it。 Yeah。 except it won't。 Employee has no
    attribute name。 And I say what？ How can that be？ And I。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我是否在设置 name 和 employee，同时也在个人中设置？我可以直接在 employee 中去掉它。一切都会很棒。所以在这里，我传入 name，跟
    name 无关，因为我是个乐观的人，我假设个人会处理好这一切。是的，除了它不会。Employee 没有属性 name。我说，什么？这怎么可能？我。
- en: decide to run the var's function on it。 Just a double check。 And I see that
    E1 has only。 an ID number and E2 has only an ID number。 And perhaps you feel this
    way sometimes at。 work that they don't really believe you have a name。 Just a
    number。 But that's a bug， not。 a feature。 Or so I'd like to think。 So what's going
    on here？ Well， here's the thing。 The。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 决定在其上运行 var 的函数。只是确认一下。我看到 E1 只有一个 ID 号，E2 只有一个 ID 号。也许你有时在工作中会感觉他们并不真的相信你有一个名字。只是一个数字。但这是一个错误，而不是一个特性。或者我想这么认为。那么这里发生了什么？好吧，事情是这样的。
- en: name attribute was never set。 We never got to person。thunder in it in which
    name was set。 And the problem is basically this。 We created a new instance of
    employee。 We asked the。 new instance do you have in it？ No。 We asked employee
    do you have in it？ Yes。 That ran。 we never got to person in it because it never
    ran。 Name was not added。 People coming from。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: name 属性从未设置。我们从未到达 person.thunder，在那里设置了 name。问题基本上是这样的。我们创建了 employee 的新实例。我们问新的实例你有它吗？没有。我们问
    employee 你有它吗？是的。那段运行了。我们从未到达 person，因为它从未运行。name 没有被添加。来自的人。
- en: statically compiled languages are often surprised by this because they see classes
    as a set of。 declarations。 And they say oh， the subclasses declarations and the
    superclasses declarations。 will be merged together。 So I get all of these different
    fields。 I get all of these different。 attributes set。 But that's not how it works
    in Python。 We set these attributes explicitly。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 静态编译语言常常对此感到惊讶，因为它们将类视为一组声明。它们会说，哦，子类的声明和父类的声明会合并在一起。所以我得到了所有这些不同的字段。我得到了所有这些不同的属性集。但是在
    Python 中并不是这样。我们显式地设置这些属性。
- en: in Python and under in it。 You don't run under in it。 The attributes not set。
    And so what。 can we do about this？ We have a few different possibilities。 One
    is to explicitly call person。 under in it。 Right there inside of employee in it。
    I can say yeah， I can run it。 There's。 nothing technically wrong with this。 But
    this is where， right， gives me the right answer。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 和在它上，你不在它上运行。属性没有被设置。那么我们能对此做些什么呢？我们有几种不同的可能性。一个是在 employee 的内部明确调用
    person。的内容。就在那儿，我可以说，是的，我可以运行它。这在技术上没有问题。但这正是，给了我正确的答案。
- en: But it's better to use super here。 Super basically says it's a proxy and it
    says I will figure。 out who we can run under in it on。 And it goes up the chain。
    It says oh， person has， done in it。 I'll run that。 Fantastic。 And then we get
    M1。 We get hello M2。 All is good。 So this is how we see attributes in use on the
    instance， on the class and on the parent。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这里使用 super 更好。Super 基本上说它是一个代理，并且它会说我会弄清楚我们可以在它上运行什么。它会向上遍历链。它会说，哦，person
    有在它上执行的内容。我会运行那个。太好了。然后我们得到了 M1。我们得到了 hello M2。一切都很好。这就是我们在实例、类和父类上看到属性的使用方式。
- en: And I should add if we have multiple parents， right， if we have something that
    hurts from。 something that hurts from something that hurts from something that
    hurts from something， it。 will just go up that whole chain until it gets to object。
    Object is the top object。 Top class in our object hierarchy。 And let's talk about
    that a bit。 What happens when I。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我还应该补充，如果我们有多个父类，对吧，如果我们有某个东西源于某个东西，而这个东西又源于某个东西，这样层层递上去，直到它到达对象。对象是我们对象层次结构中的顶级对象。让我们聊聊这个。当我。
- en: print P1 or print E1？ First of all， I get back something that's just horribly
    ugly。 I will never understand why this is like considered the default， but fine。
    It is。 Anyway， why？
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 P1 还是打印 E1？首先，我得到的东西实在是太丑了。我永远无法理解为什么这被视为默认值，但好吧，确实如此。无论如何，为什么？
- en: Because when I call print， print， why can we print anything in Python？ Because
    print turns。 its argument into a string。 How do we turn something into a string？
    We call it stir on， it。 What happens when we call stir on it？ It looks for a dunder
    stir。 And the dunder stir。 method with P1 does P1 have dunder stir？ No。 Does P1's
    class person have dunder stir？ No。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因为当我调用 print，print 时，为什么我们可以在 Python 中打印任何东西？因为 print 会将其参数转换为字符串。我们如何将某个东西转换为字符串？我们在它上调用
    stir。那么，当我们在它上调用 stir 时会发生什么？它会寻找一个 dunder stir。P1 有 dunder stir 方法吗？没有。P1 的类
    person 有 dunder stir 吗？没有。
- en: Does object have stir？ Yes。 So we get the default implementation of dunder stir。
    And。 that's where we get the default ugly result that we saw。 And with E1， it's
    basically the。 same thing just with an added step。 Does E1 have dunder stir？ No。
    Does E1's class employee。 have dunder stir？ No。 Does E1's class's parent person
    have dunder stir？ No。 Does object have， it？
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对象有 stir 吗？是的。所以我们得到了 dunder stir 的默认实现。这就是我们看到的默认丑陋结果。而对于 E1，它基本上是同样的事情，只是多了一步。E1
    有 dunder stir 吗？没有。E1 的类 employee 有 dunder stir 吗？没有。E1 的类的父类 person 有 dunder
    stir 吗？没有。对象有它吗？
- en: Yes。 We get it all good。 This is how we can do operator overloading。 Attribute
    look， up。 If you define dunder stir in your class， you're basically stopping the
    search at an， earlier stage。 And thus you never get to dunder stir in object。
    But something is still missing。 Python loves to be explicit。 And Python loves
    to work without magic。 We in the Python would。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。我们都明白了。这就是我们如何进行运算符重载的。属性查找。如果你在你的类中定义了 dunder stir，你基本上是在更早的阶段停止了搜索。因此，你永远无法到达对象中的
    dunder stir。但是仍然有一些东西缺失。Python 喜欢明确。Python 喜欢没有魔法地工作。我们在 Python 中。
- en: like to laugh at those other languages that had magic。 You know， explicit is
    better than， implicit。 But there's a big piece of magic here that we all know
    about and that we don't。 complain about too much。 And that is method rewriting。
    So you might know this and you， might not。 But basically， if I have s equals abcd
    and then I call s dot upper， I get back， abcd。 Great。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢嘲笑那些有魔法的其他语言。你知道，显式优于隐式。但这里有一块我们都知道的魔法，我们并不抱怨太多。那就是方法重写。你可能知道这一点，也可能不知道。但基本上，如果我有
    s 等于 abcd，然后我调用 s.dot upper，我得到的是 abcd。太好了。
- en: That's the normal way we would invoke a method。 But I can also say stir dot，
    upper of s。 And that works also。 It's exactly the same thing。 But something's
    wrong here。 Something's a little weird。 We know that methods are stored in class
    attributes。 And。 we know that we can retrieve a class attribute， either the class
    or the instance。 But somehow。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们调用方法的正常方式。但我也可以说 stir.dot upper of s。这也是可行的。这是完全一样的。但这里有点问题。有什么地方不对劲。我们知道方法存储在类属性中。我们知道我们可以从类或实例中检索类属性。但不知怎么的。
- en: we're getting different behavior depending on how we retrieve it。 Let's just
    look at that。 again for a moment。 Go back here。 Here we go。 Right。 I'm asking
    for the dunder of the dot， upper。 I'm asking for the upper attribute。 I can ask
    for it on the instance。 I can ask， it on the class。 In one case， it expects to
    get in the class case， it expects to get， the instance as an argument。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们检索的方式，我们得到了不同的行为。让我们再看看这一点。回到这里。好吧。我在请求 dunder 的 dot upper。我在请求 upper 属性。我可以在实例上请求它。我可以在类上请求它。在一种情况下，它期望在类的情况下，作为参数获取实例。
- en: But in the instance case， it does not。 So what's going on here？ Well， let's
    ask person dot greet。 What do we get back？ We get back a function， a plain， old
    Python function。 P1 dot greet。 I get a bound method。 Huh。 That's kind of weird。
    What's， going on？ And the answer is descriptors。 Normally when I retrieve a class
    attribute， I get the， object stored in that attribute。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但在实例的情况下，它不会。因此，这里发生了什么？好吧，让我们问 person.dot greet。我们得到的是什么？我们得到一个函数，一个普通的 Python
    函数。P1.dot greet。我得到了一个绑定方法。哈。这有点奇怪。发生了什么？答案是描述符。通常，当我检索类属性时，我得到存储在该属性中的对象。
- en: That's the normal behavior that we've seen so far that， you've probably seen
    day to day。 And you don't think much more about it than that。 But if， the attributes
    has a dunderget method。 that is to say if the attribute is of a type and， that
    type has dunderget installed。 then the result of dunderget is returned instead。
    Let's， try this。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们到目前为止看到的正常行为，你可能在日常生活中也见过。你对此不会多想。但如果该属性有一个 dunderget 方法。也就是说，如果该属性属于某个类型，而该类型安装了
    dunderget。那么，返回的结果将是 dunderget 的结果。让我们试试这个。
- en: I'm going to say here class loud number。 All right。 And basically this is just。
    going to store an integer for us。 Nothing too exciting。 And I should add by the
    way descriptors。 can be very， very complex。 I'm not going to all descriptors here。
    I'm just sort of showing。 it to you at a higher level。 But you'll sort of get
    the gist here， I think。 So basically。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里要定义类 loud number。好的。基本上，这只是会为我们存储一个整数。没什么太令人兴奋的。我应该顺便提一下，描述符可以非常复杂。我不会在这里讨论所有描述符。我只是以更高的层次向你展示它。但你应该能大致明白。因此。
- en: I have my class。 This is a totally reasonable class， right？ Dunder in itself
    N。 And then。 when we run Dunder in it， we're going to print out that we're there。
    And we're going。 to assign self N equals N。 And then dunderget， this is that special
    method。 We're going to。 say self， and I'm just going to sort of paper over the
    arguments we get for now。 We're going。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我有我的课程。这是一门完全合理的课程，对吧？Dunder 本身是 N。然后，当我们在其中运行 Dunder 时，我们将打印出我们在那里的信息。我们将会将
    self N 赋值为 N。然后 dunderget，这是那个特殊的方法。我们将说 self，我只是暂时不详细讨论我们收到的参数。我们将。
- en: to get into it in a moment。 Splat args， meaning all whatever positional arguments
    you want， to pass。 that's fine。 And then here， what are we going to do？ We're
    going to return self， dot N。 If I assign an instance of loud number to a very
    special， nothing special happens。 But if I assign it to a class attribute， magic
    happens。 Let's see。 So let's say class person。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会进入这个。Splat args，意味着你想传递的所有位置参数，这没问题。那么我们将怎么做呢？我们将返回 self.dot N。如果我将 loud
    number 的一个实例赋值给一个非常特殊的属性，什么也不会发生。但如果我将它赋值给一个类属性，魔法就会发生。我们来看看。所以假设我们定义类 person。
- en: age equals loud number 30。 Right？ So what am I doing here？ I'm creating a person
    class。 And the person class is nothing else。 And I'm just concentrating right
    now on this descriptor。 And I say， let's make age equal to an instance， one new
    instance of loud number 30。 When I， now ask。 well， when I run that， I get in loud
    number in it and equals 30 because we ran that， code。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: age等于loud number 30，对吗？那么我在这里做什么？我正在创建一个person类。这个person类什么都不是。我现在只是专注于这个描述符。我说，让年龄等于一个新的loud
    number 30的实例。当我现在问时。好吧，当我运行时，我得到loud number的初始化并等于30，因为我们运行了那个代码。
- en: It's part of the class definition。 When we define a class， the class definition
    runs。 When I say P equals person， great。 We've created a new instance of person。
    And when I say， whoops。 Oh， no， no， no， no， no， no， come back。 Well， end of talk，
    folks。 Hope to live， you in suspense。 It was much worse when that happened during
    my dissertation defense。 Anyway， what's going on here？
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它是类定义的一部分。当我们定义一个类时，类定义会运行。当我说P等于person时，太好了。我们创建了person的新实例。当我说，哎呀。不，不，不，不，不，回来。好吧，演讲结束，朋友们。希望你们保持悬念。那时在我的论文答辩期间发生时情况更糟。无论如何，这里发生了什么？
- en: What we have here is P， an instance of person。 It refers to an instance， of
    person。 Great。 That's not the truly interesting thing。 The truly interesting is
    that above， it， I have person。 which refers to the person class。 It has an attribute，
    age。 And what is， the value of age？
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有P，一个person的实例。它指的是一个person的实例。很好。这不是最有趣的事情。真正有趣的是，在它上面，我有person。它指的是person类。它有一个属性，age。那么，age的值是什么？
- en: It's an instance of loud number。 I know it's a little confusing to， keep track
    of。 But basically。 the class attribute is an object。 But of course， class attributes。
    are always objects because everything is an object in Python。 Just here， it's
    an object。 of a type that we created with this wacky dungger get method。 And watch
    this now。 I say， P。age。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个loud number的实例。我知道跟踪这一点有点混乱。但基本上，类属性是一个对象。当然，类属性总是对象，因为在Python中一切都是对象。只是这里，它是一个我们用这个奇怪的dungger
    get方法创建的类型的对象。现在看看这个。我说，P。age。
- en: I'm retrieving the class attribute via the instance。 And it invokes the method。
    Dungger get is running。 And then I get back 30。 And then I say person。age。 And
    the method。 is running and I get back 30。 That's kind of weird， right？ I mean，
    I did get the attribute。 value back。 But I didn't get the attribute itself。 I
    got the whatever dungger get in the。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过实例检索类属性。它调用了方法。Dungger get正在运行。然后我得到30。然后我说person.age。方法正在运行，我得到30。这有点奇怪，对吧？我的意思是，我确实得到了属性值。但是我没有得到属性本身。我得到了无论什么dungger
    get的。
- en: function to return to me。 Here's the weirder thing。 I did not use parentheses。
    In Python。 if I don't use parentheses， I don't invoke a method or a function。
    And here I did not。 use parentheses。 And yet， it was invoked。 What the heck？ So
    what are get parameters？
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 返回给我的功能。这更奇怪的是。我没有使用括号。在Python中。如果我不使用括号，我不会调用方法或函数。而在这里，我没有使用括号。然而，它被调用了。这是什么鬼？那么，获取参数是什么？
- en: What is it actually doing there？ Well， before I said it was just splat args。
    It actually。 gets two arguments。 And those two arguments are assigned to two parameters。
    And there。 are different names and conventions for calling these。 I call it object
    type。 Choose your own。 poison here。 So the first argument that we get after self
    is object。 From what instance。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上在做什么？好吧，之前我说它只是拆分参数。实际上，它获取两个参数。这两个参数被赋值给两个变量。调用这些参数有不同的名称和约定。我称之为对象类型。选择你自己的毒药。所以在self之后我们得到的第一个参数是对象。来自哪个实例。
- en: is the attribute being retrieved？ Right？ So through whom am I trying to retrieve
    this？
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 是正在检索的属性，对吗？那么，我试图通过谁来检索这个？
- en: And the second argument is in which class is this attribute stored。 So let's
    try this， again。 I'm going to create my class。 Age equals loud number 30。 And
    we see that。 And。 now I say p equals person a new instance。 And I say p dot age。
    And look at what I get。 for my in my printout。 It says object is an instance of
    person。 Well， that's true。 I。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是这个属性存储在哪个类中。那么我们再试一次。我将创建我的类。Age等于loud number 30。我们看到了。现在我说p等于person，一个新的实例。我说p.dot
    age。看看我在打印中得到的是什么。它说对象是person的一个实例。好吧，这是真的。
- en: accessed age via the instance of person p。 And the object is person， the class
    person。 So we know is like p dot age。 It invoked under get。 And under get knows
    on which instance。 and from which class。 And if I say person， if I say person
    dot age， object is none。 And。 still object type is the class person。 In other
    words， if I retrieve it via the class。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实例 person p 访问 age 时，对象就是 person，类是 person。所以我们知道像 p.dot age。它在 get 下被调用。并且
    get 知道是在哪个实例上，以及从哪个类中。如果我说 person，如果我说 person.dot age，对象是 None。但对象类型仍然是类 person。换句话说，如果我通过类检索它。
- en: object is none。 But if I retrieve it via the instance， object is the instance
    on which， I ran that。 Whoops， come back。 So here's the thing。 You use descriptors
    every single day。 Because methods are descriptors。 When we retrieve a method via
    the class， Python returns the。 original function。 But when we， and it can tell
    because object is set to none。 So we。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是 None。但如果我通过实例检索它，对象就是我运行它的实例。哎呀，回来。事情是这样的。你每天都在使用描述符，因为方法就是描述符。当我们通过类检索方法时，Python
    返回的是原始函数。但是当我们这样做时，它可以判断因为对象被设置为 None。所以我们。
- en: need to supply an instance as the first argument。 It knows， oh， I didn't get
    object here。 So。 we need to get that argument so that we can call the function
    correctly。 But when we。 retrieve a method via the instance， Python says， aha，
    what I want to do is take that instance。 object and turn it into the first argument，
    move it over there so that then we can call。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将实例作为第一个参数提供。它知道，哦，我在这里没有得到对象。所以我们需要获取那个参数，以便我们可以正确调用函数。但当我们通过实例检索方法时，Python
    说，啊哈，我想做的是获取那个实例对象并将其变为第一个参数，把它移到那里，以便我们可以调用。
- en: the original function with all of its arguments but with object at the front。
    Well， how's it。 going to do that？ And the answer is， partials。 So you might not
    be familiar with it but we。 have something in fun tools in Python called partials。
    So I can say， for example， death。 added a and b return a plus b totally normal
    addition function。 And then I say add five。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 原始函数及其所有参数，但将对象放在前面。那么，它将如何做到这一点呢？答案是，偏函数（partials）。你可能对它不太熟悉，但在 Python 的有趣工具中有个叫做偏函数的东西。所以我可以说，比如，添加（add）一个和
    b 返回 a 加 b，这是一个完全正常的加法函数。然后我说加五（add five）。
- en: equals partial of add and five。 Add five is a function object effectively。 It's
    a callable。 I can invoke it as you see down at the bottom。 I say add five of 10
    and it returns 15。 Because。 we sort of preloaded the first argument five on to
    add。 That's exactly what's going on。 here with our methods。 When I invoke a method
    via the instance， Python does the rewriting。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 等于 add 的偏函数和五。加五实际上是一个函数对象。它是一个可调用的。我可以像你看到的那样在底部调用它。我说 add five of 10，它返回 15。因为我们在
    add 上预加载了第一个参数五。这正是我们的方法在这里发生的情况。当我通过实例调用方法时，Python 会进行重写。
- en: and returns a partial。 It automatically assigns or binds that instance to the
    method。 Guess。 what it says here。 When I retrieve person。greed， it's just the
    function。 But in return p1。greed。 it's the bound method person greed to that particular
    object。 It's telling us what it's， doing。 But it's hard to understand without
    walking through all this attribute stuff。 Wait， a second。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 并返回一个偏函数。它自动将该实例分配或绑定到方法上。你知道它在这里说什么。当我检索 person.greed 时，它只是一个函数。但是在返回 p1.greed
    时，它是绑定到那个特定对象的 bound method person greed。它告诉我们它在做什么。但在没有逐步理解所有这些属性内容之前，这很难理解。等一下。
- en: What did it do with our original function？ Right？ Like it's very nice at all，
    to say， oh。 I defined my method and it was replaced with this， you know， descriptor
    magic。 But where is my original method greed？ And the answer is that it's put
    on another class， attribute。 It's sort of moved around to dunderdict。 And so the
    method name there is the key。 And。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它对我们的原始函数做了什么？对吧？就像说，哦，我定义了我的方法，它被替换成了这种描述符魔法。但我的原始方法 greed 到底在哪里？答案是，它被放在了另一个类属性上。它有点被移到
    dunder dict 中。所以那里的方法名称是关键。而。
- en: the original function is the value。 So if we ask for a method via the class，
    object is， none。 And we get back the original function。 The method descriptor
    just returns a function。 from dunderdict。 But if there is an object there， then
    Python basically creates a partial。 with our instance and that function returns
    them together and that is our method。 So when。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 原始函数就是那个值。所以如果我们通过类请求一个方法，对象就是 None。我们得到的是原始函数。方法描述符只是返回一个函数，来自 dunder dict。但如果有一个对象在那儿，Python
    基本上就创建了一个偏函数，将我们的实例与该函数一起返回，这就是我们的方法。所以，当。
- en: we ask for a。b in Python， an awful lot of stuff is going on。 Python looks for
    our attribute。 via iCPO。 When we finally find an attribute， it might be descriptor。
    And the descriptor。 then does some magic there depending on if we called it via
    the instance or via the class。 We use descriptors every single day without thinking
    about it very much。 And I should， add。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们请求 Python 中的 a.b 时，很多事情正在发生。Python 通过 iCPO 查找我们的属性。当我们最终找到一个属性时，它可能是描述符。而描述符根据我们是通过实例还是通过类调用它，做一些魔法。我们每天都在使用描述符，而不太考虑它。并且我应该补充。
- en: there are people who really want to implement descriptors。 You almost certainly
    don't have， to。 I think knowing the protocol is useful for a deeper understanding
    of Python。 But。 the odds of you actually implementing a descriptor on your own
    are very， very slim。 Most of the。 time if you think about implementing a descriptor，
    you can instead use what's known as a property。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人真的想实现描述符。你几乎不需要这样做。我认为了解协议有助于更深入地理解 Python。但实际上你自己实现描述符的几率非常非常小。大多数情况下，如果你考虑实现一个描述符，你可以使用所谓的属性。
- en: which is a much， much simpler form of descriptors that papers over a lot of
    this stuff。 But。 basically via these attributes， we get class attributes。 We get
    inheritance。 We get almost。 kind of sharing stuff between instances and classes。
    And we get the magic of methods and。 their rewriting。 All right。 We're at the
    end now。 Thank you very much。 Apparently we're。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种更简单的描述符形式，覆盖了很多内容。但基本上通过这些属性，我们获得类属性。我们获得继承。我们几乎能够在实例和类之间共享东西。我们获得方法的魔力和它们的重写。好了，现在到了结束。非常感谢大家。显然我们。
- en: not taking questions and sessions here。 But I will say if you want to come up，
    I have a。 booth in the expo。 You're welcome to come up and chat with me and ask
    me whatever questions。 you want， it will be my pleasure。 Thanks so much， everyone。
    [APPLAUSE]。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里不接受问题和讨论。但我想说，如果你想来，我在展会有一个展位。欢迎你来和我聊天，问我任何问题，我会很高兴。非常感谢大家。[掌声]。
- en: '![](img/51690c84e071188052a7d3143161d01e_3.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51690c84e071188052a7d3143161d01e_3.png)'
