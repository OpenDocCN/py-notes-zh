- en: P24：Talk - Bernát Gábor_ How we standardized editable installs   PEP 660 vs  PEP
    662 - VikingDen7 - BV1f8411Y7cP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P24：演讲 - Bernát Gábor_ 如何标准化可编辑安装 PEP 660 与 PEP 662 - VikingDen7 - BV1f8411Y7cP
- en: Okay， up next we have Bernat Gabor with how we standardize editable installs，
    PEP660 versus。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 Bernat Gabor 讲述如何标准化可编辑安装，PEP660 与之对比。
- en: '![](img/fe5ebb76be2e750214cfa81dada8e8fe_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe5ebb76be2e750214cfa81dada8e8fe_1.png)'
- en: PEP662。 [applause]， \>\> Thank you， thank you all。 Let me start with saying
    that I appreciate your presence here。 I know that this is not a light topic for
    anyone as Peter put it this morning。 This is probably the place where everyone
    gets upset eventually。 I'm here today to hopefully help you a bit with that。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: PEP662。[掌声]，\>\> 谢谢，谢谢大家。首先，我要感谢你们的到来。我知道这对任何人来说都不是轻松的话题，正如彼得今天早上所说。这可能是每个人最终会感到不快的地方。今天我在这里，希望能在这方面帮助你们一些。
- en: My goal here is today for you to actually have a better insight on how some
    of the packaging， works。 Hopefully if you run in some of those annoyance that
    you understand enough of how the system。 works that you can figure out what the
    problem and hopefully fix it with less annoyance at。 the end of the day。 Let me
    start with introducing myself。 Who am I？
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我今天的目标是让你们对一些打包工作的情况有更深入的了解。希望如果你们遇到了一些麻烦，能够明白系统的工作原理，从而找出问题，并希望最终能以更少的烦恼来解决。
- en: I'm a software engineer at Bloomberg。 I work in a team that primarily focuses
    on quality control inside data ingestion pipelines。 But more importantly for this
    talk， I'm an open source contributor。 Primarily I'm a member of the Python package
    and go through it。 I maintain the virtual and build PPCS and talks projects which
    are more popular ones。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我是 Bloomberg 的一名软件工程师。我所在的团队主要专注于数据摄取管道中的质量控制。但更重要的是，作为本次演讲的主题，我是一名开源贡献者。主要我是
    Python 包的成员，并进行维护虚拟环境和构建PPCS及 Talks 项目，这些是更受欢迎的项目。
- en: Also I'm the parent of two York charteriors and I'll employ their presence at
    least in。 the style virtually to hopefully give you a bit of relief for the dense
    subject of packaging。 Now let's start with what is the end of the installation。
    But before we can actually understand how we did standard at it installations，
    we have。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我还是两个约克夏犬的主人，我会利用它们的存在，至少在风格上，来希望为打包这一密集主题带来一些缓解。现在让我们开始安装的终点是什么。但在我们实际理解如何标准化可编辑安装之前，我们需要。
- en: to understand how things work in the past， then where we ended up today only
    then to realize。 what we proposed and where the future is heading。 I hope you're
    all eager to find out more about how edit the blin cells works in the past。 And
    for that we first need a very quick demo project。 Here is a quick demo project
    for your amusement。 You can see it very simple。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我先自我介绍一下。我是谁？为了理解过去的工作原理，再看看我们今天的现状，只有这样才能意识到我们所提议的内容和未来的方向。我希望大家都渴望了解过去可编辑安装的工作原理。为此，我们首先需要一个非常快速的演示项目。这是一个供你们娱乐的快速演示项目，你会发现它非常简单。
- en: It doesn't do very much。 It literally just had a simple say hi method or function
    and you can call that and call。 it you're going to say hey， it works or not。 Now
    if you just create this source directory and start up your Python interpreter
    and pass。 in your testing code basically calling the method， you'll see that it's
    not working and。 the reason for that it's not working is to actually test the
    library you first need to， install it。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 它并没有做太多事情。它实际上只是有一个简单的问候方法或函数，你可以调用它，看看它是否工作。如果你只创建这个源目录，启动你的 Python 解释器，并传入你的测试代码，基本上调用这个方法，你会发现它并没有工作。之所以没有工作，实际上是因为你首先需要安装这个库才能进行测试。
- en: So let's do that quickly。 Hopefully you're using virtual environment for this
    and not installing in your global。 Python interpreter because that's the surest
    way to eventually have a bad day。 And as we know packaging is already a bad experience
    you want to avoid getting there， quicker。 Now so usually what you're going to
    do it if you have a virtual environment you're going。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们快速进行吧。希望你们使用虚拟环境，而不是在全局 Python 解释器中安装，因为那是最终导致糟糕结果的最可靠方式。众所周知，打包本身就是一种你想尽量避免的糟糕体验。通常，如果你有一个虚拟环境，你会这样做。
- en: to use PIP to actually install your packaging to it and I know that I'm not
    sure how much。 they show up especially in the back but in the first slide there
    was a link to it so you。 can check it out later what not。 I'm going to highlight
    the part that are more important。 Here basically the only thing you really need
    to know that I installed the project after。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用PIP实际安装你的包，我知道我不确定多少。它们在后面特别显示，但在第一张幻灯片上有一个链接，所以你可以稍后查看。我要突出更重要的部分。基本上，你真的需要知道的是我在之后安装了项目。
- en: I installed the project now if I run the interpreter again with my test code
    you can see that hey。 it's work now I can test my code greatly。 But you can see
    I kind of like made a bit of a mistake here because I said hello and I。 actually
    didn't put an exclamation mark and if you're one of these grammar nets you're。
    probably screaming at me already。 But let me figure that quickly I'm going to
    quickly put an exclamation mark in it。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我安装了项目，现在如果我用测试代码再次运行解释器，你可以看到，嘿，它现在工作了，我可以很好地测试我的代码。但你可以看到，我有点犯了个小错误，因为我说了“你好”，但实际上没有加感叹号。如果你是这些语法狂热者之一，你可能已经在对我尖叫了。但让我快点解决这个问题，我会迅速加上一个感叹号。
- en: I run again my test code and nothing changed it the same thing and you might
    be aware of。 the reason for details that whenever you change a code to actually
    test your library you have。 to install it again and only then you're going to
    see that hey now you have the new change。 Obviously installing your project or
    reinstalling your project after every change is not a good。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我再次运行我的测试代码，没有任何变化，情况还是一样，你可能已经意识到。每次你更改代码以实际测试你的库时，你必须再次安装它，只有这样你才能看到，嘿，现在你有了新更改。显然，在每次更改后安装或重新安装你的项目并不是一个好主意。
- en: day for anyone so there must be a better solution than basically whenever you
    change。 the code install the project again and the solution that we're looking
    for is editable。 installations。 Editable installations are basically a way of
    installation which allows you to install。 your project which allows you to test
    your project without needing to reinstall your。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对任何人来说，这一天都可能更好，所以必须有比每次代码更改时重新安装项目更好的解决方案，而我们寻找的解决方案是可编辑安装。可编辑安装基本上是一种安装方式，它允许你安装你的项目，从而可以在不需要重新安装的情况下测试你的项目。
- en: project between code changes。 Now you still need to restart your interpreter
    to pick up code changes however importantly。 you don't have to reinstall it。 Now
    the way this is strictly used to go it was PIP exposes an editable installation
    mode。 and it was exposed during this dash E flag。 So if you pass to PIP this dash
    E flag it's not a special type of installation in which。 once you run it you don't
    have to reinstall it after every code change it automatically。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 项目在代码更改之间。现在你仍然需要重新启动你的解释器以获取代码更改，但重要的是，你不必重新安装它。现在，这种用法是PIP暴露了一个可编辑安装模式，它在dash
    E标志中被暴露出来。所以如果你传递给PIP这个dash E标志，这并不是一种特殊类型的安装，你一旦运行它就不必在每次代码更改后重新安装，它会自动。
- en: picks up the new information that you put in your business。 Now let's dive dripper。
    Let's check out how actually those editable installation works in the past what
    happened。 a year ago or potentially even today if you're using setup tools when
    you actually type dash。 E to PIP。 And what happens is basically it inherits a
    solution that was introduced back in like。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 采集你在业务中输入的新信息。现在让我们深入探讨一下。让我们看看这些可编辑安装在过去是如何运作的，发生了什么。一年前或者如果你今天使用setup工具，输入dash
    E到PIP时会发生什么。基本上，它继承了在某个时候引入的解决方案。
- en: 2003 or what not by these two tiers and then iterated by setup tools and the
    solution is。 essentially calling the Python setup。py develop comment that magically
    makes your project。 source directory be present inside the Python interpreters
    import resolution system。 Let's check out what it means to install your project
    let's find out how a normal installation。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 2003年或者更早的通过这两个层次，然后由setup工具迭代，解决方案基本上是调用Python setup.py develop命令，神奇地使你的项目源目录出现在Python解释器的导入解析系统中。让我们看看安装你的项目意味着什么，了解一下正常的安装过程。
- en: works so we can kind of like identify what are the differences from an editable
    installation。 point of view。 And the way a normal installation works is that PIP
    will take a look at your source directory。 will build the wheel from it and then
    if we install that wheel into your site packages。 in your Python interpreter。
    Now when it builds this wheel this will have two kind of information it will have
    the actual。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 工作的方式是我们可以识别可编辑安装与普通安装之间的差异。普通安装的方式是PIP会查看你的源目录，从中构建轮包，然后如果我们将这个轮包安装到你的站点包中，就会在你的Python解释器中实现。现在，当它构建这个轮包时，它将包含两种信息，实际的。
- en: business logic for example here you can still like the demo need that by your
    business logic。 and then it's going to also have generate some kind of package
    metadata and this is。 basically information that before building your wheel was
    stored inside like your pipe。 project or something like that。 Now if you look
    further the next step as I said after it creates a wheel it will actually。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑，例如这里你仍然可以像演示那样需要通过你的业务逻辑，然后它还会生成某种包的元数据，这基本上是在构建轮包之前存储在你的pipe项目或类似的东西中的信息。现在，如果你进一步查看下一步，正如我所说的，在创建轮包后，它将实际。
- en: extract that wheel into your Python interpreter and that extraction basically
    means that it's。 going to take your wheel and extract the content of the wheel
    first inside the Python site packages。 folder and also generates the binary completions
    for those files that it is extracted for the。 Python files but also enrich a bit
    the metadata that was available in the wheel basically just。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将轮包提取到你的Python解释器中，这种提取基本上意味着它会将你的轮包提取到Python站点包文件夹中，并为提取的Python文件生成二进制补全，同时还稍微丰富轮包中可用的元数据，基本上。
- en: provide additional information that's useful for the installer in this case
    PIP to find。 out how it can uninstall the project and all that kind of stuff or
    even just for example。 the installer is there just to point out that if you have
    another installer then PIP can kind。 of like get to know hey I shouldn't touch
    this because it's not my package I don't know。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 提供额外的信息，这对安装程序（在这种情况下是PIP）查找如何卸载项目及其他事情非常有用，或者甚至仅仅是为了指出如果你有其他安装程序，PIP可以了解，我不应该碰这个，因为这不是我的包，我不知道。
- en: how to handle it。 Now the difference whenever we're talking about editable installation
    is that what actually。 happened in the past as you can see here basically I'm
    doing highlighted on the output of the。 PIP install it doesn't do any of this
    wheel building magic what not it just run setup type。 I develop onto your project
    source directory and then that invocation somehow makes the magic。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如何处理它。现在，当我们谈论可编辑安装时，区别在于过去发生的事情，如你所见，我基本上在这里突出显示了PIP安装的输出，它并没有进行任何轮包构建的魔法，它只是运行setup
    type。我开发到你的项目源目录中，然后这个调用以某种方式使魔法。
- en: happen and when I say it makes the magic happen what the magic is actually it
    generates。 your project metadata in line inside your source directory so that's
    why if you install。 a project in editable install or you use to install it there
    was this magical egg info。 folder in your folder because it still needs the project
    metadata and this project metadata。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说它让魔法发生时，这个魔法实际上是它在你的源目录中生成你的项目元数据，所以如果你以可编辑安装方式安装一个项目或使用它进行安装，就会在你的文件夹中看到这个神奇的egg
    info文件夹，因为它仍然需要项目元数据，而这个项目元数据。
- en: now is stored within your project's directory and then it uses a system called
    pth files。 and it adds this pth file your site packages and what you need to do
    know about the pth。 files that whenever you add a pth file to your site packages
    folder that basically just gets。 picked up at the interpreter start up and gets
    added to the still。pad if it's a pad if。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在存储在你的项目目录中，然后它使用一种叫做pth文件的系统。它将这个pth文件添加到你的站点包中，你需要知道的关于pth文件的事情是，每当你将pth文件添加到你的站点包文件夹时，它基本上会在解释器启动时被拾取，并被添加到仍然。
- en: it's Python code in it it will actually run the Python code。 So for example
    in this case you can see once I run setup by develop it generates that egg。 info
    folder but also takes the source my project source directory and inject it via。
    the pth file onto the still。pad with them from there the Python in for system
    takes it。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了Python代码，它实际上会运行Python代码。所以例如在这个案例中，你可以看到一旦我运行setup by develop，它会生成那个egg
    info文件夹，同时也会将我的项目源目录通过pth文件注入到仍然。路径中，然后从那里Python的信息系统接管。
- en: away and makes things work。 So you can see this was the old solution and you
    might ask why isn't this enough this。 all we need do we need anything more complicated
    like maybe you already saw this problem and。 I'm here to tell you that no this
    is actually not the full solution this is a partial solution。 problem one of the
    problems is that it still require the setup。py file and the setup。py。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 摆脱旧的方式，使事情运作。因此，你可以看到这是旧解决方案，你可能会问，为什么这不够，这就是我们所需的一切，我们还需要更复杂的东西吗？也许你已经看到这个问题，而我在这里告诉你，不，这实际上不是完整的解决方案，这只是一个部分解决方案。问题之一是它仍然需要setup.py文件，而setup.py。
- en: file is basically some set of these two tiers are correct thing and for example
    we have。 a lot of fancy new back end like fleet poetry or a hatchling and all
    this still need to。 generally set up the pipe they want to develop and edit the
    installation mode。 It is not a good so we should have a better solution also another
    problem is that and。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 文件基本上是这两层中某些内容的集合，例如我们有很多新奇的后端工具，如flit、poetry或hatchling，这些仍然需要一般性地设置管道，以便他们想要开发和编辑安装模式。现在的情况并不好，因此我们应该有更好的解决方案，另一个问题是。
- en: it's kind of like it's raised back what actually we want to solve here the key
    we as a community。 never really got together and agreed what is an edit the installation
    other than the broad。 definition I gave it earlier on or like where are the boundaries
    for what an extent we should。 be able to do and shouldn't be able to do。 And also
    furthermore as I said this thing that I presented until now is basically an implementation。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点像重新回到我们真正想解决的问题，关键是作为一个社区，我们从未真正聚在一起同意什么是编辑的安装，除了我之前给出的广泛定义，或者说我们应该能够做什么以及不应该能够做什么的界限在哪里。此外，正如我所说的，我到目前为止所呈现的东西基本上是一个实现。
- en: detail of set up to from the earlier ages you might ask hey burn up 2022 why
    still a problem。 I mean Python runs for 30 years I thought we should have sold
    this 15 years ago and I'm。 here to tell you that it's not that because we did
    not try oh boy no we did try more than。 once we at least first initially came
    back then when we started to standardize the normal。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从早期的阶段来看，你可能会问，嘿，2022年，为什么这仍然是一个问题。我是说，Python已经运行了30年，我以为我们应该在15年前就解决这个问题，而我在这里告诉你，这并不是因为我们没有尝试，哦，伙计，我们确实尝试过不止一次，我们最初至少回归了一次，当我们开始标准化时。
- en: installations in 2015 and it was so controversial back then at that point that
    the writers of。 the platform and especially stated that someone else someone later
    gonna solve it we don't。 want to deal with this because otherwise we'll never
    get anything accepted。 Then it came 2019 we tried again part of the packaging
    summit at the previous in person。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年的安装非常具有争议性，当时平台的作者特别声明，后续会有人来解决这个问题，我们不想处理这个问题，因为否则我们将永远无法获得任何接受。然后在2019年，我们再次尝试，这是之前面对面会议上的包装峰会的一部分。
- en: conference we even agreed on a solution and we all walked away that hey just
    we need to。 implement it ship it then after the conference there was more follow-up
    discussion not many。 concerns for race until 2020 April when someone opened up
    again a topic that hey we agreed。 that we're gonna do it but we didn't do actually
    anything like can we like start the work on。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 会议上我们甚至达成了一项解决方案，大家都一致认为我们只需实施并推出它，随后在会议结束后进行了更多的后续讨论，直到2020年4月才再次有人提起这个话题，大家同意我们要去做，但实际上并没有任何行动，我们能否开始工作呢？
- en: it so there were that degenerated whole new work only the proof that actually
    whatever。 we agreed at the packaging summit we didn't agree like many people had
    concerns to it so。 fast forward another year so this is like the fifth try when
    we go at it we someone I can。 pick up like okay can we actually solve this and
    we then again it and then we even had two。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所以那时产生了全新的工作，证明了无论我们在包装峰会达成了什么共识，许多人对此都有担忧。快进到另一年，这是第五次尝试，我们有人提出，可以说我们能否实际解决这个问题，我们又开始讨论了，我们甚至进行了两次详细的设置。
- en: main threats each of these threats I warned you are probably like 500 the common
    each。 threat basically discussing various back and forth on the subject and I'm
    happy to say。 that after that 2021 April May edition we actually did agree mostly
    but not really I'll。 let you know later on that but first in order to actually
    understand why we had so many back。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 主要威胁，我提醒过你们，这些威胁大约有500个，每个威胁基本上都是在这一主题上进行各种讨论和反复交流，我很高兴地说，在2021年4月和5月的版本之后，我们实际上大部分达成了一致，但并不完全，我稍后会告诉你原因，但首先为了理解我们为何经历了如此多的反复。
- en: and forth I need to tell you about what were the drawbacks of the pre-r are
    basically what。 were the problems that the previous solution did not actually
    handle and many people felt。 that we should handle as a language one of the problem
    that the previous decision didn't。 handle handle is that imagine you have a project
    and you want to basically include some files。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要告诉你预先存在的缺点，基本上是之前的解决方案没有处理的问题，许多人觉得作为一种语言我们应该处理。之前的决策没有处理的问题是，想象一下你有一个项目，你想基本上包括一些文件。
- en: in your project and for example set up tools have these packages thing where
    you can specify。 one by one what package you want to include now in case of an
    individual install once you。 did this this only this exposed every package even
    if you choose some of the packages to not。 include the editable install still
    installed all your packages we made it available all。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中，例如，设置工具有这些包的功能，你可以逐个指定想要包括的包。在个别安装的情况下，一旦你这样做，这将暴露每个包，即使你选择不包括某些包，可编辑安装仍然安装了所有包，我们将其全部提供。
- en: your packages in your edit of installation basically driving the divide have
    an editable。 installation and normal installation was working also the reverse
    is true if you wanted for example。 to exclude your test files in an end-to-be
    installation it wasn't possible if you put it between your。 project source directory
    it automatically picked up because the previous solution basically。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你在安装编辑中的包基本上驱动了可编辑安装和正常安装的区别，正常安装也在工作，如果你想排除测试文件在最终安装中，这是不可能的，因为如果你把它放在项目源目录中，它会自动被识别，因为之前的解决方案基本上。
- en: lied on the fact that you put the your source directory and put it as it is
    as a whole onto。 the site packages folder so there's no let me add this or let
    me not add this type of extrusion。 logic possible to happen there another problem
    that we don't have an extra solution is like。 for example generated con imagine
    you have some kind of scheme of like a game of file in which。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 基于你将源目录作为整体放入站点包文件夹中的事实，所以没有让我添加这个或让我不添加这个类型的逻辑。另一个我们没有额外解决方案的问题是，例如生成的con，想象一下你有一种像游戏文件的方案。
- en: your service is defined and you want to generate some Python classes for example
    using Python。 thing class by using this data model code generator you can set
    up a build where you generate this。 file during the build of your package but
    this will not be running during your editable installation。 and it's not clearly
    defined how it should be even for an installation basically including。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你想生成一些Python类，例如使用Python工具，通过使用数据模型代码生成器，你可以设置一个构建，在包的构建期间生成此文件，但这不会在可编辑安装期间运行，并且并不明确它应该如何定义，甚至在安装中基本上包括。
- en: basically including a generated code as part of editable installation not just
    static code that。 lives on your disk and also another problem is editable installation
    work as previously were。 defined mostly for Python file pure Python file but for
    example in an ideal world it should be。 possible to also work for like C extension
    for example if you have a site on package it should。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上包括生成的代码作为可编辑安装的一部分，而不仅仅是静态代码，而是存在于你的磁盘上。此外，另一个问题是可编辑安装之前大多是为纯Python文件定义的，但在理想的情况下，它也应该能够适用于像C扩展这样的情况，例如如果你有一个站点包。
- en: be possible to whenever you update your site on code you don't have to like
    rerun again the。 entire installation just to pick up that site on code change
    ideally it should that also translate。 automatically again for this we don't have
    any support the way historically it worked that during。 the installation this
    extension were injected into your project source directory and it was up to。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更新站点代码时，不必重新运行整个安装以接收该站点代码更改，理想情况下这也应该自动转换。对此我们没有任何支持，历史上它的工作方式是在安装期间将此扩展注入到你的项目源目录中，由你定义的服务决定。
- en: your responsibility whenever you do change the CX extension just really install
    the package to。 pick up the changes but then we brainstormed throughout all those
    back and forth sessions that。 can we even solve some business problem or are they
    even worth solving and we did come off with a。 few new solutions or also have
    some of the system prior to solve it basically how can we have a。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你的责任是，每当你更改 CX 扩展时，只需重新安装包以接收更改，但在我们反复讨论中，我们能否解决一些业务问题，或者这些问题是否值得解决，我们确实想出了几个新解决方案，或者也有一些系统先前解决了，基本上我们如何拥有一个。
- en: life without the PTH files that we had something that's more more powerful one
    obvious solution or。 someone came up why won't we instead of just using PTH file
    to kind of like inject the source。 directory inside the site packages why don't
    we use Sim links to basically take the source directory。 and Sim link it into
    site packages and this also has the advantages that now from the port of。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 PTH 文件的生活比我们拥有的更强大，显而易见的解决方案或某个人提出的建议是，为什么我们不直接使用 PTH 文件来注入源目录到站点包中，为什么不使用符号链接将源目录链接到站点包中？这还有一个好处，就是从导入的角度来看。
- en: interpreter that files actually physically leave inside your site packages rather
    than then kind。 of like leaving it inside your source directory and you can have
    like that difference between the。 installation and the installation now this also
    has some benefits like there are no startup。 performance impact you can also basically
    install the middle or the normal installation mode there。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器实际上将文件物理地保留在你的站点包内，而不是像那样将其保留在你的源目录中，这样可以在安装与安装之间形成差异。这也有一些好处，比如没有启动性能影响，你基本上也可以安装中间或正常安装模式。
- en: is one downside if you Sim link your entire folder remember from the previous
    bullet list。 right say that you wanted to support the addition exclusion code
    generation and let's say CX。 extensions there's a this solves you the addition
    problem but doesn't solve you the extension because。 what you seem link for there
    everything in that folder is available so it's not the full solution。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你符号链接整个文件夹，这也是一个缺点，记住之前的要点。如果你想支持添加排除代码生成，假设有 CX 扩展，这解决了添加问题，但没有解决扩展问题，因为你链接的文件夹中的一切都是可用的，因此这并不是完整的解决方案。
- en: but potentially can be better than the PTH file you can also choose to simply
    the file individually。 this has the advantage that now you can support exclusion
    but that's not mean that whenever you。 add new files to your project you need
    to read on the installation to update the。 same links basically to your site packages
    so this is also not necessarily a perfect solution but。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但潜在上可能比 PTH 文件更好，你还可以选择单独处理文件。这有个好处，就是现在你可以支持排除，但这并不意味着每次你向项目中添加新文件时，都需要重新安装以更新同样的链接到你的站点包，所以这也不一定是完美的解决方案。
- en: sometimes can be better than the normal PTH file another great solution or great
    improvement that。 has been added through the last 15 years the language or import
    to the import to the。 report they were working at the end of the day if you think
    about it in Python we import。 modules not files let's use that like why do we
    even try to solve the file problem if we had the。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有时比正常的 PTH 文件更好，过去 15 年中增加了另一种伟大的解决方案或改进，语言或导入功能在一天结束时如果你想一想，在 Python 中我们导入模块而不是文件，为什么我们甚至尝试解决文件问题呢？
- en: day what you want to solve is the fact that an installation load the correct
    module rather than。 we don't really care where that file lives and we could for
    example with this thought we can extend。 the import system to manifest the module
    at import time and manifest it from the correct。 location wherever it lives it
    lives inside the site packages cool if it lived in your code cool。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 今天你想解决的是安装加载正确模块的问题，而不是关心那个文件在哪里。比如我们可以通过这个想法扩展导入系统，以在导入时清晰地指明模块，并从正确的位置进行清晰指明，无论它是否位于站点包内，或者在你的代码中。
- en: or if it lives maybe in memory because it's generated cool it can manifest it
    from there and。 doesn't have to actually exist on the disk it basically offers
    you full dynamic thing we brinched。 or I myself with Paul Moore Brinstrom run
    this in 2020 and he even made a library that basically。 allows any backend to
    kind of like provide this kind of functionality okay and the way it works it。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果它可能存在于内存中，因为它是生成的很酷，它可以从那里显示，而不必实际存在于磁盘上，它基本上为你提供了完全动态的功能。我和 Paul Moore
    Brinstrom 在 2020 年做了这个，他甚至制作了一个库，基本上允许任何后端提供这种功能。好的，它的工作方式是。
- en: still uses some import hooks because they still need to read it needs to still
    needs to have some。 kind of system to register the import to get the start of
    the importer so some code needs to run。 and the interpreter startup time but that
    does a lot less because not just registered to import。 to and then dynamically
    at import time it kind of like can support both execution code generation or。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然使用一些导入钩子，因为它们仍然需要读取，它仍然需要某种系统来注册导入，以获得导入者的开始。因此，需要在解释器启动时运行一些代码，但这少了很多，因为不仅仅是注册导入，而是在导入时动态支持执行代码生成或。
- en: for example here you can see what we actually do we map our demo module to a
    given in it that file。 and then the import system will take care of to load it
    from the correct location yeah so this is。 mostly a great solution so those are
    our problems I hope I didn't put you left to sleep though and。 let's have a look
    first now the Python build system so in order to understand the solution we proposed。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这里你可以看到我们实际上做了什么，我们将我们的演示模块映射到给定的文件中。然后导入系统将负责从正确的位置加载它，是的，所以这是一个很好的解决方案。这些就是我们的问题，希望我没有让你睡着。现在让我们先看看
    Python 构建系统，以便理解我们提出的解决方案。
- en: there's one more thing that you have about and that's the Python build system
    in order to build。 the wheel what actually happens to build the wheel and two
    distinct components need to work。 together first the build backend this is like
    setup tools hatchling fleet whatever else you。 have which basically actually builds
    the wheel and there is the build front end which creates an。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事就是 Python 构建系统，为了构建 wheel，实际上构建 wheel 时发生了什么，两大不同的组件需要协同工作。首先是构建后端，这就像
    setup tools、hatchling、fleet 或其他任何你拥有的工具，基本上是实际构建 wheel 的。而构建前端则创建一个。
- en: isolated build environment for your build backend in which it can run basically
    something that。 makes sure that you have the correct version of the setup tools
    all that kind of stuff and this。 also installs additional dependencies needed
    that is really small the text there but yeah and then。 we can call the build backend
    the build front end is the one that actually communicates with the。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的构建后端提供一个隔离的构建环境，在这个环境中，它可以运行基本上确保你拥有正确版本的 setup tools 和所有那些东西，并且这也会安装所需的附加依赖项，文本虽然很小，但确实是这样。然后我们可以调用构建后端，构建前端实际上是与。
- en: backend to the in API defined in PEPile one seven and the two main important
    methods kind of like。 it's a Python API or the get project for build wheel which
    basically give me what additional。 dependencies you need to actually build the
    wheel and the other one actually build the wheel so。 these are the two main Python
    interfaces that need to exist in order to build the wheel you can。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 后端与 PEP 517 中定义的 API，两个主要重要的方法就像是 Python API，或获取构建 wheel 的项目，它基本上告诉我实际构建 wheel
    所需的附加依赖项，另一个是实际构建 wheel。因此，这两个主要的 Python 接口必须存在，以便构建 wheel 你可以。
- en: actually see this if you use the canonical project project that build to build
    your project for。 example AI demonstrated the virtual and you can see when I say
    hey build me a wheel of this the。 version that happens it's created virtual environment
    then it's gonna actually installing that。 environment your projects build backend
    in this case like setup tools and setup tools SCM and。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用规范项目来构建你的项目，例如 AI 演示的虚拟环境，当我说“嘿，给我构建这个的 wheel”时，你可以看到发生了什么。它创建了虚拟环境，然后实际上在那个环境中安装了你的项目构建后端，在这种情况下是像
    setup tools 和 setup tools SCM。
- en: then it has the backend hey what other dependencies do you need and the backend
    comes back I need。 the wheel so the front end will now install that dependency
    inside your isolated build environment。 and then it just calls that build will
    method which actually builds the wheel and you can see at the。 end of it you end
    up with the wheel okay so these are kind of like the main steps how will get built。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它会询问后端，嘿，你还需要什么依赖项，后端会回复我需要wheel，因此前端现在将在你的隔离构建环境中安装该依赖项，然后它只需调用那个构建方法，这实际上构建了wheel，最后你可以看到你得到了wheel。好的，这些大致是构建的主要步骤。
- en: and with that now we know enough to actually solve the problem yeah and this
    is the port where I。 the point where I have to say that after 12 years of arguing
    back and forth on how to solve the problem。 we actually managed to not agree on
    how to solve the problem so we had two solutions so we decided。 to propose both
    solutions and pick the winner basically at the end of the day now the reason for。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们现在足够了解如何解决问题了，是的，这就是我不得不说的，在经历了12年的争论之后，我们实际上未能达成一致的解决方案，因此我们有两个解决方案，最终决定同时提出这两个解决方案，基本上在最后选出一个赢家。现在原因是。
- en: this one that we kind of like as a community feel to agree who should actually
    do the most of the。 heavy groundwork should it be the build backend or the build
    front end who should actually。 responsible of making that itable effect happen
    or work and we have a path for each of them we have。 the traditional wheelbase
    and we have for the virtual the wheelbase which is one of the inputs。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们社区在谁应该承担大部分重工作方面达成共识的一个问题：应该是构建后端还是构建前端，谁应该负责使可编辑效果发生或工作。我们为每种情况都有一个路径，我们有传统的wheel基础，还有虚拟的wheel基础，这是其中一个输入。
- en: I mean the build front end I'm gonna leave the build backend now at this point
    I should probably。 address that generally the way the Python enhancement works
    is that people propose a solution and that。 the solution gets debated and the
    solution should be something that the community agreed on now。 obviously doesn't
    we're not always gonna agree on and that's fine sometimes we can agree to disagree。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我是说构建前端，现在我将把构建后端留到这个阶段。我可能应该提到，通常情况下，Python增强提案的工作方式是人们提出一个解决方案，然后这个解决方案进行辩论，这个解决方案应该是社区达成一致的。显然，我们并不总是会达成一致，这也没关系，有时我们可以同意不同意。
- en: and also it's not actually a bad thing that we had a community could not agree
    in a single。 solution because if we have two solutions we can kind of like compare
    them against each other and。 make the least solution because it's not always possible
    to find a solution that fixes all your。 problems at each everyone's problem and
    oftentimes it's even more important to pick a solution rather。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，实际上我们社区无法就单一解决方案达成一致并不是一件坏事，因为如果我们有两个解决方案，我们可以相互比较，找到最优的解决方案，因为并不总是能找到一个能解决每个人所有问题的方案，而有时候选择一个解决方案甚至更为重要。
- en: than instead of being afraid of picking the wrong solution do not pick at your
    solution just because。 as a community we could not agree but with that being said
    let me tell you a bit about the first。 installation so the first installation
    mode that we came up is the path 6060 and for those of you。 wondering yeah this
    is the one that actually got accepted so the way this works this puts most of。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与其害怕选择错误的解决方案，不要因为我们作为一个社区无法达成一致而不选择你的解决方案。不过话说回来，让我告诉你关于第一个安装的一些事情。我们想到的第一个安装模式是路径6060，对于那些好奇的人来说，是的，这就是最终被接受的方案。它的工作方式是将大部分。
- en: the heavy lifting onto the build back end and it adds two methods to the communication
    channel。 between the build back end and the front end it defines this that now
    the editable installations。 also have their own isolated build environment and
    this additive build environment can have。 additional dependencies for example
    if you want to build an editable wheel or a normal wheel you。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将重担转移到构建后端，并为构建后端和前端之间的通信通道添加了两个方法。它定义了现在可编辑安装也拥有自己的隔离构建环境，这个附加的构建环境可以有额外的依赖项。例如，如果你想构建一个可编辑的wheel或普通的wheel，你。
- en: may be able to specify different dependencies in order to actually build those
    wheels so that's why。 we have another endpoint that basically provides hey back
    end get me the requirement for your building。 an editable wheel and then we have
    a build editable method that actually hey back end provide that。 wheel that you
    build and the editable installation this is basically all this actual path actually。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可能能够指定不同的依赖关系，以便实际构建这些轮子，所以这就是为什么我们有另一个端点，基本上提供“嘿，后端，给我获取你构建所需的要求”，一个可编辑的轮子，然后我们有一个构建可编辑的方法，实际上就是“嘿，后端，提供那个轮子”，你构建的可编辑安装，这基本上就是这个实际路径。
- en: contained because now from this one you'll define the editable installation
    works by first the build。 front end will create a custom isolated build environment
    it will install into that isolated。 and build environment your projects build
    back end after the build back end it has the order front。 and there's the back
    end hey what our additional dependencies needed to build an editable installation。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 包含，因为现在从这一点你会定义可编辑安装是如何工作的，首先构建前端将创建一个自定义的隔离构建环境，它将在那个隔离的构建环境中安装你的项目构建后端，在构建后端之后，它有顺序前端，后端，“嘿，我们需要哪些额外的依赖关系来构建一个可编辑安装”。
- en: and after the editable installation it installs that it basically just adds
    the back end build。 media to build install and the entire installation from this
    on and on installation works the same way。 it works for the normal wheels so there's
    no change needed on the installer side or anything。 of that it basically delegates
    all the responsibility on the back end and the back end should generate。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在可编辑安装后，它安装的基本上只是将后端构建媒体添加到构建安装中，从此以后的整个安装方式都是一样的。它对于正常的轮子也同样工作，所以在安装程序那一侧不需要任何变化，基本上将所有责任委托给后端，后端应该生成。
- en: appropriate files inside your wheel that makes the editable effect happen okay
    now this has some。 benefit like for example the back end can choose to put an
    import hook there instead of actually。 putting your source files it can put a
    pth file so basically whatever was working until now can。 continue working and
    also the back end the whenever about making which one should you actually use。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的轮子内适当的文件使可编辑效果得以实现，好吧，现在这有一些好处，比如后端可以选择放置一个导入钩子，而不是实际上放置你的源文件，它可以放置一个.pth文件，所以基本上到现在为止的所有工作都可以继续工作，后端在决定你应该使用哪个时。
- en: the pep kind of like say that well the back end should probably allow the user
    to choose whichever。 they want and yeah now there's one solution out of the previous
    kind of like semi solutions i presented。 that this doesn't support you can see
    that we proposed that you could use sim links to achieve。 the editable check sim
    links is not achievable today because the real standard doesn't support sim link。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: PEP有点像说，后端应该允许用户选择他们想要的任何内容，嗯，现在有一个解决方案是我之前提出的那种半解决方案，这并不支持，你可以看到我们提议可以使用符号链接来实现可编辑检查，今天实现符号链接是不可能的，因为实际标准不支持符号链接。
- en: like there's no point to define it and the yeah and the kind of like the conclusion
    was that if anyone。 wants sim links in the editable installations they should
    propose an additional pep that extends。 the current pep standard to support sim
    links and the big benefit is as i said before and for the。 installers or installers
    there's no change they use the existing mechanism now here's 662 and this。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 就像定义它没有意义一样，嗯，结论是，如果任何人想要在可编辑安装中使用符号链接，他们应该提出一个扩展当前PEP标准以支持符号链接的额外PEP，主要好处如我之前所说，对安装程序或安装者没有变化，他们使用现有的机制，现在这里是662。
- en: is the pep that actually i wrote and proposed so this was like my solution even
    if it wasn't accepted。 the idea with this one is that instead of making all this
    work be handled by the back end why doesn't。 the back end just provide some kind
    of metadata file like json file which is basically at least。 what modules need
    to be put from what files and then the front end is the one that actually need。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我实际写的并提出的PEP，所以这就像是我的解决方案，即使没有被接受。这个想法是，为什么不让后端提供某种元数据文件，比如JSON文件，基本上至少是从哪些文件需要放置哪些模块，然后前端实际上需要。
- en: to make it happen somehow now and the front end can from there on this side
    to use sim links pth。 via side custom sim portoque all that kind of stuff this
    has potential the benefit that it doesn't。 require at least extending existing
    standards because the front end is not bound either。 existing front end so it
    can choose for example to use sim links or it can choose to use side。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使其发生，现在前端可以使用 sim links pth，通过侧面的自定义 sim portoque 等，这有潜力带来的好处是不需要至少扩展现有标准，因为前端不受现有前端的约束，因此可以选择使用
    sim links 或自定义 pies。
- en: customized pies any of that now ultimately choosing a winner uh the decision
    was primarily made by。 paul more who's kind of like our bdf file for packaging
    and after a week when none of the。 proposals received any significant feedback
    he made the decision that he picked the pep 6060 as。 the winner and this happened
    the last year in june and his primary reason why he preferred the。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最终选择赢家，决定主要由 paul more 做出，他是我们打包的 bdf 文件，经过一周后没有提案收到任何显著反馈，他决定选择 pep 6060 作为赢家，这在去年
    6 月发生，他选择的主要原因是。
- en: sext or the 662 is that he felt that the pep 6060 by just basically imposing
    on the back end to。 enlist what type of files needs to be or modules need to be
    exposed and from which locations。 it's a bit too big and it doesn't really specify
    for the front and what it needs to do and it does。 not really like that kind of
    like full control on the front and side while if you consider the。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: sext 或662认为，pep 6060 基本上强迫后端列出需要暴露的文件类型或模块及其来源，这有点过于庞大，并且并没有真正指定前端需要做什么，前端在这种情况下并没有完全控制。
- en: pep 6060 that is much more constrained because both the back end and the front
    end knows exactly。 what files they need to produce even though the back end still
    needs to solve all the problems how。 actually makes that it's a real situation
    in fact happen okay so some lessons we learned uh after。 adopting the new standard
    a lot of the back end happily jumped on so from that and it was a。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: pep 6060 的约束更大，因为后端和前端都确切知道他们需要生成什么文件，尽管后端仍需解决所有问题，实际上这是一个真实的情况，所以我们在采用新标准后学到了一些教训，很多后端开发者很高兴地参与其中。
- en: resounding success I suppose for example hecheling PDM is conflict poetry within
    a few months implemented。 the standard and now you can use that the pulling straws
    without set up by the pie for this project。 you may notice one significant omission
    from here and that's setup tools so basically the one that's。 90% of us use doesn't
    actually and the problem here is a bit difficult like one setup tools doesn't。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我想这项目是一个成功的例子，比如 hecheling PDM 在几个月内实现了标准，现在可以使用这个项目的拉取方式而无需设置工具，你可能会注意到这里一个显著的遗漏，那就是设置工具，所以基本上是我们
    90% 的人使用的那个并不适用，而问题在于设置工具有点困难。
- en: necessarily want to take pth file and just add support for pth file basically
    a direct migration。 they would like to improve the listing system but improving
    the listing system and kind of like。 kind of like adding support for like more
    smart editable installation it's hard because setup。 tools is very much pulled
    down a lot of technical depth a code base that basically goes back 25。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不一定希望直接将 pth 文件添加支持，基本上是直接迁移，他们希望改善列表系统，但改善列表系统以及增加对更智能可编辑安装的支持非常困难，因为设置工具有很多技术债务，代码基础可以追溯到
    25 年前。
- en: years and adding changes like collecting all the files that are actually going
    to be installed or。 modules that are going to be installed it's a hard problem
    within the system of that project。 because of its architecture so not not all
    great and what's not not there's one more。 black one we did not see coming and
    this was kind of like well when I some of this project。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 收集所有要安装的文件或模块的更改是这个项目系统内的一个难题，因其架构问题，所以并不都很好，还有一个我们没有预料到的难题。
- en: and I started using it and this also proved that even with 10 years of disagreement
    we still can。 miss things we turned out that we missed with the import to solution
    that imports are great because。 they allow you to solve all the problems and they
    allow you to dynamically make any kind of logic。 happen the problem is they're
    really bad for any idea or static checker because any idea or static。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我开始使用它，这也证明即使经历了10年的分歧，我们仍然会遗漏一些东西。我们发现我们在导入解决方案中遗漏了一些，因为导入非常出色，因为它们允许你解决所有问题，并动态实现任何逻辑。问题是它们对于任何IDE或静态检查器来说都不好，因为任何IDE或静态。
- en: checker doesn't know doesn't execute any Python code so if they don't take you
    the Python code they。 don't know what type of import to do what kind of modules
    does make happen and I'm not sure that。 this is an easy problem to solve because
    if you think about it if you go from a concern that you。 never can execute any
    Python code anything other than explicitly stating what file additional files。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 检查器不知道也不执行任何Python代码，所以如果他们不带你Python代码，他们就不知道该如何导入，也不清楚需要什么样的模块。我不确定这是否是一个容易解决的问题，因为如果你考虑一下，如果你面临一个问题，你永远无法执行任何Python代码，除了明确说明哪些附加文件。
- en: you want to expose inside the Python interpreter will not work and this can
    like suggest that the。 proposal that the pep 6062 was that basically proposed
    exactly this to provide a file to the。 front end that can basically list hey these
    are additional files that I want you to make available。 now this kind of like
    point that maybe we will not have pep 6062 but if you want users to actually。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在Python解释器内部暴露的内容将不起作用，这可能暗示了pep 6062的提案，基本上是提议提供一个文件给前端，该文件可以基本列出“嘿，这些是我想让你可用的附加文件”。现在这一点可能意味着我们可能没有pep
    6062，但如果你希望用户实际上能够使用它。
- en: use our edit installations because not having auto complete on your id is going
    to be a major。 painting point we will actually need to extend pep 60 to still
    require the backend to generate。 these additional files so that the static checkers
    and the ideas can actually know about them and。 index them as they did beforehand
    in the meantime we can still using the pep h file but that's kind。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的编辑安装，因为没有自动补全会成为一个主要的痛点。我们实际上需要扩展pep 60，以仍然要求后端生成这些附加文件，这样静态检查器和IDE才能真正了解它们并像以前那样索引它们。与此同时，我们仍然可以使用pep
    h文件，但这只是。
- en: of like we did not really so much but made maybe available some of the things
    to the people。 do the newber backend made them work without needing to generate
    this custom set of that py file。 yeah that's that's mostly i'm not going to take
    questions right here but if you have any questions。 find me after the conference
    or right here and right now and i'm happy to answer any of your questions。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有做太多，但也许让一些事情对人们可用。新的后端使它们在不需要生成这个自定义py文件集的情况下工作。是的，主要是这样，我现在不打算回答问题，但如果你有任何问题，会议后或者现在就可以找到我，我很乐意回答你们的问题。
- en: '![](img/fe5ebb76be2e750214cfa81dada8e8fe_3.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe5ebb76be2e750214cfa81dada8e8fe_3.png)'
- en: and in that i would like to thank you very much。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常感谢你。
