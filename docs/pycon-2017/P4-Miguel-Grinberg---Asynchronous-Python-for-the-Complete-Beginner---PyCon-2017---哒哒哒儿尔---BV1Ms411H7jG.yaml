- en: P4：Miguel Grinberg   Asynchronous Python for the Complete Beginner   PyCon 2017
    - 哒哒哒儿尔 - BV1Ms411H7jG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P4：米格尔·格林伯格   为完全初学者讲解异步 Python   PyCon 2017 - 哒哒哒儿尔 - BV1Ms411H7jG
- en: Good afternoon everybody and welcome to our next presentation at PyCon 2017。
    Before we get started。 I would very much like you to encourage your electronic
    devices to not make any sudden noises。 because when they do everyone stares at
    you。 With that said。 I would like to introduce our next speaker。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大家下午好，欢迎参加我们在 PyCon 2017 的下一场演讲。在开始之前，我非常希望大家能鼓励你的电子设备不要发出突然的声音。因为当它们发出声音时，大家都会盯着你。说完这个，我想介绍我们的下一位演讲者。
- en: '![](img/62383f7126bcb8bb684fec52bf6e98ce_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62383f7126bcb8bb684fec52bf6e98ce_1.png)'
- en: His name is Miguel Grinberg and he will be talking about asynchronous Python
    for the complete beginner。 Please make him feel welcome。 [Applause]， Thank you
    very much。 It's a full house， no pressure。 right？ [Laughter]， Man， why do I do
    this？ Anyway， so I'm going to get something out of the way。 This is not a talk
    about flask。 I'm not going to talk about flask。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 他的名字是米格尔·格林伯格，他将为完全初学者讲解异步 Python。请让我们热烈欢迎他。[掌声] 非常感谢。观众满满，没有压力，对吧？[笑声] 天哪，我为什么要这样做？无论如何，我先说一点。这不是关于
    Flask 的演讲。我不会谈论 Flask。
- en: I'm going to mention flask less than ten times。 I'm going to try at least。 Okay？
    So great。 Something that maybe you don't know in addition to all the work I do
    with that framework that。 I cannot say， I also have an open source project that
    is an asynchronous server for the socket。 aio protocol。 That started as an extension
    to that set framework but then it grew on a life of its own and。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我会提到 Flask 不超过十次。我至少会尽量做到这一点。好的？太好了。也许你们不知道，除了我在那个框架上所做的所有工作，我还有一个开源项目，是一个用于
    aio 协议的异步套接字服务器。它最初是作为那个框架的一个扩展，但后来发展出了自己的生命。
- en: now you can use a standalone or with other frameworks like Django， et cetera。
    So I see a lot of people having problems working with asynchronous code。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以独立使用或者与其他框架如 Django 等一起使用。因此，我看到很多人处理异步代码时遇到问题。
- en: '![](img/62383f7126bcb8bb684fec52bf6e98ce_3.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62383f7126bcb8bb684fec52bf6e98ce_3.png)'
- en: So I'm going to start with a question。 How many of you have heard people say
    that async makes your code go fast or really very。 fast？ Okay。 So out of those
    of you that heard this but want to know why or don't understand how is。 that possible？
    So this is the talk for you。 I'm going to try to explain it in very simple terms。
    At least I'm going to try。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我想先问一个问题。你们有多少人听过别人说异步可以让你的代码变得很快或真的很快？好的。那么，在你们当中听过这个但想知道为什么或者不理解这是如何可能的呢？那么这场演讲就是为你们准备的。我会尽量用非常简单的术语来解释。至少我会尽量这样做。
- en: '![](img/62383f7126bcb8bb684fec52bf6e98ce_5.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62383f7126bcb8bb684fec52bf6e98ce_5.png)'
- en: So I'm going to start with a super simple definition。 We're going to build on
    this later but async。 I mean it is in a generic term。 I'm not specifically talking
    about async。io。 That's not the only way to do async。 But that is one way to do
    concurrent programming which means doing many things at once。 Okay？
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我将从一个非常简单的定义开始。我们稍后会在这个基础上展开，但异步，我的意思是，这是一个通用术语。我并不是专门谈论 async.io。这并不是进行异步的唯一方式。但这是进行并发编程的一种方式，这意味着可以同时做很多事情。好的？
- en: '![](img/62383f7126bcb8bb684fec52bf6e98ce_7.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62383f7126bcb8bb684fec52bf6e98ce_7.png)'
- en: So let's go through the few ways that we have an impact on to do multiple things
    at once。 So the most obvious way is to use multiple processes。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们来看看我们能够影响并同时做多件事情的几种方式。最明显的方法是使用多个进程。
- en: '![](img/62383f7126bcb8bb684fec52bf6e98ce_9.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62383f7126bcb8bb684fec52bf6e98ce_9.png)'
- en: From the terminal you can start your script two， three， four， ten times and
    then all the。 scripts are going to run independently all at the same time and
    the operating system that's。 underneath will take care of sharing your CPU resources
    among all those instances。 When you're using CPython， right， the most popular
    Python， that's actually the only way。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从终端，你可以启动你的脚本两次、三次、四次、十次，然后所有的脚本都会独立同时运行，而底层的操作系统会负责在所有这些实例之间共享你的 CPU 资源。当你使用
    CPython 时，对吧，这是最流行的 Python，其实这就是唯一的方法。
- en: you can get to use more than one CPU at the same time。 This is the only way。
    So the next way to run multiple things at once is to use threads。 And a thread
    is a line of execution pretty much like a process but you can have multiple。 threads
    in the context of one process。 So they all share access to common resources， right。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以同时使用多个 CPU。这是唯一的方法。因此，运行多个任务的下一种方法是使用线程。线程是执行的一条线，很像进程，但你可以在一个进程的上下文中拥有多个线程。因此，它们都共享对公共资源的访问，对吧。
- en: which is a headache。 That's why threads have such a bad frame， right？
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这真让人头疼。这就是为什么线程的声誉如此糟糕，对吧？
- en: It's difficult to write threading code。 So the operating system again is doing
    all the heavy lifting on sharing the CPU。 You don't have to worry about it when
    you write your Python code。 And of course you know the global interpreter log。
    In Python。 this is a special -- special to Python when you have multiple threads
    running， code。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 编写线程代码是很困难的。因此操作系统再次承担了共享 CPU 的所有繁重任务。当你编写 Python 代码时，你不必担心这些。当然，你也知道全局解释器锁。在
    Python 中，这是一个特别的——特指 Python 的特性，当你有多个线程运行时，代码。
- en: the global interpreter log allows only one to run Python code at a given time。
    So basically you're running in a single core even though you may have two or four
    or more。 So the third one is the topic of this talk， right， asynchronous programming。
    So to make the mystery even bigger， I'm going to tell you that the OS does not
    participate， here。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 全局解释器锁在任何给定时间只允许一个运行 Python 代码。因此，基本上即使你可能有两个、四个或更多 CPU，你也只是在一个核心上运行。所以第三个主题就是这次演讲的内容，对吧，异步编程。为了让这个谜团更加复杂，我要告诉你，操作系统并不参与这里。
- en: The OS， as far as the OS is concerned， you are going to have one process and
    there's going。 to be a single thread within that process。 But yet we can get multiple
    things done at once。 So what's the trick？ So to try to explain this， I'm going
    to go thinking completely out of the box。 I'm going to pull a real world scenario
    from the world of chess。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 就操作系统而言，你将有一个进程，并且在该进程中将有一个单线程。但我们仍然可以同时完成多件事情。那么诀窍是什么？为了尝试解释这一点，我将完全跳出框架思考。我将从国际象棋的现实场景中提取一个例子。
- en: '![](img/62383f7126bcb8bb684fec52bf6e98ce_11.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62383f7126bcb8bb684fec52bf6e98ce_11.png)'
- en: So this is a very old photo。 The lady in this photo is a unit pugger。 It's one
    of the best chess players in the world。 And what she's doing here。 it's called
    a chess exhibition。 I'm not sure this is still being done these days。 but it was
    pretty popular before computers， kill the fun out of chess by being so good at
    it。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很久以前的一张照片。这张照片中的女士是一位单位拼图师。她是世界上最好的国际象棋选手之一。她在这里做的事情被称为国际象棋表演。我不确定现在是否还在进行，但在计算机出现之前，它曾经非常流行，计算机的强大让国际象棋失去了乐趣。
- en: But when I was a kid， these were pretty exciting events if you were into chess。
    So basically she shows up at the event and then she plays a game of chess against
    lots， of people。 everybody， normal people like you and I。 She usually wins all
    of them。 But the whole idea is to play with a chess champion。 So what I'm going
    to do。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我还是个孩子时，如果你对国际象棋感兴趣，这些都是相当激动人心的事件。因此，她基本上是出现在活动上，然后与很多人进行一场国际象棋比赛。所有人，像你我这样的普通人。她通常会赢得所有比赛。但整个想法是与一位国际象棋冠军下棋。所以我打算做的就是。
- en: imagine you need to run this event。 So I'm going to just do back of the envelope
    math here。 I'm going to just pull some numbers out of nowhere。 So let's say that
    there are 24 people showing up for the event。 So there are 24 games。 And you know。
    you did pull her， she's pretty good。 So she's going to come up with a move on
    average in five seconds。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你需要运行这个活动。因此我将进行一些粗略的计算。我将随意抽取一些数字。假设有 24 个人参加这个活动。因此有 24 场比赛。你知道，她非常出色。因此她平均每五秒钟就会想出一个棋步。
- en: And the opponents are going to take 55 seconds。 So we get around a minute for
    a pair of moves。 And let's say that for the average game there are 30 moves， which
    is a short game， but she's。 going to cream everyone。 So it's going to be a short
    game anyway for most of them at all。 So imagine you're going to do this the synchronous
    way。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对手将花费 55 秒。因此我们每对棋步大约需要一分钟。假设平均每局棋有 30 个棋步，这是一场短局，但她将会压制所有人。因此对她来说，大多数棋局都是短局。所以想象一下，你要以同步的方式进行这个。
- en: So for each game it's going to last 30 minutes， right？ Have an hour。 Right？
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所以每局棋将持续 30 分钟，对吧？一个小时。对吧？
- en: So she needs to play 24 of these。 So she's going to be there playing for $12，
    right？
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 她需要下 24 场棋局。所以她将在那里玩 12 美元，对吧？
- en: Which is pretty bad， right， for her especially。 So in reality， these events
    don't run like that。 right？ They do something else。 So what they do is they use
    a synchronous mode and it works more or less like this。 She walks to the first
    game and makes her move， so five seconds， give or take。 And then she leaves the
    opponent on that table thinking， but she doesn't wait。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这对她来说可真糟糕。所以实际上，这些事件并不是那样运行的。对吧？它们会做一些其他事情。它们使用同步模式，工作原理大致如下。她走到第一局，并做出自己的第一步，花大约五秒钟。然后她让对手在那张桌子上思考，但她并不等待。
- en: She's not waiting there for the opponent to make a move。 She immediately moves
    to the second table。 And she makes a move on the second table。 And she leaves
    that opponent also thinking and moves to the third and the fourth and so。 on，
    right？ So she can go out under room and make a move on all 24 games in two minutes。
    Right？
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 她并不在那儿等对手走棋。她立即移动到第二张桌子。然后她在第二张桌子上走一步。她让那个对手也在思考，然后移动到第三张和第四张桌子，等等。对吧？所以她可以在两分钟内在
    24 场比赛中走出一招。对吧？
- en: So by that time， she's back at the first game。 And the opponent at the first
    game had more than enough time to make a move。 So she can make her next move on
    that game without waiting。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所以到那时，她回到了第一局。而第一局的对手有足够的时间走一步。所以她可以在那场比赛中不等待地做出下一步。
- en: '![](img/62383f7126bcb8bb684fec52bf6e98ce_13.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62383f7126bcb8bb684fec52bf6e98ce_13.png)'
- en: Right？ So if you do the math， she can play the whole 24 games and win them in
    one hour versus 12。 on the synchronous case。 Right？ So when people talk about
    asynchronous being really fast。 it's this kind of fast。 Right？ We're not putting
    an implant on you that pull go to play chess faster。 Right？ So she's optimizing
    her time so that she doesn't waste time waiting。 Right？ Makes sense？
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对吧？所以如果你算一下，她可以在一个小时内玩完全部 24 场比赛，而在同步的情况下则需要 12 场。对吧？所以当人们谈论异步时真的很快时，就是这种快。对吧？我们不是给你植入什么东西让你下棋更快。对吧？所以她优化了自己的时间，不会浪费在等待上。对吧？有道理吗？
- en: That's a secret， by the way。 That's the complete secret。 So that's how it works。
    So in this analogy。 you did Paul Gar， the chess champion， will be our CPU。 And
    the idea is that we want to make sure that the CPU doesn't wait or waits the least。
    amount of time possible。 And it's always finding something to do。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，这就是秘密。这就是完整的秘密。所以它的工作方式就是这样。在这个类比中，你可以认为国际象棋冠军保罗·加尔将是我们的 CPU。我们的目标是确保
    CPU 不会等待，或者尽量少等待时间。并且总是寻找可以做的事情。
- en: So now I can tell you a more complete definition。 This is still mine。 I'm just
    inventing these definitions。 I didn't take them from anywhere。 But asynchronous
    programming is a mode in which the tasks that are running release the。 CPU when
    they enter a waiting period。 And then that allows other tasks that need the CPU
    to run while the first task waits。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以告诉你一个更完整的定义。这仍然是我的定义。我只是发明这些定义。我没有从任何地方借用它们。但是异步编程是一种模式，其中正在运行的任务在进入等待期时释放
    CPU。然后，这允许需要 CPU 的其他任务在第一个任务等待时运行。
- en: '![](img/62383f7126bcb8bb684fec52bf6e98ce_15.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62383f7126bcb8bb684fec52bf6e98ce_15.png)'
- en: And basically that's the secret。 But you probably want to know a little bit
    more。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这就是秘密。不过你可能想知道更多一点。
- en: '![](img/62383f7126bcb8bb684fec52bf6e98ce_17.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62383f7126bcb8bb684fec52bf6e98ce_17.png)'
- en: How can you do that with one process and one thread？ So you need two things，
    basically。 The first thing that you need， which sounds awfully difficult， is to
    have a function that。 can suspend and resume。 We want the functions that are in
    our asynchronous program to suspend when they enter a wait。 And then when that
    condition that generated the wait ends， we want to resume those functions。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何能用一个进程和一个线程做到这一点？所以你基本上需要两样东西。第一样需要的东西，听起来非常复杂，就是有一个可以暂停和恢复的函数。我们希望在我们的异步程序中，当函数进入等待时暂停它们。当产生等待的条件结束时，我们希望恢复这些函数。
- en: from the point where they were suspended。 So sounds difficult。 but actually
    I counted four ways in which you can do this in Python， without operating system
    help。 And those ways are callback functions， which are gross。 I'm not going to
    even show an example of that because they're pre-gross。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从它们被暂停的点开始。所以听起来很难。但实际上，我在 Python 中找到了四种不需要操作系统帮助的方式。而这些方式是回调函数，这很麻烦。我甚至不打算展示那种示例，因为它们太麻烦了。
- en: But three ways that are a little bit more decent are using generator functions，
    which is a。 Python feature from years。 It's been there for a long time。 In more
    recent Python， 3。5， a nap。 there's a async/await keywords that you can use for，
    that。 And then finally。 there's a third-party package called greenlet that actually
    implement this。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但有三种稍微体面的方式是使用生成器函数，这是一种Python特性，已经存在很多年了。在最近的Python 3.5中，有一个async/await关键字可以用来实现这一点。最后，还有一个叫greenlet的第三方包，实际上实现了这一点。
- en: as a C extension to Python。 And you can install that with pip and it gives you
    another way to suspend and resume functions。 So that's the first part。 So now
    we can suspend and resume。 The next thing that we need is we need a piece of code
    that can decide how the CPU is shared， how。 you know， which function gets the
    CPU next。 Right？ So we need a scheduler of sorts。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Python的C扩展。你可以通过pip安装它，它给你提供了一种暂停和恢复函数的另一种方法。所以这是第一部分。现在我们可以暂停和恢复。接下来我们需要一段代码，可以决定CPU如何共享，知道哪个函数下一个获得CPU，对吧？所以我们需要一种调度器。
- en: And in asynchronous programming， this is called an event loop。 So we're going
    to have an event loop。 It will know all the tasks that are running or that want
    to run。 And then it will select one。 It will give control to it。 And then that
    task is going to suspend when it needs to wait for something。 And control will
    go back to the loop and the loop will find another one。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步编程中，这被称为事件循环。所以我们将有一个事件循环。它会知道所有正在运行或想要运行的任务。然后它会选择一个，给它控制权。然后那个任务在需要等待某些东西时会暂停。控制权会返回到循环，循环会找到另一个。
- en: And that's -- it will keep going that way until the script ends。 So this is
    called cooperative multitasking。 It's a thing， you know， from many years ago。
    I mean。 the very old versions of Microsoft Windows， for example， or Mac OS did
    this。 So it's an old idea。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这样——它会持续这样运行直到脚本结束。所以这被称为协作多任务处理。这是个古老的概念，你知道，从很多年前就有了。我是说，早期版本的微软Windows，例如，或者Mac
    OS都这样做。所以这是一个老主意。
- en: '![](img/62383f7126bcb8bb684fec52bf6e98ce_19.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62383f7126bcb8bb684fec52bf6e98ce_19.png)'
- en: So anyway， that's how it works。 So I created a bunch of examples to show you
    how this looks in practice。 I'm not going to have time to show all of them， but
    if you go or say that link， you。 can see more examples that I created that I'm
    not going to have time to show here。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，这就是它的工作原理。所以我创建了一堆示例，向你展示这在实践中是怎样的。我没有时间展示所有的，但如果你去那个链接，你可以看到更多我创建的例子，而我没有时间在这里展示。
- en: '![](img/62383f7126bcb8bb684fec52bf6e98ce_21.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62383f7126bcb8bb684fec52bf6e98ce_21.png)'
- en: But I'm going to show a few here。 So this is a super simple test that I created。
    Let's say we want to write a little script that prints hello， waits three seconds，
    and。 then prints world。 Okay？ So this is how you will do it in normal Python。
    You will print the first text， then sleep for three seconds， and then print the
    second， one。 Right？
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但我会在这里展示几个例子。所以这是我创建的一个超级简单的测试。假设我们想写一个小脚本，打印“hello”，等待三秒，然后打印“world”。好吗？这就是你在正常Python中如何做的。你会打印第一个文本，然后睡眠三秒，然后打印第二个，明白吗？
- en: So if I were to put a for loop on that hello at the bottom to run -- to call
    hello 10 times。 for example， this is going to run not for three seconds， but for
    30 seconds。 Right？ You know。 each function implication will run and they're going
    to run back to back。 So here are two examples that use async。io。 And you can see，
    you know。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我在底部加一个循环来运行“hello”10次，例如，这将运行不是三秒，而是三十秒。对吧？你知道，每个函数调用都会运行，它们会一个接一个地运行。这里有两个使用async.io的例子。你可以看到，你知道。
- en: there's a little bit of boilerplate at the top to create one， of these event
    loops。 And there's another little couple of lines of boilerplate at the bottom
    to run the asynchronous。 function。 But ignoring that， you can see that in the
    function， we have here two ways to do this。 suspension， so suspending a function
    and then resume it。 On the left。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部有一点样板代码来创建这个事件循环。底部还有几行样板代码来运行异步函数。但忽略这一点，你可以看到在这个函数中，我们有两种方式来实现这个。暂停，因此暂停一个函数然后恢复它。在左边。
- en: I'm using a generator function。 So generators are these special functions that
    typically you use in Python to generate。 sequences of items。 And the nice thing
    about them is that you don't have to regenerate all the entire sequence。 You can
    generate elements of that sequence as， you know， the person calling the generator，
    asks。 So you can repurpose that using this yield or yield from keywords。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用生成器函数。因此，生成器是这些特殊的函数，通常用于在Python中生成项的序列。而它们的一个优点是你不必重新生成整个序列。你可以根据调用生成器的人要求，生成该序列的元素。所以你可以通过使用这个`yield`或`yield
    from`关键字来重新利用它。
- en: And also use it for an asynchronous function。 And basically what we're saying
    on the example on the left。 when we reach the yield from， we're， saying， okay，
    loop， I'm done for now。 so I give you back control。 Please run this function for
    me that the one that follows the yield from。 So I think I just sleep for three
    seconds。 And when that's done， I'm ready to continue。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以将其用于异步函数。基本上我们在左侧示例中所说的就是，当我们达到`yield from`时，我们在说，好的，循环，我现在完成了，所以我把控制权交还给你。请为我运行这个在`yield
    from`之后的函数。所以我想我只是睡了三秒。当完成时，我准备继续。
- en: And the loop will keep， you know， it'll take note of that and then manage everything，
    because。 it's a scheduler。 That's what it does。 So if I were to call this hello
    function 10 times。 instead of running for 30 seconds， you， can see 10 hello's
    and then， you know。 a pause of about three seconds and then you're， going to see
    10 whirls。 Because， you know。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 循环会记下这一点，然后管理一切，因为它是一个调度器。这就是它的功能。所以如果我调用这个hello函数10次，而不是运行30秒，你可以看到10个hello，然后，你知道，暂停大约三秒，然后你会看到10个whirl。因为，你知道。
- en: doing that three second wait， the loop will find， you know， all the， other nine，
    right。 it'll run one first and then the other nine eventually will get run。 Okay？
    So in recent Python。 there's an improvement。 You get a much nicer syntax， which
    you can see on the right， but， you know。 functionally， these two are equivalent。
    And you have the async def declaration。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在等待三秒的过程中，循环会找到其他九个，对吧。它会先运行一个，然后其他九个最终也会被运行。好的？所以在最近的Python中，有了改进。你可以在右侧看到更好看的语法，但从功能上讲，这两个是等价的。你有`async
    def`声明。
- en: That's what you use to define a synchronous function。 And then if you use that
    syntax to declare the function， then you get to use a wait for。 the suspension
    and assuming。 So that's the point where things are suspended。 And one of the things
    that async。io， I think it's great for is that it makes very explicit。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你用来定义同步函数的方式。如果你使用这种语法声明函数，那么你就可以使用`wait for`来处理暂停和假设。所以这是事情被暂停的点。而我认为`async.io`特别好的一个方面是，它使得这一点非常明确。
- en: the points where the code suspends and resumes。 You know。 all those points where
    these magic of multitasking can happen。 But async。io is not the only one。 There
    are a bunch of others。 Actually， I don't have time to tell you about all of them。
    but I wanted to mention the ones， that are based on the greenlet package that
    I mentioned early。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代码暂停和恢复的点。你知道，所有那些可以发生多任务魔法的点。但`async.io`并不是唯一的。还有很多其他的。实际上，我没有时间告诉你所有的，但我想提一下那些基于我之前提到的greenlet包的。
- en: And these two， these are G event on the left and event let on the right。 You're
    probably going to have trouble finding where the loop is in this code。 And actually。
    you're probably going to have trouble finding what's the difference between。 this
    and the synchronous Python example。 Right？ They look kind of the same。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个是左侧的G事件和右侧的事件让。你可能会发现很难找到这个代码中的循环。而且实际上，你可能会发现很难找出这个与同步Python示例之间的区别。对吧？它们看起来有点相似。
- en: I don't know if you noticed， but the only difference is that the sleep function
    that I'm。 using on these two is not the sleep function from the Python library。
    It's a different one that each framework provides。 But that's the only difference。
    And the goal of these two frameworks， which are very much alike， is to make asynchronous。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你是否注意到了，但这两个的唯一区别在于我使用的sleep函数不是来自Python库的sleep函数。它是每个框架提供的不同的函数。但这就是唯一的区别。这两个框架的目标非常相似，就是要实现异步。
- en: programming transparent sort of。 And that could be a blessing and it also could
    be a curse。 It depends on how you look at it。 And as an open source developer。
    I find that a lot of people get into this thinking that， it's all the same。 Right？
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 编程是透明的。这可能是一个祝福，也可能是一个诅咒。这取决于你如何看待它。作为一个开源开发者，我发现很多人以为这都是一样的，对吧？
- en: I'm going to start doing whatever I do always。 And then things。 weird things
    happen because they're not considering that this underneath。 is running a loop
    and you need to make sure that you never block。 Because if you block。 then you're
    blocking the whole thing。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我将开始做我所做的任何事情。然后事情就会发生奇怪的变化，因为他们没有考虑到这个底层正在运行一个循环，你需要确保你永远不要阻塞。因为如果你阻塞了，那就会阻塞整个进程。
- en: '![](img/62383f7126bcb8bb684fec52bf6e98ce_23.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62383f7126bcb8bb684fec52bf6e98ce_23.png)'
- en: Which leads into the pitfalls。 This is actually I'm interested here in saying
    these things that I'm constantly answering。 on the issues on my GitHub project。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了陷阱。实际上，我在这里想说的是这些我不断回答的事情，关于我在 GitHub 项目上的问题。
- en: '![](img/62383f7126bcb8bb684fec52bf6e98ce_25.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62383f7126bcb8bb684fec52bf6e98ce_25.png)'
- en: Because people always trip on these things。 And a pit full number one is that
    what happens if you have。 you know， you probably have an， asynchronous program
    about maybe one task or a few of the tasks need to do some heavy。 CPU calculation。
    And the problem is if you use the CPU in your function for say one minute。 then
    during that， minute nothing else will happen。 Because this is a single thread。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因为人们总是会在这些事情上绊倒。而最大的一个坑是，如果你有一个异步程序，可能有一个任务或几个任务需要进行一些繁重的 CPU 计算。问题是，如果你在函数中使用
    CPU 比如说一分钟，那么在那一分钟内什么都不会发生。因为这是单线程的。
- en: So all tasks need to be nice to the remaining tasks and release the CPU often。
    So if you have an opportunity to wait， right， and nothing to wait for， what do
    you do？
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所有任务需要对剩下的任务友好，并且经常释放 CPU。所以如果你有机会等待，而没有任何东西可以等待，你会怎么做？
- en: And what you do is to sleep。 Basically， you have to be nice and call sleep every
    once in a while in your function。 As often as you can。 And if you're really greedy
    and you don't want to give up the time that you've got。 the， best you can do is
    you can sleep for zero seconds。 Which is basically telling the loop。 I'm going
    to sleep because I have to， I don't want， to but I have to。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你所要做的就是休眠。基本上，你需要友好地在你的函数中每隔一段时间调用休眠。尽可能频繁。如果你真的很贪心，不想放弃已经拥有的时间，那么你能做的最好的就是休眠零秒。基本上是在告诉循环：“我要休眠，因为我必须，不想，但我必须。”
- en: But please give me control back as soon as possible because I want to use the
    CPU。 So basically you sleep zero。 And if your calculation has a loop which is
    pretty common。 then you stick a sleep zero， inside that loop。 So once per iteration
    you allow other tasks to continue running。 So this number one。 Now the big one，
    this is going to be a big surprise probably。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但请尽快把控制权交还给我，因为我想使用 CPU。所以基本上你休眠零秒。如果你的计算中有一个循环，这很常见，那么你就把休眠零秒放在那个循环里。每次迭代时，你允许其他任务继续运行。这是第一点。现在最大的一个，这可能会是一个大惊喜。
- en: There's a bunch of things in the Python standard library that are designed as
    blocking functions。 So everything that has to do with networking， so reading，
    writing from network sockets。 waiting on input or output from sockets， anything
    to do with processes， with threads。 the sleep function that we've seen before，
    you cannot use them。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库中有一堆设计为阻塞函数的东西。所以所有与网络相关的内容，比如从网络套接字读取、写入，从套接字等待输入或输出，任何与进程和线程相关的，之前看到的休眠函数，你都不能使用。
- en: So this is true for every async framework。 You cannot use these functions。 If
    you use these functions， the thing is going to hang。 So don't use them。 Okay。
    It's very unfortunate。 It's like they want me to tell them when they ask about
    this， you know。 I want to use them。 Well you can't。 So you can't。 So all async
    frameworks provide replacements for these functions。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这对每个异步框架都是适用的。你不能使用这些函数。如果你使用这些函数，程序将会挂起。所以不要使用它们。好的，这非常不幸。就像他们想让我告诉他们当他们问到这个时，你知道的。我想用它们。好吧，你不能。所以你不能。因此所有异步框架都提供了这些函数的替代品。
- en: And sometimes that kind of sucks because you have to learn a different way to
    do the things。 that you know how to do。 All these very common things that you
    do with processes。 threads and networking。 Unfortunate， but it's true for async。io，
    true for event-led。 G-event。 twisted， curio， you know， all of them。 They all provide
    alternative ways to do these blocking things。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候这种情况很糟糕，因为你必须学习不同的方式来做你已经知道怎么做的事情。所有这些你用进程、线程和网络处理的非常常见的事情。不幸的是，但这对async.io、event-led、G-event、twisted、curio等都是如此。它们都提供了做这些阻塞事情的替代方法。
- en: Now you remember the sleep function in event-led。g-event that was coded almost
    or actually is identical。 to the Python one。 So the folks that developed event-led。g-event。
    they went other way to create all these alternatives。 for the versions in a very
    compatible way to the ones in the Python library。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你还记得在事件驱动的G-event中那个几乎或者实际上与Python的sleep函数是相同的函数吗？因此，开发event-led的那些人走了其他的路来创建所有这些替代方案，以非常兼容的方式与Python库中的版本相匹配。
- en: And they have both this option to monkey patch the standard library。 So basically
    they swap out the blocking functions from the Python library and they put their。
    own in their place。 So then you can take any piece of code that was designed to
    run synchronously and somehow。 they inherit this asynchronous behavior。 And for
    many applications that's enough to get code that was assigned synchronously to。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 他们都有这个选项来猴子补丁标准库。因此基本上，他们将Python库中的阻塞函数替换掉，并将自己的函数放在其位置上。这样你可以拿任何一段设计为同步运行的代码，某种程度上，它们继承了这种异步行为。对于许多应用程序而言，这足以让原本被指定为同步的代码能够。
- en: work。 But you have to use an in-led。g-event。 Now I'm going to save you guys
    time。 Somebody is going to come later in the question period and ask how do I
    do this for async。io。 And I'm going to say no， you can't。 You're not going to
    do this with async。io。 I think that you're assigned as an async framework that
    doesn't try to hide the asynchronous。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 工作。但你必须使用一个事件驱动的框架。现在我将为你们节省时间。稍后在提问环节会有人问我如何使用async.io。我会说不，你不能。你无法使用async.io做到这一点。我认为你被指定为一个async框架，它并不试图隐藏异步性。
- en: and the drug。 It wants you to design and write your code thinking asynchronously。
    which is a different， goal than these two event-led。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 它想要你设计和编写代码时考虑异步性，这与这两个事件驱动的目标不同。
- en: '![](img/62383f7126bcb8bb684fec52bf6e98ce_27.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62383f7126bcb8bb684fec52bf6e98ce_27.png)'
- en: '![](img/62383f7126bcb8bb684fec52bf6e98ce_28.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62383f7126bcb8bb684fec52bf6e98ce_28.png)'
- en: So I'm going to summarize this with a little table。 And this is probably going
    to be surprising to some of you。 So this compares processes。 threads and async
    on a number of categories。 So maybe based on what I said so far。 you think that
    these super cool， non-blocking， doing something while a task waits is exclusive
    to async。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我将用一个小表格总结一下。这可能会让你们中的一些人感到惊讶。这比较了进程、线程和异步在多个类别上的表现。所以也许基于我到目前为止所说的，你会认为这些超级酷的非阻塞、在任务等待时进行某些操作是独属于async的。
- en: And that is not true。 Processes and threads can do that pretty well too。 And
    it's actually not Python doing it。 In that case， it's the operating system doing
    it。 So there's no winner here。 There's a slight difference。 In the processes and
    threads case。 it's the operating system doing it。 In the async case， you have
    your async framework， async。io。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不真实。进程和线程也能做到这一点。而且实际上并不是Python在做到这一点。在这种情况下，是操作系统在做到这一点。所以这里没有赢家。进程和线程的情况略有不同，是操作系统在做到这一点。而在async的情况下，你有你的异步框架async.io。
- en: G event， or so on。 They're doing it。 So it's cooperative for async and preemptive。
    which is called when the operating system yanks， the CPU out of you without you
    knowing it。 But all of them can do it。 So there's no winner in this category。
    Now I already told you that if you want to maximize your multiple cores in your
    computer。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: G事件，或者其他。这都是合作的，适用于async和抢占式的，当操作系统在你毫不知情的情况下抢走CPU时就称为抢占式。但所有这些都能做到。所以在这个类别中没有赢家。现在我已经告诉你，如果你想最大化你计算机中的多核性能。
- en: then the only waste processes。 So this clear winner processes is the only option
    that can do that。 And many times people combine processes with one or the other
    two。 So they run a multi-threaded on an async program and then they run it as
    many times as。 cores you have， which is actually a pretty good idea。 But the process
    is the winner there。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 那么唯一浪费的就是进程。所以显然，进程是唯一可以做到这一点的选择。许多人会将进程与其他两种组合在一起。因此，他们在async程序上运行多线程，然后根据你拥有的核心数量运行它，这实际上是个不错的主意。但在这里，进程是赢家。
- en: So then we come to scalability。 This is an interesting one because if you're
    running multiple processes。 each process will， have a copy of the Python interpreter
    and all the resources that it uses plus a copy。 of your code， your application，
    plus all the resources that you use。 So all of that is going to be duplicated。
    So if you start going crazy and start new instances。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们来谈谈可扩展性。这是一个有趣的话题，因为如果你运行多个进程，每个进程都会有一个Python解释器的副本以及它使用的所有资源，还有你的代码副本和你使用的所有资源。所以所有这些都会被复制。如果你开始疯狂地创建新实例。
- en: you're going to find that pretty soon you're， going to reach。 you're going to
    be probably out of memory。 You cannot run a lot of Python processes on a normal
    computer。 So scalability is pretty low。 I would say in the ones or the tens， but
    no more than that。 If you go to threads， threads are a little bit more lightweight
    than processes。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你会很快发现你将达到内存限制。你不能在普通计算机上运行很多Python进程。所以可扩展性相当低。我会说在一位数或十位数，但不会超过这个。如果你使用线程，线程比进程轻量一些。
- en: So you can instantiate much more threads than processes。 So that's better。 You
    can scale a little bit better。 If you go with async， async gets all done in Python
    space。 There's no resources at the operating system level that are used。 So these
    are extremely lightweight。 So this is the clear winner。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以实例化比进程更多的线程。所以这更好。你可以稍微更好地进行扩展。如果你选择async，所有工作都是在Python空间中完成的。没有在操作系统级别使用的资源。所以这些都是极其轻量级的。所以这是明显的赢家。
- en: async can go in the thousands or tens of thousands even。 So this will be a good
    reason to go async。 Now we have the bad news of using the blocking functions in
    the Python standard library， which。 processes and threads can do no problem because
    the operating system knows how to deal with， those。 But when we lose the support
    of the operating system in async， we cannot use those functions。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: async可以达到数千或数万的级别。所以这将是一个选择async的好理由。现在我们有使用Python标准库中阻塞函数的坏消息，进程和线程没有问题，因为操作系统知道如何处理这些。但当我们失去操作系统在async中的支持时，就不能使用这些函数。
- en: and we need replacements。 And then last， the global interpreter lock。 we know
    it causes some trouble with threads。 In my experience， though。 it's not that bad
    when you have the types of applications that， are good for async。 which are heavily
    I/O， because unlike some people think， if you have。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要替代方案。最后是全局解释器锁。我们知道它在处理线程时会造成一些麻烦。不过，根据我的经验，当你有适合async的应用程序时，情况并没有那么糟，因为这些应用程序的I/O非常密集，因为与某些人的想法相反，如果你有。
- en: threads that are blocked on I/O， they don't hold the global interpreter lock。
    So if a thread goes to wait， then the operating system will give access -- will
    be able to。 give access to another thread without any problems。 So really， it's
    not that great。 I mean。 there aren't that many things that are better for async。
    It's that， right？ That's it。 So basically。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 被I/O阻塞的线程不会持有全局解释器锁。所以如果一个线程进入等待状态，操作系统将能够给另一个线程访问，而没有任何问题。所以，实际上，这并不太好。我的意思是，没有太多事情比async更好。就是这样，对吗？就这些。
- en: the closing statement that I would like to make is that really the best。 argument
    to go async is when you really need massive scaling。 So these will be servers
    that are going to be very busy。 Lots of clients want to handle lots of clients
    without going bankrupt in buying hosting， right？
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要做的总结是，实际上，选择async的最佳理由是当你真的需要大规模扩展时。这些将是非常繁忙的服务器。许多客户端希望处理大量客户，而不会在购买托管时破产，对吗？
- en: So async can do that really well。 It can go into thousands or the tens of thousands
    of connections。 And it's like nothing。 It's not a problem。 Which threads cannot
    get there and even less processes。 Any other categories， it's not really clear
    that you should go async unless you like it。 And then it's a totally valid framework
    to develop your applications， right？ So if you like it。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所以异步可以做得非常好。它可以处理成千上万的连接。就像没什么问题。线程无法做到这一点，进程更是不行。其他类别则不太清楚是否应该使用异步，除非你喜欢它。然后，这完全是一个有效的框架来开发你的应用，对吧？所以如果你喜欢它。
- en: you like it。 There's nothing to say against that。 So this is pretty much all
    I have。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你喜欢它。对此没有什么反对意见。所以这基本上就是我所拥有的全部。
- en: '![](img/62383f7126bcb8bb684fec52bf6e98ce_30.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62383f7126bcb8bb684fec52bf6e98ce_30.png)'
- en: It looks like I did good time， right？ So just going to be time for questions。
    Looks like。 Thank you。 [Applause]， \>\> Thank you， Miguel。 Are there any questions？
    Yes， we have one here。 \>\> So my question is， is it possible to schedule a new
    schedule？ Are there any questions？ Yes。 we have one here。 \>\> So my question
    is， is it possible to schedule asynchronous operation from multiple threads？
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我有好时光，对吧？所以现在是问问题的时间了。看起来。谢谢。[掌声]，>> 谢谢，米格尔。有什么问题吗？是的，我们这里有一个。>> 所以我的问题是，是否可以安排一个新的调度？有没有问题？是的。我们这里有一个。>>
    所以我的问题是，是否可以从多个线程安排异步操作？
- en: \>\> You can run a loop。 You can run multiple loops， right， in different threads。
    \>\> So each loop is per thread， right？ \>\> Correct。 \>\> They don't go together
    in the same bucket and then get to the end。 \>\> Then you have to use normal threading
    synchronization mechanisms if you need， you know。 the thread， tasks that are running
    under one loop to somehow coordinate with the other。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '>> 你可以运行一个循环。你可以在不同的线程中运行多个循环，对吧？>> 每个循环是每个线程，对吧？>> 正确。>> 它们不会在同一个桶里一起运行然后结束。>>
    然后如果你需要，你就得使用正常的线程同步机制，以便在一个循环下运行的线程任务能够与另一个循环协调。'
- en: It gets pretty nasty， to be honest。 \>\> So pretty much it gets affiliated to
    that thread。 \>\> That's correct。 \>\> That's correct。 \>\> Yes。 Yes。 because
    most of the times you have only one thread。 So yes。 \>\> All right。 Thank you。
    \>\> Yep。 \>\> Hi。 Miguel。 Thank you for that talk。 I was hoping if you can give
    me some help trying to conceptualize this in like a stack frame。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，这变得相当麻烦。>> 所以基本上它被关联到那个线程。>> 是的。>> 是的。因为大多数时候你只有一个线程。所以是的。>> 好吧。谢谢。>> 嗯。>>
    嗨。米格尔。谢谢你的演讲。我希望你能帮我尝试将这个概念化为一个堆栈帧。
- en: all this magic that happens not necessarily just with async but generators and
    everything。 in general。 How do you--， \>\> Well， the generators， they're a Python
    feature， right？
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些魔法不仅发生在异步操作中，还有生成器等等。总的来说，你怎么想——>> 嗯，生成器是Python的一个特性，对吧？
- en: They already support the， you know， saving the context when the generator function
    calls。 the yield or yield from keyword。 It basically returns。 It does sort of
    a partial return。 It returns a value and control goes back to the loop。 And then
    the loop can call that again to。 you know， to make that function to do a little，
    bit more work。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 他们已经支持你知道的，当生成器函数调用`yield`或`yield from`关键字时保存上下文。它基本上返回。它算是一种部分返回。它返回一个值，控制权回到循环中。然后循环可以再次调用它，以便你知道，让那个函数做一点更多的工作。
- en: which is exactly what you do when you write a generator function。 You basically--
    you have a function that returns partial values。 Every time you call it。 it does
    a little bit more work and returns another-- you know， another value and another
    result。 \>\> Okay。 \>\> Does that make sense？ \>\> One additional question。 \>\>
    Yes。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是你在编写生成器函数时所做的。你基本上有一个返回部分值的函数。每次调用它时，它会多做一点工作，返回另一个——你知道的，另一个值和另一个结果。>> 好的。>>
    这有意义吗？>> 还有一个额外的问题。>> 是的。
- en: \>\> In an architecture where you spawned off multiple processes of the async
    workers in， say。 for a server， how do you， like， the socket binding， how would
    that work across the different。 processes？ \>\> It's only one thread that will
    have a really large number of connections。 \>\> But if I have the same port that
    has to go through multiple processes and each of。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '>> 在一个架构中，你产生了多个异步工作进程，比如说，对于一个服务器，socket绑定是怎么在不同的进程之间工作的？>> 只有一个线程会有大量连接。>>
    但如果我有相同的端口必须通过多个进程，每个进程。'
- en: them have a single thread of async。 \>\> There are multiple ways to do it。 So
    for example。 you can have a something like NGINX， a reverse proxy in front。 So
    then you say you have four processes。 They could be listening on different ports，
    right？
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 他们有单线程异步。 \>\> 有多种方式来实现。例如，你可以有像 NGINX 这样的反向代理在前面。那么你可以说你有四个进程。他们可以监听不同的端口，对吧？
- en: Four ports， say。 And then NGINX， you know， consolidates that and then reverse
    proxy into all these backend。 async processes。 That will be one way。 \>\> Thank
    you。 \>\> Does that make sense？
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 四个端口，比如说。然后 NGINX，你知道，会整合这些并反向代理到所有后端。异步进程。这将是一种方式。 \>\> 谢谢。 \>\> 这有意义吗？
- en: \>\> How much more imprecise is an async sleep command than time。sleep？ \>\>
    More。 \>\> Could it be like seconds more or are we talking about a couple of milliseconds？
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: \>\> 异步睡眠命令比 time.sleep 不精确多少？ \>\> 更多。 \>\> 可能多几秒，还是我们谈论几毫秒？
- en: \>\> This is all cooperative， right？ So really your task depends on how the
    other tasks that are running at the same time behave。 If you have a rogue task
    that， you know， that's a lot of computation and doesn't return。 to the loop as
    often as it should， that's going to affect your timing。 So yes。 And that's actually
    the problem that I see most often is that， you know， people forget。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: \>\> 这都是协作的，对吧？所以实际上你的任务取决于同时运行的其他任务的表现。如果有一个 rogue 任务，你知道，那是大量计算而且没有及时返回到循环，这会影响你的时机。所以是的。这实际上是我最常见的问题，你知道，人们常常忘记。
- en: that they're doing async and there's some task that does something that blocks
    and that。 stops the whole thing for everybody。 So yes， imprecise？ Sure。 You need
    to make sure that all the tasks are well designed for async。 \>\> We have time
    for one more short question。 \>\> So I guess my question is related to the one
    that gentlemen asked previously。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 他们正在做异步，而有一些任务会阻塞，停止整个流程。所以是的，不精确？当然。你需要确保所有任务都为异步而精心设计。 \>\> 我们还有时间再问一个简短的问题。
    \>\> 所以我想我的问题和之前那位先生问的问题有关。
- en: So actually in JavaScript， one of the issues is we used to leave， say， for 10
    seconds。 It's actually at least 10 seconds。 So I guess in Python。 they have the
    same issue when I want to sleep a certain callback for， 10 seconds。 it's still
    at least 10 seconds。 Is that right？ \>\> It depends on which--， \>\> Yeah。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上在 JavaScript 中，一个问题是我们习惯于睡眠，假设 10 秒。实际上至少是 10 秒。所以我想在 Python 中，当我想让某个回调睡眠
    10 秒时，它仍然至少是 10 秒。对吗？ \>\> 这取决于哪个——， \>\> 是的。
- en: it depends on the other items in the queue。 \>\> So as I said before。 the sleep
    function is going to be implemented by the async framework， that you use。 So async
    IO implements sleep and then G event implements sleep in a different way， the
    wrong。 way and every framework does it in its own way。 And you can have to find
    the best async framework if you are concerned about that。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于队列中的其他项目。 \>\> 正如我之前所说，睡眠功能将由你使用的异步框架实现。所以异步 IO 实现睡眠，然后 G 事件以不同的方式实现睡眠，错误的方式，每个框架都有自己的实现方式。如果你对此有顾虑，必须找到最好的异步框架。
- en: You need to find the one that is more accurate。 But in the end， it's cooperative。
    So it depends on all the tasks being nice to each other。 If you don't have that。
    then this doesn't work。 \>\> Well， I guess in JavaScript， at least。 the guarantee
    that we will be at least 10 seconds。 \>\> Yeah， and you get a guarantee of that
    sort。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要找到一个更精确的。但最终，这是合作的。所以这取决于所有任务互相友好。如果没有这一点，那么就行不通。 \>\> 好吧，我想在 JavaScript
    中，至少有保证我们会至少 10 秒。 \>\> 是的，你得到了那样的保证。
- en: But exact times are heavily dependent on how the tasks return to the loop。 \>\>
    I think this feels like a discussion that could be continued out in the whole
    way。 Many thanks to Miguel。 \>\> Thank you。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但是确切的时间 heavily 依赖于任务返回到循环的方式。 \>\> 我觉得这似乎是一个可以在整个过程中继续讨论的主题。非常感谢 Miguel。 \>\>
    谢谢。
- en: '![](img/62383f7126bcb8bb684fec52bf6e98ce_32.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62383f7126bcb8bb684fec52bf6e98ce_32.png)'
- en: '[APPLAUSE]， [BLANK_AUDIO]。'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]，[空白音频]。'
- en: '![](img/62383f7126bcb8bb684fec52bf6e98ce_34.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62383f7126bcb8bb684fec52bf6e98ce_34.png)'
