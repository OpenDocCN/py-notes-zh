- en: P7：Al Sweigart   Yes Its Time to Learn Regular Expressions   PyCon 2017 - 哒哒哒儿尔
    - BV1Ms411H7jG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P7：艾尔·斯维加特   是的，学习正则表达式的时间到了   PyCon 2017 - 哒哒哒儿尔 - BV1Ms411H7jG
- en: So good afternoon， everyone。 We now have El Swigardt， who will be talking on，
    yes。 it's time to learn regular expressions。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大家下午好。现在有艾尔·斯维加特，他将谈论，是的，学习正则表达式的时间到了。
- en: '![](img/da584628c5b6ffc89ec806ec9cca879a_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da584628c5b6ffc89ec806ec9cca879a_1.png)'
- en: '[Applause]， Hello， hi。 I''m El Swigardt。 I''m probably best known for writing
    Python books。 including one called Automate the Boring， Stuff with Python。 which
    is released under a Creative Commons license。 So you can read this online for
    free。 You can check out the book and also my slides from bit。ly/yesregics if you
    want to follow。'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]，你好，嗨。我是艾尔·斯维加特。我可能以写Python书籍而闻名，包括一本叫《用Python自动化无聊的事情》的书，这本书是根据知识共享许可证发布的。所以你可以在线免费阅读这本书。你也可以查看这本书和我的幻灯片，网址是
    bit.ly/yesregics，如果你想跟进的话。'
- en: along with the slide deck。 I really encourage you to release your own content
    under an open license like Creative。 Commons。 One of the benefits that I have
    is that I can take a look at my web traffic and I noticed。 that the regular expression
    chapter in this book has a lot of traffic， so I thought， hey。 this would be a
    good idea for a talk。 So regular expressions are kind of this intimidating topic。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 连同幻灯片一起。我真的鼓励你将自己的内容以开放许可证（如知识共享）发布。我有一个好处，那就是我可以查看我的网站流量，我注意到这本书中的正则表达式章节流量很大，所以我想，这将是一个不错的演讲主题。因此，正则表达式有点像这个令人畏惧的话题。
- en: A lot of software developers pretty much put off learning it for most of their
    careers。 It seems really cryptic。 There's a bunch of weird punctuation marks that
    have special meaning。 It can be kind of hard to learn。 In fact， just 20 minutes
    before this talk。 I overheard somebody in the hallway say this， quote。 So I had
    to update my slides with that。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 很多软件开发者在职业生涯的大部分时间里几乎都推迟学习它。它似乎真的很晦涩。有很多奇怪的标点符号具有特殊的含义。学习起来可能有点困难。事实上，在这个演讲开始的20分钟前，我在走廊上听到有人说：“这个”，所以我不得不更新我的幻灯片。
- en: But in general， regular expressions are really powerful if you have to do text
    pattern matching。 And I really encourage you to learn them。 And so yes， it's time
    for me to start this presentation。 which is entitled yes， it's， time to learn
    regular expressions。 So the first thing that you'll learn is that they're also
    called red checks for short。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，正则表达式在文本模式匹配方面非常强大。我真的鼓励你去学习它们。所以，是的，到了我开始这个演示的时候了，标题是“是的，学习正则表达式的时间到了”。首先你会学到它们也被简称为“红色检查”。
- en: So here's two numbers， actually it's one number and one of these numbers is
    a phone number。 and the other is the population of Asia。 So which one is which？
    Well， if you're like me。 you've memorized every single American phone number that
    exists。 and you can tell that that top number is one of them。 No。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个数字，实际上是一个数字和一个电话号码，另一个是亚洲的人口。那么哪个是哪个呢？如果你像我一样，你已经记住了每一个存在的美国电话号码，你可以告诉那个顶部的数字是其中之一。不是的。
- en: that's not how you actually do that at all。 You know it's a phone number because
    you know a phone number when you see it and you know。 it when you see it because
    you know there's a specific pattern that all American phone。 numbers follow。 It's
    a few digits for the area code with dashes in the middle of it。 So that's what
    regular expressions do。 You can specify a pattern of text that you're looking
    for even if you don't know the exact。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上并不是这样做的。你知道这是个电话号码，因为你看到电话号码时就知道它是什么。你知道它是什么，因为你知道所有美国电话号码都有一个特定的模式。它是区域代码的几个数字，中间有短横线。这就是正则表达式的作用。你可以指定你正在寻找的文本模式，即使你不知道确切的内容。
- en: numbers or the exact text that you're looking for。 And it's really easy。 Python
    makes this really simple。 It's just about three lines of code。 The first is to
    import the regular expression module which is import re then you want to。 call
    the compile function and pass it your regular expression pattern that you're looking。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数字或你正在寻找的确切文本。其实这非常简单。Python 让这一切变得很简单。这大约只需要三行代码。第一行是导入正则表达式模块，即 `import re`，然后你需要调用编译函数，并传入你想要的正则表达式模式。
- en: for then you're going to call the search method on the regular expression object
    that that。 returns and you have pass it the haystack string。 I call it the haystack
    string。 If you're looking for one string inside of another I say you're looking
    for the needle。 string inside the haystack string and that's going to return a
    match object and you call。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你将对返回的正则表达式对象调用搜索方法，并传递它给干草堆字符串。我称之为干草堆字符串。如果你在另一个字符串中寻找一个字符串，我会说你在寻找干草堆字符串中的针字符串，这将返回一个匹配对象。
- en: the group method on that and that will print out the exact text that you're
    looking for。 So did I say three lines？ I meant four lines。 But it's still basically
    just three lines of text。 Compile search and group。 And also if you're busy scrambling
    to write all of this down。 Remember you can download these slides at bit。ly/yesrejects
    so just calm down。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于该分组方法，它将打印出你正在寻找的确切文本。所以我说三行了吗？我意思是四行。但基本上仍然只是三行文本。编译、搜索和分组。而且如果你忙着写下所有这些，记得可以在bit.ly/yesrejects下载这些幻灯片，所以放轻松。
- en: Stop taking notes and listen to my soothing voice。 Let's focus in on each one
    of these parts。 So starting with compile and this regular expression string of
    the pattern that you're。 sending to compile。 This is the main complicated part
    of Python's regular expression figuring out the syntax。 for this。 So let's go
    back to that phone number example。 What exactly is a phone number？
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 停止做笔记，听我温和的声音。让我们关注这些部分。首先是编译和你传递给编译的正则表达式字符串。这是Python正则表达式中最复杂的部分，理解这个语法。所以让我们回到那个电话号码的例子。电话号码究竟是什么？
- en: How do you know a phone number when you see it？ Well it starts off with a digit
    character which is one of the ten numerals zero through。 nine followed by another
    digit character and another digit character and then a dash and， so on。 So we
    need to translate this into a regular expression string in the regular expression。
    syntax and that's what we're going to pass to compile。 Remember there's compile
    search and group。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何在看到一个电话号码时知道它是什么？它以一个数字字符开始，这是十个数字中的一个，从零到九，后面跟着另一个数字字符，再一个数字字符，然后是一个破折号，等等。所以我们需要将其转换为正则表达式字符串，并将其传递给编译。记住有编译、搜索和分组。
- en: So we're going to use /d which is the regular expression syntax for a digit。
    We want to pass this as a raw string because otherwise if you don't have a raw
    string you're。 going to have to escape that slash and you're going to have all
    of these slashes in your regular。 expression string so I tend to like to send
    raw strings always to the compile function。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用/d，这是表示数字的正则表达式语法。我们希望将其作为原始字符串传递，因为如果没有原始字符串，你将不得不转义那个斜杠，并且在你的正则表达式字符串中会有很多斜杠，所以我通常喜欢将原始字符串始终传递给编译函数。
- en: So this /d will match a digit character and our phone numbers are going to have
    three。 of these for the area code followed by a dash and so on。 This is the regular
    expression string to match a phone number。 After that we get the regular expression
    object and we can call search on that and pass it。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个/d将匹配一个数字字符，我们的电话号码将有三个这样的字符作为区号，后面跟着一个破折号，等等。这是匹配电话号码的正则表达式字符串。之后我们获得正则表达式对象，可以对其调用搜索并传递它。
- en: our haystack string。 This is the string that we're searching for that pattern
    we're looking for and it will。 return a match object and it will return a match
    object if it finds the pattern otherwise。 it will return none。 So we have to check
    if the match object is none or not and when we call group on that。 match object
    remember compile search group that's going to print out the actual text that。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的干草堆字符串。这是我们要搜索的字符串，我们正在寻找的模式，如果找到了，将返回一个匹配对象，否则将返回none。所以我们必须检查匹配对象是否为none，当我们对该匹配对象调用分组时，记住编译、搜索、分组，这将打印出你正在寻找的实际文本。
- en: matches the regular expression pattern that we were looking for just like that。
    Now this seems I know I said that oh it's a lot easier than you think。 This is
    still kind of complicated remembering compile search group。 If you're just calling
    the find string method that's a lot more straightforward it's just。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配我们正在寻找的正则表达式模式，就像这样。现在这似乎，我知道我说过这比你想的要简单得多。这仍然有点复杂，记住编译、搜索、分组。如果你只是调用查找字符串方法，那要简单得多。
- en: one line of code but imagine if you didn't have regular expressions to do this
    find phone。 number example you would have to write Python code that looks like
    this which isn't that。 hard to follow but it's a lot of it and it's really gnarly
    and phone numbers are actually。 pretty simple patterns once you get into really
    much more complicated regular expressions the。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一行代码，但想象一下如果你没有正则表达式来处理这个查找电话号码的例子，你将不得不编写如下的 Python 代码，这并不难理解，但数量庞大，且非常复杂，一旦你深入了解真正复杂的正则表达式，电话号码其实是相对简单的模式。
- en: Python code that you would have to write to do the same thing as a small regular
    expression。 would just explode across pages and pages of text and we don't want
    that。 So let's examine that slash D thing that I was talking about earlier that
    that matches， a digit。 This is something called a character class it's it represents
    a range of characters or a。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要编写的 Python 代码来完成与小正则表达式相同的事情，会在页面上展开成一堆文字，而我们并不想要那样。所以让我们来看看我之前提到的那个 slash
    D，它匹配一个数字。这被称为字符类，它表示一系列字符或一个。
- en: class of characters that you're looking for and slash D is the one saying I'm
    looking。 for a digit one of the numbers。 There's a few other character classes
    there's slash W for word characters this is letters。 and numbers and I believe
    also the underscore character there's slash S for space characters。 like space
    and tab and new line and there's also the capitalized versions of these for。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你要寻找的字符类，而 slash D 是表示我在寻找一个数字，数字之一。还有其他一些字符类，比如 slash W 表示单词字符，这包括字母和数字，我相信还包括下划线字符，slash
    S 则表示空格字符，如空格、制表符和换行符，此外还有这些的大写版本。
- en: everything that's not a digit or not a word or not a space character。 Character
    classes are how you specify what exactly you're looking for so whenever you're。
    searching through a string try not to think of the actual semantic meaning of
    whatever。 text you're looking for just consider that string to be a sequence of
    symbols that you're。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一切不是数字、不是单词或不是空格字符的内容。字符类是你指定确切要寻找的内容的方法，所以每当你在字符串中搜索时，尽量不要考虑你所寻找的文本的实际语义，只需将该字符串视为你要查找的符号序列。
- en: looking for and these character classes match a certain group of symbols。 You
    can also create your own character classes by putting a bunch of characters inside
    the。 square brackets so if we wanted to say create a character class that matched
    all the vowels。 in the English language we just type a e i o u in lowercase and
    uppercase inside the square。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 查找这些字符类匹配某个符号组。你还可以通过将一堆字符放在方括号内来创建自己的字符类，所以如果我们想说创建一个匹配英语中所有元音的字符类，我们只需在小写和大写中输入
    a e i o u。
- en: brackets and now we have a character class matching vowel characters we can
    also do the。 same thing as the uppercase version of those previous character classes
    by just adding a。 character to the very front of this character class and now
    this is matching everything that's。 not a vowel character so that's going to be
    consonants it'll also be something like punctuation。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个匹配元音字符的字符类，我们也可以通过在这个字符类的最前面添加一个字符来做与之前字符类的大写版本相同的事情，现在它匹配的是所有不是元音字符的内容，所以这将是辅音，也会包括标点符号。
- en: marks or numbers that's something that you have to keep in mind it's everything
    that is。 literally not those 10 characters and we can also have ranges of characters
    if you want。 to match say all 26 letters or all 10 numbers or all or both of those
    things you can just。 use a dash character to have say zero dash nine and that's
    going to be all 10 characters。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 标记或数字，这是你必须记住的内容，它是所有不属于这 10 个字符的内容。如果你想匹配所有 26 个字母或 10 个数字，或者这两者，你可以简单地使用破折号字符，比如
    0-9，这将匹配所有 10 个字符。
- en: and this character class basically does the same thing as the slash w character
    class it's。 matching all the numbers and letters so in these examples we had the
    character at the。 very beginning or those dash characters we're not literally
    looking for those characters。 punctuation marks in regular expression syntax tends
    to have very specific meaning so if。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符类基本上与 slash w 字符类做的事情相同，它匹配所有的数字和字母。在这些例子中，我们有字符在开头或那些破折号字符，我们并不是字面上寻找这些字符。正则表达式语法中的标点符号往往具有非常具体的含义，所以如果。
- en: we're actually looking for any of these punctuation market characters just be
    sure to escape them。 with a backslash in front of them so if say we want to create
    a character class that matches。 open and closing parentheses we can just add a
    slash character in front of those parentheses。 and now we have a character class
    that matches the set of parentheses either the opening or。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上在寻找这些标点符号字符，只需确保在它们前面加上反斜杠进行转义。因此，如果我们想创建一个匹配开括号和闭括号的字符类，我们只需在那些括号前加一个反斜杠，现在我们有一个匹配一对括号的字符类。
- en: closing characters so character classes as I said this is what you're looking
    for inside。 of your regular expression is how you tell python I'm looking for
    these characters you。 can also specify a quantity of these characters we kind
    of did this with a phone number example。 just by repeating the slash D's over
    and over again but there's a shortcut for this you can。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭字符，因此字符类，正如我所说，这就是你在正则表达式中要寻找的内容，告诉 Python 我在寻找这些字符。你也可以指定这些字符的数量，我们在电话号码示例中做过这种重复`/D`的方式，但这里有一个快捷方式。
- en: use curly braces and a number in between the curly braces to say hey I'm looking
    for three。 of these digit characters followed by a dash and so on for the rest
    of the phone number。 example this matches the exact same thing as the previous
    regular expression but it's。 a bit more compact and here's the pattern that we're
    following right here we have slash D。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大括号和大括号之间的数字来表示“嘿，我在寻找三个”，后面跟着一个破折号，手机号码的其余部分也是如此。这个示例与前面的正则表达式完全匹配，但更简洁，这里是我们遵循的模式，我们有`/D`。
- en: that's the character class that's what we're looking for coming first and then
    after that。 we have the quantity that we're looking for you're going to see this
    repeated over and over。 again what we're looking for and the quantity that we're
    looking for and that curly brace。 three for matching three of the thing that it
    comes after is really handy but there's。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们要寻找的字符类，首先是这个，然后之后是我们要寻找的数量，你会看到这个重复出现，我们所寻找的和我们要寻找的数量，以及匹配后面内容的三个大括号，确实很方便，但还有。
- en: a bunch of these others and there's a huge list of punctuation marks you don't
    actually。 have to memorize these very few people do memorize these you'll just
    end up going back。 to a cheat sheet or looking them up in the documentation but
    you have all these punctuation。 marks that mean things like hey I have slash D
    I'm looking for a digit and the question。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一堆其他的标点符号，实际上你并不需要记住这些，极少数人会记住这些，你最终会回去查阅备忘单或文档，但你有所有这些标点符号，意味着像“嘿，我有`/D`，我在寻找一个数字”，而问题。
- en: mark which means I'm looking for zero or one of these digits or the plus sign
    that means。 I'm looking for one or more of these digit characters you can change
    the character class。 that you're looking for too and suddenly it's you know I'm
    looking for zero or one space。 or I'm looking for one or more spaces or use your
    own character classes like we did with。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 标记意味着我在寻找零或一个这些数字，或表示我在寻找一个或多个这些数字字符的加号，你可以更改字符类。
- en: our vowel example now we're looking for zero or one vowels and one or more vowels
    all those。 punctuation marks you don't have to memorize them right now just remember
    we have character。 classes at the first part that's what we're looking for followed
    by the quantity and now。 if it's something completely different so Japanese words
    are composed of letters and。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的元音示例中，现在我们在寻找零或一个元音和一个或多个元音，所有这些标点符号你现在不需要记住，只需记住我们有字符类，这是我们要寻找的部分，后面跟着数量。
- en: Japanese letters usually follow this consonant vowel combination so take a Japanese
    word like。 Sayonara it's made up of four letters each of those are a consonant
    and vowel it's a。 consonant vowel consonant vowel it's following that pattern
    we can create a regular expression。 that will then match this remember we have
    a character class for matching vowels and then。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 日语字母通常遵循这种辅音元音组合，所以拿一个日语单词，比如“再见”，它由四个字母组成，每个字母都是辅音和元音，遵循这个模式，我们可以创建一个正则表达式来匹配这个。请记住，我们有一个用于匹配元音的字符类。
- en: we also have that carrot one for matching that everything that's not a vowel
    technically。 this will match not just consonant letters but also numbers and punctuation
    marks we'll。 just ignore that for right now but anyway say we wanted to match
    a Japanese word which。 is made up of several of these Japanese letters we can
    have the plus sign that means one or。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有那个匹配所有不是元音的内容的插入符号，严格来说，这将匹配的不仅是辅音字母，还包括数字和标点符号，我们暂时忽略这一点，但无论如何，假设我们想匹配一个由几种日语字母组成的日语单词，我们可以加上加号，表示一个或多个。
- en: more of the thing that comes before it but technically this isn't going to work
    because。 remember it's just going to match only one of those consonant patterns
    we need to specify。 how many of those that we want to match but we also sort of
    want to group these together。 so this regular expression is going to end up matching
    something like but so it's a consonant。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在它之前的更多内容，但严格来说，这样做是行不通的，因为记住它只会匹配其中一个辅音模式，我们需要指定我们想要匹配多少个，但我们也希望将这些组合在一起。因此，这个正则表达式最终将匹配类似的东西，但它是一个辅音。
- en: character followed by a bunch of vowels and it doesn't have to be the same vowel
    it can。 just be any vowel that's the character class that we're looking looking
    for one or more。 vowel characters I'm not even going to attempt to pronounce this
    word but what we want to。 do is sort of just group together that consonant and
    vowel together and then have the plus sign。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符后面跟着一堆元音，并且元音不必是相同的，可以只是任何元音，这就是我们要寻找的字符类，寻找一个或多个元音字符，我甚至不会尝试发音这个词，但我们想要做的就是将辅音和元音组合在一起，然后再加上加号。
- en: mean one or more of these things so we can use parentheses to group these together
    and。 form just sort of one giant character class out of all these other character
    classes it's。 still the same thing we're specifying what we want to look for followed
    by how many of。 them that we want to look for so this is going to match something
    like sa sa sa sa sa sa sa。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着这些东西的一个或多个，因此我们可以使用括号将这些组合在一起，并形成一个巨大的字符类，所有其他字符类仍然是相同的，我们在指定我们想要查找的内容后，接着是我们想要查找的数量，因此这将匹配像sa
    sa sa sa sa sa sa这样的内容。
- en: sa sa sa or it'll match an actual Japanese word like Sayonara so this would
    be a pretty。 good point for me to thematically end my talk on Sayonara but actually
    there's a little。 bit more we're going to go into just a small example right here
    with red jacks is for a。 comma formatted number so if you're an American you usually
    split up your numbers into groups。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: sa sa sa，否则它将匹配一个实际的日语单词，比如再见（Sayonara），所以这将是我在再见这个主题上结束我的演讲的一个不错的时机，但实际上还有一点更多，我们要在这里稍微深入探讨一个小例子，涉及逗号格式的数字，如果你是美国人，通常会把数字分成三组，中间用逗号隔开。
- en: of three with a comma in between them in between them so let's create a regular
    expression for。 this we have to figure out what exactly it is that the pattern
    that we want to match here is so。 it's generally going to be something like one
    to three digits for the lead part and then followed。 by groups of these sort of
    comma and three digits afterwards and we'll have you know zero or more。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们为此创建一个正则表达式，我们必须弄清楚我们想要匹配的模式究竟是什么，所以它通常会是像一个到三个数字的开头部分，后面跟着这些逗号和三位数字的组，然后我们会有零个或多个。
- en: of those groups so a number like 12 is going to have zero of those comma groups
    because there's no。 commas or a number like 12，000 we'll have one of those groups
    and I could just sit here and show。 you the regular expression for this but there's
    actually a lot of nifty tools online that you can。 try out these are called red
    jacks buddy websites or red jacks tester websites and now I'm going to。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组中的一个，例如，像12这样的数字将没有任何逗号组，因为没有逗号，或者像12,000这样的数字将会有一个这样的组，我可以坐在这里给你展示这个正则表达式，但实际上网上有很多不错的工具可以尝试，这些被称为red
    jacks伙伴网站或red jacks测试网站，现在我要。
- en: do something that is highly ill advised for anybody doing a presentation and
    that is a live demo in。 which anything can go wrong especially one that requires
    using the internet so hopefully the。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 做一些对于任何进行演示的人来说都极其不明智的事情，那就是进行现场演示，其中任何事情都有可能出错，尤其是需要使用互联网的演示，所以希望。
- en: '![](img/da584628c5b6ffc89ec806ec9cca879a_3.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da584628c5b6ffc89ec806ec9cca879a_3.png)'
- en: '![](img/da584628c5b6ffc89ec806ec9cca879a_4.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da584628c5b6ffc89ec806ec9cca879a_4.png)'
- en: Wi-Fi is going to hold and I can just use this website so this is red jackser。com
    technically it's。 using JavaScript style regular expressions but regular expressions
    across multiple programming。 languages are so similar that it's going to work
    for Python as well so let's let's try out let's say。 I have my text I have a 64
    million year old egg and we want to find a regular expression that。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Wi-Fi 将会保持，我可以直接使用这个网站，这个是 red jackser.com，严格来说，它是使用 JavaScript 风格的正则表达式，但跨多种编程语言的正则表达式是如此相似，因此它也可以在
    Python 中工作，所以让我们试试，假设我有我的文本，我有一个 6400 万年历史的蛋，我们想找到一个正则表达式。
- en: '![](img/da584628c5b6ffc89ec806ec9cca879a_6.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da584628c5b6ffc89ec806ec9cca879a_6.png)'
- en: matches let's see how much I can move this not that okay there we go I want
    to write a regular。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配，让我们看看我能移动多少，不，没关系，好吧，我想写一个常规的。
- en: '![](img/da584628c5b6ffc89ec806ec9cca879a_8.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da584628c5b6ffc89ec806ec9cca879a_8.png)'
- en: expression that matches that comma delimited number so let's see what was this
    this was a digit and。 then I want between one and three of them so I'll try a
    curly brace one comma three and you can see。 as I'm typing in real time these
    websites are going to update and show you exactly what they're。 what they're matching
    so these are great if you're trying to construct a regular expression and you。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配这个逗号分隔数字的表达式，所以让我们看看，这是什么，这是一位数字，然后我想要它们的数量在一到三之间，所以我将尝试一个大括号 `{1,3}`，你可以看到，当我实时输入时，这些网站会更新，并准确展示它们在匹配什么，所以这些网站在你试图构造正则表达式时非常有用。
- en: sort of want to just build it up step by step it's a lot easier than just running
    your code seeing what。 it matches then trying to go back and change it this is
    a much more direct method so let me。 finish this up let's see we're gonna have
    that group of the comma three digit things so I'll need a。 nurse slash D and then
    a three afterwards oh wait great and I can see well oh this isn't quite working。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我想一步一步地构建，这比直接运行代码看看匹配了什么，然后再试图回去修改要简单得多，这是一种更直接的方法，所以让我完成这个，我们要有这个由逗号和三位数字组成的组，所以我需要一个
    `\d` 然后再加一个三位数，哦等等太好了，我可以看到，哦，这并没有完全奏效。
- en: because it's not matching everything right here and then we'll remember oh right
    I wanted not one of。 these comma groups but zero or more so I'm gonna add a star
    to mean zero more and I can see okay it。 matches the comma delimited number all
    right hey I got through the entire live demo and nothing went。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这里并没有匹配到所有内容，然后我们会记得哦，对了，我想要的不是这些逗号组，而是零个或多个，所以我要加一个星号来表示零或多个，我可以看到，好的，它匹配到逗号分隔的数字，好的，我成功完成了整个现场演示，没有出现问题。
- en: '![](img/da584628c5b6ffc89ec806ec9cca879a_10.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da584628c5b6ffc89ec806ec9cca879a_10.png)'
- en: '![](img/da584628c5b6ffc89ec806ec9cca879a_11.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da584628c5b6ffc89ec806ec9cca879a_11.png)'
- en: wrong whoo yes live demo completes every time I do a live demo in a talk I feel
    like I'm like。 angering the live demo god who's going to start chasing me from
    conference to conference waiting for。 me to let my guard down and just ruin the
    next live demo I try right not today okay next pipes this is。 a way that you can
    sort of provide alternate groups to choose from and the example that I want to
    use is。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 错了，哇，是的，现场演示每次我在演讲中做现场演示时，我感觉像是在惹怒现场演示之神，他会从会议追到会议，等待着我放松警惕，然后把我下一个现场演示搞砸，不，今天不行，好，下一个管道，这是你可以提供备用组以供选择的一种方式，我想用的例子是。
- en: let's say we want to create a regular expression to match sentences of Monty
    Python words and Monty Python。 words I'm gonna use underscores instead of spaces
    just make them more visible and just to make it easier。 and more consistent all
    the Monty Python words always end with an underscore but Monty Python words。 will
    be something like egg and spam or egg bacon and spam or egg bacon sausage and
    spam or spam。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想创建一个正则表达式来匹配《蒙提·派森》的单词，而《蒙提·派森》的单词我会用下划线代替空格，只是让它们更显眼，并且为了让它更容易和更一致，所有的《蒙提·派森》的单词总是以下划线结尾，但《蒙提·派森》的单词可能是“蛋”和“火腿”或者“蛋”、“培根”和“火腿”，或者“蛋”、“培根”、“香肠”和“火腿”，或者“火腿”。
- en: egg spam spam bacon and spam that one only has a little bit of spam in it so
    you might think okay。 let's create a regular expression we're gonna call compile
    that's the first step of compile search。 group and let's see we'll put these in
    a group for each word and we'll have that plus sign to mean。 one or more of this
    so we're gonna match one or more egg and one or more bacon except that's not。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 鸡蛋、火腿、火腿和火腿，这个只有一点点火腿在里面，所以你可能会想，好的，让我们创建一个正则表达式，我们称之为编译，这是编译搜索的第一步。我们将这些单词放入一个组中，并用加号表示一个或多个，因此我们将匹配一个或多个鸡蛋和一个或多个培根，但这并不。
- en: gonna quite work because what if bacon comes before the egg and what if sausage
    comes before egg or。 bacon or something like that this isn't actually going to
    work as a regular expression we just need。 some way of choosing one or another
    and we kind of do this if you think about it with character classes。 character
    classes say hey we're gonna match a or e or i or o or u except character classes
    only。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这不太好用，因为如果培根在鸡蛋前面，或者香肠在鸡蛋或培根前面，那这样其实并不能作为正则表达式正常工作。我们需要某种方法来选择一个或另一个，如果你仔细想想，我们可以用字符类来做到这一点。字符类会说“嘿，我们将匹配a或e或i或o或u”，但字符类仅仅是。
- en: work with individual characters we'd rather we want to match groups saying egg
    or bacon or sausage。 etc so we can do that with the pipe character which means
    or if you've ever programmed in a language。 like javascript or something else
    they also use the or character for the boolean or operator so it's a。 bit easier
    to remember that way so you can just put the pipe character in between these groups
    to say。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 处理单个字符，我们更想匹配组，比如鸡蛋或培根或香肠等。因此，我们可以用管道字符来实现，这意味着或。如果你曾经在像JavaScript这样的语言中编程，他们也使用或字符作为布尔或运算符，所以这样记起来会简单些。你可以在这些组之间放入管道字符。
- en: i want to match egg or bacon or sausage or and or spam and then put all of those
    groups into one。 giant group and then add a plus sign at the end so that it's
    matching one or more of those and that。 will match something like spam spam spam
    spam spam spam really stop sounding like a word if you say。 it over and over again
    and the last bit that i want to cover you've actually this is pretty much all。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要匹配鸡蛋或培根或香肠或火腿，然后将所有这些组放入一个巨大的组中，并在末尾加上一个加号，以便它可以匹配一个或多个这些内容。这样就可以匹配像“火腿火腿火腿火腿火腿火腿”这样的东西，真的说多了就会听起来不像个词，而我想要覆盖的最后一点是，你实际上需要的基本上就是这些。
- en: you need for the basics of regular expressions character classes quantities
    groups pipes that's。 essentially it this thing regular expressions that you've
    been putting off learning for years and。 years and years it's actually not that
    bad the rest of this stuff is just gravy but it's pretty。 cool i really love this
    the dot which basically means match any character except for the new line。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的正则表达式基础知识包括字符类、数量、分组和管道符号。正则表达式这个东西你可能拖延学习很多年，其实并没有那么糟糕，剩下的内容只是附加的，但这很酷，我真的很喜欢这个点，它基本上意味着匹配任何字符，除了换行符。
- en: this is great because it's a great character class you can also set a flag so
    that also includes the。 new line but you can combine it with the star character
    from several slides back that means zero or more。 and when their powers combine
    they form the dot star which just means match whatever there's a second。 one to
    this that is dot star question mark which means match the least amount of whatever
    because。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，因为这是一个很好的字符类。你也可以设置一个标志，使其包括换行符，但你可以将其与几张幻灯片之前的星号字符结合，这意味着零个或多个。当它们的力量结合时，就形成了点星，这意味着匹配任意内容。还有一个是点星问号，意味着匹配尽可能少的内容，因为。
- en: dot just means match whatever character and we're looking for zero or more of
    whatever so you can。 match whatever this is great you can use this in a string
    like looking for text angle bracket in。 between the angle brackets angle bracket
    this looks a lot like html and so let's say we want to get a。 regular expression
    that matches this html like text that's pretty simple we can just have。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 点仅仅意味着匹配任意字符，而我们寻找的是零个或多个任意内容，所以你可以匹配任意内容。这很棒，你可以在字符串中使用它，比如查找文本尖括号在尖括号之间。这看起来很像HTML，所以假设我们想要一个正则表达式来匹配这个HTML样式的文本，这很简单，我们可以直接。
- en: angle bracket dot star question mark angle bracket so we're just looking for
    whatever text in between。 angle brackets the least amount of it and then that
    would match a string that's sort of like。 angle bracket to serve humans angle
    bracket but remember there's the one with the question mark。 that's the least
    amount that's the non greedy version and then there's just dot star which is。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 角括号点星号问号角括号，所以我们只是在寻找角括号之间的任意文本，最少量的，然后这将匹配类似于“角括号为人类服务角括号”的字符串，但请记住，问号的那个是最少的，那是非贪婪版本，然后还有就是点星号，它是。
- en: the greedy version it's going to try to match the longest bit of text and that's
    when you find out。 the dark secret that really the string was angle bracket to
    serve humans angle bracket for dinner。 angle bracket ooh plot twist and the reason
    this happens is because dot star the greedy version is。 going to match the first
    part to serve humans and that technically matches the pattern that it's。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 贪婪版本，它会尝试匹配最长的文本段，这时你会发现黑暗的秘密，实际上这个字符串是“角括号为人类服务角括号吃晚餐”。角括号，哦，情节反转，而这种情况发生的原因是，点星号的贪婪版本会匹配第一部分“为人类服务”，而且这在技术上匹配它的模式。
- en: looking for but dot star is going to continue looking forward to see if there's
    an even larger。 string that it can match so if you want to match the most amount
    of text for this pattern you can use。 dot star and the least amount you can use
    dot star question mark that's pretty much it the you now。 have this solid foundation
    you can go into the python documentation and sort of look up all the。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正在寻找，但点星号会继续向前查看是否还有更大的字符串可以匹配，因此如果你想为此模式匹配最多的文本，可以使用点星号，而最少的可以使用点星号问号，这差不多就是你现在所拥有的这个坚实基础，你可以进入
    Python 文档，查找所有的。
- en: rest of the neat little tricks that you can do with regular expressions i kind
    of just want to end。 on some best practices some limitations to regular expressions
    the first of which is really important。 and that is don't ever parse html with
    regular expressions i know i went back into this slide。 and said hey that looks
    like html don't actually do that with regular expressions you'll end up。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的关于正则表达式的小技巧，我想以一些最佳实践和正则表达式的局限性来结束，第一点非常重要，那就是永远不要用正则表达式解析 HTML。我知道我回到这个幻灯片，想说嘿，看起来像
    HTML，实际上不要用正则表达式来做，你最终会发现。
- en: creating a regular expression that sort of matches html and then you'll realize
    oh wait it also needs。 to be case insensitive so then you change it a little bit
    and then you realize oh wait there's。 some attribute that's out of order or something
    weird like that and you'll have to change the。 regular expression um you'll end
    up making a regular expression that doesn't really match html instead。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个正则表达式，大致匹配 HTML，然后你会意识到哦等等，它还需要。对大小写不敏感，因此你稍微修改一下，然后你会发现哦等等，有某些属性的顺序不对或其他奇怪的情况，你将不得不更改正则表达式。嗯，最终你会得到一个根本不匹配
    HTML 的正则表达式。
- en: what you should do is use an html parsing tool like beautiful soup that module
    same thing with。 jason you want to use a jason parser to match jason text um the
    second thing is uh i used to use。 this as a interview question come up with a
    regular expression that matches a strong password you know。 something that has
    lowercase and uppercase letters and numbers and special characters the regular。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该做的是使用 HTML 解析工具，比如 Beautiful Soup，这个模块与 JSON 一样，你希望使用 JSON 解析器来匹配 JSON 文本。嗯，第二件事是，我以前常用这个作为面试问题，想出一个匹配强密码的正则表达式，你知道，包含小写字母、大写字母、数字和特殊字符的东西，正则。
- en: expression to do this turns out to be this huge giant thing especially because
    you have to get the。 all possible orderings of lowercase and uppercase and numbers
    and everything and it's really awful。 um if your regular expression starts blowing
    up into this giant thing that's probably a good。 uh time to just break it up into
    smaller regular expressions you can just use multiple regular。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式要做到这一点，结果变成了一个庞大的东西，尤其是因为你必须获取所有可能的大小写和数字的排列，一切都变得非常糟糕。嗯，如果你的正则表达式开始膨胀成这样一个庞然大物，可能是个好时机将其拆分为更小的正则表达式，你可以使用多个正则。
- en: expressions on the same bit of text something that looks for a lowercase letter
    something that looks。 for an uppercase character uh and then finally this is kind
    of going into the computer science of。 regular expressions and regular languages
    um matching nested parentheses regular expressions can't do。 this matching parentheses
    rely on having the same number of open and closed parentheses they have to。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式处理同一段文本，查找小写字母的东西，查找大写字母的东西，然后最后这有点涉及到正则表达式和常规语言的计算机科学。匹配嵌套的括号，正则表达式无法做到这一点。匹配括号依赖于开括号和闭括号的数量相同，它们必须。
- en: be in a certain order and uh technically regular expressions aren't Turing complete
    which is a。 computer science term that i'm just gonna gloss over but you can think
    of this it has regular。 expressions aren't programming languages they don't have
    flow control or loops or variables or。 things like that and the reason i know
    this is because at my last job we were doing a code review for。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 按照一定的顺序，而技术上说，正则表达式不是图灵完备的，这是一个计算机科学术语，我只会简单提及，但你可以认为正则表达式不是编程语言，它们没有控制流或循环或变量或。诸如此类的东西，我之所以知道这一点，是因为在我上一份工作中，我们正在进行代码审查。
- en: some web app and the user can type in a regular expression into the text field
    and we wanted to。 validate that make sure they were typing in a valid regular
    expression and a co-worker said hey。 can you actually come up with a regular expression
    that matches regular expressions and i leapt forward。 and said no you can't because
    regular expression strings uh have groups which require nested parentheses。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网络应用程序，用户可以在文本字段中输入正则表达式，我们想验证这一点，确保他们输入的是有效的正则表达式。一位同事说：“嘿，你能实际提出一个匹配正则表达式的正则表达式吗？”我立刻跳出来说不可以，因为正则表达式字符串有组，这需要嵌套的括号。
- en: and that requires a stack data structure which means it mean it requires a context-free
    grammar。 and that's beyond the capabilities of regular languages and i was so
    excited because it was the。 only time i've ever used my computer science degree
    for something in the real world。 um but yeah so that's just some best practices
    with regular expressions uh they do have their。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一个栈数据结构，这意味着它需要一个无上下文文法。这超出了常规语言的能力，我感到非常兴奋，因为这是我第一次在现实世界中使用我的计算机科学学位。嗯，但总之，这只是关于正则表达式的一些最佳实践，它们确实有它们的。
- en: limitations but they are so incredibly powerful and useful to have so i definitely
    encourage all of。 you to keep reading about it you can find more in the python
    documentation i also have them in。 the in the chapter in automate the boring stuff
    with python which you can read for free online。 but i really advise that you go
    ahead and whatever you do find out more about regular expressions and。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 限制虽然存在，但它们非常强大且实用，因此我绝对鼓励大家继续阅读相关内容，你可以在Python文档中找到更多信息，我也在《用Python自动化无聊的工作》的章节中有相关内容，你可以在线免费阅读。但我真的建议你去了解更多关于正则表达式的信息并。
- en: '![](img/da584628c5b6ffc89ec806ec9cca879a_13.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da584628c5b6ffc89ec806ec9cca879a_13.png)'
- en: use them because yes it is time to learn regular expressions thank you very
    much。 so do we have time for questions yes i guess line up at the microphones。
    so we do have time for some questions so if you have some questions please line
    up here。 and please keep the questions short and simple because we have only five
    minutes left so yep。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它们，因为是时候学习正则表达式了，非常感谢。那么我们有时间提问吗？是的，我想我们可以在麦克风前排队。所以我们确实有时间问一些问题，如果你有问题，请在这里排队。并请保持问题简短明了，因为我们只有五分钟的时间，所以。
- en: hello hey i was wondering if you have a good use case for look-aheads。 i do
    i remember um so one of the fancy things that you can do with regular expressions。
    wow i've been saying regular expressions a lot today one of the things that you
    can do with them。 is not only find but also find and replace um so let me。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，我想知道你是否有一个关于前瞻的好用例。我记得有，嗯，正则表达式可以做的其中一个花哨的事情。哇，今天我说了很多正则表达式。你可以做的事情不仅是查找，还有查找和替换，所以让我。
- en: let's say you had some texts like agent alice told agent bob the in the info。
    um so look-aheads are basically when you want to use the pattern that you found
    in a regular。 expression later on in that same regular expression so let's say
    you wanted to do something where。 you want to find every case of the pattern the
    word agent followed by some uh some other name。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一些文本，比如代理阿丽斯告诉代理鲍勃的信息。嗯，前瞻基本上是在你想在同一个正则表达式中后续使用你找到的模式时使用的，所以假设你想做一些事情，找到“代理”这个词后面跟着某个其他名字的每一种情况。
- en: you know and then using this space as telling it when to stop and you wanted
    to replace it with。 just star star star but keeping that first letter so this
    is sort of redacting it with a find and。 replace using regular expressions um
    this is the example that i use for using look-aheads which。 i'm going to mess
    this up i know let's see you would basically be looking for agent and then。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，然后使用这个空格告诉它何时停止，并希望用星星替换，但保留第一个字母。所以这算是用查找和替换的正则表达式进行某种删减。这是我用来使用前瞻的例子，我知道我会搞砸，让我们看看你基本上是在寻找“代理”，然后。
- en: let's see slash w i guess one or more of these， oh haha that's why everybody's
    looking at me weird there we go oh now i can't see there we go um。 yeah we're
    looking for like agent alice and we want to find this text and then replace it
    we can。 use that group that's the first group that we found so we would replace
    it with this text agent。 slash one i believe meaning just use the text of the
    first group oh wait no i would want that first。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看斜杠W，我想这些中的一个或多个，哦哈哈，这就是为什么大家奇怪地看着我，没错哦，现在我看不到了，没关系，嗯。是的，我们在寻找像“代理阿丽斯”这样的文本，我们想找到这个文本，然后替换它。我们可以使用那个组，那是我们找到的第一个组，所以我们将用这个文本代理替换它。斜杠一，我相信这意味着只使用第一个组的文本，哦等一下，我想要的是第一个。
- en: character so that's in our group followed by the rest of that name。 let me see
    if i got this right um and so this is called a look-ahead it's where you use slash
    one。 slash two to refer to the groups of characters in your regular expression
    pattern that you've。 matched before um yeah anyway let's move on to the next question
    so um in an API that i'm well my team。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 字符，所以这在我们的分组中，后面跟着那个名字的其余部分。让我看看我是否搞对了，嗯，这叫做前瞻，是你用斜杠一、斜杠二来引用你在正则表达式模式中之前匹配的字符组。嗯，好吧，我们继续下一个问题，所以，嗯，在一个API中，我的团队。
- en: writing uh we we use regular expressions and we need a negative look behind
    and python only seems。 to support fixed worth fixed worth groups um so in your
    pattern if you do like something and something。 or something or something you
    will have to be the same width which seems bizarre to us um so our。 our solution
    is to just shell out the graph and do it properly in a proper。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 写作，嗯，我们使用正则表达式，需要一个负向回顾，而Python似乎只支持固定宽度组，所以在你的模式中，如果你做类似“某个东西和某个东西，或某个东西或某个东西”，你必须保持相同的宽度，这对我们来说似乎很奇怪。所以我们的解决方案是将图表转交给外部，并在适当的情况下正确处理它。
- en: oh yeah proper regular expression and the application so do you have any other
    ideas uh i mean that is。 one way of doing it there's so there's slight variations
    between different languages and different。 command line tools in how they handle
    regular expressions especially the more advanced features。 like these look-ahead
    things um basically if you find something that python can't do you could find。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，是的，合适的正则表达式和应用程序。所以你还有其他想法吗？我意思是，这是一种做法，在不同的语言和不同的命令行工具之间，处理正则表达式的方式略有不同，尤其是这些前瞻的高级特性。基本上，如果你发现Python做不到的事，你可以找到。
- en: other regular expression modules uh if you really really need that behavior
    there's other regular。 expression modules on pi pi that you can download um do
    we have time for more questions or are we out。 hi uh this question may be against
    the general spirit of your talk to learn regular expression。 is there a tool that
    lets you uh accept that before version and after version of a text and。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 其他正则表达式模块，如果你真的需要这种行为，Pi Pi上还有其他正则表达式模块可以下载。嗯，我们还有时间问更多问题吗，还是没有了？嗨，嗯，这个问题可能与您讲座的整体精神相悖，学习正则表达式。有工具让你接受文本的版本前和版本后。
- en: suggest the regular expression or suggest some of the regular expressions you
    could come up with。 to do that that's kind of a sort of the exact project that
    i wanted to work on during the sprints。 was uh this was gonna be like a learning
    tool for uh where you can type in a regular expression and。 i'll just start spitting
    out some example strings of what it could potentially match um i from the。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 建议一些正则表达式，或者建议你能想出的正则表达式。为了实现这个目标，这正是我想在冲刺期间做的项目。这将是一个学习工具，你可以输入正则表达式，然后我会开始输出一些可能匹配的示例字符串，我从。
- en: brief look that i did around the internet for a tool like this i haven't been
    able to find anything。 that does something like that but that's a great idea somebody
    should make that or you can help me。 make that during the sprints wait for that
    thanks thanks uh do we have time for one more question。 yeah hey this is just
    uh this is uh intellectual vandalism uh how would i handle so you're saying。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我在网上简单浏览了一下，找不到这样的工具。虽然没有类似的工具，但这是个好主意，有人应该开发这个，或者你可以在冲刺期间帮我做这个，感谢你。请问还有时间问一个问题吗？好的，嘿，这简直是知识破坏行为，我该如何处理？你是说。
- en: it's not a question oh yeah it is okay we have time go ahead you're the last
    person how do i handle。 Unicode uh oh wait unit unit code oh Unicode right so
    no no go answer save it for later。 yeah so i think i've tested this out and uh
    python's regular expression module does handle。 Unicode i think i know this because
    i have uh this lod。exe program i made which copies the look of。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是个问题，哦，是的，确实是。好的，我们还有时间，继续吧，你是最后一个人，我该如何处理Unicode？哦等一下，单位代码，哦，Unicode，对，所以不，不，去回答吧，留到后面。是的，我想我测试过这个，Python的正则表达式模块确实处理Unicode，我想我知道这一点，因为我有一个程序lod.exe，它可以复制。
- en: disapproval emoji uh to my clipboard so i can just paste it uh oh wait i've
    already erased that but。 i tried pacing Unicode characters and just all sorts
    of weird stuff in and it seems to work just。 fine so bravo python yeah uh well
    i've tested that in python 3 anyway i'm not sure who knows with python。 too but
    yeah anything else oh that's it all right thank you very much。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不满的表情符号，我会把它复制到剪贴板上，这样我就可以粘贴了。哦等一下，我已经删除了那个。不过，我尝试过粘贴Unicode字符，还有各种奇怪的东西，它似乎工作得很好。所以，太棒了，Python！是的，反正我在Python
    3中测试过这个，我不确定Python 2怎么样，但没关系，还有其他问题吗？哦，就是这样，非常感谢你。
- en: '![](img/da584628c5b6ffc89ec806ec9cca879a_15.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da584628c5b6ffc89ec806ec9cca879a_15.png)'
- en: so thank you all for your great talk。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢你们的精彩演讲。
- en: '![](img/da584628c5b6ffc89ec806ec9cca879a_17.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da584628c5b6ffc89ec806ec9cca879a_17.png)'
