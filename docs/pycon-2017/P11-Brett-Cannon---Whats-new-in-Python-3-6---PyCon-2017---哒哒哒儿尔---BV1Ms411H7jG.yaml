- en: P11：Brett Cannon   Whats new in Python 3 6   PyCon 2017 - 哒哒哒儿尔 - BV1Ms411H7jG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P11：布雷特·卡农 Python 3.6的新变化 PyCon 2017 - 哒哒哒儿尔 - BV1Ms411H7jG
- en: \>\> Ladies and gentlemen， Python 3 has been released for many years and after
    every year。 they have a new version being released。 So this year， we welcome 3。6。
    You may wonder what's new in it。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 各位女士们先生们，Python 3已经发布多年，每年都会有新版本发布。所以，今年我们迎来了3.6。你可能想知道它有什么新内容。
- en: '![](img/cacb898a89c411fd6f7537986de224f6_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cacb898a89c411fd6f7537986de224f6_1.png)'
- en: We really make a huge difference in Python 3。6。 We figured out in this lecture，
    as welcome。 Brad Cannon for what's new in this。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的在Python 3.6中产生了巨大的影响。我们在这次讲座中发现，欢迎布拉德·卡农分享这个的新变化。
- en: '![](img/cacb898a89c411fd6f7537986de224f6_3.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cacb898a89c411fd6f7537986de224f6_3.png)'
- en: We're going to be in Python 3。6。 [ Applause ]， \>\> Well， thank you for the
    warm intro， everyone。 So。 yes， my name is Brad Cannon。 I work at Microsoft on
    the Azure Data Science Tools team。 And I'm here to basically tell you what's new
    in Python 3。6。 Now。 I should start off and say everything I'm about to tell you
    is already written out on the internet。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python 3.6。[鼓掌]，谢谢大家热情的介绍。所以，是的，我叫布拉德·卡农。我在微软的Azure数据科学工具团队工作。我来这里基本上是告诉你Python
    3.6的新变化。现在，我应该开始说，我将告诉你的所有内容在互联网上已经写好了。
- en: so you can completely ignore me and still get the exact same amount of information，
    more or less。 If you go to docs。python。org/3。6/whatsnew/3。6。 resmail， you can
    also get to just off of docs。python。org。 As I said， everything is there， so if
    you miss something and want to read it up on it later。 it'll be there。 So， yes，
    if my Canadian ism's frustrate you， you can ignore me。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以完全忽略我，仍然获得相同数量的信息，或多或少。如果你访问docs.python.org/3.6/whatsnew/3.6，您也可以直接从docs.python.org访问。正如我所说，一切都在那里，所以如果你错过了什么，想以后再阅读，它会在那里。因此，是的，如果我的加拿大口音让你感到沮丧，你可以忽视我。
- en: '![](img/cacb898a89c411fd6f7537986de224f6_5.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cacb898a89c411fd6f7537986de224f6_5.png)'
- en: Another way you can also do this is I'm going to be going over the 16 Python
    enhancement proposals。 that help make up Python 3。6。 So， if you go to python。org/dev/peps，
    you can read the peps。 get even more detail， and have yet another way to ignore
    me and still get the information。 So。 once again， don't feel bad if you have to
    leave or anything or want to just tune me out。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是，我将讨论16个Python增强提案，这些提案有助于构成Python 3.6。因此，如果你访问python.org/dev/peps，你可以阅读这些提案，获得更多细节，同时还有另一个方式可以无视我，仍然获取信息。所以，再次强调，如果你需要离开或者想要忽视我，也不用感到不好。
- en: I understand。 One key thing I want to say， though。 about the point that there
    are 16 Python enhancement proposals。 is that is almost our record for Python。
    The only release since we started doing Python enhancement proposals that had
    more was Python 3。0， which we all know was a very large release。 So， that should
    give you an idea of the scale in terms of new features that have come into Python
    3。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我明白了。不过，我想说的一个关键点是，16个Python增强提案几乎是我们Python的记录。自从我们开始做Python增强提案以来，唯一一个发布的提案数量更多的是Python
    3.0，大家都知道这是一个非常大的版本。所以，这应该能给你一个关于Python 3中新功能规模的概念。
- en: 6。 So， I just hope you understand that a lot of work went into this。 And I really
    want to think specifically， everyone who participated in the 2016 Python course
    print。 that happened last September at Instagram， 12 of the 16 peps I'll be talking
    about。 were somehow worked on at that sprint。 So， I specifically want to thank
    Instagram for hosting and being the largest financial contributor to that。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我只希望你理解，为此付出了很多努力。我真的想特别感谢所有参与2016年Python课程集训的人，去年九月在Instagram举行的集训，有12个我将讨论的16个提案是在那个集训中以某种方式工作的。所以，我特别想感谢Instagram的主办和对这个活动的最大财务支持。
- en: Microsoft for also being a financial contributor and letting me and my co-worker
    Steve Dower attend。 and the PSF are also helping pay for other people to attend。
    So。 thanks everyone who helped make that happen。 It made a huge difference in
    the scope of Python 3。6。 But without further ado， I'll jump into this。 I'm going
    to go in numeric order for the peps and basically just try to give you some background
    information。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢微软作为财务支持者，让我和我的同事史蒂夫·道尔参加，同时PSF也在帮助其他人参与。所以，感谢所有帮助实现这一目标的人。这对Python 3.6的范围产生了巨大影响。但不再赘述，我将开始这个话题。我会按照提案的编号顺序进行，并试着给你一些背景信息。
- en: beyond just what the feature is to liven this up a little bit。 So， without further
    ado。 PEP 468。 Preserving Keyword Argument Order。 I believe this is Eric Snow's
    pep if he happens to be in the room。 He's right there。 Basically what this does
    is whenever you start StarKWR。 historically it was just a dictionary。 So， that
    usually meant everything was randomized and you didn't know what order people
    actually specified。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了功能本身之外，让这一切更生动一些。因此，事不宜迟，PEP 468。保留关键字参数顺序。我相信这是 Eric Snow 的 PEP，如果他在场的话。他就在那儿。基本上，这个功能是每当你开始使用
    StarKWR 时，历史上它只是一个字典。因此，这通常意味着一切都是随机的，你不知道人们实际上指定的顺序。
- en: keyword arguments in and make it a function call。 What PEP 468 said was we are
    going to guarantee a mapping。 not necessarily dictionary， but a mapping， that
    will actually keep order of the keyword arguments passed in a function call。 Now，
    in Python 3。6， if you happen to be in Raymond's talk right now。 you'd be told
    about how Python 3。6 is dictionary， and she keeps the order。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里传入关键字参数并使其成为一个函数调用。PEP 468 的意思是我们将保证一个映射，不一定是字典，但一个映射，实际上会保留在函数调用中传入的关键字参数的顺序。现在，在
    Python 3.6 中，如果你正参加 Raymond 的讲座，你会被告知 Python 3.6 是字典，并且它保持顺序。
- en: I'm going to say this multiple times in this talk。 Please do not rely on the
    order of dictionary key iteration or value iteration。 It is an implementation
    detail。 It is not part of the language。 We only guarantee it in this specific
    instance in the language spec。 So。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这个讲座中会多次提到这一点。请不要依赖字典键迭代或值迭代的顺序。这是一个实现细节。它不是语言的一部分。我们只在语言规范中的这个特定实例中保证它。因此。
- en: please do not rely on the ordering of anything coming out of a dictionary unless
    I specifically。 pointed out。 We might change that in the future， but I just know
    this is a place where some people might kind of get。 up。 So， I'm going to re-arrate
    that multiple times。 But yes， as you can see， order is now kept。 Thank you， Derek。
    PEP 487， simpler customization of class creation。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要依赖从字典中输出的任何内容的顺序，除非我特别指出。我们可能在未来改变这一点，但我知道这是某些人可能会困惑的地方。因此，我会多次重申这一点。但是，是的，正如你所看到的，顺序现在得到了保持。谢谢你，Derek。PEP
    487，简化的类创建定制。
- en: We've always provided a real rich ability to customize things in Python， specifically
    from。 the creation of classes， like meta classes are a great way to really control
    creating a class。 itself。 But for anyone here who has ever tried to write a meta
    class。 you know there's a lot of little， details。 It's really messy and hard to
    get writes。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直提供了非常丰富的能力来定制 Python 中的内容，特别是类的创建，比如元类是一个真正控制类创建的好方法。但是，对于在座的任何曾尝试编写元类的人来说，你知道有很多小细节。这确实很麻烦，而且很难写对。
- en: And then we go all the way up to the top of the scale where you get class decorators，
    where。 you basically after classes created， you can pass it through a decorator，
    modify it， customize。 things in any way you want。 But there's never really any
    middle ground or there's either all the way down the guts of Python in a。 meta
    class or all the way up after the classes are created and might be too late for
    certain。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们一路走到最上面，获得类装饰器，在那里，你基本上在类创建后，可以通过装饰器传递它，进行修改，自定义任何你想要的内容。但是从来没有真正的中间地带，或者要么完全深入
    Python 的元类，要么完全在类创建后，这可能对某些事情来说太晚了。
- en: things。 So， in Python 3。6， we added this dunder in its subclass hook。 We pass
    you in the class。 any keyword arguments passed into the constructor and then basically。
    just allow you to manipulate the class before the name binding happens。 So， as
    you'll notice here。 what I did was I defined this PEP 487 class where when it's，
    subclassed。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.6 中，我们在其子类钩子中添加了这个 dunder。我们将类传递给你，任何传递到构造函数中的关键字参数，然后基本上允许你在名称绑定发生之前操控类。因此，正如你在这里注意到的，我定义了这个
    PEP 487 类，当它被子类化时。
- en: the class is being constructed， the subclass being made gets passed in and I
    just。 defined a hello method that just prints hello to the keyword argument， as
    you'll notice。 in the class line。 Nothing fancy， but the key point is a nice insertion
    point between class decorators and。 meta classes， you customize your classes as
    necessary。 PEP 495， local time disambiguation。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 类正在被构造，子类被传入，我只是定义了一个 hello 方法，它只是向关键字参数打印 hello，正如你在类行中注意到的。没什么特别的，但关键点是这是一个在类装饰器和元类之间的良好插入点，你可以根据需要自定义你的类。PEP
    495，本地时间消歧义。
- en: This led to quite a discussion on Python Dev and to the extent there was a complete
    date。 times it created just for this problem and it literally led to a single
    argument in a， constructor。 It shows you how dedicated you could say we all are
    on Python Dev to trying to get things， right。 So， think back to November 6， 2016，
    it's daily savings time， you fell asleep， you woke up。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了 Python 开发者之间相当多的讨论，以至于为这个问题专门创建了一个完整的日期时间，并且确实导致了构造函数中的单一参数。这让你看到我们在 Python
    开发中为确保事情正确而付出的努力。所以，想想 2016 年 11 月 6 日，那是夏令时，你睡着了，醒来了。
- en: and your clock next to your bed said 1。30 am。 Has it been an hour and a half
    since the start of the day or has it been two and a half hours。 since the start
    of the day？ You have no idea， right？
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你床边的钟表显示是 1:30 AM。是从一天开始以来过去了一个半小时，还是两个半小时？你完全不知道，对吧？
- en: Unless you actually keep your time zone to know which time zone it is currently，
    whether。 it's savings time in terms of the time zone or after， you have no clue。
    So what ended up happening was we added this full argument to date time instances
    to basically。 say has time folded back over itself or not。 Now obviously it's
    best to keep your time zone in your date time objects so this ambiguity。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你实际上保留你的时区以知道当前是什么时区，无论是夏令时还是之后，你都毫无头绪。因此，最终我们向日期时间实例添加了这个完整的参数，以基本上说明时间是否回折。显然，最好在你的日期时间对象中保持时区，以消除这种模糊性。
- en: doesn't show up but we all know life's not perfect and we sometimes don't have
    the time。 zone available so this allows you to specify for that funky time during
    day like savings。 where it's ambiguous whether it's the first time through the
    hour or the second time through。 the hour to know exactly where you are in terms
    of time。 PEP 498， format string literals。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不显示，但我们都知道生活不是完美的，有时我们没有可用的时区，因此这允许你在诸如夏令时的那种模糊时间中指定，知道你在时间上到底处于哪个位置。PEP 498，格式字符串字面量。
- en: Everyone loves this。 I have yet to meet a single person who doesn't like this
    unless you're on hacker news and。 you complain that we now have three ways to
    do strings but you're still better off so， I don't care。 In case you have not
    come across F strings yet which are so great by the way that Pi。 Pi has actually
    backported to Pi Pi 3 which is supposed to be 3。5 compatible but also this。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都喜欢这个。我还没遇到一个不喜欢这个的人，除非你在黑客新闻上，抱怨我们现在有三种方式来处理字符串，但你仍然更好，所以，我不在乎。如果你还没遇到 F
    字符串，顺便说一句，它们实在是太棒了，Pi 实际上已经向 Pi Pi 3 回溯，这本该与 3.5 兼容，但也。
- en: This gives you an idea of how excited people are from this。 So if you notice
    on that third string there in the example you might not quite notice it。 there's
    an F prefix much like the B prefix for byte literals or R for raw strings etc。
    What you notice is the stirred out format methods signature of how to specify
    arguments。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你知道人们对此的兴奋程度。如果你注意到例子中第三个字符串，你可能不会注意到，它有一个 F 前缀，类似于字节字面量的 B 前缀或原始字符串的 R 前缀等。你会注意到的是格式化方法的签名，如何指定参数。
- en: into a string but there's no format call。 What happens is the format string
    gets parsed by Python itself at compile time to PIC files。 teased apart and then
    basically under the hood at the byte code level ends up constructing。 the equivalent
    of the stirred out format call for you。 So not only is it cleaner because you
    don't have to call stirred out format but it actually。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为字符串时没有格式调用。发生的情况是格式字符串在编译时被 Python 本身解析为 PIC 文件。被拆分后，基本上在字节码级别构造出相应的格式调用。因此，不仅因为不需要调用格式化而更清晰，而且实际上。
- en: performs better because we can now infer things thanks to it being part of the
    actual literal。 to actually implement things at the byte code level。 So this is
    actually faster than stirred out format and all this is thanks to Eric Smith。
    in the front row。 So if you're not using this yet and you're compatible with 3。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 性能更好，因为我们现在可以推断出一些事情，因为它是实际字面量的一部分。以字节码级别实际实现一些东西。因此，这实际上比传统格式化更快，这一切都要归功于前排的
    Eric Smith。所以如果你还没在使用这个，并且兼容 3。
- en: 6 I highly advise you start， using it。 And just to appease those who are upset
    that there's now three ways to do it the percent。 ways just to be compatible with
    Python 2 and stirred out format still there because you。 do need to pass that
    around sometimes。 That's just a callable object so there's a reason we kept it。
    But anyway this is a fantastic feature in 3。6。 At 506 and 524 this will bring
    back slight nightmares for a lot of core developers because。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你开始使用它。为了安抚那些对现在有三种方法感到不满的人，%方式只是为了与Python 2兼容，旧格式仍然存在，因为有时你确实需要传递那个。这只是一个可调用对象，因此我们保留它是有原因的。无论如何，这是3.6中的一个绝佳功能。在506和524行，这会让许多核心开发人员回想起一些噩梦，因为。
- en: this was almost a month long argument that even dragged in a Linux kernel developer。
    We take security seriously but we have to make backwards compatibility seriously。
    And what came out of all this is PEP 506 thanks to Stephen to Prano we now have
    a secrets module。 Now a lot of you might know of random for randomizing numbers
    and any of that kind of， thing。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎是一个持续了一个月的争论，甚至牵扯到了Linux内核开发者。我们非常重视安全性，但也必须认真对待向后兼容性。从这一切中产生的是PEP 506，感谢Stephen
    to Prano，我们现在有了一个**secrets**模块。现在你们很多人可能知道**random**用于随机化数字和其他类似的东西。
- en: We just need a fake roll of die that you can maybe reproduce in a test。 The
    secrets module that was designed specifically for crypto level number randomization
    or anything。 else that you need to do that might be that level of safe and ready
    for security use。 So basically my key point is if you know you are doing some
    modeling and simulation keep。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一个可以在测试中重现的伪骰子。**secrets**模块是专门为加密级别的数字随机化或其他任何需要达到安全使用水平的东西而设计的。因此，我的关键点是如果你知道你在进行一些建模和仿真，保持。
- en: using random if you're not sure if this will ever have to be crypto level secure
    or you。 honestly just don't know or you do know just use secrets。 It might be
    a little slower than random but you just do not want to find out later that。 you're
    using random and somehow it's now really security related and you're screwed up
    and。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定这是否需要达到加密级别的安全性，或者你真的不知道，或者你知道的话，就使用**secrets**。它可能比**random**稍慢，但你绝对不想后悔在安全相关的情况下使用了**random**，而造成问题。
- en: now someone's really mad at you。 So use secrets if you're not sure。 The other
    thing is PEP 524 this is the thing that really caused a huge kerfuffle on Python。
    Dev for a while。 Basically in Python 3。5。0 OS。U random would block until there's
    enough entropy in the system。 because you have to initialize the random number
    generator to actually be able to make random。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有人真的对你很生气。所以如果不确定就使用**secrets**。另外，PEP 524是造成Python Dev上巨大混乱的东西。基本上在Python
    3.5.0中，**OS.Urandom**会阻塞，直到系统中有足够的熵，因为你必须初始化随机数生成器才能生成随机数。
- en: numbers。 The problem is containers don't get a lot of randomization because
    there's not a lot to。 start up for those things。 So if you start up a container
    it can actually take a few minutes for a container to actually。 generate enough
    entropy if the container is not being used constantly to make that， entropy。 So
    all right that sucks for people if there's only have this fast container they
    started。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 数字。问题是容器的随机化不多，因为这些东西在启动时不需要太多。如果你启动一个容器，实际上可能需要几分钟才能生成足够的熵，如果容器没有被持续使用以产生熵。所以，这对那些只启动了这个快速容器的人来说是个麻烦。
- en: up and yet now something Python is making them wait several minutes。 So we said
    okay Python 3。5。2 we'll make it stop blocking and we'll just fall back to， slash
    dev slash your random。 So kid people in this room might be cringing a bit because
    what we basically did was by。 accident was we caused OS。U random to no longer
    be very secure because if we swapped on you。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在Python让他们等待好几分钟。因此我们决定在Python 3.5.2中让它停止阻塞，直接回退到**/dev/random**。所以在场的人可能会有些畏惧，因为我们基本上是意外导致了**OS.Urandom**的安全性下降，如果我们交换给你。
- en: without telling you you didn't know if you're getting the more secure random
    number generator。 from Linux or the less secure one。 So what ended up happening
    is in Python 3。6 we took OS。U random back to the blocking mechanism， and we added
    a new OS。get random which will actually not block but raise an exception。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 而且你可能不知道自己是从Linux获取了更安全的随机数生成器，还是不那么安全的那个。因此，在Python 3.6中，我们把**OS.Urandom**恢复到了阻塞机制，并添加了一个新的**OS.getrandom**，它不会阻塞而是会抛出异常。
- en: So you can make a decision do you want to wait until there's enough entropy
    or you can choose。 to call another random call that won't block so you can make
    your own decision。 X plus is better than implicit we kind of screwed up on not
    thinking about that ahead， of time。 I'm very glad this got settled。 PEP 509 adding
    a private version to dict this was things to Victor Stinner there's also。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以做出决定，你想等到有足够的熵，还是可以选择调用另一个不会阻塞的随机调用，这样你可以做出自己的决定。X加比隐式的更好，我们在提前没有考虑到这一点上有些搞砸了。我很高兴这个问题得到了解决。PEP
    509为字典添加私有版本，感谢Victor Stinner，还有。
- en: in the front row。 9。9% of you will never care about this and that's fine。 Basically
    we added a version ID to dictionaries based on mutation。 You can only get to it
    at the C level on purpose because this is really meant for people who。 are going
    to be doing things like writing jets for C Python or debugging and other things。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前排，9.9%的人可能永远不会在意这一点，这没关系。基本上我们在基于变异的字典中添加了一个版本ID。你只能在C级别访问它，这样做是有意的，因为这实际上是为那些会做C
    Python的jet编写或调试等的人准备的。
- en: where they basically need to know if a dictionary is mutated or not since the
    last time they。 looked at it。 So this is really a future looking optimization
    in terms of ability to do things in Python。 So it doesn't really do anything for
    anyone quite yet but it will。 I hope so。 I'm sure Victor will make it go faster
    don't worry it will be worth it。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 他们基本上需要知道字典自上次查看以来是否发生了变更。所以这实际上是在Python中进行未来优化的能力。到目前为止，这对任何人都没有实际作用，但将来会有。我希望如此。我相信Victor会让它更快，别担心，这会是值得的。
- en: PEP 515 underscores numeric literals。 Who here has ever written a large number
    with a bunch of digits and had to count to make。 sure they weren't missing a digit。
    Yeah funny enough when I first wrote this slide that said 1 million instead of
    1 billion because。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 515 为数字字面量添加下划线。这里有谁曾写过一个大数字，数字中有一堆数字，得数一数以确保没有漏掉任何一位吗？有趣的是，当我第一次写这张幻灯片时，我说的是100万，而不是10亿，因为。
- en: I miscounted。 So I have done that and I did it publicly too。 So basically what
    happened is 515 we decided to allow you to put underscores in numbers。 For the
    specific reason to be able to group them like this to make them much more readable。
    As you will notice we are pretty liberal about where you can put them。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我算错了。所以我做到了，而且还是公开做的。所以基本上发生的事是515，我们决定允许你在数字中使用下划线。具体原因是为了能像这样分组，使其更易读。正如你所注意到的，我们在下划线放置方面相当宽松。
- en: You can put them right after the base notation so 0x and you can do it there
    and score for， hex etc。 So it is a really nice little touch that other languages
    have been doing and we realized we。 should have that too。 This is things to your
    brandl for coming up with the PEP and running most of the code and。 then I think
    Sir Hay and I finish it up。 PEP 519 any file system path protocol。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在基数表示法后直接加下划线，所以0x后也可以这样做，并且可以用作hex等。这是其他语言一直在做的一个很好的小细节，我们意识到我们也应该有。这要感谢你的品牌尔，提出了PEP并运行大部分代码，然后我认为Sir
    Hay和我完成了它。PEP 519任何文件系统路径协议。
- en: This is my fault if you don't like it。 Basically what happened was someone came
    onto the Python ideas mailing list and said I really。 like pathlib but I can't
    use it anywhere because everyone wants a string。 Everyone calls OS。path to do
    path manipulation and such。 Why don't we subclass pathlib with stir。 And then
    a big discussion broke out about how that is not a good idea because if you。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢，这是我的错。基本上发生的事是，有人来到Python想法邮件列表上说我真的喜欢pathlib，但我在哪儿都不能用，因为大家都想要字符串。每个人都调用OS.path进行路径操作等。为什么我们不让pathlib继承自str呢？然后围绕这点展开了激烈讨论，认为这并不是一个好主意，因为如果你。
- en: start doing that everyone will expect a stir to always work which isn't true
    because taking。 the stir of nine is going to always succeed and you probably didn't
    meet to specify the。 file name none when something falls through。 So it is not
    really good error reporting so once again being very explicit。 So what we decided
    to do was we created a new protocol called OS。FS path and basically。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 开始这么做，每个人都会期望str总是有效，而这并不是真的，因为取九的str总是会成功，而你可能并不打算指定文件名为none，当出现意外时。因此，这并不是一个好的错误报告方式，所以再次强调非常明确。因此，我们决定创建一个新的协议，叫做OS.FS
    path，基本上。
- en: you see that under FS path method what it is supposed to do is any object that
    represents。 a file path will return to the stir by its representation of that
    path。 So it basically allows us to tell you use pathlib as much as you want and
    as long as。 the object defines that and it will just return the representation
    of the path so we can view。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到在 FS 路径方法下，它应该做的是任何代表文件路径的对象将返回其路径的表示形式。因此，它基本上允许我们告诉你，尽可能多地使用 pathlib，只要对象定义了这一点，它就会返回路径的表示形式，这样我们就可以查看。
- en: strings more as kind of almost not a coding that is not right Stephen Turnbull
    would be。 very upset if I said that。 It is a representation and we have plugged
    this through as much as we can throughout the standard。 library so OS。Path for
    instance completely supports this protocol so if you are using。 an older library
    that is not aware of this and maybe hasn't been used very much with。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串更多的是一种几乎不算编码的东西，这并不正确，斯蒂芬·特恩布尔会对此感到非常不满。如果我这么说的话。这是一种表示方式，我们已经尽可能地将其贯穿于标准库中。因此，OS.Path
    例如完全支持该协议，所以如果你正在使用一个较旧的库，可能对此并不知情，或者没有被广泛使用。
- en: pathlib it should hopefully just fall straight through and just work and actually
    a large part。 of the standard library just works with pathlib now magically because
    we just plumbed it through。 completely throughout OS。Path。 So yeah so basically
    if you like pathlib like Fernando Perez of Jupiter who is the biggest。 fan I know
    of you can now use pathlib wherever you want。 Step 520。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: pathlib 希望它可以直接通过并正常工作，实际上标准库的大部分现在都与 pathlib 魔术般地正常工作，因为我们完全将其贯穿于 OS.Path。因此，是的，如果你喜欢
    pathlib，就像我所知道的最大的粉丝费尔南多·佩雷斯那样，现在你可以在任何地方使用 pathlib。第 520 步。
- en: Presuming Class Edgy Definition Order。 This is once again Eric Snow he really
    likes things to be in an orderly fashion apparently。 Basically when you define
    things in your class body there was no guarantee you would get。 to know the order
    of their definition later on with this much like the earlier prep where。 I talked
    about keeping the order of keyword arguments to a function call。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设类的边缘定义顺序。这再次是埃里克·斯诺，他显然喜欢事情井然有序。基本上，当你在类体中定义事物时，之前没有保证你会知道它们定义的顺序，这一点与我之前谈到的保持函数调用关键字参数的顺序非常相似。
- en: This is the same thing except it keeps the order of the definition of attributes
    in a， class。 Once again we guarantee that Dunderdick will be a mapping that keeps
    order。 Don't rely on dictionaries in general keeping this order for you。 That's
    the last time we are going to bring this up you've all been warned。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的内容相同，只是它保持了类中属性定义的顺序。我们再次保证 Dunderdick 将是一个保持顺序的映射。不要依赖字典通常为你保持这个顺序。这是我们最后一次提到这个，你们都已被警告。
- en: If I have 23 adding a frame evaluation API to CPython。 Once again this is my
    fault although Dino Veland my co-workers also part of his fault too。 This is part
    of the work we were doing at Microsoft with our pigeon experiment if you。 were
    here at Python last year and saw our talk on trying to add a jit to CPython。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我有 23 为 CPython 添加帧评估 API。再次强调，这是我的错，尽管我的同事迪诺·维兰也是部分责任。这是我们在微软进行的工作的一部分，与我们的鸽子实验有关，如果你去年在
    Python 上看到我们关于尝试将 JIT 添加到 CPython 的演讲。
- en: This was a key hook of ours to try to allow this。 Now once again 99% of you
    are not going to care about this but if you write a jit or a。 debugger or a profiler
    you are going to care about this。 Because basically what this lets you do is there
    is a C level call where we call into。 the function that is going to evaluate the
    frame of the function you are currently executing。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们尝试允许这一点的关键钩子。现在，再次强调，99% 的人不会在乎这一点，但如果你写 JIT、调试器或分析器，你会对此感兴趣。因为基本上，这让你能够进行
    C 级调用，我们调用要评估当前正在执行的函数的帧的函数。
- en: Before there was no way to configure that it was just Python's job to just take
    the。 frame of execution and just make it run to do its thing。 Now there is actually
    a place where you can insert a function to call instead。 And this is really key
    with something like a jit because now we can catch the frame， decide。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前没有办法配置这一点，只有 Python 的任务是获取执行帧并让其运行，完成它的事情。现在实际上有一个地方可以插入一个函数来替代调用。而这在 JIT
    之类的事情中非常关键，因为现在我们可以捕获帧，决定。
- en: if you want to execute it in CPython or if you want to jit it and run it through
    a jit， instead。 So dream of dreams this is what will let us put jits on pi pi
    and have you just install。 a jit through an import statement。 I should also mention
    PyCharm Slays release has a 20% speed up in their debugger。 That is because of
    this hook。 I should also mention this also added a little internal C API for storing
    data on code objects。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 CPython 中执行它，或者如果你想用 JIT 来运行它。那么梦想成真，这将让我们在 Pi Pi 上使用 JIT，并让你只需通过导入语句安装
    JIT。我还应该提到，PyCharm Slays 的版本在调试器中提高了 20% 的速度。这是因为这个钩子。我还应该提到，这也添加了一个内部 C API，用于在代码对象上存储数据。
- en: Once again once you are not going to care only people who care about the hook
    will care， about that。 PEP 525 and 530。 This is Yuri Solinov and his work to try
    to plumb more async and await through Python。 So Python 3。5 added the whole concept
    of async functions and async and await keywords。 But we only plugged it in in
    terms of normal functions that is either awaiting or returning。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你不在乎，只有关心这个钩子的人才会在乎。PEP 525 和 530。这是尤里·索林诺夫（Yuri Solinov）及其努力通过 Python 引入更多
    async 和 await 的工作。所以 Python 3.5 增加了 async 函数和 async 及 await 关键字的整个概念。但我们仅在正常函数中实现了这一点，即等待或返回。
- en: There is no way to do a generator that could also await on things。 So what these
    PEPs did is basically made generators a possibility using await。 So it seems kind
    of obvious but we only had so much time for Python 3。5。 One of the nice side effects
    of this though is list comprehensions on top of normal generator。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 没有办法创建一个生成器来等待其他事情。因此，这些 PEP 基本上使得使用 await 成为可能的生成器。虽然这看起来有点显而易见，但我们在 Python
    3.5 的时间有限。不过，这样做的一个不错的副作用是，列表推导式在普通生成器之上。
- en: expressions are generators underneath the hood。 So by making this work with
    generators it now works with list comprehensions as well。 So now list comprehensions
    can use async 4 to iterate through the iterable that you want。 to work with or
    you can call await on a result within your list comprehensions itself。 So it is
    a nice little touch up but nothing really critical。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式在底层是生成器。因此，通过使这与生成器一起工作，它现在也能与列表推导式一起工作。所以现在列表推导式可以使用 async for 来迭代你想要处理的可迭代对象，或者你可以在列表推导式中直接调用
    await。虽然这只是一个小的修饰，但并没有什么关键的变化。
- en: But it makes things nicer and smoother and just plums async all the way through
    Python。 So we have a little bit of a look at the type of things in this。 So I'm
    going to do the next step。 So the first step is the intent of this。 This is a
    little bit of a bit of a simple thing。 So we are going to do the first step。 So
    we are going to do the first step。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但它使得事情变得更好、更顺畅，并且在 Python 中彻底引入了 async。所以我们稍微看了一下这个的类型。我将进行下一步。因此第一步是这个的意图。这有点简单。所以我们要进行第一步。我们要进行第一步。
- en: So we are going to do the first step。 So we are going to do the second step。
    And then we are going to do the first step。 So we are going to do the first step。
    Now you can go all the way down to the variable level。 Now much like with function
    annotations nothing is checked at runtime。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们要进行第一步。接下来我们要进行第二步。然后我们将再次进行第一步。所以我们要进行第一步。现在你可以一直深入到变量级别。就像函数注释一样，运行时并不会检查任何东西。
- en: There is no real overhead other than anything that might need to be constructed
    or something。 if you specify something as a type in terms of the annotation。 So
    there is no penalty for doing this performance wise overall during runtime。 If
    you define a variable annotation at the class level it will be added to the dunder。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可能需要构建的任何东西外，并没有真正的开销。如果你在注释中将某个东西指定为类型。所以在运行时进行此操作在性能上没有任何惩罚。如果你在类级别定义变量注释，它将被添加到
    dunder。
- en: annotations attribute on that class and dictionary so you can just key off of
    what the attribute。 name is and see what the type hint is for that。 You can also
    do it at the local level in terms of local variables。 Those do just get tossed。
    They are in the AST though for Python。 So those are mainly there for performance
    reasons are not kept anywhere because there is no。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该类和字典上的注释属性，这样你可以通过属性名称查看类型提示是什么。你也可以在本地变量方面做到这一点。那些只是被丢弃。它们在 Python 的 AST 中存在。因此，它们主要是出于性能原因而存在，并没有被保留，因为没有。
- en: real good way to expose them anyway。 And they are basically there so the tools
    like an ipy can verify that your type hints。 have matched up to what is expected。
    Step 528 and 529。 If you are a Windows user you are probably going to hooray inside。
    If you did not see Steve Dowers talk he talked about this as well。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，真实的好方式来暴露它们。它们基本上在那里，以便像 ipy 这样的工具可以验证你的类型提示是否与预期匹配。第 528 和 529 行。如果你是
    Windows 用户，你可能会在心里欢呼。如果你没有看到 Steve Dower 的演讲，他也谈到了这一点。
- en: The REPL now uses UTF-8 so I can actually put a little emoji like that and have
    it actually。 print out。 If you are a Windows user you are probably used to seeing
    your little emoji big squares。 When dealing with some UTF-8 and that was always
    really annoying that is no longer a， problem。 The other key thing here is Windows
    now takes byte paths。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 现在使用 UTF-8，所以我实际上可以放一个小 emoji，并且它会正确显示。如果你是 Windows 用户，你可能已经习惯看到小 emoji
    变成大方块。处理一些 UTF-8 时，这一直非常烦人，但现在不再是问题。另一个关键点是 Windows 现在接受字节路径。
- en: This is a really big deal for projects like Twisted where their whole system
    is designed。 to work with byte based paths and windows wouldn't accept it because
    they were deprecated。 since I think Python 3。2。 So instead of what has happened
    is on Windows we now set the default encoding for the file。 system to UTF-8 and
    if you pass in a byte based path we do the reencoding to UTF-16 for。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这对像 Twisted 这样的项目来说非常重要，因为他们的整个系统是设计为使用基于字节的路径，而 Windows 不接受这些路径，因为自我认为 Python
    3.2 起已经弃用了。因此，现在在 Windows 上我们将文件系统的默认编码设置为 UTF-8，如果传入基于字节的路径，我们会重新编码为 UTF-16。
- en: the internal windows APIs and handle all that for you。 So basically you just
    treat paths as UTF-8 on Windows now。 So it should make things a lot smoother for
    you as well if you are transitioning from。 2 to 3 and you are dealing with byte
    based paths。 There are a couple things on the PEP I wanted to bring up。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上你现在可以在 Windows 上将路径视为 UTF-8。如果你正在从 2 迁移到 3，并且处理基于字节的路径，这将使事情变得更加顺畅。我想提到
    PEP 上的一些事情。
- en: One thing this is also from Victor Stener's Python Malick where you can do now
    is through。 an environment variable you can specify the debugging hooks for memory
    for Python itself。 You don't have to do a complete re-compilation for a Py debug
    build if you want to see where。 your memory is going and track that。 You can use
    this hook to use everything or even just force use the malick or other kind。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事，这也是来自 Victor Stener 的 Python Malick，现在你可以通过环境变量指定 Python 自身的内存调试钩子。如果你想查看内存去向并进行跟踪，你不必完全重新编译
    Py debug 构建。你可以使用这个钩子使用所有内容，甚至强制使用 malick 或其他类型。
- en: of malicks to make things work the way you want it to work without having to
    do fancy。 re-compilation stuff。 I should also mention something that Wukash laying
    a Facebook and Instagram added at the。 course branch in September was D-trace
    and system tap support。 I've been told D-trace and system tap are amazing and
    people get really elated who use， it。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让事情按你想要的方式运作而无需做复杂的重新编译。我还应该提到，Wukash 在九月的 Facebook 和 Instagram 课程分支中添加了 D-trace
    和 system tap 支持。听说 D-trace 和 system tap 非常棒，使用的人都非常兴奋。
- en: Find out that we added this。 I'm going to assume they know what they are talking
    about so I'll be elated to for。 them。 I have them personally use this but everyone
    I know who uses D-trace really loves us so。 I think we probably should all learn
    some D-trace probably。 You do have to compile this with a specific flag。 Dash
    dash with dash D-trace and what this currently traces is functioning calls and
    returns when。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 发现我们添加了这个功能。我假设他们知道自己在说什么，所以我会为他们感到兴奋。我亲自让他们使用这个，但我认识的每个使用 D-trace 的人都非常喜欢这个功能。因此，我觉得我们应该都学习一些
    D-trace。你确实需要使用特定的标志来编译这个，使用 `--with-D-trace`，而目前追踪的是在内部 Windows API 的函数调用和返回。
- en: GC started and finished and what line of code is currently executing。 I believe
    Wukash is totally open to adding more but that's just basically what we started。
    with because that was what was in an initial patch that he took and made work
    but as I。 said everyone I know who uses D-trace is elated so I feel like I need
    to learn D-trace now。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: GC 启动和完成，以及当前执行的代码行。我相信 Wukash 完全愿意添加更多功能，但这基本上是我们开始的内容，因为这是他接受的初始补丁中包含的内容。但如我所说，使用
    D-trace 的每个人都感到兴奋，所以我觉得我现在需要学习 D-trace。
- en: A couple of things that are on the slides。 We now warn you for instance when
    you use a backslash in a string that's not raw and。 the following character doesn't
    make any sense so you won't actually do /m and expect。 something to work so I'm
    going to worry about that。 We've added a couple extra bytecodes generally around
    unpacking since we added all that generalized。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 幻灯片上有几件事。比如，当你在一个非原始字符串中使用反斜杠时，我们现在会警告你，而后面的字符没有任何意义，所以你实际上不会做/m并期望某些东西能正常工作，因此我会对此感到担忧。我们增加了一些额外的字节码，主要是围绕解包，因为我们添加了所有这些通用内容。
- en: unpacking of iterables， it's about about the key that I can think about at the
    top of my。 head that's not on this slide。 Now I've had a slide for benchmarks
    which you can see current results of at speed。path。org， thanks to Victor Stinner。
    If you really want to see a longer more detailed discussion of current Python
    performance watch。 Victor's talk the recording might be up already even but I'm
    just going to go over one quick。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代对象的解包，我想在我脑海中想到的关于这一点的关键，不在这张幻灯片上。现在我有一张基准的幻灯片，你可以在speed.path.org上看到当前结果，感谢维克多·斯廷纳。如果你真的想看到关于当前Python性能的更长、更详细的讨论，观看维克多的讲座，录音可能已经上传，但我只会快速介绍一下。
- en: slide and start taking questions。 But basically Python 3。6 is fast we should
    all be happy。 If you just look at this graph real quick there's just four app
    benchmarks that we have。 as part of our performance benchmark suite。 2-3 chameleon
    HTML5 lib and tornado。 All this is normalized to Python 2。7 because that's what
    everyone historically bothers me， about。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始提问幻灯片。但是基本上Python 3.6很快，我们都应该高兴。如果你快速查看这张图表，我们有四个应用基准，作为我们性能基准套件的一部分。2-3个变色龙HTML5库和龙卷风。所有这些都是相对于Python
    2.7的，因为这是历史上大家都让我烦的地方。
- en: As you'll notice all the bar， the far left bar is the tallest bar which means
    Python 3。5， and 3。6 is faster than Python 2。7 on these benchmarks。 I don't know
    why chameleon spikes a little bit on 3。6 that day。 I asked Victor yesterday and
    he says it's probably one of the unstable benchmarks。 Sorry honestly I should
    probably take it out。 As you can see faster lower， Python 3。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，最左边的柱子是最高的，这意味着Python 3.5和3.6在这些基准测试中比Python 2.7快。我不知道为什么变色龙在3.6时稍微激增。昨天我问维克多，他说这可能是其中一个不稳定的基准。抱歉，老实说，我可能应该把它去掉。正如你所见，Python
    3的速度更快更低。
- en: 6 is faster than 2。7。 Instagram talked about how it's faster for them too so
    2。7 slow now。 That's why I think about it。 And with that I will happily take any
    questions you might have。 Thank you。 [Applause]， And I believe we have two mics
    on the left and on the right。 Hi。 Hi。 Hi。 I like F strings。 They're pretty cool。
    Yes they are。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 6比2.7快。Instagram也提到对他们来说更快，所以2.7现在变慢了。这就是我对此的看法。至此，我很乐意回答你们可能有的任何问题。谢谢。[掌声]，我相信我们有两个麦克风在左侧和右侧。嗨。嗨。嗨。我喜欢F字符串。它们很酷。是的，确实很酷。
- en: In other languages with quasi literals you can play with them in other ways。
    You can use them as patterns。 You can redefine the parser that's used inside the
    string。 Has anybody talked about that kind of add-on for Python F strings？ Not
    to that extent。 Eric is saying there's a PEP4， N9， to at least fully generalize
    it to any Python expression。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，带有准文字的表达可以用不同方式来处理。你可以将它们用作模式。你可以重新定义在字符串内部使用的解析器。有没有人谈论过这种对Python F字符串的扩展？没有达到那个程度。埃里克说有一个PEP
    4，N9，至少可以完全将其推广到任何Python表达式。
- en: you can evaluate。 Right now there's some little edge rules because it made it
    easier to implement。 So PEP4， N9 is sitting there to completely generalize it
    to any Python expression。 The problem is the PEP author doesn't know C。 So he
    wrote it saying he wanted it and it。 should work with syntax highlighters and
    such but then no one has ever implemented it。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进行评估。现在有一些小的边缘规则，因为这使得实现更容易。因此PEP 4，N9在那里完全推广到任何Python表达式。问题是PEP的作者不懂C。所以他写的时候希望它能与语法高亮器等一起工作，但从未有人实现过。
- en: So if you really care you can look at Fortnite and potentially write the patch
    for it。 I wrote my own language but oh。 501 sorry。 If you want real key details
    the man to talk to is right up here in the orange。 Cool thank you。 No problem。
    Hi thanks for all the great work on 3。6。 Welcome。 One question about the Dunder
    dict on classes being preserving water。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你真的在乎，你可以查看Fortnite并可能为其编写补丁。我自己写了一个语言，但哦。501，对不起。如果你想要真正的关键细节，可以和就在这里的橙色衣服的人谈谈。酷，谢谢。没问题。嗨，感谢你们在3.6上的出色工作。欢迎。有一个关于类上Dunder字典的保留水的问题。
- en: Does that also extend the dict of a module？ The by accident or on purpose？
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否也扩展了模块的字典？是偶然还是故意？
- en: I'm going to go with no because I don't want to encourage any accidents。 And
    the man who obsesses over order says no so I'm going with no。 Yes。 Do you profile
    memory usage on your regularly？ I don't remember off the top of my head。 Zach
    wave in turn to the bell boxes saying no。 So I'm going to go with no based on
    my comrades in the front row。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我会选择“不”，因为我不想鼓励任何意外。而那个对秩序过于执着的人也说“不”，所以我会选择“不”。是的。你定期检查内存使用情况吗？我不记得了。扎克朝铃箱挥手，表示“不”。所以基于我前排的同伴，我会选择“不”。
- en: That'd be something to talk to Victor about。 I don't know how difficult it would
    be to add。 Since we're running on Linux it should be possible but Victor's center
    would be the best。 person to talk to about that。 Any other questions？ All right
    well everyone enjoy lunch。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是跟维克托谈的事情。我不知道添加起来会有多困难。因为我们在使用Linux，应该是可行的，但维克托中心的人是最适合讨论这个问题的。还有其他问题吗？好吧，大家享用午餐吧。
- en: '![](img/cacb898a89c411fd6f7537986de224f6_7.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cacb898a89c411fd6f7537986de224f6_7.png)'
- en: '[applause]， Thank you very much。'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]，非常感谢你。'
- en: '![](img/cacb898a89c411fd6f7537986de224f6_9.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cacb898a89c411fd6f7537986de224f6_9.png)'
- en: '[ Silence ]。'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[沉默]。'
- en: '![](img/cacb898a89c411fd6f7537986de224f6_11.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cacb898a89c411fd6f7537986de224f6_11.png)'
