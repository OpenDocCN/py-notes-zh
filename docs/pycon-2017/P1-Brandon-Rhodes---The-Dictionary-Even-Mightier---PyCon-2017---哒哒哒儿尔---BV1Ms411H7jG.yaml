- en: P1：Brandon Rhodes   The Dictionary Even Mightier   PyCon 2017 - 哒哒哒儿尔 - BV1Ms411H7jG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P1：布兰登·罗兹   字典更强大   PyCon 2017 - 哒哒哒儿尔 - BV1Ms411H7jG
- en: '[BLANK_AUDIO]， [BLANK_AUDIO]， [BLANK_AUDIO]， [BLANK_AUDIO]。'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[空音频]，[空音频]，[空音频]，[空音频]。'
- en: '![](img/5243fa82c8418d4a9230f5750f6730c5_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5243fa82c8418d4a9230f5750f6730c5_1.png)'
- en: '![](img/5243fa82c8418d4a9230f5750f6730c5_2.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5243fa82c8418d4a9230f5750f6730c5_2.png)'
- en: Ladies and gentlemen， as we know， dictionary is very powerful and useful to
    us in Python。 And in Python， 0。3。6， a lot of new features are added。 And it is
    very mighty。 and even mightier than you thought。 Let's welcome Brandon Rhodes
    to give his talk。 the dictionary even mightier。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 女士们，先生们，正如我们所知，字典在 Python 中对我们非常强大且有用。在 Python 0.3.6 中，添加了许多新特性。它非常强大，甚至比你想象的还要强大。让我们欢迎布兰登·罗兹来发表他的演讲，字典更强大。
- en: '![](img/5243fa82c8418d4a9230f5750f6730c5_4.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5243fa82c8418d4a9230f5750f6730c5_4.png)'
- en: \>\> [APPLAUSE]， \>\> Well， thank you everyone， this as many of you will have
    guessed is a follow up to my 2010。 Several years ago， PyCon talk， the mighty dictionary
    in which I tried to explain the operation benefits。 but dangers of a hash table
    to a PyCon audience。 A lot has happened since then。 None of which tempted me to
    do a follow up talk。 Until Python 3。6。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: \>\> [掌声]， \>\> 好的，谢谢大家，正如你们中的许多人猜测的，这是我 2010 年演讲的后续。几年前，在 PyCon 的演讲中，我试图向 PyCon
    观众解释哈希表的操作优势和危险。自那以来发生了很多事情，没有一件让我想继续演讲，直到 Python 3.6。
- en: which Raymond Hettinger has famously said is the first version he specifically
    said， 3。6。1。 that's a better language than 2。7。 So it's clearly time that we talk
    about where the dictionary has gone in the last several years。 I chose， it turns
    out in retrospect， an interesting moment to do the original mighty dictionary
    talk February of right at the beginning of 2010。 Right before， months before 2。7
    went final and came out。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 雷蒙德·赫廷格曾著名地说，3.6.1 是他特别提到的第一个版本，比 2.7 更好。所以显然是时候谈谈字典在过去几年中的发展。我选择了一个有趣的时刻来做原来的强大字典演讲，即
    2010 年 2 月，正好在 2.7 最终发布的几个月之前。
- en: That means that my original talk purely looked at the dynamics of the hash table。
    didn't talk at all about the improvements that were just about to arrive。 As，
    PyCon 2。7。 the last hurrah of the two series quickly pulled in several innovations
    from the PyCon 3 series。 to make them at the last minute available in the last
    version of 2。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我原来的演讲纯粹关注于哈希表的动态，并没有谈论即将到来的改进。在 PyCon 2.7 中，两个系列的最后一次欢呼迅速引入了来自 PyCon 3
    系列的几项创新，使它们在最后时刻可以在 2 的最后一个版本中使用。
- en: So none of those were covered in my original talk and will be covered now。 We'll
    be covering several things that were backported to 2。7。 Then we'll move ahead
    and look at things that you cannot take advantage of in 2。7。 and that you have
    to have a modern version of Python to take advantage of。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些内容在我原来的演讲中没有覆盖，现在将会覆盖。我们将讨论几项被移植到 2.7 的内容。然后我们将继续查看一些你无法在 2.7 中利用的内容，而你必须拥有现代版本的
    Python 才能利用这些内容。
- en: Many of you will already have seen， I believe they were already being talked
    about at the conference。 dictionary comprehensions changed that earned a pep，
    debated and was resolved。 The list comprehension had been around since Python
    2。 It was an innovation when Python went from 1。6， I think was the last one， to
    2。0。 It was a big deal， you always had to make an empty list。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中的许多人可能已经看到，我相信在会议上已经有讨论过。字典推导改变了这一点，获得了一次 PEP，经过辩论后得以解决。列表推导自 Python 2 开始就存在。这是
    Python 从 1.6（我认为是最后一个）到 2.0 的创新。这是个大事件，你总是需要创建一个空列表。
- en: a pen to pen to pen to it before finally producing a completed list。 With the
    list comprehension borrowed from several other languages。 you could instead put
    the for logic， the looping logic inside of those square brackets and have the
    list created for you。 That was great for lists。 It gave us a way to build dictionaries。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 先用笔写，再写，再写，最后才产生一个完整的列表。借助于从其他几种语言中借用的列表推导，你可以把循环逻辑放在方括号内，这样就可以为你创建列表。这对列表来说很棒，也给我们提供了构建字典的方式。
- en: but the way was slightly round about。 You had to build tuples。 key and value
    and it didn't look very much like a dictionary。 and of course it was slower because
    you had to make a tuple per item that was then thrown away。 once they were inserted
    into the dictionary。 Generators came along in Python 2。4。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种方式有点绕。你需要构建元组。键和值，看起来并不像字典，当然也更慢，因为你需要为每个项目创建一个元组，然后再丢弃它。一旦它们被插入字典，生成器在 Python
    2.4 中出现。
- en: at least you could take the angle brackets off， but you were treating one inefficiency
    for another。 The generator， you're not having to create an intermediate data structure
    list。 but you're constantly having to thrash between running another bit of bytecode
    or C code in the generator。 and then running another little bit of the dictionaries
    in it logic to absorb item by item the tuples that were being generated。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 至少你可以去掉尖括号，但你是在用一种低效交换另一种低效。生成器，你不需要创建中间数据结构列表，但你不断需要在运行另一段字节码或 C 代码和在其逻辑中运行字典的小段之间反复切换，以逐项吸收生成的元组。
- en: You're still creating and freeing tuples and you have the disadvantage of swapping
    between two different call stacks。 So often wound up not really being any faster，
    though it was more conceptually convenient and saved pair of angle brackets。 You
    don't have either of those problems， of course， once you introduce the dictionary
    comprehension。 It looks like a dictionary， it has a colon， as one would expect。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然在创建和释放元组，并且你有在两个不同调用栈之间切换的劣势。因此，经常没有真正更快，尽管它在概念上更方便并节省了一对尖括号。当然，一旦你引入字典推导，你就没有这些问题。它看起来像一个字典，有一个冒号，正如人们所期望的那样。
- en: it doesn't create any of this intermediate data structures， lists or tuples，
    it's readable。 it's smaller， it's faster。 And what I think is it's greatest feature
    rarely gets mentioned。 It brings to Python a great symmetry。 If you ever taught
    Python 2。6。 and for a while I taught Python professionally， when students learn
    the list comprehension。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 它不创建任何这种中间数据结构，列表或元组，易读性强。更小，更快。我认为它最大的特点很少被提及。它给 Python 带来了很大的对称性。如果你教过 Python
    2.6，且我曾经专业教授 Python，当学生学习列表推导时。
- en: some of them， some students have imagination。 And we'll suddenly think， wait
    a minute。 if you can put the four inside of the square brackets， can you put it
    inside of the angle brackets。 and Python 2。6 would pop them on the heads and say
    no， lists are special。 And as you know。 everything in a language that's special
    and different is an obstacle to the learner。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有些学生有想象力。我们会突然想到，等一下。如果你可以把四放在方括号内，你能把它放在尖括号内吗？而 Python 2.6 会当头一棒说不，列表是特殊的。正如你所知道的，语言中一切特殊和不同的东西都是学习者的障碍。
- en: this means the old 2。6 syntax， it didn't allow this。 It meant that Python wasn't
    a language。 at least in this area， where you could learn by extrapolating， I did
    this the other day。 I'm proud of myself， I deduced the existence of an object
    that I had never thought of or seen before。 Springtime， hedges are starting to
    grow。 So I'm facing a big reel of power cord out of the garage。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着旧的 2.6 语法，不允许这样。这意味着 Python 在这个领域不是一种语言，你可以通过推断学习。我前几天做了这件事。我为自己感到自豪，我推断出了一个我从未想过或见过的对象。春天来了，树篱开始生长。所以我面对着从车库里拿出来的一大卷电源线。
- en: get it plugged in， and then loop it around myself in such a way that I can trim
    the hedges without cutting the cord into or electrocuting myself。 And suddenly
    I knew I own a cordless drill。 I own a corded hedge trimmer。 and I was suddenly
    absolutely certain that the universe I lived in included cordless hedge trimmers。
    And you understand， I was absolutely certain that they existed。 The moment that，
    you know。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 把它插上，然后以某种方式环绕自己，以便我可以修剪树篱而不切断电线或电击自己。突然我知道我有一把无绳电钻。我有一台有绳树篱修剪机。我突然非常确定我生活的宇宙里包括无绳树篱修剪机。你知道，我绝对确定它们存在。就在那一刻。
- en: one of those moments where you're like， I have introspected the universe and
    deduced a fact about it through the power of my mind。 And it was like this great
    moment， it was just the QED to do the Amazon search and start reading reviews
    of the indeed existent concept of a battery operated hedge trimmer。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个时刻，你想，我已经内省了宇宙，并通过我的思维能力推导出了一个事实。那是一个伟大的时刻，这就是 QED，进行亚马逊搜索并开始阅读确实存在的电池驱动树篱修剪机的评论。
- en: It's wonderful when languages， when systems， when APIs are set up。 where you
    can guess some behaviors from others， where you learn the square brackets。 let
    you get items in a list。 Ooh， the same square brackets let you get to the items
    in a dictionary。 And what I love most about dictionary comprehensions is they
    allow our learners to extrapolate a corner of the language that they might suddenly
    guess in there。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当语言、系统、API被设置得很好时，真是太棒了。在某些行为中可以推测其他行为，例如，方括号让你在列表中获取项目。哦，同样的方括号也让你获取字典中的项目。我最喜欢字典推导式的是，它们让我们的学习者能够推测出语言的某个角落，他们可能会突然在那儿猜到。
- en: Indeed， after Python， argued against it for several years was finally added
    to the language。 added in 3。0， backported to 2。7， really beautiful construct。
    And then， as a sort of the last thing。 right as Python 3 was being invented was
    dictionary views。 This was again。 came right out of the gate in Python 3。0， added
    to 2。7。 Previously， originally， we'd had keys。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，在经过几年的反对之后，最终将其加入了语言中。它在3.0版本中添加，并回溯到2.7，真是一个美丽的构造。然后，作为最后一项，正当Python 3被发明时，字典视图出现了。这再次是在Python
    3.0中首次引入，并添加到2.7版本。之前，我们最初只拥有键。
- en: values， and items that built ancillary data structures lists。 Interkeys， inner
    values。 inner items were added to the language when iterators were。 And they don't
    spin up a separate list。 but let you get to all the keys or all of the values
    in the dictionary's order without having them copied into an intermediate structure。
    And I honestly， I kind of wasn't paying a lot of attention to the Python 3 transition
    since I still don't get to use it at work。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 值和项目构建了附加的数据结构列表。内部键，内部值，内部项目是在迭代器引入时添加到语言中的。它们不会创建一个单独的列表，而是让你在字典的顺序中获取所有键或所有值，而不需要将它们复制到一个中间结构中。老实说，我对Python
    3的过渡并没有太多关注，因为我在工作中仍然无法使用它。
- en: And the， who does？ The， I kind of had thought， when I saw we've checked keys。
    it isn't a list anymore， values isn't a list。 I thought they had just changed
    the iter versions and renamed them to keys。 values， and items。 And， and if I wanted，
    if we want a list in Python 3， you ask for a list。 Very Pythonic， because you're
    being explicit asking for what you want。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，谁在做呢？我曾经想，当我看到我们检查键时，它不再是一个列表，值也不是一个列表。我以为他们只是改变了迭代版本并将其重命名为键、值和项目。如果我想，如果我们想要一个列表在Python
    3中，你就要求一个列表。这非常Pythonic，因为你在明确地要求你想要的东西。
- en: It turns out that's not what they did。 They ask an interesting question。 what
    if you just want to ask if something is present in the keys or present in the
    values？
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 结果发现，他们并没有那样做。他们提出了一个有趣的问题。如果你只想问某个东西是否存在于键中或值中，该怎么办？
- en: The dictionary could answer， is this value in the values with a quick loop over
    the values？
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 字典可以快速遍历值来回答，这个值是否存在于值中？
- en: But there was no way to get to that information without creating a list of the
    values and looking through that or a set or if that's appropriate。 And so， they
    thought， shouldn't there be an object that implements contains for keys， values。
    and items that just can answer that question？ Is X and Y？
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但是没有办法获取该信息而不创建值的列表并查看，或者创建一个集合，如果那合适的话。因此，他们想，难道不应该有一个对象可以实现键、值和项目的包含，能够回答那个问题吗？X和Y是否存在？
- en: By just looking directly at the interior structure of the dictionary。 In fact。
    if we had such an object， why stop it contains？ We could have it do all of the
    basic set operations for the keys。 You could ask questions like， does this dictionary
    and this dictionary have any keys in common？
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过直接查看字典的内部结构。实际上，如果我们有这样的对象，为什么只停留在包含上？我们可以让它执行键的所有基本集合操作。你可以问这样的问题，这个字典和这个字典是否有任何共同的键？
- en: Do they have any keys in the disjoint set between them？ And while you're at
    it。 you could of course add the ability to call， under， hit her。 And also throw
    in the ability to loop over dictionaries， which is all we really do anyway。 This
    was inspired by the Java collections framework。 These are called views。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它们之间是否有任何键在不相交的集合中？同时，你当然可以添加调用的能力，下面，触发她。同时还可以添加遍历字典的能力，这正是我们所做的。这是受Java集合框架的启发。这些被称为视图。
- en: That's why I used V as the placeholder there。 When you call keys， values， items
    these days。 you get a tiny little object with no storage of its own。 All it has
    is the address of its type and the address of the dictionary that it will use
    to go answer questions for you。 When you do set-like operations or membership-like
    operations on the view。 So keys， values。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我在那里使用V作为占位符的原因。当你现在调用keys、values、items时，你得到的是一个没有自己存储的小对象。它只有类型的地址和字典的地址，用于回答你的问题。当你在视图上进行类似集合或成员资格的操作时，keys和values。
- en: and items in Python 3 are view objects。 That is what was backported to 27 under
    these three methods I honestly had completely missed at the time and have never
    seen used。 View keys， view values， and view items。 On the one hand， they put iteration。
    which is typically what you want to do。 One step further away， you can no longer
    say， "iter items。"。 You now have to say， "dot items，" and you're given this tiny
    little object that is the view。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3中的项目是视图对象。这是我当时完全错过的三种方法之一，并且从未见过使用。视图键、视图值和视图项目。一方面，它们使迭代变得更进一步，通常你想做的事情。你不能再说“iter
    items”。现在你必须说“dot items”，你会得到这个小对象，它是视图。
- en: And then you have to say， "for loop over it，" and it calls "iter，" and creates
    the second object。 The iterator that knows how far through the dictionary it's
    gotten so far。 So on the one hand。 the one thing you ever really want to do is
    a step further away。 It's so conceptually clean。 and it enables a number of operations
    that otherwise aren't possible。 So the -- was decided。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你必须说：“对它进行循环”，然后调用“iter”，创建第二个对象。这个迭代器知道它已经遍历了字典多远。因此，一方面，你真正想要做的事情是更进一步。这在概念上是如此干净，并且启用了许多否则不可能的操作。因此，--被决定了。
- en: this would -- through -- would work， where it's two layer。 First。 you get the
    view by saying keys or values。 Then if you want to。 you get an iterator by trying
    to iterate。 That was backported to 27， but again。 under those different method
    names so that you weren't opted into a different behavior until your code was
    ready。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过--工作，那里有两个层次。首先，你通过说keys或values获取视图。然后如果你想要，你可以尝试迭代来获取一个迭代器。这是回溯到2.7，但又是不同的方法名称，以便在你的代码准备好之前不会自动选择不同的行为。
- en: I'll burn a slide on the order dict。 It was proposed and accepted in PEP 3。72，
    not added until 3。1。 so we're moving a little further ahead in history here backported
    to 27。 It preserves insertion order。 It's bigger， slower， in fact。 was implementing
    a linked list in Python， I believe， until 3。4， when someone then rewrote it in
    3。5。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我会在有序字典上做个幻灯片。它在PEP 372中被提议并接受，但直到3.1才被添加，所以我们在这里稍微向历史前进了一些，回溯到2.7。它保持插入顺序。实际上，它更大、更慢。我相信，在3.4之前，它是在Python中实现的一个链表，当时有人在3.5中重新编写了它。
- en: Just in time， almost for it to be obsolete。 And it's interesting。 So we had，
    since 3。1， 2。7。 if you needed it， an order dictionary。 But it never tempted us
    to close the two open PEPs involving the order of dictionaries。 One PEP said，
    "Shouldn't keywords come be delivered to the Kali in the same order they were
    written？
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 恰好是时候，几乎要过时了。这很有趣。从3.1版本起，如果你需要，它提供了一个有序字典。但它从未让我们决定关闭两个涉及字典顺序的开放PEP。一个PEP说：“关键字不应该以它们写入时的顺序传递给Kali吗？”
- en: Shouldn't a class dictionary have a natural order？"。 Those two PEPs each require
    some kind of high-performance ordered dictionary type。 because you don't want
    to slow down keyword arguments。 I mean， those get passed all the time。 and you
    don't want to slow down the Dicks that become the namespace of a class or the
    dunder dict that sits behind an object's attributes。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 类字典难道不应该有自然顺序吗？这两个PEP都要求某种高性能的有序字典类型，因为你不想减慢关键字参数的速度。我是说，这些参数是经常被传递的。你也不想减慢作为类命名空间的字典，或者作为对象属性背后的双下划线字典。
- en: So we had order in a dictionary， but even in the language we didn't use it for
    anything serious。 We kept the arbitrarily ordered traditional dictionary instead，
    because we just needed the speed。 So it exists， but it's used for corner cases
    where people know that they care about order。 All right， we're now moving out
    beyond the things ever available in Python 2。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在字典中有顺序，但即使在语言中，我们也没有将其用于任何严肃的事情。我们保持了传统的任意排序字典，因为我们只需要速度。因此，它存在，但只用于那些人们知道关心顺序的特殊情况。好了，我们现在要超越Python
    2中可用的内容。
- en: We're now heading into the middle years between now and an original talk。 First。
    we'll talk about the key-sharing dictionary proposed in PEP of 412， added to the
    language， Python 3。3。 This answers a question of space。 Imagine a small class
    whose dunder in it accepts a name， a port。 and a protocol， and saves them each
    as attributes。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正进入现在和原始演讲之间的中间年。首先。我们将讨论在PEP 412中提出的密钥共享字典，添加到Python 3.3语言中。这回答了空间的问题。想象一个小类，其dunder接受名称、端口和协议，并将它们各自保存为属性。
- en: so the little dunder dict that sits behind the object has to store the name。
    And the object has to store some value under each of those three keys。 Here。 from
    my dictionary talk in 2010， is our friend of the hash table， an array。 Indexed
    is all arrays are in RAM by an integer index。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所以坐在对象背后的小dunder字典必须存储名称。对象必须在这三个键下存储一些值。在这里。来自我在2010年关于字典的演讲，我们的哈希表朋友，一个数组。所有数组在RAM中都是通过整数索引进行索引的。
- en: And the rule is that because we are being given keys that are not themselves
    integers。 and if they are integers， maybe not successive integers， or being given
    nonsense。 like the string name， how do I find the place in memory that's named
    the string name？ Well。 the hash tables get that value， whatever it is， and they
    hash it。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是因为我们得到的键不是整数。如果它们是整数，可能也不是连续整数，或者得到一些无意义的东西，比如字符串名称，我该如何找到内存中名为字符串名称的地方？好吧，哈希表得到那个值，无论是什么，然后它进行哈希。
- en: which is kind of this act of violence where you clobber the value and just smash
    it into a bunch of bits。 32 bits， however big or small the value was， you get
    out 32 bits on a 32-bit platform and 64-bit platform。 and you now， if you need
    an integer index， have as many bits as you could want for forming one。 This simple
    dictionary， that's not at all visible on there， isn't it？ Hmm。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点像一种暴力行为，你将值砸成一堆位。32位，无论值有多大或多小，在32位平台和64位平台上都输出32位。如果你需要一个整数索引，就有尽可能多的位来形成一个。这种简单的字典在这里并不可见，是不是？嗯。
- en: I might fix that in a minute if I feel like live coding。 We have， as you can
    see。 eight slots ready to be populated， and so eight slots。 we will need three
    bits in order to distinguish them。 We choose the 1。0。0 slot as the one that will
    hold the key name and whatever its value is。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想现场编码，我可能会在一分钟内修复它。正如你所见，我们有八个槽位准备填充，因此需要三个比特来区分它们。我们选择1.0.0槽作为存储键名称及其值的槽。
- en: and so that gets written into the dictionary。 We now arrive at our second one。
    hashing the key port into its hash is 101， so it takes the slot， it happens next
    door。 And now。 this was a big topic in the original talk， what happens if the
    third key happens to have a hash that's already been used。 1。0。0 in this case？
    And you'll remember that there's the technical term collision for what happens
    when we try to store proto and run smack into the fact that name is already taking
    that slot。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就写入字典。我们现在到了第二个。将键端口的哈希计算为101，所以它占用槽，发生在隔壁。现在，这是原始演讲中的一个大主题，如果第三个键恰好有一个已经被使用的哈希，1.0.0在这种情况下会发生什么？你会记得，当我们尝试存储proto并碰到名称已经占用该槽时，这种情况被称为碰撞。
- en: So we do some math involving the other bits and choose an emergency backup slot
    that it can live in as well。 So here it goes， we're going to try to store proto，
    and so it has to go somewhere else。 It's now a little more expensive to look up
    or to reset than the other values。 Name and port。 you'll find right where you
    look for them， proto you'll find after running into every time you look for it。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们进行一些数学运算，涉及其他部分，并选择一个应急备份槽让它存放在那里。接下来，我们将尝试存储proto，因此它必须去其他地方。现在查找或重置的成本比其他值稍高。名称和端口。你会在你寻找它们的地方找到，proto会在每次寻找时出现。
- en: the fact that it's not sitting at the slot you'd expect。 Imagine now that you
    have your second object of this type。 You store name， you store port。 proto comes
    in， collides and has to move to its separate slot。 Someone named Mark Shannon
    looked at this picture and said， wow， over there on the left hand side。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是，它并没有坐在你期望的槽位上。现在想象你有第二个这种类型的对象。你存储名称，你存储端口。proto进来，发生碰撞，必须移动到它的独立槽。有人叫马克·香农看到了这个图，并说，哇，左边那里。
- en: the first column and the second column are absolutely identical。 They look exactly
    the same。 We're storing exactly the same five blank spots and three hashes and
    exactly the same five blank spots and three keys in both of these object under
    dictionaries。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列和第二列是绝对相同的。它们看起来完全相同。我们在这两个字典下的对象中存储的五个空白位置和三个哈希以及五个空白位置和三个键完全相同。
- en: I should mention that the strings are not really inside the dictionary。 the
    integer 53 isn't in the dictionary， but the dictionary really stores。 If you can
    imagine that you're looking at the matrix where it all becomes code。 what it actually
    stores are the addresses of the string object that says name or port or the integer
    object that says 53。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该提到字符串并不真的在字典内部，整数 53 也不在字典中，但字典确实存储。如果你能想象你在看矩阵，所有内容变成代码。它实际上存储的是字符串对象的地址，比如说名称或端口，或者整数对象的地址，比如说
    53。
- en: So whenever in my dictionaries I put a little string or integer， I really mean
    the eight bytes。 always the same size from a 64-bit machine that tell you where
    in memory to go find the object。 But the whether proto is a string or the address
    of it， it's the same top and bottom。 And Mark Shannon thought about this， classes
    just been created。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所以每当我在字典中放一个小字符串或整数时，我真正指的是八个字节。始终是来自 64 位机器的相同大小，告诉你在内存中哪里找到对象。但无论原型是字符串还是它的地址，都是上下相同。马克·香农考虑过这个，类刚刚被创建。
- en: What if we wait for the first ever call to that classes under init？
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们等待第一次调用该类的 init 呢？
- en: It will create an instance of the object that looks like this。 What if we then
    go in and split apart and store in separate areas of memory the hashes and the
    keys and keep them forever？
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它会创建一个看起来像这样的对象实例。如果我们然后将哈希和键分开并存储在内存的不同区域，永远保持它们呢？
- en: And with the objects under dict， only store the values。 Because that first object
    created might go away sometime。 but we keep forever linked to the class that frozen
    set of hashes and keys so that as someone then creates a second instance of the
    object。 as someone then creates a third instance of the object。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 而在字典下的对象中，只存储值。因为第一个创建的对象可能会消失，但我们永远保持与类的链接，那个冻结的哈希和键的集合，这样当有人创建第二个对象实例时，或者当有人创建第三个对象实例时。
- en: You're only burning the space for storing the values。 You're only burning one
    third the space and getting two-third savings because you're not over and over
    and over again in every object。 repeating the hash， repeating the key when in
    so many classes they're exactly the same every time。 Memory savings， even on a
    tiny object that fits inside of an eight entry。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你只在存储值上消耗空间。你只消耗三分之一的空间，并获得三分之二的节省，因为你并不是在每个对象中一遍又一遍地重复哈希，重复键，尤其是在许多类中，它们每次都是完全相同的。内存节省，即使在一个适合八个条目的微小对象中。
- en: five of which can be populated， Python dictionary， you're saving 128 bytes for
    every object。 If there's thousands or millions that adds up to real measurable
    savings。 You do burn a little space because every dictionary ever created now
    needs eight extra bytes so that if it is stored in split fashion it knows where
    to get to the values array that's separate in that case from the keys。 But when
    measurements were done the extra eight bytes was easily made up for by the savings
    for common objects with repeated attributes。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 其中五个可以填充，Python 字典，每个对象节省 128 字节。如果有成千上万或者数百万个，这将累积成实际可测量的节省。你确实会浪费一点空间，因为每个字典现在都需要额外的八个字节，以便在分割存储时知道如何访问与键分开的值数组。但是在测量时，额外的八个字节很容易通过常见对象的节省来弥补。
- en: In fact， object oriented programs， I mean， normal lists and dictionaries don't
    care about this。 So if a program uses a lot of NumPy arrays or lists it doesn't
    benefit。 But object oriented programs with lots of objects often use 10 to 20%
    less memory because of this innovation。 Key sharing， Python 3。3， what do you care
    about？ Because of course you can't turn this on or off。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，面向对象的程序，我是说，普通的列表和字典对此并不在乎。因此，如果一个程序使用大量 NumPy 数组或列表，它不会受益。但具有大量对象的面向对象程序通常会因为这一创新而减少
    10% 到 20% 的内存。关键共享，Python 3.3，你关心什么？因为当然你不能打开或关闭这个功能。
- en: It's just going to happen。 And only if you're on 3。3 or later the takeaway for
    you is that in your objects make sure that DunderInIt assigns every attribute
    you're ever going to use。 Set them to none if you need to or to the empty string
    or whatever makes sense but get them in because if you don't。 And during it's
    lifetime one of your objects tries using a new attribute then its values will
    have to be thrown away。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会发生。只有在你使用 3.3 或更高版本时，你需要注意的是，在你的对象中，确保 `DunderInIt` 为你将要使用的每个属性分配值。如果需要，可以将它们设置为
    None、空字符串或其他合适的值，但一定要包含这些属性，因为如果你不这样做，在对象的生命周期内，如果尝试使用新的属性，其值将不得不被丢弃。
- en: A full Dunderdict will， a traditional dictionary will have to be allocated for
    it and all of its attributes copied over。 If a single key， a single attribute
    is added that's not in that original prototypical set of keys then you lose the
    sharing。 But this is a habit you should already have had。 Pi Pi can't do a lot
    of optimizations if attributes come and go randomly。 They also recommend setting
    them all in DunderInIt。 And it's good documentation。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的 `Dunderdict`，传统字典必须为其分配，并将其所有属性复制过来。如果添加了一个不在原始原型键集合中的单个键或单个属性，那么你就失去了共享。但是，这是一种你应该已经养成的习惯。Pi
    Pi 如果属性随机出现和消失，无法进行很多优化。他们还建议在 `DunderInIt` 中将它们全部设置。这也是良好的文档。
- en: I can read your DunderInIt function and know all of the attributes and not be
    very surprised later when I see one appear in the middle of a method。 So this
    was already a best practice。 This best practice now carries an additional benefit
    in Python 3。3 key sharing。 Alright for the next few minutes we get to delve into
    the exciting world of computer security of dealing with people who want to break
    your application。 This next thing， randomly seeded hashes， was not a pep。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以阅读你的 `DunderInIt` 函数，并了解所有的属性，当我在方法中间看到一个出现时不会感到惊讶。所以这已经是一种最佳实践。这一最佳实践在 Python
    3.3 中现在有了额外的好处：键共享。好吧，在接下来的几分钟里，我们将深入探讨计算机安全的精彩世界，处理那些想要破坏你应用程序的人。这下一件事，随机种子哈希，并不是一个推荐。
- en: It only warranted an issue in the Python bug tracker。 And it has to do with
    this。 How fast does a dictionary normally fill？ Let's say I have five things I
    need to put in。 Let's kind of watch the speed here。 Stone， bowl， oop， collide，
    cat， doe， eagle。 Notice that sometimes a dictionary key takes a little longer
    to make it in because of the collision。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅引发了 Python bug tracker 中的一个问题。它与这个有关。字典通常填充的速度有多快？假设我有五个东西需要放入。让我们观察一下这里的速度。Stone，bowl，oop，collide，cat，doe，eagle。注意，有时候字典键的插入需要更长的时间，因为发生了碰撞。
- en: But when collisions don't take place， which on average isn't very often。 notice
    that the last two interies， doe and eagle， made it in as fast as the first ones。
    New insertions， unless they collide， don't take any longer than the first one。
    As we talked about in my original version of this talk。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当没有发生碰撞时，平均而言，这种情况并不常见。注意最后两个条目，doe 和 eagle，插入的速度和第一个一样快。新的插入，除非发生碰撞，否则不会比第一个花更长的时间。正如我在这次演讲的最初版本中所谈到的。
- en: the thousandth or millionth item added to a dictionary should insert just as
    quickly as the first one。 Which is the magic of a dictionary。 Stone， bowl， boop，
    cat， doe， eagle。 That's the magic of the dictionary。 It turns out， if the person
    using your web application isn't your friend。 they can take that benefit away。
    What if they were to come up with a series of words。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到字典中的第千或第百万个项目应该和第一个一样快速。这就是字典的魔力。Stone，bowl，boop，cat，doe，eagle。这就是字典的魔力。事实证明，如果使用你网络应用程序的人不是你的朋友，他们可能会带走这个好处。如果他们想出一系列单词呢？
- en: and they have all the time in the world to do this before they hit your website？
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 他们有充足的时间在访问你的网站之前完成这个操作吗？
- en: Where the second value is guaranteed to collide with the first。 And then the
    third is going to collide with the first two， and then the fourth with the first
    three。 and so on， maybe through thousands of potential keys。 Then the rhythm，
    doe， cat， eagle。 goes something like this。 A back， buying， cab， deal。 Easels。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个值必然会与第一个发生碰撞。然后第三个将与前两个发生碰撞，第四个与前三个，以此类推，可能会穿过数千个潜在的键。然后节奏是，doe，cat，eagle。大致是这样的：A
    back，buying，cab，deal。Easels。
- en: That wasn't exactly the snappy rhythm that we saw before， was it？
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是我们之前看到的那种节奏，对吧？
- en: What happens at a keyboard if you're loading information into a database？ And
    instead of going。 you know， first thousand people， second thousand， third thousand，
    four thousand。 I remember once I was loading a table and it went first thousand。
    Second thousand。 Third thousand。 And was like then two minutes before the four
    thousand were done because I'd declared a column unique but not added an index
    to let the dictionary as more and more people were added。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在键盘上加载信息到数据库，会发生什么？而不是逐个去，知道，第一千人，第二千，第三千，第四千。我记得有一次我在加载一个表，它是第一千，第二千，第三千，然后在第四千完成之前差不多过了两分钟，因为我声明了一个列为唯一，但没有添加索引来让字典随着越来越多的人添加。
- en: quickly check all the previous people for a duplicate。 If somebody chooses a
    set of keys where the fifth one takes five times as long and the tenth one takes
    ten times as long as the first insert。 then I am suddenly in a situation called
    accidentally quadratic。 Where the amount of time I take will vary with the square
    of the number of items entered。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 快速检查所有之前的人以查找重复。如果有人选择了一组键，其中第五个花费的时间是第一个插入的五倍，而第十个花费的时间是第一个插入的十倍，那么我突然处于一个称为意外平方的情况。插入的项目数量的时间将随着数量的平方而变化。
- en: meaning thousand items should take about a million moments of work。 And there's
    actually a blog about this。 I highly recommend to you all accidentally quadratic。tumbler。com。
    It is an entertaining blog of one or two posts a month about all kinds of high-end
    professionally designed software projects that it turns out if their corners have
    quadratic rather than linear or logarithmic behavior。 Things， browsers， servers
    that it turns out you can make instead of going one， two， three， four。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着千个项目应该花费大约一百万个时刻的工作。实际上有一个关于这个的博客。我强烈推荐你们查看意外的平方。tumbler.com。这是一个每月一两篇关于各种高端专业设计软件项目的娱乐性博客，结果它们的边界具有平方而非线性或对数行为。事情，浏览器，服务器，结果你可以做到，而不是逐个增加。
- en: five through a set of items of work give you that sinking feeling by going one，
    two， three， four。 and so forth。 How many of you have ever run something that had
    exactly that pattern？
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 五个项目给你一种沉重的感觉，一，一，二，三，四，依此类推。你们有多少人曾经运行过完全相同模式的东西？
- en: It's always known what's gone wrong typically when you see something slowing
    down like that。 So we had to fix the hash function。 How does a hash function work？
    Well， one version of Python。 This is one that we used for a long time。 We， in
    the main loop。 have the hash of the string so far as we're partway through it，
    hashing it。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你看到某个东西变慢时，问题是什么是很明显的。所以我们必须修复哈希函数。哈希函数是如何工作的？嗯，这是一个版本的Python。这是我们长期以来使用的版本。在主循环中，我们有当前字符串的哈希值，正如我们正在进行中的部分。
- en: And to absorb the next character of information， we multiply the current hash
    by a million and three。 Oh， magic number， million and three。 And then we exclusive
    or in the next character of the string to flip in the lower byte。 whichever bits
    are set in the incoming character。 So we're feeding characters in each time。 multiplying
    by a million， three， and then pulling in 8 bits more of information from the next
    character。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了吸收下一个信息字符，我们将当前哈希乘以一百万加三。哦，魔法数字，一百万加三。然后我们将下一个字符的异或运算引入低字节。无论是输入字符中设置的哪一位。因此我们每次都在输入字符，乘以一百万加三，然后从下一个字符中提取8位更多的信息。
- en: You'll understand a bit about how this is filling the complete 32-bit or 64-bit
    hash with information。 If you ever played around with multiplication as a kid，
    either by hand or on a calculator。 where you might have discovered that by making
    a number in a thousand and one where all of the digits are just zero。 Or just
    zeros or ones， you could produce an output number that was kind of cool。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你将了解如何用信息填充完整的32位或64位哈希。如果你小时候玩过乘法，无论是手动还是用计算器，你可能发现将一个数字变成千百个零，或者仅用零和一，可以产生一种很酷的输出数字。
- en: It was little copies of your original number trapped inside of this much， much
    larger value。 For simplicity， I will， as they taught me in elementary school，
    a lie。 the rows that are just zeros for space here。 But you might have found that
    you could make even bigger numbers。 put some zeros and then another one。 Now，
    add another copy of your original number inside of the digits of the large output
    of the multiplication。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种被困在这个更大值中的你原始数字的小副本。为了简单起见，我会像在小学时被教导的那样，撒谎。这里的行只是零以节省空间。但你可能会发现你可以制作更大的数字。放一些零，然后再放一个“1”。现在，在大乘法输出的数字中再添加一个原始数字的副本。
- en: But you might have noticed that you can't put those ones too close together。
    where all of a sudden the pretty little copies of your numbers start looking more
    interesting。 Digits that aren't in the original will begin to show up。 All of
    a sudden you won't be able to predict what the next digit is because， of course。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可能已经注意到，不能把这些数字放得太近。突然间，你的数字的漂亮小副本开始变得更有趣了。原始数字中没有的数字开始出现。突然之间，你无法预测下一个数字是什么，因为，当然。
- en: the ones carry and move information leftward is interesting the asymmetry。 The
    ones carrying never bother the numbers to the right can make all kinds of assertions
    about the numbers to the right odd and even multiple of five or not。 multiple
    of ten。 You can't do that facing leftward in the number because that carry that
    happens pushes new digits and chaos out in the direction of the higher order numbers。
    When you add and therefore when you multiply， which is simply a repeated addition。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将信息向左移动的“1”有趣的是它的不对称性。“1”不干扰右边的数字，可以对右边的数字做出各种声明，例如是奇数和偶数，是否是五的倍数，是否是十的倍数。你不能在数字向左的情况下做到这一点，因为发生的进位会将新的数字和混乱推向更高位。当你加法，因此当你乘法时，这实际上是简单的重复加法。
- en: So when we sit here repeatedly multiplying a number by a million three and then
    putting new bits in the bottom。 we are taking this number in binary and look at
    how it uses its ones。 Two tucked in right at the bottom to make sure that two
    copies of the value that you've accumulated so far are just shifted by one bit
    and then forced to add with each other。 Then a bit of a gap in the middle that's
    only sparsely populated with ones just bringing a few more copies of that number
    in and then four ones up at the top that make sure that four copies of the previous
    hash value are piled right next to each other in order to add and create all sorts
    of interesting carries and chaos as the bits slowly in the process of multiplication
    move leftward。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当我们在这里重复将一个数字乘以一百万三，然后将新的位放入底部时，我们正在将这个二进制数字提取出来，并观察它如何使用“1”。两个紧靠在底部，以确保你迄今为止积累的值的两个副本仅仅向左移了一位，然后强制相加。然后中间有一点间隙，那里只有稀疏的“1”填充着，带来了更多该数字的副本，最后在顶部有四个“1”，确保四个先前哈希值的副本紧挨在一起，以便相加并产生各种有趣的进位和混乱，因为位在乘法过程中缓慢地向左移动。
- en: And that's of course why we or the incoming bytes into the bottom because the
    multiplication is constantly shoving upward into the high bits。 the entropy that
    we introduced by reading through the string in the lower bits。 That's mathematicians
    since they learned we were interested in hash functions and computer scientists
    alike have done far more formal analyses than this kind of hand waving I'm doing
    to give you the feel of how a hash works。 We can now have a number of mathematical
    properties to rate hash functions and we can get things like Python's hash function
    and ask which properties it has how evenly it distributes bits。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然就是我们或者说底部的输入字节的原因，因为乘法不断将信息推向高位。我们通过在低位读取字符串引入的熵。自从数学家们得知我们对哈希函数感兴趣以来，计算机科学家们做了比我这类手势式的解释更正式的分析，以便让你理解哈希是如何工作的。我们现在可以对哈希函数进行多种数学属性的评估，并且可以拿到像
    Python 的哈希函数，询问它具有哪些属性以及它如何均匀地分配位。
- en: But this kind of idea of visualizing the multiplication hopefully will give
    you a little bit of an instinct for how hash functions work and what the formalisms
    of then proving good properties are about。 It's about whether the big crazy number
    you're using to shove information to the left does a good job of scattering around
    any patterns that might have been in the original values。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种可视化乘法的想法希望能给你对哈希函数如何工作及其良好属性证明形式的直觉。这与您用于将信息向左推送的大疯狂数字是否有效地散布原始值中的任何模式有关。
- en: And this was a big problem with Python。 It always used this algorithm always
    started with the same value。 So if I knew you were using Python for your application。
    I could sit at home and try to come up with values with strings that would have
    the same hash。 This became famous in December of 2011， a security conference 28C3。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 Python 中是个大问题。它总是使用这个算法，并且总是从相同的值开始。所以如果我知道你在你的应用程序中使用 Python，我可以在家里想出一些字符串，使它们有相同的哈希值。这在
    2011 年 12 月的安全会议 28C3 中变得非常著名。
- en: efficient denial of service attacks， DOS's on web application platforms。 Platforms
    because Python was not their big target。 Python had this problem but so did almost
    every other language。 They in fact， this is kind of fun。 it was 2011。 So they
    made a list of the web application technologies they were about to discuss and
    to know how important each of them were。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 高效的拒绝服务攻击（DOS）针对网络应用平台。因为 Python 不是他们的主要目标。Python 确实有这个问题，但几乎每种其他语言也有。事实上，这有点有趣。这是在
    2011 年。他们列出了即将讨论的网络应用技术，以及它们各自的重要性。
- en: They went and found a website that ranked programming languages by their importance
    to the web。 You'll be happy to know that our vulnerability to deliberately created
    hashes only affected 0。2% of the web according to the numbers they had at the
    time。 Python's hash function could be broken。 They didn't actually illustrate
    how to do this but they said it could be broken computationally looking for possibilities
    with what's called a meet in the middle attack。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 他们找到了一个按编程语言对网络重要性进行排名的网站。根据当时的数据，你会高兴地知道，我们对故意创建的哈希的脆弱性仅影响了网络的 0.2%。Python
    的哈希函数是可以被破解的。他们并没有实际说明如何做到这一点，但他们表示可以通过寻找所谓的“中间相遇攻击”来计算破解。
- en: They could only find reasonable size attack strings for 32 bit systems， hadn't
    done it for 64。 They did a web search to find out what our web framework was。
    They found that it had a max size of 1MB if you post form data to it。 It'll throw
    it out and not even look at it。 It's over a MB。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 他们只能为 32 位系统找到合理大小的攻击字符串，尚未对 64 位进行测试。他们进行了网络搜索，找出我们的网络框架是什么。他们发现，如果你向它提交表单数据，最大大小为
    1MB，超过这个大小它就会抛弃而不进行处理。
- en: So they played around with a MB payloads where all of the names and values or
    all the names were going to collide。 They were able to make a plone site spend
    7 minutes of CPU in order to parse a single 1MB request。 Such a site once you
    learned the trick was a very easy site to bring down。 Just two months ago。 if
    you're interested in the cryptography of hash functions， a really。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 他们尝试了一些 MB 负载，其中所有的名称和数值，或者说所有名称都将发生冲突。他们能够让一个 plone 网站花费 7 分钟的 CPU 来解析一个单一的
    1MB 请求。一旦你学会了这个技巧，这样的网站很容易被攻击。就在两个月前，如果你对哈希函数的密码学感兴趣，确实。
- en: really neat blog post appeared of someone who has published their work and has
    figured out how to produce 64-bit hash collisions。 not the little 32-bit collisions
    of the original research。 Go look for that on medium。com。 If you want to see how
    someone， Robert Gross， he's learning cryptography and to have a target to practice
    on。 he took Python's old hash function， put it through the ringer and figured
    out in a moderate amount of computing time how to get some lists of hundreds at
    least of keys that even on a 64-bit system hash to the same value。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一篇非常有趣的博客文章出现了，作者发布了他们的工作，找到了如何产生 64 位哈希冲突的方法，而不是原始研究中的小型 32 位冲突。去 medium.com
    上找找。如果你想看看某人，罗伯特·格罗斯，他在学习密码学并有一个练习目标，他对 Python 的旧哈希函数进行了深入研究，并在适度的计算时间内找到了至少几百个键，在
    64 位系统上哈希到相同的值。
- en: Great article。 So the immediate response we had to do something quickly was
    to sprinkle a little randomness around this basic hash algorithm。 We also decided
    to dignify 1，000，000 in 3 with a pound-to-find statement apparently。 By adding
    a few random bits at the beginning， every website。 every time Python launched
    would have a different output for a given string。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒的文章。因此，我们立即做出的反应是快速采取一些措施，在这个基本哈希算法周围增加一点随机性。我们还决定用一个显然是 pound-to-find 语句来使
    1,000,000 在 3 中有尊严。通过在开头添加一些随机位，每个网站，每次 Python 启动时，对于给定字符串都会有不同的输出。
- en: So you could no longer count on your list of pre-computed collisions working。
    Then there was a bit of randomness， a suffix added at the end or exclusive or
    at the end that helped hide the prefix so it wasn't too easy to say if a site
    exposed its dictionary order in its JSON return value made it harder to use that
    to guess what their secrets that particular server was using。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你不能再依靠你预先计算的碰撞列表来工作。然后加入了一些随机性，在最后添加了一个后缀或异或运算，这帮助隐藏了前缀，因此如果一个站点在其JSON返回值中暴露了字典顺序，就不那么容易猜测该服务器使用的秘密。
- en: The main thing you'll notice is that your web applications can't easily be DOS。
    It's not a perfect solution， but it makes it much。 much harder to create a situation
    where you just fall over doing seven minutes of CPU work。 And your dictionary
    has always come out in a different order。 For exactly the same program。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到的主要问题是，你的网络应用程序不能轻易受到DOS攻击。这不是一个完美的解决方案，但它大大增加了创建让你在七分钟的CPU工作中崩溃的情况的难度。而且你的字典总是以不同的顺序输出。对于完全相同的程序。
- en: exactly the same input， suddenly the dictionary order goes random apparently
    in 3。3 and subsequent。 They made because this was a security issue， bug fix releases
    of 267， 3。1 and 2。 But remember there because they couldn't break existing tests
    in code。 you only get that protection against DOS attacks with the dash capital
    R flag。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 完全相同的输入，突然字典顺序在3.3及其后续版本中似乎变得随机。因为这是一个安全问题，他们做出了267，3.1和3.2的错误修复发布。但请记住，由于他们无法打破现有代码测试，你只能通过使用大写R标志来获得对DOS攻击的保护。
- en: I believe there's also an environment variable that will turn on the randomness。
    So they pointed out the uselessness of that the next year。 At the next instance
    of the same security conference at 29 C3。 they use apparently successive integers。
    Hash flooding DOS reloaded was presented by three new researchers to outline how
    badly many languages had responded to the original filing and complaint。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信还有一个环境变量可以开启随机性。因此，他们在第二年指出了这一点的无用性。在下一届29 C3安全会议上，他们显然使用了连续的整数。三位新研究人员展示了哈希洪水DOS重载，概述了许多语言对原始文件和投诉的糟糕响应。
- en: They were not actually able， I noticed， to remotely watching a Python app figure
    out how to create collisions。 but they at least were able to recover the random
    key by calling hash in a Python program。 which suggested that information was
    being leaked that maybe could have been exploited remotely。 And more importantly，
    these researchers solved the problem。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我注意到，他们实际上无法远程观察Python应用程序如何创建碰撞，但他们至少能够通过在Python程序中调用哈希来恢复随机密钥。这表明信息可能被泄露，可能会被远程利用。而更重要的是，这些研究人员解决了这个问题。
- en: They did the work and introduced CipHash， made it free for any language that
    wanted to use it。 which is random each time you start the run time up。 You get
    set of hashes you've never seen before。 we'll never see again。 And no attacker
    should be able to reasonably guess what that secret is and generate collisions
    for you。 CipHash did earn a PEP 4。56。 It was proposed。 Everyone said no because
    it's too slow。 Python dev。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 他们做了工作并引入了CipHash，使其对任何想要使用它的语言免费。每次启动运行时时，它都是随机的。你会得到一组你从未见过的哈希，以后也不会再见到。而且没有攻击者能够合理地猜测这个秘密是什么并为你生成碰撞。CipHash确实获得了PEP
    4.56的提案。大家都说不，因为它太慢了。Python开发者。
- en: well wait a minute if you do this to the bits， if we combine this， we do this
    many bytes at a time。 And finally they got it fast enough that they put it in。
    And it was accepted as standard track for the language。 It's in 3。4， 3。5， 3。6。
    You have default turned on all the time。 Hard crypto protection。 So far as we
    know at the moment。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，如果你对这些位进行处理，如果我们将其结合起来，以许多字节为单位处理。最终，他们使其速度足够快，以至于将其纳入标准轨道。它在3.4，3.5，3.6中，你默认始终开启。硬加密保护。就我们目前所知。
- en: Such things always change。 At the language level from those kind of DOS attacks。
    the lighter weight sprinkle of randomness is there in 3。3。 And in many bug fix
    releases of previous versions。 if you remember to turn them on with dash capital
    R or an environment variable。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的事情总是会变化。在语言层面上，来自那些DOS攻击的随机性轻量喷洒出现在3.3版本中。在许多以前版本的错误修复发布中，如果你记得用大写R标志或环境变量将其开启。
- en: So that is why your dictionary suddenly went out of order if you were using
    Python 3。4。 And 3。5。 We'll get to 3。6 in a minute。 Internal change that I'll just
    describe very briefly。 PEP 509 added a private version number。 They burned 8 more
    bytes in every one of our dictionaries。 They went in and every dictionary has
    a version number and they have elsewhere in memory。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么如果你在使用Python 3.4和3.5时，你的字典会突然失序。我们很快就会谈到3.6。内部变化我会非常简要地描述。PEP 509添加了一个私有版本号。他们在我们的每一个字典中额外消耗了8个字节。每个字典都有一个版本号，并且它们在内存的其他地方。
- en: a master version counter。 And when you go and change your dictionary。 the master
    counter is incremented from a million to a million in one。 And that value of a
    million in one is written into the version number of that dictionary。 So what
    this means is you can come back later and know if it's been modified without reading
    all of its maybe hundreds of keys and values。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个主版本计数器。当你去更改字典时，主计数器从一百万递增到一百万加一。这个一百万加一的值被写入该字典的版本号。这意味着你可以在稍后返回时知道它是否被修改，而不必查看它可能有的数百个键和值。
- en: You just look and see if the version has increased since the last time you were
    there。 A lot of the pain of trying to optimize Python is that anything can change
    at any time。 Someone could decide to monkey patch。 So code that looks like it
    should be referencing a built-in。 but you use all the time， could instead be intercepted
    by someone having injected a function of that name at the module level。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需查看，自上次你在那里以来，版本是否增加。试图优化Python的很多痛苦在于，任何事情都可以随时改变。有人可能决定进行猴子补丁。因此，看起来应该引用一个内置的代码，但你一直在使用的，可能会被在模块级别注入了同名函数的人拦截。
- en: Or they could edit the built-in's module。 Someone writing an optimized version
    of a function can now check for that。 Has the globals of a module changed？ Look
    at its version number hidden in that dictionary。 You'll know whether it's been
    touched and if it hasn't。 you can keep using the optimized version of a routine
    that has inlined the built-in。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 或者他们可以编辑内置模块。编写优化版本函数的人现在可以检查这一点。模块的全局变量是否改变？看看那个字典中隐藏的版本号。你将知道它是否被触及，如果没有，你可以继续使用已内联内置的优化版本例程。
- en: Has the built-in's dictionary changed？ Look at its version number。 All sorts
    of optimizations that Python's dynamic nature had made impossible。 You never know
    when someone might replace a built-in with something else。 Are now possible because
    the dictionaries that hold the built-ins。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的字典改变了吗？看看它的版本号。各种优化因Python的动态特性而变得不可能。你永远不知道什么时候有人可能会用其他东西替换内置项。现在是可能的，因为持有内置项的字典。
- en: that hold class namespaces and that hold module namespaces。 Now。 along with
    all of our other dictionaries， have a version number。 It's internal。 I haven't
    seen an interface for users to get to it， but it's an implementation detail of
    Python 3。 Now， to accelerate optimization on that platform， PEP 509 is where you
    can get more details。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 持有类命名空间和模块命名空间的字典，现在，连同我们所有的其他字典，都有一个版本号。它是内部的。我还没见过用户获取它的接口，但这是Python 3的一个实现细节。现在，为了加速该平台的优化，PEP
    509是你可以获取更多细节的地方。
- en: I gloss over that quickly to talk about compact dictionaries。 The big， big change
    in Python 3。6 that changes dictionaries forever。 A dictionary you'll recall fills
    up one item at a time。 There's collisions， hopefully not on most of the values。
    At this point。 it's as full as it's going to get。 If you add another key to this
    dictionary。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我快速略过这一点，谈谈紧凑字典。在Python 3.6中，发生了巨大的变化，永远改变了字典。你会记得，字典是一次填充一个项。可能会有碰撞，希望大多数值不会碰撞。在这一点上，它达到了最大的填充度。如果你再往这个字典中添加一个键。
- en: that's more than two-thirds full， so a new dictionary hash table is allocated
    of 16。 Twice is big and all the keys are reinserted before you're allowed to continue。
    Looking back at what it looked like when it just had five keys in it。 this is
    as full as we're going to let it get。 And yet it still has noticeable blank space
    in it。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这超过三分之二是满的，因此分配了一个新的字典哈希表，大小为16。两倍的大小，并在允许你继续之前，所有的键都被重新插入。回想一下，当它只有五个键时的样子。这是我们允许它达到的最大填充度。然而，它仍然有明显的空白空间。
- en: Three of its rows are holding nothing。 Eight bytes on a 64-bit system of hash。
    Eight bytes of address for that key。 Eight bytes of address for that value。 72
    bytes are still empty when we declare it so full that we're throwing it out and
    starting over with a more sparse data structure。 In 2012， Raymond Hettinger had
    an idea。 He introduced it on Python dev and immediately some improvements to it
    were suggested。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它的三行什么也不存储。在64位系统的哈希中占用八个字节。该键的地址占用八个字节。该值的地址占用八个字节。当我们声明它如此满以至于要扔掉并重新开始一个更稀疏的数据结构时，72个字节仍然是空的。在2012年，雷蒙德·赫廷格有了一个想法。他在Python开发中介绍了它，并立即提出了一些改进建议。
- en: Every problem in computer science can be solved with an extra layer of interaction。
    What if we don't use those big 24-bit rows to remember which hash locations we've
    used？
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中的每个问题都可以通过增加一层交互来解决。如果我们不使用那些大的24位行来记住我们使用过的哈希位置，会怎么样？
- en: What if instead we were simply to use eight bytes？
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们简单地使用八个字节会怎么样？
- en: And when it's time to start adding items to the dictionary。 what if we simply
    remembered in a little bitty array of eight bytes the location in a bigger list
    of where we had put the hash。 the key， and the value？ Instead of a dictionary
    having to keep entire 24-bit slots free。 as it now has reached five items and
    needs to go to eight entries。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当是时候开始向字典中添加项目时，如果我们只是记住一个小的八字节数组中更大列表的哈希位置、键和值会怎么样？而不是字典必须保持整个24位槽位的空闲，因为它现在已达到五个项目并需要转到八个条目。
- en: we instead can only have three bytes left free。 Because of the eight bytes up
    at the top that we have available to remember the indexes of our keys。 we're only
    using five， we're leaving three empty， and so three bytes wind up empty wasted
    and unused right before the dictionary is ready to resize rather than what was
    at 72。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能剩下三个字节可用。因为我们上面有八个字节可用于记住键的索引。我们只使用了五个，留了三个空着，因此在字典准备重新调整大小之前，三个字节就变得空闲且未使用，正如在72时所看到的。
- en: So the old dictionary had lots of extra space， the new one packs all of the
    keys and values into a short list that it grows。 and if it doubles in size， then
    it simply reallicates all of the keys in a contiguous area。 In 2015。 they added
    this to pipy， which is allowed to do crazy things to be more efficient。 It's interesting。
    a few things sped up significantly， four percent， eight percent gains。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所以旧的字典有很多额外空间，新的字典将所有键和值打包到一个短列表中，它会增长。如果它的大小翻倍，那么它只需在一个连续的区域中重新分配所有的键。在2015年，他们将这个添加到了pipy，这使得进行更高效的疯狂操作成为可能。有趣的是，几件事情显著加速，获得了四个百分点、八个百分点的提升。
- en: some benchmarks slowed down because we added a level of indirection。 which is
    the problem with solving problems in computer science， it can make things slower。
    Some things got slightly slower， slightly faster with one or two big wins。 but
    the big reason for doing this wasn't speed。 It was actually exciting that the
    speed had barely changed。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一些基准测试变慢了，因为我们增加了一层间接性。这就是解决计算机科学问题的难题，它可能使事情变得更慢。有些东西变得稍微慢一点，稍微快一点，有一两个大的成功，但这样做的主要原因并不是速度。实际上，速度几乎没有改变，这让人感到兴奋。
- en: adding an extra level of indexes because we got much better memory usage。 Another
    year went past。 a normal Python people couldn't benefit， and in Nada， I don't
    think I've met him。 opened an issue with a patch that added it to Python 3。3。5
    something。 A whole month went by。 no one addressed the issue， he kind of pinged
    and said， "Oh， this is big。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 增加一个额外的索引层，因为我们得到了更好的内存使用。又过了一年，普通的Python用户无法受益，而在Nada，我想我没见过他。开了一个问题，补丁将其添加到Python
    3.3.5上。整整一个月过去了，没人处理这个问题，他提醒道，"哦，这很重要。
- en: it would have to be addressed on Python Dev，" which often means it's not going
    to happen。 And then in September something magic happened。 For the first time，
    the core devs got together。 all in a room by themselves for a few days， and had
    a core Dev sprint， and at the end of that。 a message suddenly appeared on this
    moribund issue。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这必须在Python开发者中解决，"这通常意味着这不会发生。然后在九月发生了一些神奇的事情。核心开发者们第一次聚在一起，独自在一个房间里待了几天，进行了一次核心开发冲刺，最后，一个消息突然出现在这个停滞不前的问题上。
- en: We discussed a lot about your compact interchange， and we all wanted in 2。6。
    But the code isn't ready yet？ Well， let's just push it into Python 2。3 before
    the deadline this weekend， and we'll fix it up later。 They wanted it that bad。
    And of course， predictably， immediately， someone said， "Isn't this premature？
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了很多关于你的紧凑交换，我们都希望在 2.6 中实现。但代码还没有准备好？好吧，就在这个周末的截止日期之前，把它推入 Python 2.3，我们稍后会修复它。他们想要得那么急。当然，果然，马上就有人说，“这不是太早了吗？”
- en: Who wasn't on the group of core devs？ But no， they'd spent like an entire day
    talking it out。 how this affected the future。 And it made it in。 In Python 2。6，
    the new dictionary is much faster。 Iterations faster， there aren't empty spaces
    to have to go past。 And it remembers the order。 Because that big table it's adding
    to， it's a simple append。 Can you now depend on the order？
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 谁不在核心开发者组中？但不，他们花了一整天讨论这个问题。这对未来的影响如何。最终在 Python 2.6 中实现了。新的字典速度更快。迭代更快，不再有空格需要跳过。而且它记住顺序。因为那张大表格是在添加，它是一个简单的追加。你现在能依赖顺序吗？
- en: Is the big question？ Because they went ahead， and for free got to accept a PEP
    asking the keyword args be ordered。 and asking that class Dixby ordered， and that
    meta class input be ordered。 All those uses for dictionaries that had won an order
    now had them。 They think， the core devs。 I think， often think that they're just
    helping users who might notice that dictionaries are now ordered。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 大问题是什么？因为他们已经继续前进，免费接受了一个 PEP，要求关键字参数有序，并要求类 Dixby 有序，以及元类输入有序。所有那些对字典的使用现在都有了顺序。他们认为，核心开发者们。我认为，他们常常认为自己只是帮助那些可能注意到字典现在有序的用户。
- en: But if you look on stack overflow， order isn't something that people are going
    to stumble across。 It's something they already expect dictionaries to have。 The
    human mind， naturally， by its nature。 expects dictionaries to have order。 If you've
    ever taught Python， this is always a stumbling block。 Raymond thinks the guarantee
    might be almost inevitable， but Beasley says this is permanent。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你查看 Stack Overflow，顺序并不是人们会偶然发现的东西。这是他们对字典的期望。人类的思维，自然地，期望字典有顺序。如果你曾教过 Python，这总是一个绊脚石。雷蒙德认为保证几乎是不可避免的，但比斯利说这是永久的。
- en: and I agree with him。 I say 3。6 is brought about dictionaries for humans。 [Applause]。
    I don't think they're ever rolling this one back because the normal programmer
    who doesn't even know about hash tables has always expected them to be ordered。
    and will write code that depends on it。 I end with the wish slightly modified
    that I ended my last talk with。 May your hashes be unique。 Your keys rarely collide，
    and your dictionaries be foreve[r ordered。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我同意他的观点。我认为 3.6 为人类带来了字典。[掌声]。我不认为他们会撤销这一点，因为那些甚至不知道哈希表的普通程序员一直期望它们是有序的，并且会编写依赖于它的代码。我以略微修改的愿望结束，就像我上次演讲结束时那样。愿你的哈希是唯一的。你的键很少冲突，而你的字典永远是有序的。
- en: Thank you very much。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢。
- en: '![](img/5243fa82c8418d4a9230f5750f6730c5_6.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5243fa82c8418d4a9230f5750f6730c5_6.png)'
- en: '[Applause]， [Applause]。'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]， [掌声]。'
- en: '![](img/5243fa82c8418d4a9230f5750f6730c5_8.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5243fa82c8418d4a9230f5750f6730c5_8.png)'
- en: '[BLANK_AUDIO]。'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[空音频]。'
- en: '![](img/5243fa82c8418d4a9230f5750f6730c5_10.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5243fa82c8418d4a9230f5750f6730c5_10.png)'
