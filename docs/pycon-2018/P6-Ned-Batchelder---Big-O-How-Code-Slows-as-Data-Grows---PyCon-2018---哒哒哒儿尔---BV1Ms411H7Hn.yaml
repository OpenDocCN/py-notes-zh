- en: P6：Ned Batchelder - Big-O How Code Slows as Data Grows - PyCon 2018 - 哒哒哒儿尔
    - BV1Ms411H7Hn
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P6：**Ned Batchelder - Big-O：随着数据增长代码如何减速 - PyCon 2018 - 哒哒哒儿尔 - BV1Ms411H7Hn**
- en: \>\> Good afternoon， everybody， and welcome to the final talk here of this Python。
    I'm especially honored here to have a fellow Ned here。 So it's not often。 I hope
    you appreciate the honor that we have arranged to have two Neds on the stage at
    one， time。 Ned Batchler here is going to talk about Big O， how code slows as data
    grows。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: \>\> 大家下午好，欢迎来到这场Python的最后讲座。我特别荣幸能有另一位**Ned**在这里。所以这并不常见。我希望你能欣赏我们安排在同一时间有两个**Ned**在舞台上的荣誉。**Ned
    Batchler**将谈论大O，随着数据增长代码如何减速。
- en: There probably will not be time for questions afterwards， but you may be able
    to catch Ned。 elsewhere。 Thanks very much， Ned Batchler。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 之后可能没有时间提问，但你可以在其他地方找到**Ned**。非常感谢你，**Ned Batchler**。
- en: '![](img/6cde5d5d991ebe38049e6e258c259295_1.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6cde5d5d991ebe38049e6e258c259295_1.png)'
- en: '[ Applause ]， \>\> Hi， everyone。'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]，\>\> 嗨，大家好。'
- en: '![](img/6cde5d5d991ebe38049e6e258c259295_3.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6cde5d5d991ebe38049e6e258c259295_3.png)'
- en: Thank you for coming to this last talk session。 I've been trying to think of
    this slot。 not as the exhausted speaker， and half of the， people are already on
    planes slot。 but as the grand finale of PyCon。 So thank you for joining me here。
    So as Ned said。 my name is Ned Batchler。 I'm Ned Bat on most social media。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢大家参加最后一个讲座。我试图将这个时段视为不是疲惫的演讲者的时间，已经有一半的人在飞往其他地方，而是作为PyCon的盛大结局。所以感谢你们在这里与我一起。所以正如Ned所说，我的名字是**Ned
    Batchler**。在大多数社交媒体上我叫**Ned Bat**。
- en: and there's a bit short link there at the bottom of the。 slide that links to
    this talk online if you want to follow along with the slides。 And those two short
    things will be at the bottom of most of the slides， too。 So I've been writing
    software for a long time， and one of the things that interests me about。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在幻灯片底部有一个简短的链接，如果你想跟随幻灯片，可以在线查看这个讲座。这两个简短的链接在大多数幻灯片底部也会出现。所以我已经写软件很长时间了，而让我感兴趣的一件事是。
- en: writing software is that there are two mindsets that inform the process of writing
    software。 The first is computer science， which is really a branch of mathematics。
    and so it's very theoretical。 You do proofs。 You think about very abstract concepts。
    The other mindset that informs writing software is software engineering， which
    is very pragmatic。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 编写软件的一件事是，有两种心态影响着编写软件的过程。第一种是计算机科学，实际上是数学的一个分支，因此非常理论化。你会做证明，思考非常抽象的概念。另一种影响编写软件的心态是软件工程，这非常务实。
- en: and is basically concerned only with whether you are writing software that works。
    How can we write software that works？ And there is some crossover。 Lots of computer
    science underpins software engineering， but we don't think about it every， day。
    But there's a few topics that do crossover into the everyday of software engineering。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上只关心你是否在编写可运行的软件。我们如何编写有效的软件？确实有一些交集。很多计算机科学的基础知识支持着软件工程，但我们并不每天都考虑这些。但是，有一些主题确实与软件工程的日常工作交叉。
- en: And in particular， I'm interested in people who are working in software engineering
    who。 don't have formal computer science backgrounds and maybe feel a little bit
    insecure about that。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我特别对那些在软件工程领域工作的人感兴趣，他们没有正式的计算机科学背景，可能对此感到有些不安。
- en: '![](img/6cde5d5d991ebe38049e6e258c259295_5.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6cde5d5d991ebe38049e6e258c259295_5.png)'
- en: And one of the things that they seem to feel keeps them from sitting at the
    grown-ups table。 is this thing called Big O。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 他们似乎认为让他们无法坐在成年人桌子旁的一个因素，就是这个叫做大O的概念。
- en: '![](img/6cde5d5d991ebe38049e6e258c259295_7.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6cde5d5d991ebe38049e6e258c259295_7.png)'
- en: The Big O is really a simple thing。 And I've made a rhyme here to help you remember
    what it is。 It's about how your code slows as your data grows。 And an English
    major friend of mine pointed out that the rhyme is on the O sound like Big， O。
    And I didn't intend that at all， but that's cool。 So the question is。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大O其实是一个很简单的概念。我这里有一个押韵的方式来帮助你记住它。这是关于你的代码在数据增长时如何变慢的。而我的一个英文专业的朋友指出，这个押韵的声音就像大O。我并没有故意这样，但这很酷。所以问题是。
- en: how does your code slow down as the data gets larger and larger？
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据越来越大时，你的代码是如何变慢的？
- en: And this is not the same as the running time of any particular run of your code。
    We're not trying to measure the time in seconds。 We're not trying to figure out
    exactly how many of them you can do in one transaction。 We're talking about the
    trend over time， over many runs of your code。 How does it slow down as the data
    gets larger and larger and larger？
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这与特定运行代码的运行时间并不相同。我们并不是在测量秒数，也不是在试图确切计算一次交易可以完成多少个。我们讨论的是在多次运行代码过程中，时间趋势如何。随着数据越来越大，它是如何减慢的？
- en: And one very pragmatic way to think about this is， let's say you have a chunk
    of code。 you give it a certain amount of data， it takes a certain amount of time。
    How much longer will it take to work on 10 times as much data？ If I give it 10
    times as much data。 how much longer does it take？ And you might think intuitively，
    well， it'll take 10 times as long。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常务实的想法是，假设你有一段代码，你给它一定量的数据，它会花费一定的时间。处理十倍数据将花费多长时间？如果我给它十倍的数据，花费多长时间？你可能会直观地想，它会花费十倍的时间。
- en: obviously。 But that turns out not to be true。 Some code will take 10 times as
    long。 Some code will take twice as long。 Some code will take 100 times as long。
    and some code won't take any longer at all。 And Big O is all about characterizing
    that growth of the time of the code as the data grows。 How the code slows as the
    data grows。 And computer science people approach this topic in a very。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这种情况并不成立。有些代码可能花费10倍的时间，有些代码可能花费两倍的时间，有些代码可能花费100倍的时间，而有些代码根本不会花费更长时间。大O表示法正是用于描述代码在数据增长时的时间增长情况，以及代码如何随着数据增长而减慢。计算机科学的人们在这个话题上采取了非常。
- en: very mathematical way。 But software engineers approach it in a very， very pragmatic
    way。 And I'm trying to， I'm going to explain the pragmatic approach。 It doesn't
    have to be done in a mathy way， it can be done in a pragmatic way。 So let's get
    some terminology out of the way。 This is called the Big O notation。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常数学化的方式。但软件工程师以一种非常务实的方式来处理这个问题。我将尝试解释务实的方法。这并不一定需要以数学的方式完成，它可以以务实的方式完成。所以我们先处理一些术语。这被称为大O表示法。
- en: And the way it's written is a capital O and a parenthesis， and。 then a bunch
    of stuff with an N in it and a closed parenthesis。 Okay？ I told you it was simple。
    The N is meant to stand in for how much data you have。 And the O stands for order
    of。 And the idea is that we're talking about the running time of your code grows
    on。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 它的写法是一个大写字母O和一个括号，然后是包含N的许多内容和一个闭括号。明白了吗？我告诉过你这很简单。N代表你的数据量。而O代表顺序。其目的是讨论代码的运行时间是如何增长的。
- en: the same order of some mathematical expression of N。 The key thing here is although
    it looks like a function call。 there's a name and then parenthesis with stuff
    inside， it's not a function call。 it's just a notation。 And there's probably a
    mathy reason why it looks like a function call， but。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 某些数学表达式的顺序是相同的。关键在于，虽然它看起来像是一个函数调用，但它只是一个符号。这里可能有数学原因使它看起来像函数调用，但。
- en: it doesn't matter。 Just know that it's not a function call， it's just a way
    of labeling a piece of。 code as having a certain growth pattern。 So let's take
    a real world example。 Let's say we have to count the number of beans and jars，
    right？ We've got this guy in the left。 he opens up to jars， he starts pulling
    out beans one by one。 Right。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这无关紧要。只要知道这不是函数调用，它只是标记一段代码具有特定增长模式的方式。那么我们来一个现实世界的例子。假设我们需要统计罐子里的豆子，对吧？左边这个家伙打开两个罐子，开始一颗颗地拿出豆子。
- en: we can see here N is the number of beans， right？ If we give this guy a jar with
    ten times as many beans。 it's going to take him ten times as long， obviously，
    right， and he's sweating。 This is what's known as O of N， meaning that the time
    it takes to complete the task。 grows in the same way that N grows。 It's on the
    order of N。 If N doubles， the time doubles。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这里的N是豆子的数量，对吧？如果我们给这个家伙一个装有十倍豆子的罐子，显然他会花费十倍的时间，而且他在流汗。这被称为O(N)，意味着完成任务所需的时间与N的增长方式相同。它的顺序是N。如果N翻倍，时间也翻倍。
- en: If N is ten times more， the time is ten times more。 And you might think， well。
    there's no other way to approach this task。 But there is， of course， you get beans。
    jars that have labels on them that tell you， how many beans are in them。 Right。
    this guy on the right has a much easier job。 You can see how much happier he is
    about it。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果N是十倍，那么所需的时间也是十倍。你可能会想，嗯，这个任务没有其他办法处理。但是，当然可以，你可以得到带标签的豆子罐，告诉你里面有多少豆子。对吧，右边的这个人工作简单得多。你可以看出他对此有多开心。
- en: Because it doesn't matter how large a jar you give this guy on the right。 it's
    going to take the same amount of time for him to tell you how many beans are in
    the jar。 This is what's known as O of one， which is kind of a weird mathematicians
    way of saying。 that N isn't involved at all。 No matter what happens to N， the
    running time remains the same。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因为无论你给右边的这个人一个多大的罐子，他告诉你罐子里有多少豆子所需的时间都是一样的。这就是所谓的O of one，这是一种奇怪的数学术语，意味着N完全不涉及。无论N发生什么，运行时间保持不变。
- en: O of N is slower in the long run than O of one。 And this is a silly real world
    example。 But for instance， when you do 4X in my list， you have an O of N operation。
    because you have to look at every element in the list， every bean in the jar。
    When you do LEN of my list， you don't have to look at the elements of the list
    at all。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: O of N在长期来看比O of one更慢。这是一个愚蠢的现实世界例子。但例如，当你对我的列表执行4X操作时，你就是在进行O of N操作，因为你必须查看列表中的每个元素，每颗豆子。当你执行LEN操作时，你根本不需要查看列表中的元素。
- en: Turns out Python lists are kind of like those jars on the right。 The length
    of the list is written on the label on the outside of the list。 And so no matter
    how long the list is， getting the lengths of the list is a constant time operation。
    By the way， these drawings were drawn by my son， who is in art school。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，Python列表有点像右边的那些罐子。列表的长度写在列表外面的标签上。因此，无论列表多长，获取列表长度都是一个常数时间操作。顺便说一下，这些画是我儿子画的，他在艺术学校。
- en: One thing you might not have noticed if you look at their eyebrows， they're
    shaped like beans。 [LAUGHTER]， That's art school for you。 [LAUGHTER]， [APPLAUSE]，
    All right。 another real world example。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有注意到的一件事是，如果你看他们的眉毛，它们的形状像豆子。[笑声]，这就是艺术学校的风格。[笑声]，[掌声]，好吧，另一个现实世界的例子。
- en: '![](img/6cde5d5d991ebe38049e6e258c259295_9.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6cde5d5d991ebe38049e6e258c259295_9.png)'
- en: Let's say I tell you I'm going to give you a book and I want you to find a certain
    word。 in the book， like horse。 If I hand you a novel， you're going to start reading
    until maybe you find the word horse。 This sounds like an O of N operation again，
    because if I give you a novel that's twice， as long。 it might take you twice as
    long until you encounter the word horse。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我告诉你我要给你一本书，我希望你在书中找到一个特定的词，比如“马”。如果我把一本小说递给你，你会开始阅读，直到你找到“马”这个词。这听起来又像是O
    of N操作，因为如果我给你一本小说，长度是之前的两倍，你可能会花两倍的时间才能遇到“马”这个词。
- en: But let's say I give you a different book。 I give you an encyclopedia。 Now you
    open the encyclopedias to the middle。 If the word you're looking for is earlier
    than that。 then you do another divide and conquer， step until you find the word
    horse。 Now if I give you an encyclopedie that's twice as large， it's not going
    to take you， twice as long。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但是假设我给你一本不同的书。我给你一本百科全书。现在你把百科全书翻到中间。如果你要找的词比那更早，那么你就需要再进行一步分治，直到你找到“马”这个词。现在如果我给你一本大小是两倍的百科全书，所需的时间不会是两倍。
- en: There's just one more divide and conquer step to find it。 That's what's called
    O log of N。 which is a fancy mathematicians way of saying that。 So these are both
    real world examples of the kinds of tasks that sort of sounds similar。 when you
    first hear them， but how you organize the data and therefore what algorithm you
    can。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 只需再进行一步分治法就能找到它。这就是所谓的O log N，这是一种花哨的数学术语。因此，这两个都是在你第一次听到时听起来相似的现实世界例子，但数据的组织方式决定了你可以使用什么算法。
- en: use on the data really affects how the length of time it takes you to do the
    task changes。 as the size of the data changes。 Right？ That's what we're talking
    about is how your code slows as your data grows。 Let's get some other terms out
    of the way because I'm going to be speaking here and I might。 throw out some words
    that are a little bit different than earlier。 When we say O of one。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对数据的操作确实会影响你完成任务所需的时间长度，随着数据规模的变化，对吗？我们要讨论的是当你的数据增长时，代码的运行速度会减慢。让我们先解决一些其他术语，因为我将要在这里说话，可能会提到一些与之前稍有不同的词。当我们说O
    of one时。
- en: we might call it constant time。 I might say that the label to bean jars are
    a constant time algorithm because the time。 remains the same no matter what。 O
    of N is often called a linear operation because if you look at it mathematically。
    there's， a linear relationship between the size of the data and the running time。
    O of N squared is a thing we haven't seen yet， but we will。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能称其为常数时间。我可能会说给豆子罐贴标签是一个常数时间算法，因为无论如何时间保持不变。O(N)通常被称为线性操作，因为如果从数学上看，数据的大小和运行时间之间存在线性关系。O(N²)是我们还没有见过的概念，但我们将会看到。
- en: That's the case where when you give it 10 times more data， it takes 100 times
    as long to run。 and that's called quadratic because now you've got a quadratic
    equation involved。 If you don't remember what a quadratic equation is， it doesn't
    matter。 It's just a word that means N squared。 And some other words for big O。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当你给它10倍的数据时，运行所需的时间将增加100倍。这被称为二次，因为现在涉及到一个二次方程。如果你不记得什么是二次方程，也没关系。这只是一个表示N的平方的词。还有一些其他的关于大O的词。
- en: it's sometimes called complexity or time complexity or algorithmic。 complexity
    or if you want to sound really fancy， you can call it asymptotic complexity。 It's
    all the same thing。 One of the underlying themes of this talk is that this topic
    of big O notation is littered。 with mathematical detritus that doesn't really
    matter to the key concept。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时被称为复杂度、时间复杂度或算法复杂度，或者如果你想听起来更花哨，可以称之为渐近复杂度。这些都是同一个意思。这个讲座的一个基本主题是，大O符号的主题充满了其实对关键概念并不重要的数学杂物。
- en: And don't let that stuff throw you。 That's just chaff being thrown at you by
    mathematicians。 You don't have to let it throw you off the path。 So how do you
    actually determine the big O of a piece of code？
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让这些东西让你困扰。这只是数学家抛给你的杂音。你不必让它把你从正道上偏离。那么你到底如何确定一段代码的大O呢？
- en: The first step is you figure out what code you're talking about。 And that sounds
    kind of silly。 but in a large system， you might be looking at one function， and
    that might be the important thing。 but it really might actually be important to
    consider。 all the callers of the function or maybe you're looking at two large
    chunk of code you need。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是弄清楚你在讨论哪个代码。这听起来有点傻，但在一个大型系统中，你可能在查看一个函数，而这个函数可能是重要的。但考虑到所有调用这个函数的地方，实际上可能也很重要，或者你可能在看两大块代码。
- en: to think about a small piece。 If you're going to describe a piece of code。 be
    very clear about what piece of code you're， talking about。 And then when you look
    at that code。 you should figure out what N is。 And I don't mean like whether it's
    100 or 1，000。 I mean。 what is it measuring？ So if you have some code that's iterating
    over all the records in a database。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想一小段代码。如果你要描述一段代码，要非常明确你在谈论的代码是哪一段。然后当你查看那段代码时，你应该弄清楚N是什么。我并不是指它是100还是1,000。我是说，它在测量什么？比如如果你有一些代码是遍历数据库中的所有记录。
- en: then N is how， many records in the database。 And our bean example， it was how
    many beans in the jar。 If you're doing a string search， it might be the length
    of the string。 And then here's where the real work comes in。 You're going to think
    about that code running and you're going to figure out how many steps。 there are
    in the code in a typical run。 Let me tell you what I mean by typical first。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后N就是数据库中的记录数量。在我们的豆子示例中，就是罐子里有多少豆子。如果你在进行字符串搜索，可能就是字符串的长度。接下来就是真正的工作开始了。你需要考虑代码的运行情况，并且找出在一次典型运行中代码的步骤数。让我先告诉你什么是典型的。
- en: There's two meanings of typical。 One is what kind of data is it going to get？
    In the real world。 there's sort of real world data that kind of is what you kind
    of can， expect。 And then there's worst case data， right？ A string of 40，000 spaces
    is not typical data。 Typical data is， you know， last names。 It's mostly ASCII。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 典型有两个含义。一是它会获取什么样的数据？在现实世界中，有种真实的数据是你可以预期的。然后还有最坏情况的数据，对吧？一串40,000个空格并不是典型数据。典型数据是，比如说，姓氏。它主要是ASCII字符。
- en: It's about most to 15 characters along that kind of thing。 So you can think
    about what your typical data。 And then another meaning of a typical run is that
    over many runs of your algorithm。 there's， a certain number of times a loop might
    run or a certain length of string it might get。 So you kind of think about the
    design center of your code。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是大约15个字符的内容。所以你可以考虑一下你的典型数据。然后，典型运行的另一个意思是，在你算法的多次运行中，循环可能运行的次数或字符串的某个长度。因此，你要考虑代码的设计中心。
- en: And you imagine running that code through that design center and you count the
    steps。 And what I mean by steps is very vague。 And in a way， a lot of this topic
    is very vague。 There are no units in anything we're talking about。 And the number
    of steps。 it kind of doesn't matter what you count as a step。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象将这段代码通过那个设计中心运行，并且你要计算步骤。这里我所说的步骤非常模糊。在某种程度上，这个话题的很多内容都是非常模糊的。我们讨论的内容没有任何单位。而步骤的数量，其实不太重要你将什么算作一个步骤。
- en: And it kind of doesn't matter that some steps might actually take longer than
    others because。 really what you're thinking about is if I'm doing n equals 10，
    I'll have this many steps。 Now how many for n equals 100？ And so exactly what
    steps there are doesn't matter as much as how does that count grow？
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 而且其实不太重要的是某些步骤可能比其他步骤更耗时，因为你真正关心的是如果 n 等于 10，我将有这么多步骤。现在 n 等于 100 的话，有多少步骤？所以到底有哪些步骤并没有那么重要，重要的是这个计数是如何增长的？
- en: And I'll show you some examples so you'll get a sense of it。 So you count the
    steps in a typical run and since we put in n at the top and not 10 exactly。 the
    number of steps is going to be an expression in n。 You might end up with， well。
    it's 3n plus 47 steps。 Something like that。 And then what you do is you keep only
    the most significant part of that expression。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我会给你一些例子，这样你就能感受到它。所以你计算一次典型运行中的步骤，由于我们在顶部放入的是 n，而不是 10，步骤的数量将是 n 的一个表达式。你可能会得到，比如说，3n
    加上 47 步骤。类似这样的东西。然后你所要做的就是保留该表达式中最重要的部分。
- en: So you keep only the highest coefficient piece and then you throw away the coefficients。
    So if you had 47 n squared plus 53 n plus 101， that's n squared。 You throw away
    all the lower order components and the coefficients。 And the reason is that as
    n gets larger and larger and larger， the lower order components。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你只保留最高阶的项，然后丢掉系数。因此如果你有47 n 的平方加上53 n 加上101，那就是 n 的平方。你丢掉所有低阶的项和系数。原因是随着 n
    越来越大，低阶的项。
- en: matter less and less。 3n plus 1， the 1 is really important when n is 1， but
    when n is a billion。 who cares about， the 1？ So we're trying to get to that long
    term trend as the diddy gets very。 very large。 And if it's 3n， that doubles when
    n doubles， just the way n doubles when n doubles。 So the 3 is irrelevant too。
    So you get rid of the lower order components and you get rid of the coefficients。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这变得越来越不重要。3n 加 1，当 n 等于 1 时，1 是非常重要的，但当 n 达到十亿时，谁在乎 1 呢？所以我们试图得到那种长期趋势，因为当 n
    变得非常非常大时。如果是 3n，当 n 加倍时它也加倍，就像 n 加倍时的情况。因此，3 也是不相关的。因此你丢掉低阶的项和系数。
- en: And what's left is your big O notation。 Now let's look at some examples。 True
    fact。 I wrote this code in November and it didn't occur to me until I was lying
    in。 bed this morning that this code is about moms and it's Mother's Day。 So here's
    an example of some code。 What we're going to do is we're going to have a data
    structure called Moms。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是你的大 O 符号。现在让我们看一些例子。真实的事情是，我在11月份写了这段代码，今天早上躺在床上时才意识到这段代码是关于妈妈的，今天是母亲节。所以这里有一些代码的例子。我们将要创建一个叫做
    Moms 的数据结构。
- en: which is a list， of tuples。 And the tuples are people and their mothers。 And
    then we're going to write a function called find mom。 And find mom is going to
    take that list of moms in the name of a child and it's going。 to find the child's
    mom。 Now if you think about searching through this list。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个元组的列表。元组是人和他们的母亲。然后我们将要写一个叫做 find mom 的函数。find mom 将接收这个妈妈的列表和一个孩子的名字，并找到孩子的妈妈。现在如果你想象一下在这个列表中搜索。
- en: in some runs we'll find it in the first， entry。 And some runs we'll find it
    in the last entry。 So on average in a typical case we'll find it about n over
    two times。 We're going to look through half the list。 So if we come down to this
    line。 this loop is going to run n over two times。 And I'm going to say that there
    are three steps in this loop。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们会在第一个条目中找到它。而在某些情况下，我们会在最后一个条目中找到它。因此，平均而言，在典型情况下，我们大约会找到它`n/2`次。我们将查看列表的一半。因此，如果我们来到这一行，这个循环将运行`n/2`次。我会说这个循环中有三个步骤。
- en: We have to get the tuple out of the list and then we have to assign the child
    to child。 name and we have to assign the mom to mom name。 So there's three steps。
    which means that this line is going to contribute three times， n over two steps
    to our count。 In this comparison we're going to do n over two times and there's
    only one step。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须从列表中提取元组，然后我们必须将孩子的名称分配给`child.name`，并将妈妈的名称分配给`mom.name`。因此有三个步骤，这意味着这一行将为我们的计数贡献`3
    * n/2`步。在这个比较中，我们将进行`n/2`次，并且只有一步。
- en: So that gives us another n over two。 And then this line is only going to happen
    once because it's the end of the function。 So that's going to give us one more
    step。 And so our total is going to be 3n over 2 plus n over 2 plus 1。 which simplifies
    down， to 2n plus 1。 I said that we get rid of the lower order components。 which
    is the 1， we get rid of the， coefficient， which is 2。 This is an o of n function。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这给了我们另一个`n/2`。然后这一行只会发生一次，因为它是函数的结束。因此，这将为我们再增加一步。所以我们的总数将是`3n/2 + n/2 + 1`，简化后为`2n
    + 1`。我说过我们去掉低阶成分，也就是`1`，去掉的系数是`2`。这是一个`O(n)`函数。
- en: So we've just determined that the asymptotic complexity of find mom is o of
    n。 And the way people say that in the real world in a cubicle is find mom is o
    of n or find。 mom is linear。 Find mom is o of n。 And so you saw when we were going
    through the steps。 we didn't really care which steps， were expensive。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们刚刚确定了查找妈妈的渐近复杂度是`O(n)`。人们在办公室里说查找妈妈是`O(n)`，或者说查找妈妈是线性的。查找妈妈是`O(n)`。所以你看到当我们在逐步分析时，我们并不在乎哪些步骤是昂贵的。
- en: which we only wanted to know is the relationship between the n and the number。
    of steps and when n changes the number of steps is going to change。 And that's
    what we're looking for。 And notice we have no idea whether this is fast or slow。
    We don't know whether this function is going to take a minute or a millisecond。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想知道的是`n`与步骤数之间的关系，当`n`变化时，步骤数也会变化。这正是我们要寻找的。请注意，我们不知道这是快还是慢。我们不知道这个函数会花费一分钟还是毫秒。
- en: All we know is that if we give it 10 times more data， it's probably going to
    take 10， times as long。 Let's look at another example。 Also about moms。 The same
    data structure。 the same mom's data structure。 But now what we're going to do
    is we're going to write a function which tells us in。 that data structure and
    how many grandmothers are there。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只知道，如果我们给它10倍的数据，可能会花费10倍的时间。让我们看另一个例子，同样是关于妈妈的。相同的数据结构，相同的妈妈的数据结构。但现在我们要做的是编写一个函数，告诉我们在那个数据结构中有多少个奶奶。
- en: That is how many people are mentioned both as a mom and as a child in our list。
    So now we're going to go all the way through to the end of the list。 And I mentioned
    that n over two before。 But remember， we're throwing away coefficients。 so in
    a way the half never mattered。 And as you work through this more。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在我们的列表中提到的，既作为妈妈又作为孩子的人数。因此现在我们将一直查找到列表的末尾。我之前提到过`n/2`。但请记住，我们抛弃了系数。因此，在某种程度上，"一半"并不重要。随着你进一步研究这一点。
- en: you'll sort of get a sense of what you can not collect。 in the first place because
    you're going to throw it away anyway。 So for instance。 this line is going to run
    n times。 And notice I didn't write three times n here because like I said。 we're
    throwing away coefficients。 This is an o of n line。 We're going to run this line
    n times。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你会有一种感觉，什么是你不能首先收集的，因为你反正会把它扔掉。例如，这一行将运行`n`次。请注意，我没有在这里写`3n`，因为就像我说的，我们抛弃了系数。这是一个`O(n)`的行。我们将运行这一行`n`次。
- en: Now this line is going to run n times also， but it's calling a function， find
    mom， which。 we just determined was an o of n operation in and of itself。 When
    you call it once it's o of n。 and we're going to call it n times， that's going
    to give， us n squared。 And we can continue on and say this is n， but remember，
    we're going to throw away the lower。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这条线也会运行 n 次，但它调用了一个函数，find mom，我们刚刚确定这是一个 o 的 n 操作。当你调用一次时，它是 o 的 n，而我们将调用
    n 次，这将给我们 n 平方。我们可以继续说这是 n，但记住，我们会丢弃较低的部分。
- en: order components。 We already found an n squared。 It's kind of uninteresting
    to keep finding the n's。 But we're finding a bunch of n's。 We're going to end
    up with n squared plus some number of n plus one。 which is o of n squared。 So
    find how many grandmothers is a quadratic function？ It's o of n squared。 Now the
    ideal of course is o of one， right？ Constant time。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: order components。我们已经发现了一个 n 平方。这种不断找到 n 的过程有点无趣。但我们找到了很多 n。我们最终会得到 n 平方加上一些
    n 以及一个，这就是 o 的 n 平方。那么，找出多少个祖母是一个二次函数？这就是 o 的 n 平方。理想情况下，当然是 o 的一，对吧？常数时间。
- en: You can work on any amount of data and not have it take any longer。 It seems
    kind of impossible。 Like how could that be？ But remember， we saw a line of my
    list is o of one。 because no matter how long the list， is， the length is written
    on the outside。 we can just pick it up。 That's kind of boring。 Really interesting
    is looking up a key in a dictionary is o of one。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以处理任何数量的数据，而不会花费更多的时间。这看起来有点不可能。怎么会这样？但记住，我们看到我的列表是 o 的一，因为无论列表多长，长度都写在外面。我们可以直接取出来。这有点无聊。真正有趣的是，在字典中查找一个键是
    o 的一。
- en: No matter how many keys are in a dictionary， it takes about at the same amount
    of time to。 look up a key as in a one element dictionary and in a million element
    dictionary， which is。 why dictionaries are heavily optimized and engineered and
    underpin every name look up。 in Python because they're fast。 And we'll get back
    to why it is， but very quickly。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 无论字典中有多少个键，查找一个键所需的时间大约和在一个元素字典中查找的时间相同，而在一个百万元素的字典中也是如此，这就是为什么字典被高度优化和设计，并支撑了
    Python 中每个名称查找，因为它们很快。我们会回到为什么是这样，但非常快。
- en: it's because there's a thing called， a hash function which turns a key into
    a number and in typical data。 the numbers are all different。 And so you can very
    quickly use that number to find the place in the dictionary where the。 value is。
    No discussion of big O notation would be complete without showing you the graph。
    Along the bottom， we have that flat green line labeled one of the x-axis is data。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为有一个称为哈希函数的东西，它将键转换为一个数字，而在典型数据中，这些数字都是不同的。因此，你可以非常快速地使用那个数字找到字典中值的位置。关于大
    O 符号的讨论，如果不展示图表是不会完整的。在底部，我们有一条标记为一的平坦绿色线，x 轴是数据。
- en: So data grows to the right and then the time grows going up。 So the big flat
    line at the bottom is o of one。 That looks great。 Log n was looking through the
    encyclopedia。 The linear line going diagonally is o of n。 And the big red one，
    n squared， just zoos， literally off the chart。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所以数据向右增长，然后时间向上增长。所以底部的大平坦线是 o 的一。这看起来很好。对数 n 就像是在查阅百科全书。斜向上升的线是 o 的 n。而大红色的
    n 平方，简直是超出了图表的范围。
- en: So the n squared is one of those bad things you try to avoid because it really
    grows really。 fast when things get big。 Now when we looked at our code。 we have
    to understand what functions we're calling and， how。 what kind of complexities
    they're adding into our total function。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 n 平方是那些你试图避免的坏东西之一，因为当数据变大时，它确实增长得非常快。现在当我们查看我们的代码时，我们必须了解我们正在调用哪些函数，以及如何调用。它们为我们的总函数增加了什么样的复杂性。
- en: This is a chart of the typical operational complexities of lists， dicks， and
    sets in， Python。 When people say dictionaries are o of one， that sentence doesn't
    make any sense。 Nouns like dictionary can't have an algorithmic complexity。 Operations
    have an algorithmic complexity。 So what you're supposed to say is that looking
    up a key in a dictionary is o of one。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Python 中列表、字典和集合的典型操作复杂性图表。当人们说字典是 o 的一时，这句话没有任何意义。像字典这样的名词不能有算法复杂性。操作才有算法复杂性。所以你应该说在字典中查找一个键是
    o 的一。
- en: Now you'll notice that a lot of these are kind of the same。 Appending to a list
    is o of one。 adding a key in a dictionary is o of one， adding a value， in a set
    is o of one。 A big difference is looking up a value in a list is o of n。 So if
    you're going to search for a value in a list， it's going to have to look at every。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你会注意到，很多都是相似的。向列表添加元素是o(1)，在字典中添加键是o(1)，在集合中添加值是o(1)。一个很大的区别是，在列表中查找值是o(n)。所以如果你要在列表中搜索一个值，它必须查看每一个元素。
- en: element in the list。 It's going to be that left bean counting guide with the
    sweat coming off of his forehead。 But looking up a key in a dictionary or a value
    in a set is o of one， which is why they're。 really valued。 So pro tip right off
    the bat。 If you've got a program that's going too slow。 look to see if you're
    looking up a value， in a list and replace it with a look up in a set。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的元素。它就像那个左边的豆子计数指南，额头上渗出的汗水。但在字典中查找一个键或在集合中查找一个值是o(1)，这就是它们真正被重视的原因。所以一个专业的小提示。如果你的程序运行得太慢，看看你是否在列表中查找一个值，并用集合中的查找替换它。
- en: But there are trade-offs。 So when I say replace the list look up with a set
    look up。 you've got to keep your eye， on the big picture。 And this is where understanding
    what piece of code you care about matters。 So I said replace a list look up with
    a set look up。 Let's say we have some code like this where we're going to make
    a list。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有权衡。因此，当我说用集合查找替换列表查找时，你必须关注大局。这就是理解你关心的代码片段的重要性所在。所以我说用集合查找替换列表查找。假设我们有这样的代码，我们将创建一个列表。
- en: We make a list and then we try to find the thing in the list。 And that line
    is o of n。 We just saw that on the table of Python complexities。 So you might
    think， well， I know what I'll do。 I'll make a set instead and then I can look
    it up in a set。 That's good。 If you can do that。 that's good。 Don't make the list
    in the first place。 You make a set。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个列表，然后尝试在列表中找到东西。而那一行是o(n)。我们刚在Python复杂度表中看到过。因此你可能会想，我知道我该怎么做。我会做一个集合，然后我可以在集合中查找。这很好。如果你能做到，那很好。不要首先创建列表，直接创建集合。
- en: That is you go ahead and you make a list anyway and then you convert it to a
    set and。 then you do the look up in a set。 So now that last line is great。 It's
    o of 1。 but you've added a line before it turning the list into a set which itself，
    is o of n。 Like literally you've actually slowed down your program by a tiny amount。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，你可以继续创建一个列表，然后将其转换为集合。然后你在集合中查找。所以最后一行很好，它是o(1)，但你在它之前添加了一行，将列表转换为集合，这本身是o(n)。实际上，你的程序已经稍微变慢了。
- en: You still have the o of n operation of converting the list into a set。 So it's
    very easy once you get into this algorithmic complexity stuff to get sort of。
    focused on the little things and lose sight of the big picture。 This would be
    a bad trade-off。 A good trade-off would be even if you're making a list if you
    can convert into a set once and。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然有将列表转换为集合的o(n)操作。因此，一旦你进入这个算法复杂性的问题，很容易专注于小事，而忽视大局。这将是一个不好的权衡。一个好的权衡是，即使你正在创建一个列表，如果可以先转换为集合。
- en: then do many lookups。 So if you're going to do many lookups in your list。 then
    it makes sense to turn it into a， set once。 And then you have o of n and then
    many o of 1 and your program will go faster。 So you always have to keep in mind
    what the real usage is of your code and where the time。 is being spent about where
    you're going to sort of work on reducing the algorithmic complexity。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后进行多次查找。所以如果你打算在列表中进行多次查找，那么将其转换为集合是合理的。然后你有o(n)和许多o(1)，你的程序会运行得更快。因此，你总是要记住你代码的实际用法是什么，以及时间花在哪里，在哪儿努力减少算法复杂性。
- en: and whether it's worth it。 Now this is don't read this code。 It's a code doesn't
    matter。 This is a real example of code that got me started down this path。 This
    was from a project last summer。 The code on the left is shorter and has fewer
    data structures and fewer functions and in。 fact fewer loops， but it's slower
    than the code on the right。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以及是否值得。这段代码不重要。不要阅读这段代码。这是一个让我走上这条道路的真实代码示例。这是来自去年夏天的一个项目。左侧的代码更短，数据结构更少，函数更少，实际上循环更少，但它比右侧的代码慢。
- en: And the reason is that if we label things as o of n and o of 1， the code on
    the left has。 an o of n operation there because it's looking up a value in a list。
    The code on the right only has o of 1 operations。 So the code on the right。 even
    though it's longer and has more functions and more data， structures and more loops。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为如果我们将事物标记为O(n)和O(1)，左边的代码有一个O(n)操作，因为它在列表中查找一个值。右边的代码只有O(1)操作。因此，右边的代码虽然更长，包含更多的函数和数据结构以及更多的循环。
- en: is o of 1 where the one on the right is o of n。 And in fact。 I was using it
    to draw drawings like this。 These functions work over an entire list of points
    and if you go up a level in the code。 you'll see actually that that function is
    called once for each point in the list of points。 So the o of n on our slow side
    was turning into o of n squared。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的复杂度是O(1)，而右边的复杂度是O(n)。实际上，我是用它来绘制这样的图形。这些函数作用于整个点列表，如果你深入代码，就会发现这个函数实际上是对每个点调用一次。因此，我们的慢代码的O(n)变成了O(n²)。
- en: And so the slow code was taking 20 seconds。 The fast code was taking a half
    a second。 On only 2。000 points， right？ I've been giving examples like oh when
    n gets to a billion， n got to 2。000 here and made， a huge difference in my running
    time。 Because n squared is really worse than n。 At the end of 2，000， n squared
    is 4 million operations and o of n is 2，000 operations。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是慢代码需要20秒，快代码只需半秒。在仅仅2000个点的情况下，对吧？我一直在举例，比如当n达到十亿时，这里n只达到2000，却对我的运行时间产生了巨大的差异。因为O(n²)确实比O(n)要糟糕得多。在2000时，O(n²)是400万次操作，而O(n)只有2000次操作。
- en: And that's a big difference。 So it really does pay off sometimes to reduce the
    algorithm that complexity of your code。 to reduce the running time。 Now we've
    been talking about o of 1 and o of n and o of n squared。 There's more possibilities。
    So there's more possibilities of kinds of complexities you might encounter in
    the real。 world。 Of course there's o of n cubed and n fourth， right？
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个巨大的区别。因此，有时候确实值得降低算法的复杂度，以减少运行时间。现在我们一直在讨论O(1)、O(n)和O(n²)。还有更多的可能性。因此，在现实世界中你可能会遇到更多种类的复杂度。当然，还有O(n³)和O(n⁴)，对吧？
- en: If we called how many grandmothers once for every child for some reason， we'd
    have an。 n cubed operation。 If I use that point algorithm once again for every
    point。 I'd have gone back up on an n， level。 I'd add another coefficient to my
    n。 You can also have worse things like o of 2 to the n。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们出于某种原因对每个孩子调用一次“祖母”的数量，我们将有一个O(n³)操作。如果我再次对每个点使用那个点算法，我将会上升到O(n)的级别。我会为我的n增加另一个系数。你也可能会遇到更糟糕的情况，比如O(2^n)。
- en: If you have n Boolean choices and you try all the combinations of them， you've
    got 2 to， the n。 If you have n things and you try to try all permutations of those
    n things， you'll have。 n factorial。 So as bad as n squared is， there's sort of
    no upper limit to how horrible your code can。 get。 So think about how your loops
    are working， how much data you're working on， and keep an。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有n个布尔选择，并尝试所有组合，你将得到2的n次方。如果你有n个东西，并尝试所有这些n个东西的排列，你将得到n的阶乘。因此，尽管O(n²)已经很糟糕，但你的代码可能会更糟糕，几乎没有上限。因此，要考虑你的循环如何工作，处理的数据量，以及时刻关注复杂度在哪里变得非常非常大。
- en: eye on where those complexities are getting really， really big。 The other kinds
    of possibilities is there could be more dimensions。 So we've been talking about
    doing algorithmic analysis where we have one variable n。 But you could have others，
    right？ If I'm telling you that I've got a string search algorithm over some number
    of strings。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种可能性是可能有更多的维度。因此我们一直在讨论只有一个变量n的算法分析。但你也可以有其他变量，对吧？如果我告诉你我有一个针对一些字符串的字符串搜索算法。
- en: I might also have to consider the length of those strings。 Typically， they're
    fairly short。 but if you're doing bio-python or something， you have DNA。 samples
    that are billions of characters long， and then suddenly the lengths of the strings。
    matter too。 For example， when I was doing that point drawing code。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能还需要考虑那些字符串的长度。通常，它们相当短，但如果你在做生物计算或者其他相关工作时，可能会有长度达到数十亿字符的DNA样本，这时字符串的长度也变得很重要。例如，当我在做那个点绘制代码时。
- en: there was a line intersection algorithm， that I found whose stated complexity
    was n plus k times log of n。 where n is the number， of lines and k is the number
    of intersections among those lines。 And I don't know how to figure that out。 That's
    like a mathy thing that you can just read about。 I didn't have to figure out what
    that complexity was。 Now we saw this graph before。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个我发现的线交点算法，其声称的复杂度是 n 加 k 乘以 log n，其中 n 是线的数量，k 是这些线之间的交点数量。我不知道怎么计算出来。这就像是一个你可以阅读的数学问题。我并不需要弄清楚那种复杂度是什么。我们之前看过这个图表。
- en: Algorithmic complexity really matters as numbers get large。 But another place
    where you have to be careful not to over-apply the idea is when numbers。 are small。
    So let's zoom into that lower left-hand corner of the graph。 If we zoom in there。
    suddenly the lines don't look so clear-cut。 The green line is actually above the
    other lines for most of them。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数字变大，算法复杂性真的很重要。但还有另一个地方需要小心不要过度应用这个概念，那就是当数字很小时。所以让我们放大图表的左下角。如果我们在那里放大，突然间这些线看起来并不是那么清晰。绿色线实际上在大多数情况下高于其他线。
- en: And the n squared line， that red line， is actually below everything for a lot
    of the， time。 And the reason is that when numbers are small， all those coefficients
    and lower order components。 that we threw away， those mattered。 Right？ 3n plus
    1， when n is 1， that 1 at the end really matters。 And also， we haven't taken into
    account what the actual time of the steps is。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 而 n 平方那条红线，实际上在很大一部分时间里是低于其他所有线的。原因是当数字很小的时候，所有那些我们丢弃的系数和低阶分量都是重要的，对吧？当 n 为
    1 时，3n 加 1 的最后那个 1 确实很重要。而且，我们还没有考虑到每个步骤的实际时间。
- en: You might have an n squared operation where you are doing n squared times a
    millisecond。 And you might be comparing that with a constant time algorithm that
    always takes a minute。 Well。 n has to get pretty large before that constant time
    algorithm is worth it。 When n is a billion。 it's worth it。 But when n is 10， you
    should stick with the n squared algorithm。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有一个 n 平方的操作，执行 n 平方乘以毫秒。你可能会将其与一个始终需要一分钟的常数时间算法进行比较。好吧，n 必须变得相当大，那个常数时间算法才值得。当
    n 达到十亿时，它才值得。但当 n 为 10 时，你应该坚持使用 n 平方算法。
- en: So as Rob Pike once said， fancy algorithms are small and n is small and n is
    usually， small。 So don't go overboard with trying to fancy up your algorithmic
    complexity。 It doesn't matter when n is small and usually your n is small。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 Rob Pike 曾说过的，花哨的算法很小，而 n 通常也很小。所以不要过于追求让你的算法复杂化。当 n 很小的时候，这并没有关系，而你通常的 n
    也很小。
- en: '![](img/6cde5d5d991ebe38049e6e258c259295_11.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6cde5d5d991ebe38049e6e258c259295_11.png)'
- en: All right。 Some advanced topics。 There's a thing called amortization。 which
    is really a long term averaging over operation。 So when I say that appending to
    a list is o of 1， that doesn't mean that every single。 time you append to the
    list， it takes a small amount of time。 In fact。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，一些高级主题。有一种叫做摊销的东西，它实际上是对操作的长期平均。因此，当我说向列表追加是 o 的 1 时，这并不意味着每次向列表追加时都只需花费很少的时间。实际上。
- en: it usually takes a small amount of time。 But every once in a while。 the whole
    list has to be copied and moved someplace else。 which gets longer and longer as
    the list gets longer。 But it also gets less and less frequent as the list gets
    longer so that over the long run。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常只需花费很少的时间。但是偶尔，整个列表必须被复制并移动到其他地方。随着列表变长，这个过程会变得越来越长。但随着列表变长，这种情况的发生频率也会越来越低，因此从长远来看。
- en: the average is still o of 1。 So amortization is a fancy word meaning averaging
    and it means that individual operations can。 take different amount of times。 Algorithmic
    analysis is really about the long term trends over many。 many runs。 And we haven't
    talked about the worst case。 So earlier we talked about the typical case。 And
    some people think big o implies typical case or big o implies worst case。 No。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值仍然是 o 的 1。因此，摊销是一个 fancy 词，意为平均，这意味着单个操作可以花费不同的时间。算法分析实际上是关于许多次运行后的长期趋势。而我们还没有讨论最坏情况。早些时候我们谈到了典型情况。一些人认为大
    O 隐含典型情况或大 O 隐含最坏情况。并不是。
- en: You have to say whether you're talking about the complexity of the typical case
    or the worst， case。 Here's an example where I make a set of 50，000 numbers which
    differ by 47。 I'm kind of walking up the numbers by 47。 Adding that number into
    the set is an o of 1 operation。 So the whole building， the whole set is o of n
    and it took about 10 milliseconds。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须说明你是在讨论典型情况的复杂性还是最坏情况。这是一个例子，我创建了一个包含 50,000 个数字的集合，这些数字相差 47。我是在按 47 的步伐增加这些数字。将这个数字添加到集合中是一个
    O(1) 操作。因此，整个集合的构建是 O(n)，并且大约花了 10 毫秒。
- en: Here I'm building another set of integers exactly the same size， 50，000 numbers。
    But I happen to choose a step that I happen to know was going to make all the
    hashes exactly。 the same。 So all the numbers got exactly the same hash which turns
    into an o of n operation， which。 means making this set took 34 seconds， 3300 times
    longer。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我构建了另一个大小完全相同的整数集合，50,000 个数字。但我恰好选择了一个步长，我知道这个步长会导致所有哈希完全相同。所以所有数字都得到了完全相同的哈希，这变成了
    O(n) 操作，这意味着创建这个集合花费了 34 秒，慢了 3300 倍。
- en: Dicks also have this problem and people were using it to DDoS web servers which
    is why。 Python added hash randomization。 And it's a fascinating topic but it's
    an example where although Dicks are o of 1 in the typical。 case， occasionally
    you have to worry about the worst case。 And there's more math。 So if you dig into
    the math， basically mathematicians have taken every letter that either looks。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Dicks 也存在这个问题，人们利用它进行 DDoS 攻击网络服务器，这就是 Python 添加哈希随机化的原因。这是一个迷人的话题，但这是一个例子，尽管
    Dicks 在典型情况下是 O(1)，偶尔你还是需要担心最坏情况。而且还有更多数学。如果你深入研究数学，基本上数学家们已经对每个字母进行了处理，这些字母看起来。
- en: like an o or sounds like an o and given it a meaning。 And you don't need it。
    You don't need it at all。 And there might be mathematicians in the audience right
    now who are going to say。 you， know， you're not really even talking about big
    o。 Yeah， shut up。 I don't care。 We all。 this is what we mean by big o。 And those
    experts by the way。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 像 O 或听起来像 O 并赋予它意义。而你并不需要它。你根本不需要它。现在可能在场的数学家会说，你根本不是在谈论大 O。是的，闭嘴。我不在乎。我们所说的就是大
    O。顺便说一下，那些专家们。
- en: so I wrote a blog post when I was first starting to think， about this with the
    same title。 big o how code slows as data grows。 And a lot of people liked it but
    one guy wasn't so pleased。 He thought that not only had I gotten something wrong
    but the thing I'd gotten wrong was so。 important that the entire blog post was
    something that I should be ashamed of。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我在开始思考这个问题时写了一篇博客文章，标题也是一样的。大 O 如何随着数据增长而减慢代码。很多人喜欢这篇文章，但有一个人并不满意。他认为我不仅犯了错误，而且我所犯的错误是如此重要，以至于整篇博客文章应该让我感到羞愧。
- en: And I actually looked into it。 I gave him the benefit of the doubt。 I learned
    a little bit more about algorithmic analysis。 I concluded he was actually wrong。
    He remains convinced he is right。 The good news is I got another blog post out
    of it。 So。 if on your journey to explore these things you find people like this，
    just walk around。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我实际上对此进行了调查。我给了他一些怀疑的好处。我对算法分析了解得更多了。我的结论是他实际上是错的。他依然相信自己是对的。好消息是我从中写了一篇博客文章。所以，如果在探索这些事物的过程中你遇到这样的人，绕过他们，继续前行。
- en: them and keep going。 It doesn't matter。 I mean if you're into the math， go and
    do the math。 But if you're just trying to do software engineering， it doesn't
    matter。 All right。 so in conclusion， big o is useful。 It can help you understand
    how your code might perform when the data gets very large。 It doesn't have to
    be complicated。 It doesn't have to be mathy。 And you can do the thing。 Thanks。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这没关系。我的意思是，如果你对数学感兴趣，就去做数学。但如果你只是想做软件工程，那就没关系。好的，所以总结一下，大 O 是有用的。它可以帮助你理解当数据变得非常庞大时你的代码可能的表现。它不必复杂，也不必是数学的。你可以做到这一点。谢谢。
- en: '[Applause]， [Applause]， [Applause]， [Applause]， (applause)， [Applause]。'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]，[掌声]，[掌声]，[掌声]，（掌声），[掌声]。'
- en: '![](img/6cde5d5d991ebe38049e6e258c259295_13.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6cde5d5d991ebe38049e6e258c259295_13.png)'
