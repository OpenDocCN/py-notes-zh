- en: P10：Mario Corchero - Effortless Logging A deep dive into the logging module
    - PyCon - 哒哒哒儿尔 - BV1Ms411H7Hn
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P10：马里奥·戈尔基罗 - 无缝日志记录 深入探讨日志模块 - PyCon - 哒哒哒儿尔 - BV1Ms411H7Hn
- en: \>\> Hey， everyone。 Welcome to the talk on Evers Fertless Logging， a deep dive
    into the。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '>> 嘿，大家。欢迎来到关于无缝日志记录的讲座，深入探讨日志模块。'
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_1.png)'
- en: logging module。 The topic is very near and dear to my heart， so let's welcome
    Mario。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 日志模块。这个话题对我来说非常重要，所以让我们欢迎马里奥。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_3.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_3.png)'
- en: '[ Applause ]， \>\> Hello， everyone。 My name is Mario Gorchiro。 and I''m here
    today to speak about logging。 Well， that''s my guinea pig。 If you want to find
    me afterwards and speak about more logging。 or anything related to Python or traveling
    to Spain， if you''re planning some holidays。'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]，>> 大家好。我是马里奥·戈尔基罗，今天我在这里谈论日志。好吧，那是我的小白鼠。如果你想在之后找我聊更多关于日志的内容，或者任何与Python或计划去西班牙度假的事情。'
- en: I'll be around。 And also， I know that you saw this first slide and you thought，
    oh， my God。 this is one of those slides where maybe the topic is interesting，
    but it's all going。 to be about how happy Mario said Bloomberg that they are recruiting
    in London， New York。 San Francisco， many other places。 The company is great， great
    benefits， but I'm not going。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我会在这里。而且，我知道你看到这张幻灯片时会想，哦，天哪。这可能是那种主题很有趣，但全是关于马里奥说布隆伯格在伦敦、纽约、旧金山等许多地方招聘的幻灯片。公司很棒，福利很好，但我不打算去。
- en: to say anything about that。 So today the topic is we're going to see why logging
    is important。 how logging works， how can we use it， how to configure it。 We'll
    try to see some code。 and then some sample recipes。 I'm going to have to flash
    through the slides because。 I just rehearsed it and I don't have much time。 So
    first of all， it's why logging。 And I like。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 说些关于这个的话。因此今天的主题是我们要看看为什么日志很重要，日志是如何工作的，我们如何使用它，如何配置它。我们将尝试查看一些代码，然后一些示例配方。我将不得不快速浏览幻灯片，因为我刚刚排练过，没有太多时间。所以首先，为什么要日志。我喜欢。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_5.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_5.png)'
- en: to realize that today when you write code， you might be writing documentation
    because you。 realize the issue that when people read your code， that it's not
    you， have to understand。 what you wrote， but you also need to realize that when
    your code is running in production。 as a black box， people are going to see your
    code when you are away on holidays on Spain。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 意识到今天当你写代码时，你可能也在写文档，因为你意识到，当人们阅读你的代码时，理解的不是你写了什么，而是你也需要意识到，当你的代码在生产环境中以黑箱的形式运行时，人们会看到你的代码，而你可能正在西班牙度假。
- en: as we're going to discuss afterwards。 And you don't want them to call you because
    they。 are not able to figure out what's going on， right？ And logging and instrumentation
    is。 what it does for you。 It allows you to see what application is doing when
    it's running。 So I like to see that some kind of documentation for developers
    and CSAT means when things are。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们接下来要讨论的。你不想让他们打电话给你，因为他们无法弄清楚发生了什么，对吧？而日志记录和监控正是为你做这些的。它使你能够看到应用在运行时的表现。因此，我喜欢把这看作是开发人员的某种文档，CSAT意味着当事情发生时。
- en: on fire that they need to see。 Some first will likely go farther and say that
    if you use。 a debugger in development， you are doing it wrong because they say
    that if you are not。 able to reason about your program on your development environment，
    just with the logs。 how are you going to be able to do it in production？ I'm not
    one of those。 I can't still use the。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现问题时，他们需要查看。一些人可能会进一步说，如果你在开发中使用调试器，你就是在做错，因为他们认为如果你不能仅凭日志在开发环境中推理你的程序，那么你怎么能在生产环境中做到呢？我不是那种人。我仍然可以使用。
- en: debugger。 I can see the reasoning behind it。 I really try to instrument my application。
    in such a way that I deal with what I'm just running the test。 If I see the logs，
    I will。 be able to understand what's the issue behind it。 So you would say， yeah，
    but that's all。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器。我能理解这样做的理由。我确实努力对我的应用进行监控，以便在运行测试时处理问题。如果我看到日志，我就能理解背后的问题。因此你可能会说，是的，但这就是所有内容。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_7.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_7.png)'
- en: cool， but I'm old school。 I like print， right？ Print is a great tool。 I can
    just print whatever。 I want。 Print is not -- you want to use the right tool for
    the right job。 Logging has many。 features that you won't get out of print。 First
    of all， logging allows for multi-threading。 If you are printing things around
    multiple threads， everything is going to collide。 It's。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，但我属于老派。我喜欢打印，对吧？打印是一个很好的工具。我可以随意打印我想要的内容。打印并不是——你需要为每个工作使用合适的工具。日志记录有许多特性是打印无法提供的。首先，日志记录允许多线程。如果你在多个线程中打印内容，一切都会发生冲突。
- en: more flexible。 You can categorize your logs as we're going to see in a minute。
    For me。 the most beautiful thing is the design of logging。 It allows you to split
    the how from， the what。 What I mean is logging has this kind of collaborative
    approach that it allows you， to say。 what do you want to log without worrying
    about how is it going to be logged？ What do。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 更灵活。你可以像我们马上要看到的那样对你的日志进行分类。对我而言，最美妙的事情是日志记录的设计。它允许你将“如何”和“什么”分开。我想说的是，日志记录采用了一种协作方式，让你可以说你想记录什么，而不必担心它将如何被记录。你想要什么。
- en: I mean for this is if you are writing a library， you can instrument it with
    logs and the person。 that's going to use the library in application can worry
    about how those are going to be treated。 First of all， I've seen this picture
    on every good speaker's presentation。 I don't know if。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我的意思是，如果你在编写库，你可以用日志来记录它，而将要使用该库的应用程序可以担心这些日志如何被处理。首先，我在每个优秀演讲者的演示中都看到了这张图片。我不知道是否。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_9.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_9.png)'
- en: that happened to you。 I have to use it。 We're going to see how logging works。
    What are the。 different parts that it has and how everything blacks together。
    The first of all is the logger。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你来说发生过。我必须使用它。我们将看看日志记录如何工作。它有哪些不同的部分，以及所有内容是如何结合在一起的。首先是logger。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_11.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_11.png)'
- en: class。 The logger class is the main class that you interact with。 When you're
    writing a Python。 program， you take a logger， you call one of the methods that
    you have and pass a string。 template and the arguments to it。 This thing goes
    into the logger code and it appears whatever。 you want。 It's not really like that。
    The first thing that's going to happen is that the logger。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 类。Logger类是你互动的主要类。当你编写Python程序时，你会获取一个logger，调用你拥有的方法之一，并传递一个字符串模板及其参数。这个东西会进入logger代码，然后显示你想要的内容。实际上并不是这样的。首先发生的事情是logger。
- en: is going to create a log record that contains not only the template and the
    message that。 you have but also context about where this is being logged。 Once
    that's done， we know。 that that object cannot magically go to your console。 What's
    going to happen is that a。 handler -- sorry， this way。 A handler would take your
    log record and put it into a stream。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它将创建一个日志记录，不仅包含你的模板和消息，还包含关于日志记录位置的上下文。一旦完成，我们就知道那个对象不能神奇地出现在你的控制台上。发生的事情是一个处理程序——抱歉，就是这样。一个处理程序会获取你的日志记录并将其放入一个流中。
- en: like a CDL or a file or an email or whatever you want。 There are multiple handles
    in the。 standard library that can take your records and put it on whatever destination。
    If you haven't。 checked them out， I invite you to do it because there are some
    that are really， really cool。 Like for example， you can send ELOX via HTTP with
    an already pre-built handler that is。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 像CDL或文件或电子邮件或任何你想要的内容。在标准库中有多个处理程序可以获取你的记录并将其放到任何目标上。如果你还没有查看过这些处理程序，我邀请你去看看，因为有些确实非常酷。例如，你可以通过已经预构建的处理程序通过HTTP发送ELOX。
- en: in the standard library。 That's what we discussed。 Now we have the logger that
    takes this kind。 of message。 It goes into the code of the logger， then it creates
    a record and then it takes。 the record to the handler and it appears。 That's all
    good。 But you might be wondering。 that log record is an object。 So how is that
    object being transformed into a string when。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库中。这就是我们讨论的内容。现在我们有一个logger，它接受这种类型的消息。它进入logger的代码，然后创建一个记录，再将记录交给处理程序并显示。这一切都很好。但你可能会想，日志记录是一个对象。那么这个对象是如何在转换为字符串时被处理的呢？
- en: I'm logged into a console？ Even if you have this three handler that we spoke
    about with。 this file handler， all these kind of handlers that at the end just
    output strings， all that。 code needs to be shared somewhere。 That's what the formatter
    comes in。 Formatter will。 just take this log record and transform it into a string。
    We understand logging now， right？
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我登录到控制台了吗？即使你有我们之前讨论的三个处理程序，这个文件处理程序，以及所有这些最终只输出字符串的处理程序，所有的代码都需要在某个地方共享。这就是格式化程序的作用。格式化程序会将这个日志记录转换为字符串。我们现在理解日志记录了，对吧？
- en: So we have a logger which takes a string。 It goes through the logger code。 It
    meets a log， record。 but by sending it to the handler， and the handler is going
    to format the string。 Everyone understands logging now， right？ It's really simple。
    There's one more thing that。 we want to introduce。 So there's also filters。 They
    just allow you to filter logs on more。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们有一个记录器，它接受一个字符串。它经过记录器代码。它满足一个日志记录。但通过将其发送到处理程序，处理程序将格式化这个字符串。每个人现在都理解日志记录了，对吧？这真的很简单。还有一件事我们想介绍。还有过滤器。它们只是允许你对日志进行更多的过滤。
- en: like fine-tuned characteristics。 So it's basically a class where you can decide
    whether based。 on any character of the log record whether you want to let it pass
    or not。 Okay。 We have。 the whole stack now。 So a logger takes a string。 Well，
    at the template and the parameters go。 through the logger code。 Filters might
    allow it to pass or not。 We're going to emit it in。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 像是微调的特性。这基本上是一个类，你可以决定是否基于日志记录的任何特性让它通过。好的。我们现在有了整个堆栈。因此，记录器接受一个字符串。模板和参数通过记录器代码。过滤器可能会允许它通过或不通过。我们将把它发射出来。
- en: the handler。 The handler is going to format it。 There's also filters in the
    handler， and。 if all of that works， and now we're going to have our beautiful
    log printed into the console。 or whatever script we have。 Not that totally simple。
    We have also a logger hierarchy。 I know。 this is starting to get complicated，
    but we are going to go a little bit later on that， way。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序将格式化它。处理程序中还有过滤器，如果所有这些都有效，那么我们的漂亮日志将打印到控制台或我们拥有的任何脚本中。没那么简单。我们还有一个记录器层次结构。我知道，这开始变得复杂，但我们稍后会深入探讨。
- en: So now there's the logging hierarchy。 Whenever you create a logger， you have
    this。 function that will retrieve a logger with the string separated tokens that
    you pass on it。 So here。 and this will create a hierarchy for you。 So here basically
    what we are saying。 is we want to get the logger parent child， and that logger
    is a child of parent which at。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有日志记录层次结构。每当你创建一个记录器时，你都有这个函数，它会检索一个带有你传递的字符串分隔标记的记录器。所以这里，它会为你创建一个层次结构。所以这里基本上我们在说，我们想要获取父子记录器，而那个记录器是父记录器的子记录器，同时又是根记录器的子记录器，所有记录器都继承自它。
- en: the same time is a child of the root logger that all loggers inherit from。 You
    can see。 it kind of the， like the， you can see the root logger like object， okay，
    on Python 3。 But don't worry， you don't need to land MRO。 There's no multiple
    inheritance here。 Okay。 So this is complex， but now we get it。 So we said we have
    a logger， takes the template。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，根记录器就像一个对象，好的，在Python 3中。但别担心，你不需要了解MRO。这里没有多重继承。好的。这是复杂的，但我们现在明白了。所以我们说我们有一个记录器，接受模板。
- en: takes some parameter， then we have the filter， we are going to meet in a lot
    of law， we formatted。 but we're going to do the same thing again。 And now if the
    logger has this attribute called。 propagate set to true， which is the default，
    it's going to meet it to all the party handler。 And now this is really important。
    This is what confuses a lot of people when using logins， tag。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接受一些参数，然后我们有过滤器，我们将在很多法律中见面，我们进行了格式化。但我们将再次做同样的事情。现在，如果记录器有一个名为propagate的属性，默认为true，它将会传播到所有的父处理程序。这一点非常重要。这就是很多人在使用日志时感到困惑的地方。
- en: And it's that when you have parent loggers， parent loggers， the code that is
    shared is。 the call to the handlers。 Okay。 So what I mean is once the， once a
    logger is done processing， well。 when a， when a logger has called all the handler
    that it has， it's not going to。 call the parent logger， it's going to call the
    parent handlers。 So it's going to call。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有父日志记录器时，父日志记录器共享的代码是对处理程序的调用。好的。我想说的是，一旦记录器完成处理，当记录器调用它所拥有的所有处理程序时，它不会调用父日志记录器，而是调用父处理程序。所以它将进行调用。
- en: the handlers of his parent logger。 So the filter code， for example， won't be
    executed。 Okay。 This was complex。 We do now know how logging works， right？ Now，
    now， okay， some， more things。 So loggers also have a category and a navel and
    some of the attributes that。 will control some of the particularities of your
    logs and how they travel through the。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 他的父记录器的处理器。因此，过滤器代码，例如，将不会被执行。好吧。这很复杂。我们现在知道日志记录是如何工作的，对吧？好吧，还有一些事情。因此，记录器也有类别和级别，以及一些将控制日志的特性和它们如何在其中传递的属性。
- en: logging stack。 Basically， category on both logger and handler will allow you
    to set a threshold。 on both of them。 So for example， if a logger has a category
    of warning， it will only log， warning。 and above log records。 And now you might
    be wondering， like， what happens if。 the parent logger has a level of error only，
    but the child one has info？ So because as， we said。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 日志堆栈。基本上，记录器和处理器的类别将允许你为它们设定阈值。例如，如果记录器的类别为警告，它将只记录警告及以上级别的日志记录。现在你可能会想，如果父记录器只有错误级别，但子记录器有信息级别会发生什么？正如我们所说。
- en: only the， the parent handlers code is the one that is being executed on the，
    parent。 That won't be an issue。 But we'll， we'll， we'll see that in more details
    on， all of the。 on all of the slides。 I don't want to make， make， make some of
    the things。 Now with all that。 this is the actual， this is the actual diagram
    that you have in the， documentation of Python。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 只有父处理器的代码在父级上执行。这不会是个问题。但我们将在所有幻灯片上更详细地讨论这个。我不想做出一些事情。现在，有了这些，这就是你在Python文档中看到的实际图表。
- en: Actually， this whole talk came because the first time I saw this， slide， it
    was， I was like， yeah。 this is correct， but I have no idea how to， I mean， I know
    how， to read this， but it's super hard。 right？ If you have no context about how
    logging works， this is great。 then you can follow the diagram， but it's really
    hard to reason about logging。 Okay。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这整个演讲的起因是我第一次看到这个幻灯片时，我想，是的。这是正确的，但我不知道如何。我是说，我知道如何阅读这个，但这太难了，对吧？如果你对日志记录的工作原理没有背景，这很棒。然后你可以跟随图表，但关于日志记录的推理真的很难。好吧。
- en: So we have wind scene logging， let's see， let's see now how， how can we use
    those， those loggers？
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们有窗口场景日志记录，让我们看看，现在我们如何使用这些记录器？
- en: This is an example on how to use logging。 And you can see that we are， getting
    here a logger。 we are logging on the bug， and some interesting things are， for
    example， here we see， we see x info。 This is， if you are on stack， if you are
    in an exception scope。 this is going to log not only your message， but it's also
    going to log the exception。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于如何使用日志记录的示例。你可以看到，我们在这里获取了一个记录器。我们在记录错误，举个有趣的例子，这里我们看到了信息。如果你在堆栈中，如果你在异常范围内，这不仅会记录你的消息，还会记录异常。
- en: that you are being handling。 This is super useful。 At the same time， we spoke
    about the。 the levels that logger have， like the bug info warning error and critical，
    and exception。 is not a new level。 It's just error level with x， with x info to
    true。 If you want to， log this。 the stack information outside of an exception，
    you also have this new parameter。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在处理的。这非常有用。同时，我们谈到了记录器的级别，比如调试、信息、警告、错误和严重。异常不是一个新级别。它只是错误级别加上x，x信息为真。如果你想在异常之外记录堆栈信息，你还有这个新参数。
- en: called stacking for that you can use。 Okay。 So now， I'm going to， I'm going
    to show you。 some issues that I was doing at the beginning， where I was recently
    logging without reader。 documentation， and I'm only， I'm the only one that does
    this。 I'm not all of you read。 the documentation before using any library， right？
    But I didn't， and these are some things。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 叫做堆栈的，可以用来实现。好吧。现在，我要展示一些我刚开始时遇到的问题，那时我最近没有查看文档就进行日志记录，而我只是，我是唯一一个这样做的人。你们都没有在使用任何库之前阅读文档，对吧？但我没有，这些是一些事情。
- en: that I realized that I wanted to do different from the way I was using it。 So
    first of all， is。 well， disclaimer， this can start flame wars bigger than space
    versus tabs。 Okay。 But basically。 I used to do format on the message and just
    pass a string to the logger。 Ideally， what。 you want to do is this。 Some people
    will claim that this can， this can cause what's。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我意识到我想以不同于我使用它的方式来做。所以首先，这是。好吧，免责声明，这可能会引发比空格与制表符更大的争论。好吧。基本上，我以前在消息上做格式，然后将字符串传递给记录器。理想情况下，你想要做的是这个。有些人会声称这会导致什么。
- en: called a hasten bug， because if it depends on how you logging configuration
    is， is the。 only application you may see a narrow note at the time that you are，
    that you are like。 printing this message。 But being realistic， I think this is，
    this is， this is a much better。 way to pass a message。 And this is actually now
    an error on pilot， even if pilot is opinionated。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为“急促错误”，因为它取决于你的日志配置，只有在你打印此消息时，可能会看到一个狭窄的笔记。但说实话，我认为这是传递消息的更好方式。即使是在意见明确的情况下，这实际上现在是一个飞行员错误。
- en: that hey。 Next thing is this。 How many times have you seen this beautiful exception
    where。 it says a terrible error will happen？ Data。 And the problem is that what
    you want to do。 is this to see the whole exception， because if you do this and
    you get a key error， what。 you're going to get is the string representation of
    a key error。 And the string representation。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个事情是这个。你见过多少次这种漂亮的异常，它说会发生可怕的错误？数据。问题是你想要做的是查看整个异常，因为如果你这样做并且遇到键错误，你将得到一个键错误的字符串表示。字符串表示。
- en: of a key error is the key error that you're missing。 So if in your tribe log
    you are doing。 a lot of access to dictionaries， you're going to get a really meaningful
    data， right？ How。 beautiful is that？ So just use x info and you'll get the whole
    stack and line and the type。 of exception of what happened。 If you want to create
    your own logger hierarchy， you can， do it。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 键错误是你缺少的键错误。因此，如果在你的日志中你进行大量对字典的访问，你会得到非常有意义的数据，对吧？这多美好啊！所以只需使用 x info，你就能获得整个堆栈、行号和发生的异常类型。如果你想创建自己的记录器层次结构，你可以做到。
- en: And in some situation that's useful， but most of the time what you want to do
    is。 to link your log hierarchy with your folder naming。 This will make， for example，
    if you're。 working in library requests， but just doing that， all your logs in
    all your files that。 you have requests will have the parent log of requests。 So
    this is like super handy。 And。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这很有用，但大多数时候你想要做的是将你的日志层次结构与文件夹命名链接起来。这将使得，例如，如果你在处理库请求，那么只需这样做，你所有文件中的日志将拥有请求的父日志。所以这非常方便。
- en: you don't have to think about naming， which is the biggest issue in computer
    science。 So we know how to use it， but how do we configure this？ We spoke about
    this beautiful design。 on logging where you can write code that uses logging and
    then on a totally separate space。 you're going to configure how that works。 So
    we're going to see that。 And there are three。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必考虑命名，这在计算机科学中是最大的问题。我们知道如何使用它，但我们该如何配置它？我们谈到了日志记录的优美设计，在那里你可以编写使用日志记录的代码，然后在完全不同的空间中配置其工作方式。因此，我们将看到这一点。总共有三个。
- en: main ways to configure it。 You can configure it by writing code。 You can use
    an init file。 or you can configure it with a dictionary。 So first of all， you
    can plug everything together。 or you can use for really simple scripts and things
    like that。 You can use basic config。 It just has some kind of a list of same defaults
    for scripts and things like that。 It will。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 配置它的主要方法。有几种方式可以配置它：你可以通过编写代码进行配置，也可以使用初始化文件，或者通过字典进行配置。因此，首先，你可以将所有内容连接在一起，或者可以用于非常简单的脚本之类的东西。你可以使用基本配置。它只是有一些相同的默认值列表，适用于脚本等。
- en: just log to std error。 And it would， this is exactly the function that will
    be called。 if you start to use logging without having to configure it。 It has
    a lot of parameters。 so with basic config， you can， for example， start logging
    to a file instead of a std error。 And you can set the level， format， and many
    other things。 You can check documentation。 Then。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记录到标准错误。这正是如果你开始使用日志记录而不配置它时将调用的函数。它有很多参数，因此通过基本配置，你可以，例如，开始记录到文件而不是标准错误。你可以设置级别、格式和许多其他内容。你可以查看文档。
- en: this is probably the most interesting one， like configuring from a dictionary。
    When you。 configure for a dictionary， you're just going to list all the components
    that we explained， before。 So， for example， here we can see that we have plugins，
    logger and the root logger。 being configured to this one only to error level and
    this one to console level。 So you。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最有趣的一点，比如从字典配置。当你从字典配置时，你只需列出之前解释的所有组件。因此，例如，在这里我们可以看到我们有插件、记录器和根记录器，它们配置为只有错误级别和这个配置为控制台级别。
- en: can see the plugins logger doesn't have any handler， but that's not an issue
    because it's。 going to use the handler of the parents。 And oh， and if you wondered，
    yeah， you can also。 configure the logging with an in-file， but I don't like it，
    so I'm not going to present， it。 If you want to configure it from a file， you
    say， "YAML file，" and then use the dict， one。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到插件的日志记录器没有任何处理程序，但这不是问题，因为它将使用父级的处理程序。而且哦，如果你想知道，是的，你也可以通过一个文件来配置日志记录，但我不喜欢这样，所以我不会展示。如果你想通过文件进行配置，你可以说“YAML
    文件”，然后使用字典。
- en: which is much more powerful。 And now we're going to see how this code goes through
    the。 logging code of the Sunday library。 Something I really like about logging
    is that the code。 if you understand all the design decisions that are around logging，
    the code is really。 easy to follow。 So if you have an issue with logging or you
    don't understand nothing， you。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这更强大。而现在我们将看到这段代码如何通过星期日库的日志记录代码。我非常喜欢日志记录的一点是，如果你理解所有关于日志记录的设计决策，代码其实是非常容易理解的。所以如果你在日志记录上遇到问题，或者你完全不理解，你。
- en: can use it on this time something。 You can just literally open the code with
    many other Python。 modules and read and see what's going on。 Anyway， we are going
    to see what this line。 is going to be doing。 So first of all， is the blue okay？
    Can you read？ Okay。 So don't。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在这个时候使用它。你可以直接打开代码与许多其他 Python 模块并阅读，看看发生了什么。无论如何，我们将看到这行代码将会做什么。那么首先，蓝色可以吗？你能看见吗？好的，所以别担心。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_13.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_13.png)'
- en: worry， that's just a string。 So basically， this is the info method of a logger。
    And I。 think that's -- you can see the first thing that is doing is going to check
    if this logger。 is enabled for the category that we are trying to log， which is
    info。 If that's the case， then。 it's going to call this underscore log method，
    which we can see here。 It's huge。 Here you。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心，这只是一串字符串。所以基本上，这是日志记录器的 info 方法。我认为，首先，它会检查这个日志记录器是否启用于我们尝试记录的类别，也就是 info。如果是这样，它将调用这个下划线日志方法，我们在这里可以看到。这很庞大。这里你。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_15.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_15.png)'
- en: have a lot of code， so it looks like a more technical talk， right？ And here
    you can see。 that we are building this here in red， which is also not really great。
    We are building this。 log record that we spoke about。 And it doesn't have just
    the message and the arcs that is。 what we provided， but it has all kind of all
    the set of information that is collected around。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多代码，所以看起来像是更技术性的讨论，对吧？在这里你可以看到，我们在这里用红色构建这个，这也不是很好。我们正在构建我们讨论过的日志记录。它不仅仅包含消息和我们提供的参数，还有收集到的所有信息集。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_17.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_17.png)'
- en: the function that you are using。 Once that's done， we are going to call handle
    in the logger， yet。 okay？ And the things that handler is going to do is it's going
    to check if the， logger is enabled。 And if the logger is enabled and the filter
    is going to go through， then。 it's going to call the handlers， steal the code
    of the logger。 So here we're still in。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在使用的函数。一旦完成，我们将调用日志记录器中的处理程序，可以吗？处理程序将做的事情是检查日志记录器是否启用。如果日志记录器启用，并且过滤器也通过，那么它将调用处理程序，窃取日志记录器的代码。所以这里我们仍然在。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_19.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_19.png)'
- en: the call of the logger。 This is， I think it's like the main bulk of logging
    that you're interested。 on。 And what this is doing is， well， if I cannot read
    what's here， I don't know how， can you do it。 So what you can see here is that
    C is the current logger， and then it's。 going to go for each of the loggers， it's
    going to go through all the handlers that the logger。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录器的调用。我认为这就是你感兴趣的日志记录的主要部分。它所做的是，如果我无法阅读这里的内容，我不知道，你怎么能做到。你可以看到 C 是当前的日志记录器，然后它将遍历所有的日志记录器，遍历日志记录器的所有处理程序。
- en: has and check the level and then send the log to the handler。 Once it's done
    with all， the handlers。 you can see here that if propagate is set to true， if，
    so if propagate is set， to true。 it's going to take the parent logger and then
    call all the handlers above。 As you， can see。 this is what I was speaking about
    before that a logger doesn't call the parent， logger。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它会检查级别，然后将日志发送到处理器。一旦完成所有处理器。你可以在这里看到，如果propagate设置为true，那么，如果propagate设置为true，它将获取父记录器，然后调用所有上层的处理器。正如你所见。这就是我之前提到的记录器不会调用父记录器的原因。
- en: It just calls the handlers of all the parents。 That's really， that's for me，
    at least。 it was one of the most confusing things。 The other thing that a parent
    logger used for is。 that if a logger doesn't have a log level set， it's going
    to try to get the level from the。 parent and the rigoratively。 That's what the
    hierarchy is useful。 Now， once you're done， here。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是调用所有父级的处理器。这真的，对我来说，至少这是最令人困惑的事情之一。父记录器用于的另一件事是，如果记录器没有设置日志级别，它将尝试从父级获取级别，这就是层级结构的用处。现在，一旦你完成了，在这里。
- en: you're going to go to the code of the handler and here in the handler， you're
    basically。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你将进入处理器的代码，在这里的处理器中，你基本上。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_21.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_21.png)'
- en: you have this for multi-threading and then you're just going to call a meet
    on the handler。 and that's up to implementation of the handler。 So as we saw some
    handlers can log to files。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你为多线程做这个，然后你只需在处理器上调用一个meet。这取决于处理器的实现。所以正如我们看到的，一些处理器可以记录到文件中。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_23.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_23.png)'
- en: some handlers can log to console。 That's totally up to whatever you want to
    do on the， handler。 Okay。 So we saw， we saw loggers， we saw handlers， we saw for
    matters， we've seen。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一些处理器可以记录到控制台。这完全取决于你想在处理器上做什么。好的。所以我们看到，我们看到记录器，我们看到处理器，我们看到了一些事项。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_25.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_25.png)'
- en: a lot of things and this is really cool and if you want to use the standard
    things on the， login。 that's great。 But how do we go about sending logging？ It
    has a beautiful design。 and it's ready to be extended but it's always nice to
    have some kind of basic recipient on。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 很多事情，这真的很酷，如果你想在登录时使用标准的东西，那很好。但是我们怎么发送日志呢？它有一个优雅的设计，并且随时可以扩展，但有一些基本的接收器总是很好。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_27.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_27.png)'
- en: how to do it。 So that's what we're going to see now。 I'm going to run through
    them but。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如何做到这一点。这就是我们现在要看到的。我将逐个演示。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_29.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_29.png)'
- en: we're going to see some examples。 So this is， I know， I know 12 factor apps，
    I know you。 should log to STD out。 This works great in Heroku but for my home
    server that I have。 a lot of this configuration。 So here what I'm doing is I have
    a single file that is going。 to have all the logs of requests， because I'm sending
    requests around。 I have a debug log。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一些示例。所以我知道，我知道12因素应用程序，我知道你应该记录到STD out。这在Heroku上效果很好，但对于我家里的服务器，我有很多这种配置。所以在这里我做的是我有一个单一的文件，将包含所有请求的日志，因为我在发送请求。我有一个调试日志。
- en: file that just holds， that like expires on two hours。 So if there is any issue，
    I can。 go and check it。 I have an error log file that has all the errors from
    two months for， example。 And as you can see， you can just have many handlers from
    different purposes that。 can be used in different situations。 I'm going to predict
    the code on， I'm going to put the。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个只是保存两小时后过期的文件。所以如果有任何问题，我可以去检查它。我有一个错误日志文件，其中记录了两个月来的所有错误，例如。正如你所见，你可以有许多来自不同目的的处理器，可以在不同情况下使用。我将预测代码，我将把它放在。
- en: slides and everything on， on like on pikens on this schedule so you can take
    it after。 what you want。 Although some of the， some of the recipes are already
    in the cookbook and。 the other ones I'm actually trying to get them into the cookbook。
    Now this is a way to， log JSON。 not super interesting unless you want to do it。
    This is useful for， if you are。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 幻灯片和一切都在这个日程上，所以你可以在你想要的时候进行。虽然一些食谱已经在烹饪书中，而其他的我实际上在努力将它们放入烹饪书中。现在这是一种记录JSON的方法。除非你想这样做，否则并不是特别有趣。这对你来说很有用，如果你是。
- en: using some kind of a greater and this is， so let's say that you're writing an
    application。 in Flask on， on some kind of web server， you can， you can use filters，
    you can abuse of。 filters to add some kind of contextual information like a correlation
    ID。 And that will allow。 you to， if you are using Splunk for example， and there
    is an error， you can get that correlation。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用某种过滤器，假设你正在 Flask 上写一个应用程序，在某种网络服务器上，你可以利用过滤器，滥用过滤器来添加一些上下文信息，比如关联 ID。这将允许你，如果你使用
    Splunk 例如，并且出现错误，你可以获取到那个关联。
- en: ID and see all the logs that are related to that correlation ID。 From Python
    3。4 I think， you have。 if you are lucky to be doing Python 3。6， we hope， I hope
    you do。 You can use a。 new factory method in the login stack that also can do
    the same thing。 Money is much cleaner。 Although this is actually one of the way
    that is recommended but nowadays it's much better。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ID 并查看与该关联 ID 相关的所有日志。从 Python 3.4 开始，我认为，如果你有幸使用 Python 3.6，我们希望，我希望你能这样做。你可以在登录栈中使用一个新的工厂方法，它也能实现相同的功能。钱会变得干净得多。尽管这实际上是推荐的方式之一，但如今的效果要好得多。
- en: to the factory。 This is really cool。 So your application is really verbose and
    it has some。 info logs that are okay but you only want to see those info logs
    whenever there is an， error。 By just doing this kind of buffering handler， what
    you are doing is that you will。 see the info logs only one， like you will see
    for example， you can configure it to three。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到工厂。这真是太酷了。因此你的应用程序非常冗长，并且有一些信息日志还不错，但你只希望在出现错误时查看这些信息日志。通过做这种缓冲处理，你所做的是，你将只会看到信息日志，比如你可以配置成显示三条。
- en: you will see whenever an error happens， you will see the three， the three info
    logs that。 precedes him。 This is really useful for troubleshooting as you can
    imagine。 Okay。 So what happens。 one of the issues of logging is whenever you log
    something that's going to block and tell。 all that machinery that we saw is going
    to be done。 This means that if you are sending， an email。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每当发生错误时，你将看到三条在其之前的信息日志。这对于故障排除非常有用，正如你可以想象的那样。好的。那么发生了什么呢。日志的一个问题是，每当你记录某些内容时，这将会阻塞并告知所有我们看到的机制将要完成。这意味着如果你正在发送电子邮件。
- en: if you have an SMTP handler that will send you an email， that line is going。
    to block until the limit is done。 So you can also use a queue handler which basically
    allows。 you to queue your log to be handled in a different way， in a different
    place。 Now the concept。 of log record that we spoke about is key here because
    we built a log record before the code。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个 SMTP 处理程序会给你发送电子邮件，那么该行将会阻塞，直到限制完成。所以你也可以使用队列处理程序，这基本上允许你将日志排队，以不同的方式，在不同的地方处理。现在我们所谈论的日志记录概念是关键，因为我们在代码执行之前就构建了一个日志记录。
- en: of the handler has come through。 All the information about the log is captured
    at the time you。 create the log and not at the time that you emitted。 Sorry。 Oh，
    you have found this super， useful。 So if you are creating a CLI tool and you want
    as many Unix tools to log for example。 warning and above to STD error and info
    and below to STD out， you can use this small， this。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有日志信息在你创建日志时被捕获，而不是在你发出时。抱歉。哦，你发现这非常有用。所以如果你正在创建一个 CLI 工具，并希望尽可能多的 Unix 工具记录，例如，将警告及以上记录到
    STDERR，将信息及以下记录到 STDOUT，你可以使用这个小工具。
- en: simple filter to do that。 Because by default， there is no way to do it。 And
    this will allow。 you to do exactly that。 With that configuration， you can also
    use the config as we saw before。 This is not important。 We are going to jump it
    and anyone here knows what's Kahoot。 So。 get into Kahoot。edu because we are going
    to do a small questionnaire。 And if you went。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的过滤器来做到这一点。因为默认情况下，没有办法做到这一点。这将允许你正好做到这一点。通过该配置，你还可以使用之前看到的配置。这并不重要。我们将跳过这一点，有人在这里知道
    Kahoot 吗？所以，进入 Kahoot.edu，因为我们要进行一个小问卷。如果你来过的话。
- en: I will let you first stroke my guinea pig if you come to London and I will pay
    you a， year round。 How am I with time？ Oh， five minutes。 If you go to Kahoot。edu，
    I will give you a。 code and then you can play。 I will give you 20 seconds to join。
    Not a lot of time。 Oh， sorry。 I need to tell you the code。 The code is 2161911。
    216。 Oh， I can paste it here。 Right？ Oh， no。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来伦敦，我会让你先抚摸我的豚鼠，我会给你一年的报酬。我时间还剩多少？哦，五分钟。如果你去 Kahoot.edu，我会给你一个代码，然后你可以玩。我会给你
    20 秒的时间加入。时间不多。哦，抱歉，我需要告诉你代码。代码是 2161911。216。哦，我可以在这里粘贴吗？对吗？哦，不。
- en: I don't。 There you are。 2161911。 Did anyone log in？ Oh， yeah。 Wow。 100 pliers。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道。你在这儿。2161911。有人登录吗？哦，耶。哇。100个钳子。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_31.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_31.png)'
- en: Okay， let's start。 So these are some questions。 Really important question I
    would like to see。 if you know them。 Wow， 150。 Are there that many people here？
    Okay。 The walls are coming closer。 So wait。 No， no， no， no。 It started。 Sorry。
    Oh。 How do I stop this thing？ Okay。 Here。 No。 No。 Okay。 Oh。 There you are。 Change
    screen。 Yeah。 There you are。 So what of the following。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们开始吧。这些是一些问题。我想看看一些非常重要的问题。如果你知道它们。哇，150。这里有那么多人吗？好的。墙壁越来越近了。等一下。不，不，不，不。开始了。抱歉。哦。我要怎么停止这个东西？好的。这里。不是。没有。好的。哦。你在这儿。换屏幕。是的。你在这儿。那么以下哪一个。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_33.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_33.png)'
- en: is the finding the logging module？ Sorry。 That was really great。 It was filter。
    Next one's。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 找到日志模块吗？抱歉。那真的很好。它是过滤器。下一个是。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_35.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_35.png)'
- en: going to be better。 Okay。 So PPP is the only person that managed to do that。
    So what is。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 会更好。好的。所以PPP是唯一一个成功做到这一点的人。那么是什么呢？
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_37.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_37.png)'
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_38.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_38.png)'
- en: the default output of basic config？ The SDDR， SDDR makes or a file in temp there。
    Wow。 People。 are participating。 I think this was going to be a disaster。 Great。
    Is SDDR。 That's a。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 基本配置的默认输出是什么？SDDR，SDDR生成或在临时文件中。哇。人们。正在参与。我认为这将是一场灾难。太好了。SDDR。那是一个。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_40.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_40.png)'
- en: catch up。 That's why I put that question。 Okay。 What happens if we call basic
    config。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 追赶。这就是我提出那个问题的原因。好的。如果我们调用基本配置会发生什么。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_42.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_42.png)'
- en: twice， right？ Because it's going to configure your whole stack twice。 Is it
    going to only。 the first one's going to work？ Only the second one？ What's going
    to happen？ If there's a free。 beer here， stick it seriously。 So only the first
    one will take effect。 And actually if。 you log something， so if you just log a
    log record and then you call basic config， the， second call。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 两次，对吗？因为它将配置你的整个堆栈两次。只有第一次会生效吗？只有第二次？会发生什么？如果这里有免费啤酒，请认真对待。所以只有第一次会生效。实际上，如果你记录了某些东西，那么如果你只记录一个日志记录，然后调用基本配置，第二个调用。
- en: like the call that you do will be the second call and that won't work。 That's。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你做的调用将是第二个调用，这样是行不通的。那样。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_44.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_44.png)'
- en: quite a catch up。 Okay。 Which one of this is not a value format for templates？
    So basically。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 相当值得追赶。好的。这些中哪一个不是模板的值格式？所以基本上。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_46.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_46.png)'
- en: when you create a format or you pass a template for it， so which one of this
    is not valid？
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个格式或传递一个模板时，哪个是不有效的？
- en: This is for， this is if you have worked with login before。 Otherwise， you know，
    choose random。 Okay。 I mean， I cannot pay that many beers， right？ Who's the original
    developer of login？
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是针对，如果你之前使用过登录。否则，你知道，随便选择。好的。我的意思是，我不能请那么多啤酒，对吧？谁是登录的原始开发者？
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_48.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_48.png)'
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_49.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_49.png)'
- en: Gito， Victor and Nelson， maybe synonymous。 But who committed it？ Come on。 Great。
    Oh， who's。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Gito，Victor和Nelson，可能是同义词。但谁提交的？来吧。太好了。哦，谁是。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_51.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_51.png)'
- en: James B？ So what year was it brought to you？ It was long ago。 For those that
    do Java as。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: James B？那么它是什么时候引入的？很久以前了。对于那些做Java的人来说。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_53.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_53.png)'
- en: well， or respect， the login model was important。 Well， it's like the design
    of the login model。 is actually brought from log4j。 And yeah， it was 2002。 And
    I think this is now the most。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，或者说，登录模型是重要的。嗯，它就像登录模型的设计。实际上是从log4j引入的。对，是2002年。我认为现在这是最重要的。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_55.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_55.png)'
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_56.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_56.png)'
- en: important question of the whole survey。 Okay。 Take it seriously。 What is the
    name of this， region？
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 整个调查中重要的问题。好的，认真对待。这是什么名字，区域？
- en: I'm from here。 Catalonian Madrid， Exzler Maduda， or France？ Yes， Exzler Maduda。
    If you。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我来自这里。加泰罗尼亚的马德里，Exzler Maduda，或者法国？是的，Exzler Maduda。如果你。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_58.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_58.png)'
- en: want to go for the reason that I have really good advice。 So James B。 One。 Where
    is James。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 想去的原因是我有很好的建议。所以詹姆斯·B。一个。詹姆斯在哪里。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_60.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_60.png)'
- en: B？ James B？ Whoo。 Okay。 So with that， I'll give you some links。 This is an article
    about。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: B？詹姆斯·B？哇。好的。所以就这样，我给你一些链接。这是一篇关于的文章。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_62.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_62.png)'
- en: login， the how to and the cookbook。 Those are really useful。 And just go on，
    read the code。 The code of the login model is really easy to read。 And it's really
    well designed， even。 if it's old。 The design around it is really good。 So with
    that， I'll leave you。 Oh， no。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 登录，如何操作和手册。这些都非常有用。继续吧，阅读代码。登录模型的代码真的很容易阅读。即使它很旧，设计也非常好。所以就这样，我留给你。哦，不。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_64.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_64.png)'
- en: it doesn't work。 One second， one second。 This is really important， as well。
    There you are。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这不行。等一下，等一下。这也很重要。你看。
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_66.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_66.png)'
- en: So now we have time for questions， right？ That's my guinea pig。 It's the need
    of my scene。 Okay。 For the questions， there's a mic up front if anybody has any。
    Hey， I have a question。 So say I'm developing a library and I want to use logging，
    right？ But I don't want to。 presume what my users might configure， how my users
    might configure the logging module。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有时间提问，对吗？那是我的小白鼠。这是我场景中的需求。好的。提问的话，前面有个麦克风，如果有人有任何问题。嘿，我有个问题。假设我正在开发一个库，我想使用日志记录，对吧？但我不想假设我的用户可能如何配置日志模块。
- en: How should I go about doing that？ Do I just call the module， get the logger
    for the module。 name and then log to that and leave it on them？ Or what do I do？
    Yeah。 So my advice would be that you log as you think that it's useful for your
    users。 in the sense of you want to log the information that will help them travel
    to the issues。 And。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我该怎么做？我是否只需调用模块，获取模块的日志记录器名称，然后记录到那里，由他们来处理？还是我该怎么做？是的。所以我的建议是，你记录你认为对用户有用的信息。也就是说，你想记录可以帮助他们解决问题的信息。
- en: something really important that I see a lot is don't log errors on your library。
    If there。 is an error in your library and you're going to throw an exception，
    don't log it as well。 Because it can happen that your client might want to just
    capture the exception and ignore， it。 And if you are logging an error， then you
    are forcing them to put a higher threshold。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到很多很重要的事情是，不要在你的库中记录错误。如果你的库中出现错误并且你要抛出异常，不要同时记录它。因为可能会发生你的客户端只想捕获异常并忽略它。如果你在记录错误，那么你就强迫他们设定一个更高的阈值。
- en: on your library。 That makes sense？ Hello。 I have a question about multiple inheritance。
    You mentioned at the beginning that there， is no such thing and it actually disappoints
    a little。 So is there any way to implement， multiple inheritance in case I have
    some specific logger but I use it in different models and。 I want to have the
    same config， the same logger？ Yes。 So the only thing you can do。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的库中。这有道理吗？你好。我有一个关于多重继承的问题。你在开始时提到过，没有这种东西，实际上有点让我失望。那么有没有办法实现多重继承，如果我有一些特定的日志记录器，但我在不同的模型中使用它，并且想要相同的配置，同样的日志记录器？是的。所以你能做的唯一事情是。
- en: so the only thing that's shared across logger by inheritance， is as we said。
    the level that's going to take by default if no one is set and the handler， that
    it had。 So usually what you would see is that multiple loggers， I've seen situations，
    like that。 you'll see that multiple loggers will just have the same list of handlers。
    And， because the code of。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所以通过继承，logger 之间唯一共享的内容是我们所说的。如果没有设置的话，它默认会采用的级别和它拥有的处理器。所以通常你会看到多个日志记录器，我见过这样的情况。你会发现多个日志记录器会有相同的处理器列表。而且，因为代码的原因。
- en: you know， the configuration code is actually in the handler， it's just， fine
    to list them as a list。 I don't know if I explain it too well。 Yeah。 I think I
    understood。 Thank you。 One last question。 After that， like， here， Mario will be
    outside。 Yeah。 Okay。 It was a great talk。 Do you have any suggestions how to do
    logging in multiple， processing with multiple processes？
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，配置代码实际上在处理程序中，只是，把它们列成一个列表是可以的。我不知道我解释得是否清楚。是的。我想我明白了。谢谢。最后一个问题。在这之后，马里奥将在外面。是的。好的。这是一次很棒的演讲。你有什么建议如何在多个进程中进行日志记录吗？
- en: There are some particular issues there。 Yeah。 So that's actually quite tricky。
    So the problem when you have， like， if you fork， if you have multiple processes。
    the problem is that you cannot have multiple processes。 log in into the same file
    because everything will get messed up。 So the useful suggestion。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 那里确实有一些特定的问题。是的。这实际上相当棘手。所以当你分叉时，如果有多个进程，问题是你不能让多个进程同时写入同一个文件，因为一切都会搞得一团糟。所以这个建议很有用。
- en: there is to use a queue handler as we saw before and then have a single process
    doing。 all the logging。 So basically you'll have， you know， when you fork and
    everything， that。 queue will have the two ends and then you just in queue all
    the logs and a single process。 will do all the processing and there won't be any
    issue。 Thank you。 We're done for the session。
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个方法是使用队列处理程序，就像我们之前看到的那样，然后让一个进程来处理所有的日志。所以基本上，你知道，当你分叉一切时，那队列会有两个端点，然后你只需将所有日志放入队列中，一个进程会完成所有处理，不会有任何问题。谢谢你。我们这一环节结束了。
- en: The Mario will be outside。 Thank you for all。 Thanks Mario for your questions。
    [APPLAUSE]。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 马里奥将在外面。谢谢大家。感谢马里奥提出的问题。[鼓掌]
- en: '![](img/8e833d21fd81c1421b1c4f15a832d831_68.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e833d21fd81c1421b1c4f15a832d831_68.png)'
