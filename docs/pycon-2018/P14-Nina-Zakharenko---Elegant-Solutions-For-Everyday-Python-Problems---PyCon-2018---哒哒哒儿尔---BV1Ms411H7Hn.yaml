- en: P14：Nina Zakharenko - Elegant Solutions For Everyday Python Problems - PyCon
    2018 - 哒哒哒儿尔 - BV1Ms411H7Hn
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P14：妮娜·扎哈连科 - 日常Python问题的优雅解决方案 - PyCon 2018 - 哒哒哒儿尔 - BV1Ms411H7Hn
- en: All right， everyone。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，大家。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_1.png)'
- en: Let's give a warm pike on。 Welcome to Nina Jacques-Arranco。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们热烈欢迎妮娜·雅克斯-阿兰科。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_3.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_3.png)'
- en: '[applause]， Hi， everyone。 I''m Nina。 I''ve been writing code professionally
    for well over a day。 I''ve worked for some pretty cool companies like Meetup，
    HBO， Reddit。 But these days I work at Microsoft as a cloud developer advocate。
    And up on the screen there is our mascot， Bit， the cute little raccoon。'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]，大家好。我是妮娜。我已经专业编写代码超过一天。我曾在一些很酷的公司工作，比如Meetup、HBO、Reddit。但这些天我在微软担任云开发者倡导者。屏幕上的是我们的吉祥物，比特，这只可爱的小浣熊。'
- en: So if you think he's cute too， come find me after the talk for a sticker or
    a pin。 And I'm here to talk to you today about elegant solutions for your everyday
    Python problems。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你也觉得他可爱，演讲结束后来找我要贴纸或徽章。我今天来这里是为了和大家讨论日常Python问题的优雅解决方案。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_5.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_5.png)'
- en: The slides for this talk are hosted at bit。ly/elegant-python-2018。 So if you
    want to follow along。 go ahead and check out the slides。 The slides contain lots
    of links to useful information like additional documentation。 And this is an intermediate
    level talk where I'm going to be giving a whirlwind tour of。 some of my favorite
    Python language features。 So if you don't absorb everything right at this very
    minute。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这次演讲的幻灯片托管在bit.ly/elegant-python-2018。所以如果你想跟着一起看，可以去查看幻灯片。幻灯片中包含了许多指向有用信息的链接，比如额外的文档。这是一个中级水平的演讲，我将快速浏览一些我最喜欢的Python语言特性。如果你在此刻无法吸收所有内容，也没关系。
- en: don't be afraid。 Feel free to revisit the material if you need it。 It might
    be useful to you if you're coming to Python from another language。 Or if you wanted
    to learn about some cool Python features like magic methods， iterators， decorators。
    and context managers。 I'm also going to highlight some useful packages that can
    take that default Python behavior。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕。如有需要，请随时重新查看材料。如果你是从另一种语言转到Python，这可能对你有用。或者如果你想了解一些酷炫的Python特性，比如魔法方法、迭代器、装饰器和上下文管理器。我还会突出一些有用的包，能够改变默认的Python行为。
- en: up to the next level。 And please be aware that this talk targets Python 3。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到下一个层次。请注意，这次演讲的目标是Python 3。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_7.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_7.png)'
- en: Now what is elegant code？ It really kind of depends on the problems that we're
    trying to solve。 I started out my career working as an enterprise Java developer。
    And I worked with some of the popular libraries and language features at the time。
    But all of it always felt bolted on。 It never felt elegant。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么什么是优雅的代码呢？这实际上取决于我们想要解决的问题。我刚开始职业生涯时是一名企业Java开发者，曾使用当时一些流行的库和语言特性。但所有这些始终感觉像是附加上去的，从未感到优雅。
- en: I think I still have nightmares about abstract， singleton， proxy， factory beans。
    Knowing laughs from the Java developers in the room。 So when I discovered Python。
    it really felt like a brush of fresh air。 Breath of fresh air。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我仍然会对抽象、单例、代理、工厂bean有噩梦。在场的Java开发者发出会心的笑声。所以当我发现Python时，真的感觉像是清新的空气。清新的空气。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_9.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_9.png)'
- en: It has some innovative features that don't feel bolted on to the language。 Well
    how do we go ahead and pick those right tools for the job？
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一些创新的特性，感觉不是强行加入语言中的。那么我们该如何选择合适的工具呢？
- en: We've all kind of read the Zen of Python。 If you haven't。 go ahead and open
    up an interpreter and type in import this。 And the Zen of Python is a little poem
    that kind of indicates the best way of writing， Python code。 And it kind of starts
    off with beautiful is better than ugly， simple is better than complex。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都读过《Python之禅》。如果你还没有，请打开解释器并输入import this。《Python之禅》是一首小诗，指明了编写Python代码的最佳方式。它的开头是“美胜于丑，简单胜于复杂”。
- en: Explicit is better than implicit and complex is better than complicated。 Those
    are great ideas。 How can we accomplish that in our own code？ Well I'm here today
    to share with you some practical code that you can take and use to。 make your
    code simpler more elegant and more explicit today。 But you have to remember that
    beauty is in the eye of the beholder。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 显式优于隐式，复杂优于复杂化。这些都是很好的观点。我们如何在自己的代码中实现这一点？今天我在这里与您分享一些实用的代码，您可以用它来让您的代码更简单、更优雅、更明确。但您必须记住，优雅在于观察者的眼中。
- en: So what's beautiful and elegant for me may not be elegant for you。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所以对我来说美丽和优雅的东西可能对你来说并不优雅。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_11.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_11.png)'
- en: Let's dive into magic methods。 A little bit of terminology to discuss here before
    we dive in。 Magic methods usually start and end with a double underscore。 And
    you might hear me and others refer to that as "dunder。"。 So if you are wondering
    what that has meant throughout the conference， that's your little。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解魔法方法。在深入之前，我们先讨论一点术语。魔法方法通常以双下划线开始和结束。您可能会听到我和其他人称之为“dunder”。所以如果您在会议期间一直在想这是什么意思，这就是您的小提示。
- en: bit of terminology。 And magic methods， by implementing them。 you can really
    kind of make your objects behave， like different built-ins。 Things like numbers。
    like lists， like dictionaries and lots more。 You're used to implementing magic
    methods like "dunder stir。" "dunder repper，" but there's， a whole world of other
    ones that you can implement。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一点术语。通过实现魔法方法，您可以真正使您的对象表现得像不同的内置对象。比如数字、列表、字典等等。您习惯于实现像“dunder stir”、“dunder
    repper”这样的魔法方法，但还有一个您可以实现的魔法方法的世界。
- en: Here I have a money class。 It's kind of a straightforward currency class。 And
    I'm going to use it as an example to show you how instances of this money class
    can。 be acted on like numbers。 This money class knows about a conversion rate
    for a particular currency。 It's based on the dollar。 So here $1 represents 88
    cents of a euro。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我有一个货币类。它是一种简单明了的货币类。我将用它作为示例来展示如何将这个货币类的实例当作数字进行操作。这个货币类知道某种特定货币的汇率。它是基于美元的。因此这里的$1代表88美分的欧元。
- en: And we have a constructor that accepts a symbol and an amount。 This class also
    implements dunder stir so it knows how to represent the currency when。 we try
    to print it out。 Lastly， it knows how to convert from one currency to another
    using this convert method。 excuse， me。 Kind of basic stuff。 If we want to represent
    the cost of two different meals and different currencies。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个接受符号和金额的构造函数。这个类还实现了dunder stir，因此当我们尝试打印它时，它知道如何表示货币。最后，它知道如何使用这个转换方法在不同货币之间进行转换。抱歉，有点基础的内容。如果我们想表示两种不同餐食的成本和不同货币。
- en: here we have， the cost of our soda in dollars。 When we print it out， it looks
    all nice。 It has our symbol。 We represent the cost of a pizza in euro。 And because
    we implemented that dunder stir method， we can see that nice print out。 Now let's
    implement one more magic method。 We're going to implement dunder add。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们汽水的美元成本。当我们打印出来时，它看起来非常好。它有我们的符号。我们以欧元表示比萨的成本。由于我们实现了那个dunder stir方法，我们可以看到很好的输出。现在让我们再实现一个魔法方法。我们将实现dunder
    add。
- en: And add stands for addition。 So if we wanted to， we could also support subtraction，
    multiplication。 and a slew of other mathematical， operations。 Now let's see why
    this is so powerful。 This allows us to use the class in a really intuitive way。
    It's currency。 You expect to be able to add it together or perform other operations
    on it。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 而add代表加法。所以如果我们愿意，也可以支持减法、乘法和一系列其他数学操作。现在让我们看看为什么这如此强大。这使得我们可以以非常直观的方式使用这个类。这是货币。你期望能够将其相加或进行其他操作。
- en: So now I can print out the cost of my soda that's in dollars added to the cost
    of my pizza。 that's in euros。 It's pretty cool stuff。 If the second object is
    in a different currency。 it just does that conversion under the hood。 We don't
    have to worry about it。 In the previous example， we saw that add maps to the plus
    symbol。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以打印出我的汽水成本，美元与我的比萨成本，欧元相加。这些东西都很酷。如果第二个对象是不同的货币，它会在后台进行转换。我们不必担心。在前面的例子中，我们看到add映射到加号符号。
- en: Other magic methods can map to other things。 For example。 the dunder get item
    magic method maps to brackets， square brackets in this， case。 you can use those
    to access items by index in a list or an dictionary by key。 Some magic methods
    also map to built-in functions。 So in this example here， I have a class。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 其他魔法方法可以映射到其他内容。例如，dunder get item 魔法方法映射到方括号，在这种情况下，你可以使用它们通过索引访问列表中的项目或通过键访问字典中的项目。一些魔法方法还映射到内置函数。因此在这个例子中，我有一个类。
- en: It's a square shape。 And when I call the built-in method， Len， on this class。
    I want to know how many sides， does my shape have。 So in this case， my shape has
    four sides。 We'll see how this comes into play a little bit later in the talk。
    Let's chat about custom iterators。 The terminology can be really confusing at
    first。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个方形。当我在这个类上调用内置方法 Len 时，我想知道我的形状有多少条边。因此在这种情况下，我的形状有四条边。稍后我们将看到这在谈话中的作用。让我们聊聊自定义迭代器。术语一开始可能会让人感到困惑。
- en: but if you remember this small handful， of guidelines for making classes iterable。
    it'll be a breeze。 In order to make a class iterable。 a class needs to implement
    the magic method dunder， iter。 Dunder iter has to return an iterate tour。 And
    in order to be an iterate tour， a class needs to implement dunder next。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你记住这几条关于使类可迭代的指导方针，它就会变得简单。为了使一个类可迭代，类需要实现魔法方法 dunder iter。Dunder iter 必须返回一个迭代器。为了成为一个迭代器，类需要实现
    dunder next。
- en: And there's a specification for our implementation of dunder next。 It must raise
    the exception stop iteration when there are no more items to return。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们实现的 dunder next，有一个规范。当没有更多项目返回时，它必须引发异常 stop iteration。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_13.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_13.png)'
- en: Here's a scenario。 Let's say that we have a server instance running services
    on different ports。 Some of these services are active and some of them are inactive。
    And we want to be able to loop over our server instance。 But when we do that。
    we only want to make sure that we loop over the active services。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个场景。假设我们有一个服务器实例在不同的端口上运行服务。其中一些服务是活跃的，而一些则是非活跃的。我们希望能够循环遍历我们的服务器实例。但当我们这样做时，我们只想确保循环遍历活跃的服务。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_15.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_15.png)'
- en: Here's an example class。 We have defined a few services。 We have FTP running
    on port 21。 SSH on port 22， HTTP on port 80。 Some of these services are active。
    In my example here。 FTP is an inactive service。 So to make this server iterable，
    in our constructor。 we're going to initialize to the current position。 And as
    we're looping。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例类。我们定义了一些服务。我们在 21 端口上运行 FTP，在 22 端口上运行 SSH，在 80 端口上运行 HTTP。其中一些服务是活跃的。在我的示例中，FTP
    是一个非活跃服务。因此，为了使这个服务器可迭代，在我们的构造函数中，我们将初始化为当前的位置。当我们循环时。
- en: we're going to call this dunder next method under the hood。 And we just kind
    of keep going through our list of services。 If it's active， we return it。 If not。
    we skip it。 If we maintain our state so we know what position we're at in our
    list of services。 When we're all done and there's no more services， we raise that
    stop iteration exception。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在幕后调用这个 dunder next 方法。我们继续通过服务列表。如果是活跃的，我们返回它。如果不是，我们跳过。如果我们维护我们的状态，我们就知道在服务列表中的位置。当所有服务完成且没有更多服务时，我们引发
    stop iteration 异常。
- en: Notice that this is an iterator because it implements dunder iter。 And we can
    return self in this case because this class is also implemented a dunder next。
    Remember that dunder iter is actually called when we first start iterating before
    we ever。 call next for the first time。 So if we're looping over this iterable
    server in a for loop or in a comprehension。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这是一个迭代器，因为它实现了 dunder iter。在这种情况下，我们可以返回 self，因为这个类也实现了 dunder next。请记住，dunder
    iter 实际上是在我们第一次开始迭代时被调用的，而在我们第一次调用 next 之前。所以如果我们在 for 循环或推导中循环遍历这个可迭代的服务器。
- en: that initialization， happens under the hood。 If we need to。 we can also get
    the iterator by hand using the iter built in。 Now we can do something like this。
    We can just loop over the protocol and the port in our iterable server and print
    it out。 That loop server， all our active services。 Pretty cool。 But if you。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 该初始化是在幕后发生的。如果需要，我们还可以手动使用内置的 iter 获取迭代器。现在我们可以这样做。我们可以直接循环遍历我们可迭代的服务器中的协议和端口并将其打印出来。这个循环服务器是我们所有活跃的服务。非常酷。但如果你。
- en: if your iterator doesn't need to maintain a lot of state， like in our example。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的迭代器不需要维护大量状态，就像在我们的例子中那样。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_17.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_17.png)'
- en: below， which I would say is probably most of the time， use a generator instead。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我会说大多数时候使用生成器更好。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_19.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_19.png)'
- en: Here we have a new implementation of our dunder iter method。 And notice that
    we're not explicitly maintaining a position。 That's because our generator。 which
    is also an iterator， doesn't know where it was in， the past。 It only knows how
    to continue onward into the future。 So we're just looping over our services。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有一个新的双下划线迭代器方法的实现。请注意，我们并没有显式地维护一个位置。这是因为我们的生成器，作为一个迭代器，并不知道它在过去的位置。它只知道如何继续向未来前进。因此，我们只是循环遍历我们的服务。
- en: We're checking to see if that service is active or not。 And then we do something
    special。 We're going to yield the name， the protocol of that service and the port。
    What exactly is yield？
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在检查那个服务是否活跃。然后我们做一些特别的事情。我们将yield该服务的名称、协议和端口。yield究竟是什么？
- en: Well， a yield is like a return sort of。 We'll cover it in more detail later。
    But what you need to know for now is that after we yield， we still maintain some
    implicit， state。 And when we come back after a yield， we just end up continuing
    where we left off。 That means we don't have to maintain a lot of state like our
    current position because。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，yield就像一种返回。我们稍后会更详细地讨论。但现在你需要知道的是，在yield之后，我们仍然保持某种隐式状态。当我们在yield之后回来时，我们就会继续我们停下的地方。这意味着我们不需要维护很多状态，比如我们的当前位置。
- en: it's done for us implicitly。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是隐式为我们完成的。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_21.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_21.png)'
- en: Quickly， let's go over why this works。 Technically。 when you use a single parentheses
    to create a generator comprehension， the proper。 name for that is generator expression。
    But I like generator comprehension much better。 It makes a lot more sense to me。
    So I'm creating a very， very， very simple generator。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回顾一下为什么这能工作。从技术上讲，当你使用单个括号创建生成器表达式时，适当的名称是生成器表达式。但我更喜欢生成器理解，这对我来说更有意义。所以我正在创建一个非常非常简单的生成器。
- en: I'm just getting a number in a range of one。 And if I check out the variable
    that I've created。 my gen， I'll see that it's a generator。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是在一个范围内获取一个数字。如果我检查我创建的变量my gen，我会发现它是一个生成器。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_23.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_23.png)'
- en: expression。 Now remember that an iterator must implement dundernext。 If I call
    the next built-in。 which maps dundernext under the hood on my generator， I get
    my one， value， which was just zero。 And if I try to call next on it again， I get
    that stop iteration exception。 And remember that our iterator has to raise that
    stop iteration when there are no more， elements。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式。请记住，迭代器必须实现双下划线next。如果我调用内置的next，它在我的生成器内部映射到双下划线next，我得到的值就是零。如果我再次尝试调用next，我将遇到停止迭代异常。请记住，当没有更多元素时，我们的迭代器必须引发停止迭代。
- en: That's really cool。 We can implement iterators with much less code。 and we don't
    need to waste our time or resources， on maintaining state。 So really。 really kind
    of fast and easy way to implement iteration when you need it。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的很酷。我们可以用更少的代码实现迭代器，而且我们不需要浪费时间或资源去维护状态。因此，这是一种非常快速且简单的方法来实现所需的迭代。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_25.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_25.png)'
- en: Let's check a little bit about method magic。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微了解一下方法魔法。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_27.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_27.png)'
- en: We can alias methods pretty easily。 We just assign them to a variable。 In this
    case。 I'm assigning the method dunderadd to a new variable called concat。 And
    now I can use it just like I'd be able to use dunderadd because methods are just，
    objects。 So I was previously using the plus sign under the hood。 Now I've kind
    of renamed my method。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地为方法创建别名。我们只需将它们赋值给一个变量。在这种情况下，我将双下划线add方法赋值给一个名为concat的新变量。现在我可以像使用双下划线add一样使用它，因为方法只是对象。因此，我之前在内部使用的是加号。现在我重新命名了我的方法。
- en: and I can also call concat。 And when I ask Python， are these two values equal
    to each other。 I get back a true。 And I'll chat a little bit about why that's
    important in a few slides。 But next。 I'm going to show you a little bit more magic。
    Get adder。 So in this example。 I've defined a very simple dog class。 It has a
    method called speak。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我也可以调用concat。当我询问Python这两个值是否相等时，我得到一个true。稍后我会聊聊这点为什么重要。但接下来，我要给你展示更多的魔法。获取加法器。所以在这个例子中，我定义了一个非常简单的狗类。它有一个叫做speak的方法。
- en: And when I call speak on my dog instance， it goes bark bark。 There's a built-in
    method I can use called get adder that takes an object， a name， and。 note that
    that name must be a string and a default value if I want to provide one。 And the
    default value is optional。 So if I call get adder on my dog instance。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在我的狗实例上调用 speak 时，它会发出“汪汪”的声音。我可以使用一个名为 get adder 的内置方法，该方法接受一个对象、一个名称，并注意那个名称必须是字符串，并且如果我想提供一个，默认值也是可选的。所以如果我在我的狗实例上调用
    get adder。
- en: I have a -- and pass in the value of string -- I'm， sorry， speak as a string。
    I'll see that I have a bound method。 And now I can just go ahead -- if I save
    that method to a variable。 I could just call it， like any method。 So using get
    adder， we got that speak attribute。 If speak wasn't on that instance， because
    I didn't provide a default value， I would。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个--并传入字符串的值--抱歉，作为字符串说。我会看到我有一个绑定方法。现在我可以继续--如果我将该方法保存到一个变量中。我可以像调用任何方法一样调用它。因此，通过使用
    get adder，我们得到了那个 speak 属性。如果 speak 不在那个实例上，因为我没有提供默认值，我就会。
- en: have gotten an attribute error instead。 To avoid exceptions， you can try to
    provide a default value。 Here's an example of how we might be able to use something
    like this。 Here I've written the tiniest ever command line tool that takes dynamic
    commands。 So I have a class operation and I've defined a few methods on it。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到了属性错误。为了避免异常，你可以尝试提供一个默认值。这是我们可能如何使用类似的东西的示例。我这里写了一个最小的命令行工具，可以接受动态命令。因此，我定义了一个操作类，并在其上定义了一些方法。
- en: I have a method called say hi that prints out hello and the pass in argument
    of a name。 I have a method say bye that prints out goodbye with the pass in argument。
    And I've also defined a default method that will print out that this operation
    is not， supported。 Now if you look down to the main method， what am I doing？
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个叫 say hi 的方法，它打印出 hello 和一个名字作为参数。我还有一个方法 say bye，它打印出 goodbye 和传入的参数。我还定义了一个默认方法，它会打印出这个操作不被支持。如果你看看主要方法，我在做什么？
- en: I'm creating a new instance of my operations class。 And let's assume I have
    some error handling in there。 That would probably be a nice touch。 The next thing
    I do is I grab the user input and I split it up into a command and an argument。
    Lastly， I call get adder with my three arguments。 The first one is the instance
    of the class operations。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在创建我的操作类的新实例。假设我在其中有一些错误处理，那可能是一个不错的补充。接下来，我抓取用户输入，并将其分成一个命令和一个参数。最后，我用我的三个参数调用
    get adder。第一个是操作类的实例。
- en: The second one is the command that I've extrapolated from user input。 The third
    one is a default。 And lastly， I call that method with an argument。 In this case，
    I'm going to provide a name。 Let's check out the output of running my little demo
    script。 If I do say hi and Nina。 I get the output that I expected， hello Nina。
    If I just try to type in some junk。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是我从用户输入中提取的命令。第三个是一个默认值。最后，我用一个参数调用那个方法。在这种情况下，我将提供一个名字。让我们检查一下运行我这个小演示脚本的输出。如果我说
    hi 和 Nina，我得到了预期的输出，hello Nina。如果我只是尝试输入一些垃圾。
- en: I'm going to get back an error message that says this。 operation is not supported
    and I can do it on the fly。 Pretty cool。 Next I want to touch on funktools。partial。
    This takes three arguments， function。 In this case。 I'm going to abbreviate it
    to funk， some arguments and some keyword arguments。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我会收到一条错误消息，说明此操作不受支持，我可以随时处理。这很酷。接下来，我想谈谈 funktools.partial。它接受三个参数，函数。在这种情况下，我将其缩写为
    funk，一些参数和一些关键字参数。
- en: And what this does is returns a new partial object which behaves like the funk
    but called。 with those arguments and those keyword arguments。 If any additional
    arguments are passed in。 they're just appended to args。 If any additional keyword
    arguments are passed in。 they extend and override quarks。 Let's see how this works。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法返回一个新的部分对象，其行为类似于 funk，但使用那些参数和关键字参数进行调用。如果传入任何附加参数，它们会被附加到 args 中。如果传入任何附加关键字参数，它们将扩展并覆盖
    quarks。让我们看看这是如何工作的。
- en: If I pass in a binary number as a string to the built in int function and I
    specify the， base。 in this case two， to signify that it's a binary number， we'll
    get that value back， as a decimal。 Let's say I want to be able to call this function
    on any binary number without having。 to always specify the base。 I could do this
    with a partial。 I import my funktools。partial。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将一个二进制数作为字符串传递给内置的 int 函数，并指定基数，在这种情况下是二，表示它是一个二进制数，我们将得到该值，以十进制形式返回。假设我想能够在任何二进制数上调用这个函数，而不必总是指定基数。我可以用部分功能做到这一点。我导入我的
    funktools.partial。
- en: I'm sorry， from funktools import partial。 And then I make a new partial called
    base two。 The function that I'm passing in is an int and the keyword argument
    that I'm passing in。 is base two。 If I then examine this object， I'll see that
    it's a funktools。partial object。 Now what can I do with it？ I can go ahead and
    call base two on any binary number and that argument。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 抱歉，来自 funktools 的 import partial。然后我创建了一个名为 base two 的新 partial。我传递的函数是一个整数，而我传递的关键字参数是
    base two。如果我检查这个对象，我会看到它是一个 funktools.partial 对象。那我可以用它做什么？我可以在任何二进制数字上调用 base
    two 和那个参数。
- en: the base equal to， is now implicit and I get back the value as a decimal。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: base 等于现在是隐式的，我得到了一个十进制的值。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_29.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_29.png)'
- en: So we've talked about lots of magic methods and method magic。 Let's see this
    stuff in action and see how it applies to us。 There's a library that I really
    like that's unfortunately very poorly named。 It was looking for a new maintainer
    that got adopted by Mozilla。 So thank you， Mozilla。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈到了许多魔法方法和方法魔法。让我们看看这些东西是如何运作的，以及它是如何适用于我们的。有一个我非常喜欢的库，不幸的是名字非常糟糕。它正在寻找新的维护者，后来被
    Mozilla 采用了。所以谢谢你，Mozilla。
- en: It's called a GitHub and it really kind of has nothing to do with GitHub。 It
    is a REST API client with a transparent syntax and it facilitates rapid prototyping。
    on any REST API， not just the GitHub one。 It's implemented in about 400 lines
    of code。 You can add support for any REST API in about 30 lines of code and this
    project at GitHub。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个叫做 GitHub，实际上和 GitHub 没有太大关系。它是一个具有透明语法的 REST API 客户端，并且促进了在任何 REST API 上的快速原型制作，而不仅仅是
    GitHub 的。它大约用 400 行代码实现。你可以用大约 30 行代码为任何 REST API 添加支持，项目在 GitHub。
- en: it knows everything it needs to know about the protocol， REST， HTTP， etc。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 它了解关于协议、REST、HTTP 等所需的一切。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_31.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_31.png)'
- en: But it assumes nothing about the upstream API。 Here we defined an endpoint URL
    and some other connection properties。 This is quite a bit of code but let's focus
    on the important bits that the class name is， GitHub。 We expect an API token，
    this is going to be our GitHub API token and that we provided。 a API URL of api。github。com。
    After we define that endpoint and other connection properties。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但它对上游 API 并没有假设。在这里我们定义了一个端点 URL 和其他连接属性。这是一段相当多的代码，但让我们关注重要的部分，类名是 GitHub。我们期望一个
    API 令牌，这将是我们的 GitHub API 令牌，以及提供的 API URL 为 api.github.com。在我们定义这个端点和其他连接属性之后。
- en: we can just start using the API。 I've made a new instance of that class that
    I showed earlier。 I've provided a token， my GitHub API token which I'm sorry I'm
    not sharing with all of。 you today but you'll have to imagine it。 And I get back
    a status and some data。 What I call that instance， gh。user。repos。get。 What it's
    actually mapping to is the get method of /user/repos on api。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始使用 API。我已经创建了之前展示的那个类的新实例。我提供了一个令牌，我的 GitHub API 令牌，抱歉今天不能与大家分享，但你们需要想象一下。我得到了一个状态和一些数据。我称这个实例为
    gh.user.repos.get。它实际上映射的是 API 中的 /user/repos 的 get 方法。
- en: github。com。 That was it。 That was all the setup I had to do。 But if we try to
    provide a path that doesn't exist， we just get a 404。 So gh。path。doesn't exist。get
    404。 Because remember it's up to you to spell things correctly。 There's no validation
    of any sort if the URL doesn't exist or anything else goes wrong。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: github.com。这就是我需要做的所有设置。但如果我们尝试提供一个不存在的路径，我们只会得到一个 404。所以 gh.path.doesn't exist.get
    404。因为请记住，你需要正确拼写。如果 URL 不存在或其他任何事情出错，就没有任何验证。
- en: The error that's thrown by the API is just going to get returned。 Okay， magic。
    How does this work？
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: API 抛出的错误将被直接返回。好的，魔法。这是如何工作的？
- en: Well each call to the API class is going to ferry to an incomplete request。
    We can use it in two different formats。 One is the square bracket format because
    we are implementing get adder here。 And we've also aliased get item to get adder。
    So that allows us to use the dot syntax。 First。 we check to see if it's a URL
    or not。 If it is， we just kind of keep appending to the path。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 API 类都会转发到一个不完整的请求。我们可以用两种不同的格式使用它。一种是方括号格式，因为我们在这里实现了 get adder。我们也将 get
    item 别名为 get adder。这使我们能够使用点语法。首先，我们检查它是否是 URL。如果是，我们就继续追加到路径。
- en: If it's not， what we do is check and see if that value is an HTML HTTP method
    or not。 If it's in our list of predefined HTTP methods。 If it is， go down to the
    client class。 You'll see that once we get to one of those keywords in this example，
    it's get。 We're going to go and actually call the API with the URL that we've
    now built up。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是，我们要做的是检查那个值是否是一个HTML HTTP方法。如果它在我们预定义的HTTP方法列表中。如果是，就进入客户端类。你会看到一旦我们到达这个示例中的某个关键字，即`get`，我们将实际调用API，使用我们现在构建的URL。
- en: And it does that using a partial method。 So we return a partial with the HTTP
    method and the URL that we've built up。 I think this library is pretty cool。 It's
    worth taking a look at the source code to see how it's written。 I use it all the
    time when I'm prototyping。 Next， let's talk about context managers。 When should
    you use one？ If you want to perform an operation， an action before， after an operation。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了一个部分方法。所以我们返回一个部分与我们构建的HTTP方法和URL。我觉得这个库非常酷。值得查看一下源代码，看看它是如何编写的。我在原型设计时总是使用它。接下来，我们来谈谈上下文管理器。你什么时候应该使用它？如果你想在操作之前或之后执行一个操作。
- en: Common scenarios here are closing a resource when you're done with it， like
    a file or network。 connection， performing some cleanup before or after a function
    call。 An example is feature flags。 It's the ability to toggle a feature of your
    application on and off easily。 For example。 if you want to do some A/B testing
    and show a blue checkout button to some of。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 常见场景包括在完成后关闭资源，比如文件或网络连接，在函数调用前后执行一些清理。一个例子是特性标志。它可以轻松地切换你的应用程序中的某个特性。例如，如果你想进行A/B测试，向一些用户展示蓝色的结账按钮。
- en: your users in a red checkout button or others in seeing which of those options
    allow you。 to convert more users or something like a rolling release。 If you want
    to test your code for 5% of your users and see if it affects your resources。 or
    bogs down your site or something like showing a beta version to users who are
    opted into。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你的用户看到红色的结账按钮，或者其他人看到蓝色的按钮，看看哪个选项能让你转化更多用户，或者进行滚动发布。如果你想测试你的代码对5%的用户的影响，看看它是否影响你的资源，或者让你的网站变得缓慢，或者像向选择参与的用户展示测试版本那样。
- en: a beta testing program。 Here I have a really brief feature flags class。 I only
    have one feature。 So beta， do I want to show a beta version of my homepage or
    not？ We have two methods。 Is on will return true or false if that feature is on
    and a toggle method that allows me to。 set a value for that flag on or off。 How
    do I temporarily turn these flags on and off when I'm testing them？
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个测试计划。在这里我有一个非常简单的特性标志类。我只有一个特性。那么beta，我是否想显示我主页的测试版本？我们有两个方法。`is_on`会返回true或false，表示该特性是否开启，还有一个`toggle`方法，可以让我设置该标志的值是开启还是关闭。当我测试这些标志时，如何临时开启和关闭它们？
- en: What I want is something like this context manager that only has that feature
    flag on。 in the context that I'm provided and when it exits that context to turn
    the feature flag。 back to whatever it was set to before。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要的是像这样的上下文管理器，它只在我提供的上下文中启用那个特性标志，并在退出该上下文时将特性标志恢复到之前的设置。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_33.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_33.png)'
- en: We can do this with the magic methods， dunder enter and dunder exit。 In our
    constructor we save the old value whatever that feature flag was so we can set。
    it back later。 In dunder enter we're going to toggle that flag to on and in dunder
    exit we're going to。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过魔法方法`__enter__`和`__exit__`来做到这一点。在我们的构造函数中，我们保存旧值，无论那个特性标志是什么，这样我们就可以稍后将其设置回去。在`__enter__`中，我们将切换该标志为开启，在`__exit__`中我们将。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_35.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_35.png)'
- en: do our cleanup and set it back to the old value。 The better way to do this is
    using the context manager decorator。 You import that from context lib and then
    you just throw that decorator on any function。 It allows you to kind of define
    that factory function for with statements without needing。 to create a separate
    class with dunder enter and dunder exit methods。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 进行清理并将其设置回旧值。更好的做法是使用上下文管理器装饰器。你从`contextlib`导入，然后将那个装饰器应用到任何函数上。它允许你定义该工厂函数以用于`with`语句，而无需创建一个具有`__enter__`和`__exit__`方法的单独类。
- en: What we're doing in the middle， first we are implementing the behavior of dunder
    enter。 So turning that feature on。 Then we yield， which I'll go back to in a second。
    After we come back from that yield we're going to toggle that feature back to
    the value that。 it was， that cleanup。 Let's get back to yield a little bit。 What's
    happening here？
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在中间所做的，首先是实现`dunder enter`的行为。所以开启那个功能。然后我们使用`yield`，我稍后会回到这一点。我们从那个`yield`返回后，将该功能切换回之前的值，进行清理。让我们再回到`yield`，这里发生了什么？
- en: Yield is giving up control for the time being。 You do what you need to do before
    the method is run。 Then you yield control to the method that you're being used
    in。 Once you。 that method completes yields comes back， the yield is over and we
    reenter our。 context managers so we can run that cleanup code that we wanted to
    run on exit。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Yield`暂时放弃控制。你在方法运行之前做你需要做的事情。然后将控制权交给正在使用的方法。一旦该方法完成，`yield`就结束，我们重新进入我们的上下文管理器，以便运行我们希望在退出时运行的清理代码。'
- en: With either implementation we can use the context manager， leave our tests，
    allow our。 tests to leave state the way that they found it。 If we try to just
    turn these feature flags on and off it can cause issues with our tests。 further
    down the line。 In order to explain a better way of doing this I want to touch
    on decorators。 The simple explanation for them is that there's syntactic sugar
    that allows modification of。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两种实现方式，我们可以使用上下文管理器，让我们的测试保持状态，与它们发现的状态相同。如果我们仅仅开启和关闭这些功能标志，可能会导致我们测试中的问题。为了更好地解释如何做到这一点，我想谈谈装饰器。简单的解释是，它们是一种语法糖，允许对某些内容进行修改。
- en: an underlying function。 Decorators wrap a function in another function and then
    they do something。 they either， you， know， before the call， after the call。 with
    the provided arguments or they modify the。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基础函数。装饰器将一个函数包装在另一个函数中，然后它们执行某些操作。它们可以在调用之前或调用之后，处理提供的参数，或者修改它们。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_37.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_37.png)'
- en: return value of， or the arguments in some way。 I've defined a user class here
    that has a flag is authenticated and a constructor that。 takes a name and sets
    a value。 And we have a little web application with these users and we want to
    show pages for them。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值或以某种方式处理参数。我在这里定义了一个用户类，它有一个`is_authenticated`的标志和一个构造函数，接受一个名称并设置一个值。我们有一个小型网络应用程序，包含这些用户，我们想为他们展示页面。
- en: but we want to throw an exception if a user who's not authenticated is trying
    to access。 data that's only for logged in users。 We have a profile page method
    here and we check to see if that user is not authenticated。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果一个未认证的用户试图访问仅限登录用户的数据，我们想抛出一个异常。我们这里有一个个人资料页面的方法，我们检查该用户是否未认证。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_39.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_39.png)'
- en: throw an exception。 But we can use a decorator to remove some code duplication。
    Here I've written a method called enforce authentication and this method does
    something， funny。 It contains another method inside of it called wrapper。 And
    the enforce authentication accepts a argument that's a function while our wrapper
    function。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出一个异常。但我们可以使用装饰器来消除一些代码重复。在这里，我写了一个叫做`enforce authentication`的方法，这个方法有点有趣。它包含了另一个方法，叫做`wrapper`。而`enforce
    authentication`接受一个函数作为参数，而我们的`wrapper`函数。
- en: accepts an argument that's a user。 That inner function returns that。 the passed
    in function called with the arguments that。 were passed into the inner function
    and then outside of that context we return a wrapper。 But this can be a little
    bit confusing at first but take a look at the important logic。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接受一个参数，该参数是一个用户。那个内部函数返回它。传递给内部函数的参数被调用，然后在外部上下文中我们返回一个包装器。但这一开始可能有点混乱，但看看重要的逻辑。
- en: in the middle。 If the user is not authenticated then we raise an exception。
    Same thing as from our previous code。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间。如果用户未认证，则我们抛出一个异常。与我们之前的代码相同。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_41.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_41.png)'
- en: We can use this in a few different ways。 We can use it without a decorator。
    We could just call enforce authentication with a function which is display profile
    page。 And then we pass in an instance of a user， our argument。 Or we can use that
    syntactic sugar and use a decorator instead using the @ symbol。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以几种不同的方式使用它。我们可以不使用装饰器。我们可以直接调用`enforce authentication`与一个函数，即`display profile
    page`。然后传入用户的实例，作为参数。或者我们可以使用语法糖，使用`@`符号作为装饰器。
- en: So we add @enforceauthentication on any page that we want to enforce authentication
    on。 And now that's just going to raise an exception if an unauthenticated user
    tries to call that。 You don't have to litter your code with a bunch of copy and
    pasted stuff。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们在任何需要强制身份验证的页面上添加`@enforceauthentication`。如果未经身份验证的用户尝试调用该页面，现在就会抛出异常。你不需要在代码中到处放置复制粘贴的东西。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_43.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_43.png)'
- en: One quick thing about decorators， you can have a problem with lost context。
    For example。 now our decorated function doesn't have the correct name and it doesn't
    have。 that docstring that we had defined for it。 If you run into this problem。
    look up how to use contextlib。wraps。 It's really easy。 In use cases for decorators，
    logging， timing。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 关于装饰器，有一个快速的事情是你可能会遇到上下文丢失的问题。例如，现在我们的装饰函数没有正确的名称，也没有我们为其定义的文档字符串。如果你遇到这个问题，可以查找如何使用`contextlib.wraps`。这真的很简单。在装饰器的用例中，有日志记录和计时等。
- en: validation， rate limiting， mocking and patching， there's a cool feature called
    a context decorator。 That's a context manager and a decorator combined。 It's been
    in the standard library since Python 3。2 and using them you can easily write classes，
    that can be used both as a decorator and as a context manager with that with statement。
    And context decorator is used by context manager already。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 验证、速率限制、模拟和修补，还有一个很酷的功能叫做上下文装饰器。这是一个上下文管理器和装饰器的结合。从Python 3.2起它就在标准库中，使用它们你可以轻松编写可以同时作为装饰器和上下文管理器使用的类，并且上下文装饰器已经被上下文管理器使用。
- en: So you get that functionality automatically for free。 For our context manager
    from earlier。 that's just kind of the same code。 We are saving the value of our
    feature flag before we enter the context manager。 then。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你自动获得该功能，完全免费。对于我们之前的上下文管理器，代码几乎是一样的。我们在进入上下文管理器之前保存了特性标志的值，然后。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_45.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_45.png)'
- en: we yield and then we set it back to what it was。 While using that decorator。
    we can use it either as a context manager or we can use。 it as a decorator by
    adding it to our get profile page function in this case and passing。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成然后再将其设置回原来的样子。在使用该装饰器时，我们可以将其用作上下文管理器，或者在这种情况下通过将其添加到我们的获取配置文件页面函数中来用作装饰器，并进行传递。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_47.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_47.png)'
- en: in those arguments。 A library that I like that uses this feature really well
    is called freeze gun。 It lets you， your Python test travel through time and you
    can use it as a context manager。 in that first example with the with。 So for just
    one part of your test。 you want the date and time to be this specific date。 Once
    you exit the context manager。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些参数中。我喜欢的一个很好地使用这个特性的库叫做freeze gun。它可以让你的Python测试穿越时间，你可以在第一个示例中将其用作上下文管理器。因此，在测试的某一部分，你想要日期和时间为这个特定日期。一旦你退出上下文管理器。
- en: your date goes back to what it was or you can use it。 as a decorator and just
    freeze time in a whole function using that decorator。 Read the source code sometime。
    It's really mind bending。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你的日期可以恢复到原来的样子，或者你可以将其用作装饰器，只需在整个函数中使用该装饰器来冻结时间。有空时请阅读源代码。这真的让人脑洞大开。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_49.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_49.png)'
- en: Lastly， I very， very briefly want to touch on name tuples。 I'm not going to
    go into the implementation， but I do want to show you two features of name。 tuples
    that I find to be useful。 What name tuples are are a lightweight representation
    of data。 You can create the tuple subclasses with named fields。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想非常简要地谈谈命名元组。我不打算深入实现，但我想给你展示两个我觉得有用的命名元组的特性。命名元组是一种轻量级的数据表示。你可以使用命名字段创建元组子类。
- en: So kind of much faster than a fully heavyweight object。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这比完全重量级对象快得多。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_51.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_51.png)'
- en: This is a quick example from active state。 We have a name tuple called cache
    info and it just kind of contains some random information。 Number of cache hits，
    misses， a maximum size， et cetera。 We can give these name tuples default values。
    In this case。 I have a routing table and I have a few values that I'm saving a
    prefix， a queue name， a wait time。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自活跃状态的一个快速示例。我们有一个名为缓存信息的命名元组，它包含一些随机信息。缓存命中次数、未命中次数、最大大小等等。我们可以给这些命名元组默认值。在这个例子中，我有一个路由表，并且我保存了一些值，比如前缀、队列名称和等待时间。
- en: We can set defaults with two different ways。 The first one is by specifying
    dunder defaults on dunder new。 So in the first case， I'm specifying a default
    wait time of 20 seconds always for all instances。 of this name tuple， but it can
    be overwritten if I need to。 In the second instance。 I'm customizing a prototype
    with underscore replace。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用两种不同的方式设置默认值。 第一种是通过在双下划线new上指定双下划线默认值。 所以在第一个案例中，我始终为所有实例指定一个默认的等待时间20秒。
    这个命名元组可以被覆盖，如果我需要的话。 在第二个实例中，我使用下划线replace自定义一个原型。
- en: So by calling underscore replace and passing in a default of a user prefix and
    a default。 of a user queue queue name， that's another way of specifying some defaults
    for my name， tuples。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所以通过调用下划线replace并传入用户前缀的默认值和用户队列名称的默认值，这是为我的命名元组指定默认值的另一种方式。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_53.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_53.png)'
- en: Lastly， name tuples can also be subclassed and extended。 If you see here where
    I define my class person， I am extending a name tuple and now I can provide。 other
    kind of heavier wait methods if I want to in this example， dunderster。 So you
    got lots and lots of new tools。 We learned about magic methods。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，命名元组也可以被子类化和扩展。 如果你看到这里我定义了我的类person，我在扩展一个命名元组，现在如果我想在这个示例中提供其他更复杂的等待方法，比如双下划线ster，也是可以的。
    所以你得到了很多新的工具。 我们了解了魔法方法。
- en: making your objects behave like built-ins， numbers， list， dictionaries， et cetera。
    We learned about some method magic， things like aliasing， get adder， context managers。
    for managing your resources， decorators， doing something before or after a call，
    modifying。 a return value， validating arguments。 We learned about context decorators。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让你的对象像内置类型那样工作，比如数字、列表、字典等。 我们学习了一些方法魔法，比如别名、获取添加器、上下文管理器。 用于管理资源的装饰器，执行调用前或调用后的操作，修改返回值，验证参数。
    我们了解了上下文装饰器。
- en: which are context managers and decorators in one。 Iterators， generators， looping
    over your objects。 We learned about the yield keyword and what that does。 And
    lastly， we covered on name tuples。 which are these lightweight classes。 A quote
    that I kind of really appreciate is that perfection is achieved not when there。
    is nothing more to take away or nothing more to add， but when there is nothing
    left to， take away。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括上下文管理器和装饰器。 迭代器、生成器，循环遍历你的对象。 我们了解了yield关键字及其作用。 最后，我们还涉及了命名元组。 我很欣赏的一句话是，完美不是在于无可再去或无可再加，而是当没有任何东西可以去除时。
- en: So less is more， elegant code can be poetic。 It can be easy to copy and paste
    from stack overflow or try to randomly stick with paradigms。 of the programming
    language you came for。 But resist that urge。 If you kind of deep dive into Python，
    it will really open your mind into some new insights。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所以少即是多，优雅的代码可以是诗意的。 从Stack Overflow复制和粘贴或者随机坚持你所学的编程语言范式可能很容易，但要抵制这种冲动。 如果你深入探讨Python，它会真正开启你新的见解。
- en: '![](img/80428c441b0bf033d425c3dbeda56110_55.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80428c441b0bf033d425c3dbeda56110_55.png)'
- en: Because you want to be an elegant Pythonista。 We're a nice hat。 You want to
    use the tools that you learned about today to get started。 And remember that with
    great power comes great responsibility。 So use them very wisely。 If you're using
    a decorator on every single function in a class， we think your approach。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你想成为一个优雅的Pythonista。 我们是个不错的社群。 你想使用今天学到的工具来入门。 并记住，强大的能力伴随重大的责任。 所以要非常谨慎地使用它们。
    如果你在一个类的每个函数上使用装饰器，我们认为你的方法。
- en: Consider refactoring。 Simplicity is better。 It's up to you to choose the right
    tool for the job。 Thank you。 [APPLAUSE]。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑重构。 简单更好。 选择合适的工具来完成工作是你的责任。 谢谢。 [掌声]。
