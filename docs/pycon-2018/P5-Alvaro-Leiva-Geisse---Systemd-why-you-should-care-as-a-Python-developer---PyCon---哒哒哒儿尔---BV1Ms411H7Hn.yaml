- en: P5：Alvaro Leiva Geisse - Systemd why you should care as a Python developer -
    PyCon - 哒哒哒儿尔 - BV1Ms411H7Hn
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P5：阿尔瓦罗·莱瓦·盖塞 - Systemd，作为Python开发者你为什么应该关心 - PyCon - 哒哒哒儿尔 - BV1Ms411H7Hn
- en: \>\> Afternoon everybody。 Welcome to our last set of sessions here on this third
    day of PyCon。 Today we're going to， this afternoon we're going to start off with
    a talk on system D。 why you should care as a Python developer。 Let's give a big
    hand here for Avada。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '>> 大家下午好。欢迎来到PyCon第三天的最后一场会议。今天下午，我们将开始一个关于system D的演讲，作为Python开发者你为什么应该关心它。让我们热烈欢迎Avada。'
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_1.png)'
- en: '[ Applause ]， \>\> And， sorry， one thing we will not have time to take questions
    as part of the session。 but if you do have questions you can catch Avaro afterwards
    outside。 Thanks。 \>\> Hello。 Okay。 let''s start。 My friend over here already said
    I''m Avaro。 I''m a production engineer at Facebook and Instagram and I''m here
    to talk to you about。'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]，>> 抱歉，会议中我们没有时间回答问题，但如果你有问题，可以在会后在外面找阿尔瓦罗。谢谢。>> 你好。好吧。我们开始吧。我旁边的朋友已经说过，我是阿尔瓦罗。我是Facebook和Instagram的生产工程师，今天来和大家聊聊。'
- en: system D and why should you care as a Python developer。 Before we start I have
    a couple of things to say。 The first thing is that this is my first PyCon talk
    and of course the day before my talk。 I lost the complete use of my voice。 So
    now you hear me like this is just because I'm struggling。 Yesterday I was completely
    mute to the kind of like feeling that one episode of friends。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: system D以及作为Python开发者你应该关心的原因。在开始之前，我有几件事要说。首先，这是我第一次在PyCon演讲，当然在演讲前一天，我失去了完全的声音。所以你听到我这样说，是因为我在挣扎。昨天我完全失声，感觉就像《老友记》中的某一集。
- en: where she could not talk。 So yeah。 So that's the first thing。 So that's why
    we're not going to have questions here because nobody wants to hear more of， my
    voice。 The second thing is that this presentation is going to be two parts。 The
    first one is going to be a slide where I just say like what is system D， a few
    cool。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 她无法发言。所以这就是原因。我们这里不会有问题，因为没人想听更多我的声音。第二件事是，这次演讲将分为两个部分。第一部分是一个幻灯片，我将讲述什么是system
    D，以及一些酷炫的东西。
- en: things that you can do and then I'm going to go into a practice mode where I'm
    going。 to show you code where you can do the part like why should you care as
    a Python developer。 That's kind of the point of the talk right？ Where PyCon？ Okay。
    So with that out of the way let's start。 So system D is many things to many people
    and in general we want to treat system D as a。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以做的事情，然后我将进入实践模式，展示你可以做的部分，作为Python开发者你为什么应该关心。这大概是演讲的重点吧？我们是PyCon？好吧，废话少说，我们开始吧。所以system
    D对很多人来说是很多东西，通常我们希望将system D视为一个。
- en: service manager。 So the first thing that we need to ask ourselves， what is a
    service manager？
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 服务管理器。那么我们首先需要问自己，什么是服务管理器？
- en: As the name you play， a service manager is something that manages your service。
    That means that it's not your service by itself。 It's not a path。 It's not a thing。
    It's not a thing that allows you to operate your service。 Start， stop， reload，
    restart。 It's also the thing that is supposed to manage the life cycle of your
    service。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名，服务管理器是管理你的服务的东西。这意味着它本身不是你的服务。它不是一个路径，不是一个事物，也不是让你操作服务的东西。启动、停止、重新加载、重启。它还应该管理你服务的生命周期。
- en: So if you want your young application to start at boot but only after your postgres
    server。 is already ready to run， that's the job of your service manager。 So in
    the good old days。 that means the time before system D， there was no real service。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你希望你的应用在启动时运行，但只在你的Postgres服务器已经准备好后，那就是你的服务管理器的工作。在往昔的好日子里，即在system D之前，实际上没有真正的服务。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_3.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_3.png)'
- en: manager per se。 So you have to be your own service manager。 And the way that
    you do this is you wrote shell script that I hope that looks good but。 where basically
    in this shell script you define the operation that you needed to do。 For instance
    here you have start， stop， restart and for some reason， force reload is the same。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本身的管理器。所以你必须成为自己的服务管理器。你这样做的方式是写一个我希望看起来不错的shell脚本。在这个shell脚本中，你定义了需要执行的操作。例如，这里你有启动、停止、重启，出于某种原因，强制重新加载是一样的。
- en: thing after start。 And you wrote this in shell。 This was a look or this was
    a good thing in general because if you are writing shell。 script that means that
    you can write whatever you want。 If you want to start your service in a certain
    way， nobody is telling you how to do it， you。 have to do it by yourself。 The problem
    with freedom in this sense is that for instance in that weird section over。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '启动后的事情。你在shell中写的。这是一种看法，或者说这总体上是件好事，因为如果你在写shell脚本，那意味着你可以随意写。如果你想以某种方式启动服务，没有人告诉你该怎么做，你必须自己去做。在这种意义上，自由的问题是，例如在那个奇怪的部分。 '
- en: there that you see， the only line that's actually starting the service is the
    line 110 and everything。 else is just boilerplate code。 You have argument parsing。
    you have print output and all the things that you needed to， do to make a fully
    functional program。 And you do this for all of your units on your server。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的只有实际启动服务的那一行是第110行，其他的都是样板代码。你有参数解析，你有打印输出和你需要做的所有事情，以使程序功能完整。你为服务器上的所有单元都做这个。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_5.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_5.png)'
- en: So this was good but yeah。 So then came system D。 It was obvious for a long
    time for the units community and other architecture communities。 that even though
    system 5 was good enough for what we have， we needed a change to be able。 to grow
    servers faster and have better startup times。 So as always happens。 at least two
    things arise。 One was after the other was system D and probably I'm forgetting
    the one service manager that。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这很好，但接着来了system D。对于单元社区和其他架构社区来说，显而易见的是，尽管system 5对我们来说已经足够好，但我们需要改变，以便能够更快地扩展服务器，并拥有更好的启动时间。所以像往常一样，至少出现了两件事。一件是在另一件是system
    D，可能我忘了一个服务管理器。
- en: people really like。 But yeah， so these two were like the big one。 And as usually
    this happened。 they went into a little war and system D at the end won basically。
    And by one。 I mean that is part of all major distribution。 I'm not saying that
    it's better。 I'm just saying that it's there。 So that's kind of the first spirit
    that I want to show you and that's the spirit of。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 人们真的很喜欢。但是是的，这两者就像是最大的一个。通常这发生了，他们进入了一场小战争，最后基本上是system D赢了。我的意思是，这是一部分所有主要的发行版。我并不是说它更好，只是说它存在。所以这就是我想展示的第一种精神，就是这次演讲的精神。
- en: this talk。 It's not extremely good。 It's more like system D is a part of your
    server。 It's part of there， how can we use it to do our things better。 So what
    makes it so different。 so low and capable for many people。 Basically where you
    used to have a shell script。 now you have unit files。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它并不是极其出色，更像是system D是你服务器的一部分。它在那儿，我们如何利用它来更好地做事情。那么是什么让它如此不同，低效且适合许多人。基本上，你以前有一个shell脚本，现在你有了单元文件。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_7.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_7.png)'
- en: So you now don't have executable things， you just now have the clarity of things。
    Basically you write this unit file and if you're running a service， it's called
    a service， file。 And where you specify how your service should look like and then
    you let system D configure。 your service as it should。 So this is not the execute
    level， you cannot just dot and run that file。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你现在没有可执行的东西，你现在只是有事物的清晰度。基本上你写这个单元文件，如果你正在运行一个服务，它叫做服务文件。在那里你指定你的服务应该是什么样子，然后你让system
    D配置你的服务如它应有的样子。所以这不是执行级别，你不能只点点就运行那个文件。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_9.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_9.png)'
- en: So you need something to execute it。 And I hope that really looks good。 So if
    you want to start your service， you ask it to start it for you。 You don't do it
    yourself and this is a completely change of part of you。 You say system CTL。 start
    my service。 If you want to stop it， you do system CTL， stop my service。 If you
    remember。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你需要一些东西来执行它。我希望这看起来真的不错。如果你想启动你的服务，你要求它为你启动。你不自己去做，这是你的一部分完全改变。你说system CTL。启动我的服务。如果你想停止它，你做system
    CTL，停止我的服务。如果你还记得。
- en: I didn't specify how to stop my service。 But since this is a unique service。
    system D kind of know how the thing should be done。 So I didn't need to wrote
    that algorithm。 But if you really ask me the reason why I think system D is the
    fact that in its system or。 service manager or most services， or most service
    is because if you ask for a status。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有指定如何停止我的服务。但因为这是一个独特的服务，system D知道应该怎么做。所以我不需要写那个算法。但如果你真的问我为什么我认为system
    D的原因在于它的系统或服务管理器或大多数服务，因为如果你请求状态。
- en: for information for your service， it gives it to you。 And this is something
    that you think。 like it's obvious， but it's before system D was， not possible。
    Things like， is my service running？
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的服务提供的信息，它会给你。这是你认为理所当然的事情，但在 system D 之前，这是不可能的。像“我的服务正在运行吗？”这样的事情。
- en: It makes sense that system D can tell you that information because it can discharge
    yourself。 So he created the first fork， exec， he knows the piece of your main
    application。 So he can keep track of it。 He can tell you when your service starts。
    And now you know that these two things are actually real。 In system five， when
    you ask service。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: system D 能够告诉你这些信息是有道理的，因为它可以自行释放。所以他创建了第一个 fork，exec，他知道你的主应用程序的一部分。所以他可以跟踪它。他可以告诉你你的服务何时启动。而现在你知道这两件事实际上是真实的。在系统五中，当你询问服务。
- en: the name of the service status， it says running。 But it didn't tell you like
    when or all those information。 It also gives you a little piece of data that before
    system D was actually not possible to。 get entirely。 That is all the processes
    that are running within your service。 And I explain this right away when I explain
    the concept of C group。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 服务状态的名称时，它会说正在运行。但它没有告诉你具体的时间或所有相关信息。它还提供了一些数据，这在 system D 之前实际上是不可能完全获取的。那就是你服务中正在运行的所有进程。我在解释
    C 组的概念时就会立刻说明这一点。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_11.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_11.png)'
- en: So this would not be a system D talk if I did not talk about two things。 The
    first one is socket activation and the second one is C group。 So let's at least
    tackle one。 A C group。 Sorry。 A C group is basically a linear scan of feature
    that allows you to impose restriction on a。 certain list of process。 So in common
    language， it's like I have a process and I want to say you can only use。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我不谈论两件事，这就不是一个 system D 的演讲。第一件事是套接字激活，第二件事是 C 组。所以至少让我们先解决一个。C 组。抱歉。C 组基本上是一个特性线性扫描，允许你对某个进程列表施加限制。所以用通俗的话说，这就像我有一个进程，我想说你只能使用。
- en: 40% of CPU， 10 megabytes of RAM。 You can only access this type of memory or
    CPU IO。 Sorry。 or IO like this IO。 That's what C groups allows you to do。 And
    you see groups for this purpose but also for a slightly different purpose。 So
    C 10 D before starting your service， it will create a C group just for that service。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 40% 的 CPU，10 兆字节的 RAM。你只能访问这种类型的内存或 CPU IO。抱歉。或者像这样的 IO。这就是 C 组允许你做的事情。你会看到为了这个目的而存在的组，但也会有稍微不同的目的。所以在启动你的服务之前，C
    10 D 会为该服务创建一个 C 组。
- en: So system slides， my app service， that's the name of the C group。 And the convention
    of C 10 D specific， it doesn't have to do anything with C groups。 It's just a
    name。 So then start your service。 Then if your main process starts to child processes。
    these processes are also going to， be part of the process tree。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 system slides，我的应用服务，那就是 C 组的名称。而 C 10 D 的约定并不需要与 C 组有任何关系。它只是一个名称。所以启动你的服务。然后如果你的主进程启动了子进程，这些进程也将成为进程树的一部分。
- en: So if you go into the main process and then look at the process tree， you're
    going to。 see these two child processes。 But you can also instead of doing that。
    go through the C group and then list all the， processes in the C group and you're
    still going to see them。 But here's where it's cool because if one of the child
    processes decide to double fork。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你进入主进程，然后查看进程树，你会看到这两个子进程。但你也可以选择不这样做，而是通过 C 组列出所有进程，你仍然会看到它们。但是这很酷，因为如果其中一个子进程决定双重派生。
- en: itself and then demonize and escape the parent， it will no longer be part of
    the process tree。 So in a regular point of view， you will lose sight of it。 But
    since it cannot escape the C group。 system D can still tell that demon spawned
    by main， process is part of the service。 So for the first time in all of Linux
    history， we were able to actually kill a service in。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它自己然后进行守护并逃离父进程，它将不再是进程树的一部分。所以从常规的角度来看，你将失去对它的视野。但由于它无法逃离 C 组，system D 仍然可以告诉你，由主进程生成的守护进程是该服务的一部分。所以在整个
    Linux 历史上，这是我们第一次能够实际终止一个服务。
- en: his entirety。 Because now we don't have to keep track of individual process。
    We just say C group。 goodbye。 And then everything goes。 So I hope you like my
    explanation of C groups。 Let's move on to now what cool things can we do with
    system D。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它的整个内容。因为现在我们不需要跟踪单个进程。我们只需说 C 组。再见。然后一切都消失了。所以我希望你喜欢我对 C 组的解释。接下来我们来看看我们可以用
    system D 做些什么酷的事情。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_13.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_13.png)'
- en: So the first thing that I want to show you is template。 And so a template， and
    again。 I hope this looks， a template is basically a unit file。 The same。 but instead
    of having the name myapp。service is myapp@。service。 And then in your file。 you
    put this upper sent， sorry， this percentage Y。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我想给你展示的第一件事是模板。因此，模板，且再次希望这看起来不错，模板基本上是一个单元文件。相同，但不是myapp.service，而是myapp@.service。然后在你的文件中，你放置这个百分号Y。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_15.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_15.png)'
- en: So then when you want to start your service， you start your service as myapp@
    and then award。 It doesn't matter which one it is。 In this case， I put the configuration
    name。 So what system D will do is that it will replace that percentage Y with
    the word that。 you put there。 So this is cool because if you have， for instance，
    this is UIC。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当你想要启动你的服务时，你可以以myapp@的形式启动服务，然后给予奖励。无论是哪一个都没关系。在这种情况下，我放置了配置名称。所以system D会做的是用你放在那里单词替换那个百分号Y。这是很酷的，因为例如，这里是UIC。
- en: which I'm pretty sure most of us， are familiar with， if you have UIC point，
    sorry。 the configuration point to different version， of your app， you can actually
    do roll up with this。 So you can start myapp@version1conf and then start myapp@version2conf，
    have two of them running。 with your A/B testing。 And when you decided that one
    is good， you take out one and leave the other。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信我们大多数人都很熟悉这个，如果你有UIC点，抱歉，配置点指向你应用程序的不同版本，你实际上可以通过这个进行回滚。因此，你可以启动myapp@version1conf，然后启动myapp@version2conf，让它们同时运行，进行A/B测试。当你决定其中一个是好的，你就取出一个，保留另一个。
- en: Or you can roll back by just stopping the other one。 So this is actually a cool
    feature that you should get overlooked as a toy thing， but it's。 really powerful。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以通过停止另一个服务来回滚。因此，这实际上是一个很酷的功能，你应该不要把它视为一个玩具东西，但它真的很强大。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_17.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_17.png)'
- en: As I said， this would not be a system D talk if I didn't talk about socket activation
    and。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说的，如果我不谈论套接字激活，这就不会是一次system D的演讲。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_19.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_19.png)'
- en: secret。 That's about socket activation。 I'm going to say something that is obvious
    to everybody。 And it's like before when you don't do socket activation and you
    want to do network， you。 start your application， then eventually your application
    will open a port， we start listening。 to a port for AT。 And then this port will
    become an open file for your application。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密。这是关于套接字激活的内容。我将说一些对每个人来说都很明显的事情。就像以前，当你不使用套接字激活并且想要进行网络连接时，你启动你的应用程序，最终你的应用程序会打开一个端口，我们开始监听AT端口。然后这个端口将成为你应用程序的一个打开文件。
- en: And this little piece of data is really important。 Then you will get a request
    and then you will see back a response。 This thing has an implicit contract， then
    since the port is an open file of your application。 if your application goes down，
    the port is closed or it's not listened or whatever you。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '这一小块数据是非常重要的。然后你会收到请求，然后你会看到回应。这个东西有一个隐含的契约，因为端口是你应用程序的一个打开文件。如果你的应用程序崩溃，端口会关闭或不再监听，或者无论你。 '
- en: want to name it。 So if somebody sent your request， you can send an answer。 So
    socket activation works， change the logic of application port request。 In socket
    activation。 system D will start and he will start listening to your port。 So instead
    of you starting to listen on port AT， system D will start listening to you。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 想要给它命名。因此，如果有人向你发送请求，你就可以发送回应。所以套接字激活的工作方式是改变应用程序端口请求的逻辑。在套接字激活中，system D会启动并开始监听你的端口。因此，不是你开始监听AT端口，而是system
    D开始监听你。
- en: An open in a port is basically lightning fast。 Then you will get a request。
    So you have port request。 And only when you request system D will activate your
    service。 So socket activation， you get it。 And then system D will just gladly
    pass the file descriptor to your app。 So this file descriptor is something that
    has already been been and has already been。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个端口基本上是闪电般快速。然后你会收到一个请求。因此，你有端口请求。只有当你请求时，system D才会激活你的服务。所以套接字激活，你明白了吗？然后system
    D会愉快地将文件描述符传递给你的应用程序。这个文件描述符是已经被使用过的。
- en: listened to it。 So your application， all it needs to do is read and accept the
    connection。 And then you can send a response back。 This gives you a lot of flexibility
    and options。 The first one that it allows you to， but even in production， but
    in your dev server or in。 your laptop， if you're developing and some of you're
    developing， use MySQL as a back-end。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你的应用程序需要做的就是读取和接受连接。然后你可以发送一个响应。这给你提供了很多灵活性和选项。首先，它允许你在生产环境中这样做，但在你的开发服务器或笔记本电脑上，如果你正在开发，并且有些人正在开发，使用MySQL作为后端。
- en: You don't have to have MySQL always run。 You just have it running the first
    time that you hit a test that will go to your MySQL。 That's kind of the point。
    So save resources and only activate the stuff that you want。 The other thing is
    that since this program that leads into the port and the program that。 actually
    accept the connection are different， you can start your program as root。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要让MySQL一直运行。你只需在第一次测试时让它运行，这样会去连接你的MySQL。这就是要点。所以节省资源，仅激活你想要的东西。另一件事是，由于导致端口的程序和实际接受连接的程序是不同的，你可以以root身份启动你的程序。
- en: And I assume that everybody renamed his root user as Widdle。 So， bad jokes。
    If you like bad jokes。 this is going to be the percentage for you。 So， okay， back
    on track。 System D will start your port and system D runs as root。 It can be into
    any port in the system。 But then your application can run as a normal user。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设每个人都将他们的root用户重命名为Widdle。所以，开个玩笑。如果你喜欢烂笑话，这对你来说会很合适。那么，好吧，回到正轨。System D会启动你的端口，并且System
    D以root身份运行。它可以在系统中的任何端口。但是你的应用程序可以以普通用户身份运行。
- en: And the cool thing about this is that without this， your application has to
    start as root。 run into the port and then either drop privilege or start a process
    with a different user。 Right now， the application from the beginning doesn't have
    all the privileges that it wants。 So that's another thing that is cool。 And finally，
    if you run only model Linux。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 而这件事情很酷的是，如果没有这个，你的应用程序就必须以root身份启动，进入端口，然后要么降低权限，要么以不同用户启动一个进程。目前，应用程序从一开始就没有它所需的所有权限。这也是一件很酷的事情。最后，如果你只运行模型Linux。
- en: you can use SO port reuse and then you can have， for instance running the first
    version of your application。 like I say， and then you can， ask system D to start
    the second version of your application but also listening to the。 port。 So， this
    is an option of the kernel like SO port reuse。 I won't go into it but go and dig
    it because it's really cool。 So。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用SO端口重用，然后你可以有，例如，运行你应用程序的第一个版本。就像我说的，然后你可以请求System D启动你应用程序的第二个版本，同时也监听这个端口。所以，这是内核的一个选项，像SO端口重用。我不会深入讨论，但你可以去挖掘一下，因为这真的很酷。
- en: then you will have your two applications running and again， you do A/V testing
    and when。 you're ready to say that version two is up for production， you just
    made it the final。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你将有两个应用程序运行，接着你进行A/V测试，当你准备好将版本二投入生产时，你只需将其设为最终版本。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_21.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_21.png)'
- en: one。 Cool。 So， how do we make this possible？ It's simple。 The service files
    remain almost in touch。 The important thing is that now you create a socket file
    where you specify what do you。 want to listen and you start the socket file as
    you will start any service。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒。那么，我们如何实现这个呢？很简单。服务文件几乎保持不变。重要的是，现在你创建一个套接字文件，指定你想要监听的内容，然后像启动任何服务一样启动这个套接字文件。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_23.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_23.png)'
- en: Now， in your code， since you would normally do open a socket， be into a board
    and execute， a listen。 Then all the things are already done for you or system
    D。 What you need to do is instead。 of doing that， you just socket from FD instead
    of socket。 socket， you open a file descriptor。 and that file descriptor is the
    one that was handed to you by system D。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的代码中，由于你通常会打开一个套接字，进入一个板块并执行一个监听。那么所有的事情都已经为你或System D处理好了。你需要做的只是从FD中获取套接字，而不是直接使用socket。你打开一个文件描述符，而这个文件描述符是System
    D交给你的。
- en: You see that there is a library there that's called PISTM D and that's my library
    that I。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到那里有一个叫做PISTM D的库，那是我的库。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_25.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_25.png)'
- en: created。 So， say way into my library。 And Python， sorry， in Facebook。 we use
    a lot of Python and we use a lot of system D。 So basically。 we create a library
    to be able to interact with system D in the same way that。 does an involved executing
    to process。call all the time。 So。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 被创建。所以，进入我的库。对不起，在Facebook我们使用很多Python和system D。基本上，我们创建了一个库，以便能够以与`process.call`相同的方式与system
    D进行交互。因此。
- en: we basically do a divas interface to system D。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上做了一个divas接口到system D。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_27.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_27.png)'
- en: Now does it work？ I'm sure that everybody can read that great thing。 You PIP
    install PISTM D。 You hope that's better。 You import it as you would normally import
    it。 And then if you have a unit on your service， you just load it like that and
    then you can。 start and stop and do all the operations that you want。 Nothing
    fancier。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它如何工作？我相信每个人都能看懂那个精彩的东西。你可以使用`PIP install PISTM D`。希望这更好。你像正常导入那样导入它。如果你的服务上有一个单元，你只需像那样加载它，然后你可以开始、停止并执行你想要的所有操作。没有更复杂的。
- en: If you want to get information from your running service， you can also get it。
    So first thing you can get the main app， the main PID。 And since this is not executing
    a shell and then parsing the text out and giving you something。 that main PID
    is an integer because we talk over divas， divas knows about types， so you。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从正在运行的服务中获取信息，也可以获得。首先，你可以获取主应用程序，主PID。由于这不是执行一个shell并解析文本，而是给你一些东西，主PID是一个整数，因为我们通过divas通信，divas了解类型，所以你。
- en: get it at school。 And if you want to get the list of process， you can get it。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在学校可以获得。如果你想获取进程列表，可以获取。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_29.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_29.png)'
- en: And that concludes the first part of the presentation。 I'm going to move to
    a demo。 So we're going to have your system D with PISTM D。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了演示的第一部分。我将进行一个演示。所以我们将有你的system D与PISTM D。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_31.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_31.png)'
- en: And I want to show you a few things that cannot make a -- I hope。 In general
    application。 if you want to execute a shell command， the thing that you will do，
    is process。call， right？
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我想给你展示一些不能做的事情——我希望如此。一般来说，如果你想执行一个shell命令，你会调用`process.call`，对吧？
- en: So first is if I want to execute sleep， I will execute it。 And then you will
    see， like right there。 there is a child of the parent process that I created。
    This has three consequences。 The first consequences is that it's run as the same
    user of my application。 That means that it has all the same privileges that my
    application has。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我想执行sleep，我会执行它。然后你会看到，就在那里，我创建的父进程的一个子进程。这有三个结果。第一个结果是它以我应用的同一用户身份运行。这意味着它拥有我应用的所有权限。
- en: The second thing is that it runs as the same C group， so it has the same view
    of the system。 And the third thing is that it has the -- if the parent goes away，
    the children also goes。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第二件事是，它在同一个C组中运行，所以它对系统的视图是相同的。第三件事是，如果父进程消失，子进程也会消失。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_33.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_33.png)'
- en: away。 So running a process sounds a lot like starting a service。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 独立。因此，运行一个进程听起来很像启动一个服务。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_35.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_35.png)'
- en: So instead of doing that， C10D provides a nice feature that is called a transient
    unit。 So instead of restarting a service that means creating a unit file and reload
    it， I can。 actually execute PISTM D。run。 Everything that you saw there is that
    it returns right away and it returns what it's supposed。 to be a unit file。 Let
    me start that。 The second thing that you see is that it's created as its own process。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，C10D提供了一个称为瞬态单元的不错功能。因此，不必重启一个服务（这意味着创建一个单元文件并重新加载），我实际上可以执行`PISTM D.run`。你看到的一切都是它立即返回，并返回应有的单元文件。让我开始。第二件事是，它作为自己的进程被创建。
- en: It's not part of the process three。 It's away。 So this is cool because all this
    restriction that we just took goes away。 I'm going to go as far as saying that
    almost all the calls that you make to do in your service。 can be replaced with
    PISTM D。run on Linux。 It will not work on other things different than Linux。 But
    yeah。 So that's cool。 Okay。 So let's see what happened。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是进程树的一部分。它是独立的。这很酷，因为我们刚刚采取的所有限制都消失了。我会大胆说，你在服务中进行的几乎所有调用，都可以用`PISTM D.run`在Linux上替代。它在其他操作系统上是行不通的。但确实，这很酷。好的。那么，让我们看看发生了什么。
- en: So the thing that happened is that I system D actually created a unit for me
    and it started。 as a different service。 That means that if I go here and just
    cut that file。 you will see that it gives me a unit， file that I didn't create
    and as it should be。 it's in run system D transient unit。 So with this， I can
    execute stuff with this and it will run。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以发生的事情是，我的 system D 实际上为我创建了一个单元，并且它作为一个不同的服务启动。这意味着如果我在这里剪切那个文件，你会看到它给了我一个我没有创建的单元，文件是正确的，它在运行
    system D 瞬态单元中。因此，通过这个，我可以执行一些东西，并且它会运行。
- en: see the unit file that was， created and then I can see how can do the same thing
    with my normal service。 So let me go there。 Okay。 What other things can we do？
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 查看创建的单元文件，然后我可以看看如何用我的普通服务做同样的事情。所以让我去那里。好的，我们还可以做些什么？
- en: So this is one thing that I think it's cool and is like I can actually start
    a batch process。 So if you see， I'm still on my mini demo right there that you
    see。 But for some reason。 I created a batch process。 I added a PTY and then I
    linked together the StvN and StvOut。 Really magic and I only did it with this
    command over here that you can see。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是我认为很酷的一件事情，我可以实际上启动一个批处理过程。所以如果你看到，我仍然在我的迷你演示中，但出于某种原因，我创建了一个批处理过程。我添加了一个
    PTY，然后将 StvN 和 StvOut 连接在一起。真的很神奇，我只是用你可以看到的这个命令做到的。
- en: You see this should give you a little bit。 So StvN StvOut。 PTY true and I give
    it a name and I give it a name and here I can show。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这应该给你一点启发。所以 StvN StvOut，PTY 为真，我给它一个名字，我在这里可以展示。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_37.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_37.png)'
- en: you the， you see the service unit that would be created for that。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，服务单元会为此创建。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_39.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_39.png)'
- en: So this is a normal shell and I can do stuff like， and actually verify that
    this is what。 I'm running。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是一个普通的 shell，我可以做一些事情，并且实际验证这就是我正在运行的内容。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_41.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_41.png)'
- en: So I can do all this kind of stuff。 And here is the first thing that I think
    it。 why this indeed run is better than suppressive， the call for some things is
    that I can do with this。 If I want to run this as a different user， right， all
    I need to do is just add user at。 end and then the name of the user。 And then
    as you see my shell。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我可以做这些事情。这是我认为的第一件事。为什么这确实运行比压制调用更好的原因是，我可以用这个做。如果我想以不同的用户身份运行这个，对吧，我所需要做的就是在末尾添加用户和用户名。然后你会看到我的
    shell。
- en: it's running as the background user and this is how you， accomplish that。 If
    you。 instead of doing from PTY。code， you start from a service file， this is how
    you， will do it。 So this is actually cool because now in your program you can
    execute pieces of code and， privilege。 So let's see what other cool things can
    with them。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它作为后台用户运行，这就是你完成此操作的方式。如果你不是从 PTY`code`开始，而是从服务文件启动，这就是你要做的。因此，这实际上很酷，因为现在在你的程序中你可以执行代码片段并获得特权。所以让我们看看还可以用它们做些什么酷的事情。
- en: And I will start going relatively fast until I run out of time and showing different
    settings。 The settings you can use it in any combination that you like and most
    of them have more。 different versions of configuration。 But the ones that I'm
    showing you are meant to give you a curiosity and go and read the。 man page， see
    all the blog posts， send me messages on messenger or Instagram。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我会开始相对快速地进行，直到我时间耗尽，并展示不同的设置。你可以以任何你喜欢的组合使用这些设置，而且大多数都有更多不同的配置版本。但我展示的这些是为了激发你的好奇心，去阅读手册页，查看所有的博客帖子，或者在
    Messenger 或 Instagram 上给我发消息。
- en: If you care about my cat， I don't have cats。 I have sons。 Okay。 Okay。 So the
    first one is Protecom。 Protecom is actually a quite good idea and it's the link
    is the following。 You start your young application。 Why would your young application
    have access to the SSH keys or the AWS credential to your。 users？ So what Protecom
    does is that it literally will take away for your service。 Just service。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你关心我的猫，我没有猫。我有儿子。好吧。好的。所以第一个是 Protecom。Protecom 实际上是个不错的主意，链接如下。你启动你的年轻应用。为什么你的年轻应用会有权限访问
    SSH 密钥或 AWS 凭证呢？所以 Protecom 做的是，它实际上会从你的服务中拿走这些东西。
- en: It will not have anything underneath home and route。 So that means that now
    if somebody had your service， it get limited exposure to your application。 And
    that， if you ask me， I think it's really cool。 Now， Django。 and I say Django because
    I'm Instagram and we work a lot with Django。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它不会在home和root下面有任何东西。 这意味着现在如果有人有你的服务，它对你的应用程序的暴露程度受到限制。 如果你问我，我认为这真的很酷。 现在，Django。
    我之所以提到Django，是因为我在Instagram工作，我们与Django有很多合作。
- en: Django has one thing where it just read templates， read data from back end and
    then expose it。 to the wire。 So it actually doesn't need to write information
    into disk。 So the second option is Protecom is System Street。 And what that does
    is that it tries to make your whole system read only。 So that way your service。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Django有一个功能，就是读取模板，从后端读取数据，然后将其暴露给网络。 所以它实际上不需要将信息写入磁盘。 所以第二个选项是Protecom是System
    Street。 它的作用是让你的整个系统变为只读。 这样你的服务就可以。
- en: only your service， can not write anywhere， not even in temporal， directory。
    Of course。 you can modify this and there are different options。 But yeah。 So this
    is one cool thing that you can do。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 只有你的服务，不能在任何地方写入，甚至连临时目录也不能。当然，你可以修改这个选项，存在不同的选择。 但没错。这是你可以做的一个很酷的事情。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_43.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_43.png)'
- en: Okay。 So the next one that you can do， it's a little longer and I just put all
    of them together。 is that even though Protecom and Protec systems are cool， they
    are really like catch all， back。 Like sometimes I want to have a few pieces， not
    all of them。 So you can have like a part of that。 One part is you can have read
    only directories。 So I can specify which directories I want to be read only。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。 下一个你可以做的事情稍微复杂一点，我把它们都放在一起。 就是即使Protecom和Protec系统很酷，它们确实像是一个万用的备份。 有时候我只想要其中的几个，而不是全部。
    所以你可以只选择其中的一部分。 一部分是你可以拥有只读目录。 所以我可以指定我希望哪些目录是只读的。
- en: So I can say， "grow directory。"， You can read it because I need you to access
    my AWS credentials。 But don't write into it because don't。 In accessible directories
    is the same thing that you saw。 It just goes away。 And write directories， I don't
    have to explain it。 It's just obvious。 Okay。 Private TMP， it works awesome because
    it's for your service， it gives a private version。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我可以说，“增长目录。” 你可以读取它，因为我需要你访问我的AWS凭证。 但不要写入，因为不允许。 不可访问的目录和你看到的情况一样。 它只是消失了。
    而写入目录，我就不需要解释了。 这显而易见。 好的。 私有TMP，它效果很好，因为它是为你的服务提供的，给了一个私有版本。
- en: of what would be the TMP directory。 So we don't share the same TMP as the rest
    of the system does。 So you can put stuff there or other service， can put stuff
    on their TMP and they won't， collide。 You can do the same thing with any directory
    when you specify with temporal file system。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 就是什么将是TMP目录。 所以我们不与系统的其他部分共享同一个TMP。 你可以在这里放置东西，或其他服务可以在他们的TMP上放置东西，它们不会冲突。 当你用临时文件系统指定时，你可以对任何目录做同样的事情。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_45.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_45.png)'
- en: So if you see， it will mount barcode to my S， as a temporal file system as a
    TMP FS。 The cool thing about these two features is that once your service is down，
    all the temporal。 files that you created are also going away。 So this is one of
    the prerelated that you have when you let system manager service。 The two last
    ones that I have here， it's one thing that most people don't know that， they can
    do。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你看到，它会将条形码挂载到我的S上，作为临时文件系统TMP FS。 这两个功能的酷炫之处在于，一旦你的服务停止，所有你创建的临时文件也会消失。
    所以这是你在让系统管理服务时拥有的特权之一。 我在这里提到的最后两个功能，大多数人不知道他们可以做到这些。
- en: You can beam path for your application。 So what I can do is。 I can make believe
    my application that barlib， my S， leave over， there is actually SRV icon。 So these
    two directories are actually， but only for my service， not everybody else。 And
    then you can read only path。 It's of course you can mount it， but mount it as
    read only。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为你的应用程序提供路径。 我可以让我的应用程序相信，barlib，我的S，实际上是在SRV图标上。 所以这两个目录实际上是为我的服务而设，不是给其他人的。
    然后你可以有只读路径。 当然你可以挂载它，但以只读的方式挂载。
- en: But here's the cool thing。 What I mounted here is not a folder。 It's a file。
    So you can also mount files。 And you can also do this with mount operation。 The
    problem is that that idea is kind of weird to people。 It's also weird。 But yeah。
    so you can do that。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有一个很酷的事情。 我挂载的不是一个文件夹，而是一个文件。 所以你也可以挂载文件。 你可以通过挂载操作来做到这一点。 问题是这个想法对人们来说有点奇怪。
    这确实有点奇怪。 但没错，你可以这么做。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_47.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_47.png)'
- en: Let's move next。 Oh， this one is cool。 And I'm glad I still have time to show
    you this。 So how about you？ We talk about disk。 We talk about permissions。 How
    about network access？
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续。哦，这个很酷。我很高兴我还有时间向你展示这个。那么你呢？我们谈论磁盘。我们谈论权限。那么网络访问呢？
- en: So what this does is that I'm running batch and I have there， you can sell to
    your service。 and just to your service。 Hey， I don't want you to access anything
    on the internet or anything access you except。 IP 88832。 So now what I have here
    is an application that can only， we can do more than ping， but。 it can only ping
    888 and if I try to point for four， it will tell me operation not permitted。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这意味着我正在运行批处理，我在那里，你可以出售给你的服务。仅仅是为了你的服务。嘿，我不想让你访问互联网或任何你可以访问的东西，除了IP 88832。所以现在我这里有一个只能，我们可以做更多的ping的应用，但它只能ping
    888，如果我尝试指向4，它会告诉我操作不被允许。
- en: because I cannot even create it。 So you can have a firewall just for your service。
    This is system D。 System D only gives you access to it through Python。 It says，
    I don't do anything special already。 So that's cool。 There are other options more
    restrictive to that， but that one was cool。 And then the cool one， again， this
    is system D。 These are C groups。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我甚至无法创建它。所以你可以为你的服务设置一个防火墙。这就是系统D。系统D仅通过Python提供访问权限。它说，我并没有做任何特别的事情。所以这很酷。还有其他更严格的选项，但这个选项很酷。而且这个酷的选项，仍然是系统D。这些是C组。
- en: Let's see how system D use C group。 Here I have a unit that basically I said
    use 20% of CPU。 only use 10 megabytes of RAM， and you're only allowed to spawn
    five processes。 So let me show you what that means。 So right here。 if you see
    I have the memory limit and then the task limit。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看系统D如何使用C组。这里我有一个单元，基本上我说使用20%的CPU。仅使用10MB的RAM，你只能生成五个进程。所以让我给你展示这意味着什么。所以在这里。如果你看到我有内存限制，然后是任务限制。
- en: The task limit means that I can only have up to five running process at a certain
    time。 Or let's say like this， I can only fork five times at a time if that makes
    sense。 Okay。 The only one that I want to show you here to explain is the CPU。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 任务限制意味着我一次只能有五个运行的进程。或者说这样，我一次只能分叉五次，如果这样理解的话。好的。我想在这里向你展示的唯一一点是CPU。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_49.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_49.png)'
- en: You have to be limited that the other ones work。 So I will do a simple Python
    program that I have been doing since I learned to code。 That is just basically
    using all the CPU that I can。 So if you see right there is that I'm trying to
    use all the CPU that I can。 And if you see that nice number that doesn't go too
    much above 20， rounding stuff like that。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须有限制，以便其他东西能工作。所以我将做一个简单的Python程序，这是我学会编码以来一直在做的。基本上就是尽可能使用所有CPU。所以如果你看到那里，我正试图使用我能使用的所有CPU。如果你看到那个漂亮的数字，没有超过20，四舍五入之类的。
- en: Accounting is not really the best thing that you can do。 So it goes like that。
    And that's how you restrict。 And oh， I will do something。 I will try to overflow
    and turn。 And if you see there it says kill it。 So the Ummatini was also smart
    enough to know that this is the thing to kill because this。 is the one that is
    actually violating your things。 And I'm going to go to a nice stop here。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 会计并不是你能做的最好的事情。所以事情就是这样。这样你就可以限制了。哦，我会做点什么。我会尝试溢出并转动。如果你看到那里说杀掉它。所以乌玛蒂尼也聪明到知道这是需要杀掉的东西，因为这才是真正违反你规则的那个。我将在这里停一下。
- en: There are more things to know to show。 I just want to show the last thing but
    I want to explain it。 Oh， of course， of course， of course something has to be
    to go over and yeah， we're done。 Thank you。 That was it。 Honestly， I'm here for
    questions。 I'm just not on stage。 So。 ping me if you have anything。 Thank you
    guys for coming。 [APPLAUSE]。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多的事情需要了解。我只想展示最后一件事，但我想解释一下。哦，当然，当然，当然有事情必须被超越，是的，我们完成了。谢谢。这就是全部。老实说，我在这里是为了回答问题。我只是不在舞台上。所以，如果你有什么问题，请联系我。谢谢大家的到来。[鼓掌]。
- en: '![](img/c90a92fa1d2f34ba1a999222b1943e92_51.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90a92fa1d2f34ba1a999222b1943e92_51.png)'
