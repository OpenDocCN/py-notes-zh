- en: P8：RaymondHettinger-DataclassesThecodegeneratortoendallcodegenerators-PyCon2018
    - 哒哒哒儿尔 - BV1Ms411H7Hn
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P8：RaymondHettinger-数据类 终结所有代码生成器的代码生成器 - PyCon2018 - 哒哒哒儿尔 - BV1Ms411H7Hn
- en: Alright everyone， let's try and pack in， defrag yourselves if you can。 save
    some room on the end if possible。 It's going to be standing room only。 Alright。
    let's get started with the talk。 I'd like to introduce to you， Raven Headinger。
    Let's give him a round of applause。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，大家，让我们试着挤一挤，如果可以的话，整理一下，尽量在最后留出一些空间。现场将只有站立的空间。好的，让我们开始演讲。我想向你们介绍 Raven Headinger。请为他鼓掌。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_1.png)'
- en: '![](img/f533ae2bed1736499c0d9d25630db316_2.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_2.png)'
- en: '![](img/f533ae2bed1736499c0d9d25630db316_3.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_3.png)'
- en: It's Finks for Slides。 It's awesome。 It's the fastest， easiest way to make slides。
    So hello。 my name is Eric Smith， it's nice to meet you。 Usually when I stand up
    and talk。 I talk about something I wrote。 But now I'm talking about something
    that other people wrote and did a fantastic job at。 And I get to be the vehicle
    who hopefully does justice to their creation。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Finks for Slides。太棒了。它是制作幻灯片最快、最简单的方法。所以你好，我叫 Eric Smith，很高兴见到你。通常，当我站起来讲话时，我谈论的是我写的东西。但现在我讲的是其他人写的内容，而且他们做得非常出色。我希望我能成为那个能够公正表达他们创作的人。
- en: I prepared the talk as a "What is this all about？" Something for us to think
    about together。 What does this mean for us？ What does it do？ So I'd like this
    to be a thinking exercise for us as we look at it。 I'd like it to be a tutorial
    and I'd like my slides for you to be a recipe book of how to use it to a great
    effect。 So without further ado， let's see anything on this page。 Interesting。
    No， no， no， no， no， no， no。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我准备了这个演讲作为一个“这到底是怎么回事？”让我们一起思考的内容。这对我们意味着什么？它做了什么？所以我希望这是一个思考练习。当我们看这个时，我希望它成为一个教程，我希望我的幻灯片能成为如何高效使用它的食谱。因此，废话少说，让我们看看这个页面上的任何东西。有趣吗？不，不，不，不，不，不，不。
- en: Okay， on to interesting things。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，接下来是有趣的内容。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_5.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_5.png)'
- en: I'll start with the make file。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从构建文件开始。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_7.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_7.png)'
- en: '![](img/f533ae2bed1736499c0d9d25630db316_8.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_8.png)'
- en: '[laughter]， Introduction。 There we go。'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[笑声]，介绍。开始吧。'
- en: '![](img/f533ae2bed1736499c0d9d25630db316_10.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_10.png)'
- en: Rebuilding slides on stage。 All right。 So the title of the talk is the Code
    Generator to Endol- Code Generators。 What does the Code Generator do for you？
    You give it a list of specifications and it writes code for you。 Is that good？
    If your specifications are good and the code it generates is what you want。 then
    it's good。 If your specifications are bad， probably not going to work out so well。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在舞台上重建幻灯片。好的。这次演讲的主题是“终结所有代码生成器的代码生成器”。代码生成器为你做了什么？你给它一系列规范，它为你编写代码。这好吗？如果你的规范很好，而它生成的代码是你想要的，那么这就是好事。如果你的规范不好，可能就不太好。
- en: If the Code Generator does something different than what you expect it's going
    to do， not so well。 So when you work with Code Generators， your goal is to be
    in harmony with the Code Generator and think about its worldview。 because it's
    going to write code on your behalf。 In theory， you're unit testing everything
    you do。 but people tend to miss a fair number of cases that are covered well by
    this tool。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码生成器的行为与你预期的不同，那就不太好了。因此，当你使用代码生成器时，你的目标是与代码生成器保持一致，考虑它的世界观，因为它将代表你编写代码。理论上，你会对所做的每一件事进行单元测试，但人们往往会遗漏许多这个工具可以很好覆盖的情况。
- en: So it helps to really become one with this tool。 One of the things I'd like
    to name tuples is they have a near zero learning curve。 On the other hand， they
    had very limited capabilities。 So this is exactly the opposite situation。 The
    data classes module is the amount of code is several times larger than that for
    named tuples。 But it provides a much richer set of functionality。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，真的有助于与这个工具融为一体。我想命名元组的原因之一是它们几乎没有学习曲线。另一方面，它们的功能非常有限。因此，这正好是相反的情况。数据类模块的代码量比命名元组多出几倍，但它提供了更丰富的功能集。
- en: which means it's kind of an entire ecosystem of tools that are worked together
    in tools and possibilities。 One of the things that I really like were some excellent
    design choices were made so that right out of the box。 if you use it in the simplest
    possible way， it mostly does for you what you want it to do most of the time。
    But then it grows with you as you start to have more exotic needs。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它是一整套相互配合的工具和可能性。我真的很喜欢其中一些出色的设计选择，使得如果你以最简单的方式使用它，它大多数时候可以满足你的需求。但随着你开始有更多特殊需求，它也会与你共同成长。
- en: So why do we want a Code Generator？ Because it can save you time。 the time you
    would have spent writing that code is paid back right away。 Also。 Code Generators
    reduce wordiness。 A lot of Python classes， when people first learn Python。 they
    feel like there's a lot of boilerplate in there。 Writing the repper， writing the
    dunder in it。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们为什么需要代码生成器呢？因为它可以节省你的时间。你原本用来编写那段代码的时间会立即得到回报。此外，代码生成器减少了冗长。当人们第一次学习 Python
    时，很多 Python 类让他们觉得里面有很多模板化的内容。编写 repper、编写 dunder。
- en: writing a dunder EQ， writing a dunder hash， etc。 And that feeling of boilerplate
    never really goes away。 You get used to knocking out that code quickly， but you
    feel like that code isn't contributing the expression of your business logic。
    The idea of this Code Generator is to get you past that step。 Next question is
    what are data classes for？ It depends on who you ask。 There are two world views。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 dunder EQ、编写 dunder hash 等等。这种模板化的感觉并不会消失。你习惯于快速敲出那段代码，但你会觉得那段代码并没有贡献于业务逻辑的表达。这个代码生成器的理念就是帮助你跨过这一步。接下来的问题是，数据类的目的是什么？这取决于你问谁。有两种世界观。
- en: and of those two world views， the people who see it one way don't tend to see
    it another。 Those people who think data classes are primarily about data， which
    means I need a holder for data。 I need an aggregate data structure， something
    like a struct in another language。 If that is your world view， data classes support
    that world view。 They are data holders。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种世界观中，持有一种观点的人通常不容易看到另一种观点。那些认为数据类主要是关于数据的人，认为我需要一个数据的持有者。我需要一个聚合数据结构，类似于其他语言中的
    struct。如果这是你的世界观，数据类支持这一世界观。它们是数据持有者。
- en: But there's another world view that says I spend a lot of time writing classes
    putting interesting functionality in it。 and I'd like the boilerplate to go away
    so I could focus on the business logic。 If you think of it as a tool to help you
    write classes and you're going to write lots of methods anyway。 it just takes
    out the boilerplate for you， data classes are for you as well。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但是还有另一种世界观，认为我花了很多时间编写类并放入有趣的功能。我希望模板化的内容消失，以便我可以专注于业务逻辑。如果你将其视为帮助你编写类的工具，而你又将编写很多方法，它只会为你去掉模板化的内容，数据类对你来说也是合适的。
- en: The word data in data classes has to do with it being a data holder。 and the
    classes part has to do with it as a class generator。 It is both things。 and it
    means different things to different people at different times。 I'd like this to
    be a joint thinking exercise together for us to explore this。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类中的“数据”一词与其作为数据持有者有关，而“类”部分则与它作为类生成器有关。它是两者兼具的，意味着在不同的时间对不同的人有不同的含义。我希望这能成为我们共同思考的练习，以便深入探讨。
- en: and instead of me just putting in one way give you information。 I would like
    you to assess each piece as it comes to you。 Here's what to think about。 One of
    the things you want to learn is how to use the code generator。 Also。 when you
    use a code generator， the most critical thing to know is what code it writes for
    you。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是我只以一种方式给你信息。我希望你在收到每一部分时进行评估。你需要思考的其中一件事是如何使用代码生成器。此外，当你使用代码生成器时，最重要的是知道它为你编写了什么代码。
- en: One of the things that I really liked about name tuples， one of what I thought
    was a best feature。 was it had a verbose option， and when you used a name tuple
    it showed you the code that it wrote for you。 A benefit for that is no one ever
    had a question what code was written for me， ever。 On the other hand， no one has
    ever said anything nice to me about that feature ever。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的很喜欢命名元组的一个特点，我认为这是一个最佳功能。它有一个详细选项，当你使用命名元组时，它会向你展示为你编写的代码。这样一个好处是，没有人会对我编写的代码产生疑问。另一方面，没有人曾经对我说过这个功能的好话。
- en: Eric didn't copy that into data classes， and I took it out in Python 3。7。 so
    you no longer get to see the code that's generated unless you come to this talk。
    If you don't say that you like something it might disappear someday。 Alright。
    so what code does it write for you？ And the next question， even more important。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Eric 没有将其复制到数据类中，我在 Python 3.7 中删除了它。因此，除非你来参加这个讲座，否则你将不再看到生成的代码。如果你不说你喜欢某样东西，它可能会在某天消失。好吧，那它为你写了什么代码？接下来的问题，更加重要。
- en: once you know what code it writes to you， is that what you really wanted？ Sometimes
    yes。 sometimes no。 This is a somewhat opinionated data structure。 and it has some
    opinions that I really like， but they may not reflect your worldview at all。 And
    then any tool you essentially have to ask the question。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道它为你写了什么代码，这真的是你想要的吗？有时候是，有时候不是。这是一个有些主观的数据结构，它有一些我非常喜欢的观点，但可能完全不反映你的世界观。然后任何工具你都必须问这个问题。
- en: is the time spent invested learning the tool， teaching other people to use it
    and to read it。 is that worth the time that it saved you？ Some tools have an increase
    in complexity。 some have a net decrease in complexity， and like a rainbow， each
    person sees their own rainbow。 And whether this tool is beneficial for you or
    not， very much depends on your point of view。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 投入时间学习这个工具、教其他人使用它和阅读它，值得你节省的时间吗？一些工具增加了复杂性，另一些则减少了复杂性，就像彩虹一样，每个人看到的都是自己的彩虹。这个工具对你是否有益，确实很大程度上取决于你的观点。
- en: One challenge for me is I train lots of people， enormous numbers of people to
    use Python。 And these folks benefit a great deal by having the classes completely
    spelled out so that they can learn how Python operates。 the language teaches you
    what it does。 On the other hand， when they need to do it on their own。 they often
    don't do it well and leave parts out。 So if I introduce data classes to them。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，一个挑战是我训练很多人，数量庞大的人员使用 Python。这些人通过完全拼写类受益匪浅，这样他们就可以学习 Python 的运作方式。语言教会你它的作用。另一方面，当他们需要独立完成时，他们通常做得不好，遗漏了部分内容。所以如果我向他们介绍数据类。
- en: on the one hand， the likelihood of them doing it correctly the first time is
    very high。 On the other hand， the likelihood of them understanding what happens
    behind the scene goes down。 Imagine a world where you have used Python classes
    and have never written a dunder in it yourself。 never written a dunder hash， never
    written a dunder repper。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，他们第一次正确完成的可能性非常高。另一方面，他们理解幕后发生的事情的可能性却降低。想象一个你使用 Python 类却从未自己编写 dunder
    的世界，从未编写过 dunder hash，从未编写过 dunder repper。
- en: How would you even begin to comprehend this tool？ It is possible in an organization
    that if you adopt this tool wholesale。 all of the examples in the code won't have
    dunder in it's dunder reppers， dunder hash。 and so there's nothing to teach the
    users about what it does。 On the other hand。 education problems are problems that
    are easy to solve。 Have a tech talk for lunch。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你怎么能开始理解这个工具呢？在一个组织中，如果你完全采用这个工具，代码中的所有示例都不会在它的 dunder reppers、dunder hash 中有
    dunder。因此，没有任何东西可以教用户它的作用。另一方面，教育问题是容易解决的问题。举办一次午餐技术讲座。
- en: take a look at this tutorial and it will show you the code。 So if the engineering
    problem is we don't know something， the solution is just teaching it。 But I can't
    see in advance how it's going to work out in your world。 And also。 we have this
    realization that while it's nice to have a code generator saving its time writing
    code。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这个教程，它会向你展示代码。所以如果工程问题是我们不知道某件事情，解决方案就是教学。但我无法提前看到它在你们的世界中会如何运作。而且，我们意识到虽然有代码生成器节省了编写代码的时间是不错的。
- en: we spend more time reading and debugging code than we spend writing code。 So
    a question you want to ask yourself is this improve your debugging experience
    or does it make it worse？
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花在阅读和调试代码上的时间比编写代码的时间多。因此，你要问自己的一个问题是，这是否改善了你的调试体验，还是让它变得更糟？
- en: On the one hand， any tool that introduces an abstraction makes debugging worse
    because it hides something behind the abstraction。 On the other hand， if it automatically
    does a lot of things correctly for you and it's a well tested tool。 as this one
    is， usually your bug is somewhere else。 so it precludes those bugs being there
    to begin with。 But again。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，任何引入抽象的工具都会使调试变得更糟，因为它隐藏了抽象背后的内容。另一方面，如果它为你自动正确地完成很多事情，并且这是一个经过良好测试的工具，就像这个工具一样，通常你的错误在其他地方。因此，它预防了那些错误的存在。但是再一次。
- en: whether this is a net win for you or not really depends on your world view and
    what you're doing with it at the time。 So these are the questions you should ask
    yourself as it's coming up。 So I'm going to do something terrible here which is
    to quickly recount the history beginning up。 going up to the creation of data
    classes。 I've got Eric。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你来说是否是一个净收益，真的取决于你的世界观以及当时你在做什么。所以这是你在这个问题出现时应该问自己的问题。因此，我将在这里做一些可怕的事情，迅速回顾从起源开始的历史，直到数据类的创建。我有**埃里克**。
- en: the creator of the tool here to correct me on any of this。 but this is a dangerous
    undertaking because the last time I did it。 I left someone out and they were quite
    angry about it。 So they are now included in this one。 That said， history is quite
    difficult because there are very few new ideas under the sun。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 工具的创造者在这里纠正我关于这些内容的任何说法，但这是一个危险的工作，因为上一次我这样做时，遗漏了某个人，他们对此相当生气。所以他们现在被包括在内。话虽如此，历史是相当困难的，因为阳光下几乎没有新想法。
- en: Every time we think we've done something original。 you don't have to look too
    far back in time to where someone else had the same problem and came up with the
    solution。 This might be the first time all the pieces were put together。 So in
    a very brief history of time。 probably omitting some people， in the beginning，
    there were dicks， tuples and handwritten classes。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们认为自己做了原创的事情时，回顾过去，你会发现其他人也曾面临同样的问题并找到了解决方案。这可能是所有要素第一次被整合在一起。因此，在一个非常简短的时间历史中，可能省略了一些人，一开始有**元组**、**元组**和**手写类**。
- en: We used Dickshires for lookups， tuples for structures and handwritten classes
    when we wanted more functionality and the world was just fine。 Later， we added
    a code generator for you， named tuples。 It wrote some code for you that essentially
    its goal was to take a tuple and add names to the fields。 To this end， it succeeded。
    However， if you wanted something else。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**Dickshires**进行查找，使用**元组**构建结构，当我们想要更多功能时则使用手写类，那个世界就很不错。后来，我们为你添加了一个代码生成器，命名元组。它为你写了一些代码，其基本目标是将一个元组添加字段名。为此，它成功了。然而，如果你想要其他东西的话。
- en: like not having a tuple underneath the hood， of course it didn't work too well
    for you because it's a named tuple。 If you hate tuples， then you're not going
    to like named tuple as well。 Tuples being un-mutable。 being un-packable， being
    hashable might be things that you want or might not。 Later。 we got something called
    type simple namespace， which is just a very quick way to make a data holder。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在底层没有元组一样，当然这对你来说并不太好，因为它是一个命名元组。如果你讨厌元组，那你也不会喜欢命名元组。元组不可变、不可打包、可哈希可能是你想要的特性，也可能不是。后来，我们得到了一个叫做**类型简单命名空间**的东西，这只是一个快速创建数据持有者的方式。
- en: As far as being a code generator， it generates very， very little for you。 but
    a lot of people really like it because it's so lightweight。 On the opposite end
    of the lightweight scale， we had ORMs， things like Django， SQL， Alchemy， PWE。
    As far as I know， these were the tools that pioneered using field specifications
    to generate more complex data structures behind the scene。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 就代码生成器而言，它为你生成的内容非常、非常少，但很多人喜欢它，因为它非常轻量。在轻量级的另一端，我们有**ORM**，像**Django**、**SQL**、**Alchemy**、**PWE**这样的东西。就我所知，这些工具开创了使用字段规范在后台生成更复杂数据结构的先河。
- en: I know ORM being something， you make a class with field specifications and it
    generates the database behind the scenes for you。 That's fantastic。 Another tool
    that is very old and famous in the Python world is the Traitlets module。 Traitlets
    was all about validating data as it came in。 Traitlets was well-loved。 not as
    popular as some of these new tools， but it was very good at its job。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道ORM是这样的，你创建一个带有字段规范的类，它会在后台为你生成数据库。这真是太棒了。另一个在Python世界中非常古老且著名的工具是**Traitlets模块**。Traitlets专注于验证输入的数据。Traitlets非常受欢迎，虽然没有一些新工具那么流行，但它在自己的工作中做得很好。
- en: It pioneered the idea of using class variables for specifications of what should
    go in data or whatnot。 In the past few versions of Python， we've gone through
    this evolution of adding type annotations to the language。 First， we just had
    a notation for attaching it directly to a function or a class。 In it was inert。
    It didn't do anything。 Later， we got the typing module and third-party tools like
    MyPy that could scan all of the types and perform static typing checking for you。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 它开创了使用类变量来指定数据应包含的内容的理念。在过去的几个Python版本中，我们经历了将类型注释添加到语言中的演变。起初，我们只是有一个将其直接附加到函数或类的符号。它是惰性的，没有任何作用。后来，我们得到了typing模块和像MyPy这样的第三方工具，可以扫描所有类型并为你进行静态类型检查。
- en: Then Quito and Lisa Roach worked together on a PEP to create a new and clean
    syntax for it。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后基托和丽莎·罗奇一起合作制定了一个PEP，以创建一个新的干净语法。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_12.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_12.png)'
- en: As of Python 3。6， you can just write visitor count in to essentially declare
    without creating this variable just declaring its data type。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.6开始，你可以简单地写visitor count，以本质上声明它，而不需要创建这个变量，只需声明它的数据类型。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_14.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_14.png)'
- en: That was a beautiful notation。 There was also a third-party module library called
    Adters。 I am not a user of the Adters module， but I know it's very popular and
    it was an inspiration for data classes。 I put all of these things together。 It
    was time to put in some standard library support and Eric foolishly volunteered。
    He thought， "How hard could it be？ Did you end up putting a little effort into
    a Derek？"。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个美丽的符号。有一个第三方模块库叫做Adters。我不是Adters模块的用户，但我知道它非常受欢迎，并且它为数据类提供了灵感。我把这些东西都结合在一起。是时候添加一些标准库支持了，埃里克愚蠢地自愿了。他想，“这会有多难？你最后是否投入了一点精力在德里克上？”
- en: Over 100 hours？ Over 200 hours？ Over 200 hours？ And he's not done yet。 I've
    developed a number of collections classes before and I know they live with you
    forever。 You will have a lifetime of feature requests for this for everything
    you decided not to do。 Someone will request it。 For every design decision where
    you went left。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 超过100小时？超过200小时？超过200小时？而且他还没有完成。我以前开发过许多集合类，我知道它们会伴随你一辈子。你将会面临终生的功能请求，针对你决定不做的每一件事情。有人会请求它。对于你选择向左走的每一个设计决策。
- en: someone will argue that you should have gone right。 There will be bugs in there
    that you cannot have imagined at this phase。 And five years from now。 somebody
    will go， "It's too slow。 We need to write the whole thing in C。 Someone will protest
    that it uses the exact inside。"， And in fact， it does。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有人会争辩说你应该直接这样做。这里会有你在这个阶段无法想象的bug。五年后，某人会说，“太慢了。我们需要用C重新写整个东西。”有人会抗议它使用了确切的内部。“事实上，它确实如此。”
- en: And you will never get any love for it except for right now。 We love you for
    what you did。 It was really a magnificent thing。 [applause]， I do have some good
    news for you based on my history in Python。 Every year that I contributed something
    useful to the language， Quito came to talk to me and said。 "I really liked it。"，
    He said， "I'll double your salary。" And for 18 years。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了现在，你永远不会获得任何认可。我们爱你所做的事情。这真是太壮观了。[掌声]，根据我在Python中的历史，我有一些好消息给你。每年我为语言贡献有用的东西，基托都会来找我，说，“我真的很喜欢。”他说，“我会加倍你的薪水。”在18年里。
- en: every year he's doubled my salary。 [laughter]， Being an open source contributor
    pays really。 really well not。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每年他都给我加倍薪水。[笑声]，成为开源贡献者真的很好。真的很好。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_16.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_16.png)'
- en: Okay。 The goals of this， according to the PEP， data classes are roughly， very
    roughly。
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，根据PEP的说法，数据类大致上，非常粗略地说。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_18.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_18.png)'
- en: a mutable name tuple with defaults。 There's more to it than that。 but if you
    need to file it away in your law of mind with one little phrase， "What is it？
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有默认值的可变命名元组。这不仅仅是这样，但如果你需要用一个小短语将其归档在你的脑海中，“这是什么？”
- en: '" that''s an answer。 It built on the success of the adders package。 It writes
    boilerplate code for you， and it provides an elegant syntax for data holders。
    Okay。 I''m done。 Any questions？ Oh， would you like to see it？ All right。'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: “这是一个答案。它基于adders包的成功。它为你编写样板代码，并为数据持有者提供优雅的语法。好的，我说完了。有问题吗？哦，你想看看吗？好的。”
- en: '![](img/f533ae2bed1736499c0d9d25630db316_20.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_20.png)'
- en: I'm kind of section comparing it with named tuples。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在将其与命名元组进行比较。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_22.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_22.png)'
- en: I would like this to have been a talk that was only about data classes and not
    named tuples。 but named tuples is what people know。 And the first question that
    comes to mind when you use data classes is。 "What's different？" And， "What's the
    same？" So the goal of this is to answer that。 and the goal is to hit， "What is
    the common case？"， The simplest case of using the data classes。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这次演讲只关于数据类，而不是命名元组。但命名元组是人们所知道的。当你使用数据类时，首先想到的问题是。“有什么不同？”还有，“有什么相同？”所以这次演讲的目标是回答这个问题，并且目标是探讨“什么是常见情况？”，使用数据类的最简单情况。
- en: So without further ado， here is a data class。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，事不宜迟，这里是一个数据类。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_24.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_24.png)'
- en: '![](img/f533ae2bed1736499c0d9d25630db316_25.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_25.png)'
- en: and the goal is to store a color in the HSL system， storing the hue， the saturation，
    and lightness。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是将颜色存储在 HSL 系统中，存储色相、饱和度和亮度。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_27.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_27.png)'
- en: He used the number of degrees on the color wheel。 Saturation and lightness are
    typically expressed as a floating point number percentage of a saturation。 So
    the way you make that using a data class is you use a class decorator at data
    class。 You write a normal class。 You use that notation created by Lisa and our
    quido to indicate that。 hue is an integer。 And saturation is a float。 One really
    nice thing is you can specify default value for the float。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 他使用了颜色轮上的度数。饱和度和亮度通常表示为浮点数百分比的饱和度。因此，使用数据类的方式是你使用类装饰器在数据类上。你编写一个普通的类。你使用丽莎和我们的quido创建的符号来指示。色相是一个整数，而饱和度是一个浮点数。一个非常好的地方是你可以为浮点数指定默认值。
- en: Let's compare that to the name tuple version。 You also have to do an import。
    And these three lines are exactly the same as these three lines。 So the only part
    that is different is instead of at data class。 you have an inherit from named
    tuple。 So do they look very structurally very similar to each other？
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其与命名元组版本进行比较。你也必须做一个导入。这三行与这三行完全相同。所以唯一不同的部分是，而不是在数据类中，你是从命名元组继承的。那么它们在结构上看起来是否非常相似？
- en: I agree。 One of the questions we are going to ask ourselves is， "Is it easy
    to use？"。 This is somewhat beautiful and elegant。 It's a nice way to specify a
    data holder。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我同意。我们要问自己的一个问题是，“它使用起来容易吗？”这在某种程度上是美丽而优雅的。这是指定数据持有者的一个很好的方式。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_29.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_29.png)'
- en: So so far， the only evident distinction is that there's a complete difference
    in approach。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，唯一明显的区别是方法上有完全不同的处理方式。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_31.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_31.png)'
- en: Data classes use a class decorator and named tuples inherited class that has
    a different meta class。 that goes in and fills in all of the values for you。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类使用类装饰器，而命名元组继承一个具有不同元类的类。它会进入并为你填充所有的值。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_33.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_33.png)'
- en: So how do you work with this data class？
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你如何使用这个数据类？
- en: '![](img/f533ae2bed1736499c0d9d25630db316_35.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_35.png)'
- en: Well， you create an instance of it， much as you would as a name tuple。 Which
    raised the question？
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，你创建它的实例，就像你会做命名元组一样。这引出了一个问题？
- en: I passed in two arguments。 How many arguments are there in the HSL system？ H，
    SNL？
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我传入了两个参数。HSL 系统中有多少个参数？H，SNL？
- en: It's not intended to be a hard question。 Three。 Okay。 Where did the third one
    come from？
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个困难的问题。三个。好的。第三个来自哪里？
- en: '![](img/f533ae2bed1736499c0d9d25630db316_37.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_37.png)'
- en: Not intended to be a hard question。 I'm pointing at the answer。 Okay。 So there
    was a default value。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个困难的问题。我指向答案。好的。所以有一个默认值。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_39.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_39.png)'
- en: So one of the nice features of it is the wrapper came for free。 And it shows
    you how it was made and it gives you a self-explanatory look。 This greatly helps
    during debugging。 Also， it lets you access the fields by name。 This is really
    nice。 If you've ever worked with straight tuples and have to refer to。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它的一个不错的特性是包装器是免费的。它向你展示了是如何制作的，并给你一个自我解释的外观。这在调试过程中非常有帮助。此外，它允许你按名称访问字段。这真不错。如果你曾经使用过普通的元组并不得不引用。
- en: square brackets three or square brackets zero， you'll find that this is a great
    improvement。 Can you build one of them off of another？ There's a function called
    replace that takes in a instance of a data class。 and lets you replace one or
    more fields。 This says model off of one color and make another color。 This color
    has the same saturation and lightness but a different hue。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号三个或方括号零，你会发现这是一个很大的改进。你能否从另一个构建其中一个？有一个名为`replace`的函数，它接受一个数据类的实例，并让你替换一个或多个字段。这表示从一种颜色生成另一种颜色。这种颜色具有相同的饱和度和亮度，但色调不同。
- en: So we're just spinning it around the color wheel。 So we also have the ability
    to turn it into a regular dictionary。 This is important。 Conceptually， anything
    that's a key value store should be easy to turn into a dictionary。 However， this
    thing is ordered like a tuple and once in a while you're going to want to unpack
    it。 or use it in a tuple circumstance。 This gives you the ability to convert it
    back into a tuple if you need。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们只是围绕颜色轮旋转。因此我们还可以将其转换为常规字典。这一点很重要。在概念上，任何键值存储都应该容易转换为字典。然而，这个东西像元组一样是有序的，而且偶尔你会想要将其解包或在元组的情况下使用它。如果需要，这可以让你将其转换回元组。
- en: One of the nice things about data classes is it builds type annotations for
    you so we can record some information。 some metadata about the class。 Here's something
    new。 You can assign a value to it。 Our data classes by default， mutable or immutable。
    Mutable。 Hey。 who remembers the name of my company？
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类的一个好处是它为你构建类型注释，这样我们可以记录一些信息，一些关于类的元数据。这是一些新内容。你可以为它赋值。我们的数据类默认是可变的或不可变的。可变的。嘿，谁还记得我公司的名字？
- en: '![](img/f533ae2bed1736499c0d9d25630db316_41.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_41.png)'
- en: Mutable minds。 All I need to teach people is to have people in the audience
    with mutable minds。 If you have an immutable mind， get out。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 可变的思维。我需要教给人们的就是让听众拥有可变的思维。如果你有一个不可变的思维，那就离开吧。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_43.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_43.png)'
- en: And so if I'm going to build a student， I want to use data classes for it because
    I need them to be mutable。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我要构建一个学生，我希望使用数据类，因为我需要它们是可变的。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_45.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_45.png)'
- en: so I can put in new information。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我可以输入新信息。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_47.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_47.png)'
- en: Now let's see how big it is。 Import sys and we'll see that this instance is
    168 bytes。 I'd also like to use time it to see how fast does it take to access
    the hue。 By default。 this does a million iterations so we're looking at 33 nanoseconds
    here on my 5-year-old machine。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看它的大小。导入sys，我们会看到这个实例是168字节。我还想使用`time`来看看访问色调需要多快。默认情况下，这会进行一百万次迭代，因此在我这台五年的旧机器上，我们看到的是33纳秒。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_49.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_49.png)'
- en: '![](img/f533ae2bed1736499c0d9d25630db316_50.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_50.png)'
- en: Now let's compare that with working with a name tuple。 Notice we make the color
    the same way。 Notice it has the same appearance。 Notice that it has the same field
    name access。 But now we get to a difference。 One difference is that in name tuples。
    the methods start with an underscore。 I regret this choice。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将其与命名元组进行比较。请注意，我们以相同的方式创建颜色。请注意，它具有相同的外观。请注意，它具有相同的字段名称访问。但现在我们遇到了一个区别。一个区别是，在命名元组中，方法以下划线开头。我对这个选择感到遗憾。
- en: I wish I had still used an underscore but a trailing underscore。 But because
    this has a stretch。 a strong hint that it's a private method。 It's not private
    at all。 It was just put in there to prevent a namespace conflicts with actual
    fields named a replace。 So this is not pretty but it does have an advantage。 It's
    discoverable。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望我仍然使用下划线，但用一个尾随下划线。但因为这个有一个延展，强烈暗示它是一个私有方法。其实它并不私有。它只是在那里以防与实际字段名`replace`发生命名空间冲突。所以这看起来不漂亮，但确实有一个优点。它是可发现的。
- en: If you do a dir of the object， you'll see this method。 But if you do a dir of
    the data class。 you won't see the functions that operate on it at all。 This is
    a normal relationship between objects and our methods and functions。 So as dict
    is also a method and here's a difference， it returns an ordered dict。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对对象执行`dir`，你会看到这个方法。但是如果你对数据类执行`dir`，你将完全看不到操作它的函数。这是对象与我们的方法和函数之间的正常关系。因此，作为方法的字典（dict）有一个区别，它返回的是有序字典。
- en: We would actually like to switch that to return a regular dict but there's a
    chance that people rely on it being an ordered dict。 So I'm going to have to go
    through a deprecation cycle before I can actually switch this to a regular dict。
    So in this case， data classes will lead us because they don't have any legacy
    code to model after。 And if you want to turn something into a tuple， it's the
    same way as you turn it into a list。
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上想将其切换为返回一个常规字典，但人们可能依赖于它是一个有序字典。因此，我需要经过一个弃用周期才能将其切换为常规字典。所以在这种情况下，数据类会引领我们，因为它们没有任何需要遵循的遗留代码。如果你想将某个东西转换为元组，方法和转换为列表是一样的。
- en: Its annotations are exactly the same。 Here's a superpower of named tuples that
    data classes don't have。 They unpack。 Can you do that with data classes？ The answer
    is yes but you have to first wrap this in a call to as tuple。 Which is a quite
    reasonable thing unless you're going to be doing this a lot。 If we check the size
    of this instance， it's significantly smaller， only 72 bytes versus the 168。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它的注解是完全相同的。这是命名元组的一项超能力，而数据类没有。它们可以解包。你能用数据类做到这一点吗？答案是可以，但你必须先将其包装在调用 `as tuple`
    中。这是一个相当合理的事情，除非你需要频繁这样做。如果我们检查这个实例的大小，它明显更小，只有72字节，而168字节。
- en: Unfortunately， if we run a timing on it， the name tuple field access is slower
    by quite a bit。 61 nanoseconds。 I do have a fix for this but I wasn't able to
    get it into 3/7。 Really only 15 minutes？ Oh my goodness， we will speed up。 So
    I have a fix for this so as of 3/8。 I can make this access faster than data classes
    but it's going to take some C code to do it。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果我们对其进行计时，命名元组的字段访问速度慢了不少，61纳秒。我确实有一个修复方法，但没能在3/7中完成。真的只需要15分钟？哦我的天，我们会加快速度。因此，从3/8开始，我可以使这个访问速度超过数据类，但这需要一些C代码来实现。
- en: Running through property and item getter is pretty fast but not as fast as this
    one up here。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过属性和项目获取器的运行速度相当快，但不如上面这个快。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_52.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_52.png)'
- en: So here's the summary of all of the differences。 We have a replace function
    in a data class。 It's a replace method。 As dict is a function instead of a method。
    We get a regular dict instead of an ordered dict。 The method versus function again。
    Data classes are immutable。 Name tuples are immutable or frozen。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是所有差异的总结。数据类中有一个替换函数。它是一个替换方法。而字典是一个函数而不是一个方法。我们得到一个常规字典而不是有序字典。方法与函数之间的区别。数据类是不可变的。命名元组是不可变的或冻结的。
- en: Data classes can't be hashed by default。 In general。 that's a good thing because
    we don't know in advance whether you're going to put hashable fields inside。 Whereas
    name tuples presume that you're putting something hashable inside。 By default。
    they don't iterate which means that you can't unpack them。 By default。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类默认情况下无法被哈希。一般来说，这是一件好事，因为我们无法提前知道你是否会放入可哈希的字段。而命名元组则假设你会放入某些可哈希的内容。默认情况下，它们不能被迭代，这意味着你无法解包它们。默认情况下。
- en: they have no comparison methods whereas name tuples sort just like tuples。 They
    have a different underlying data store。 The data is stored in an instance dict
    for data classes and it's stored in a tuple for name tuple。 The size of the data
    class is more than twice as large。 On the other hand。 it's more than twice as
    fast。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它们没有比较方法，而命名元组则像元组一样进行排序。它们有不同的底层数据存储。数据类中的数据存储在实例字典中，而命名元组中的数据存储在元组中。数据类的大小超过两倍。而另一方面，速度也超过两倍。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_54.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_54.png)'
- en: If you'd like a quick rundown of all differences， it is on this table。 Alright。
    so let's go look at the code that gets generated。 So here was a common case that
    we just looked at。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想快速了解所有差异，可以查看这张表。好吧，让我们看看生成的代码。我们刚才查看了一个常见的案例。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_56.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_56.png)'
- en: '![](img/f533ae2bed1736499c0d9d25630db316_57.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_57.png)'
- en: This is the code you write。 What do you get for that？ What does it do for you？
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你编写的代码。你能得到什么？它对你有什么帮助？
- en: '![](img/f533ae2bed1736499c0d9d25630db316_59.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_59.png)'
- en: Well， as we look below， we'll find the code that it generated。 And the most
    important part is these first of this top section up here。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，当我们查看下面时，我们会发现它生成的代码。最重要的部分是上面这个顶部区域的前面部分。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_61.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_61.png)'
- en: So let's see what we get。 Like name tuples， it gives you a nice doc string。
    In fact。 the same doc string。 I really like that it's under init。 It has a type
    annotations built directly inside so it's introspectable。 It has a nice wrapper
    and the wrapper is exactly what you would write by a hand except that a lot of
    people would leave off a dull name。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们看看我们得到了什么。像名称元组一样，它给你一个很好的文档字符串。实际上，是相同的文档字符串。我真的很喜欢它在初始化下。它直接内置了类型注解，因此是可内省的。它有一个不错的封装，封装正是你手动写的内容，只是很多人会省略一个无聊的名称。
- en: This is a case of the generated code being nicer than what most people would
    write by hand。 It's incorporating a best practice for you。 The equal method is
    really interesting。 What name tuples would do is this comparison here on the second
    line。 It's what most classes would do。 This one is somewhat interesting though。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成的代码比大多数人手动写的代码更好的一个例子。它为你整合了最佳实践。相等方法非常有趣。名称元组会在第二行进行这样的比较。这是大多数类会做的。然而，这个例子稍微有点有趣。
- en: It checks to see if the other method is of the other object is of the same class。
    So it refuses to compare apples to oranges。 This gives us a much stronger relationship
    between types。 It's something that I wish had been done for enums because it is
    possible now for us to have the enum color red equal one be equal to an enum size
    small。 medium and large where small is one。 And of course those things should
    be non-comparable and so this best practice is built into data classes by default。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它检查另一个方法的对象是否属于同一类。因此，它拒绝将苹果与橘子进行比较。这在类型之间建立了更强的关系。我希望对枚举也这样做，因为现在可能存在枚举颜色红色等于一个与枚举大小小型、中型和大型，其中小型为一的情况。当然，这些东西应该是不可比较的，因此这种最佳实践默认内置于数据类中。
- en: And I think this is a really nice win。 It's something most people wouldn't think
    to do but it will improve code quality and help you avoid some really hard to
    find bugs。 Another thing that people commonly forget is whenever you write an
    equality method you also need to say something about hashing。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这是一个非常好的胜利。这是大多数人不会想到的事情，但它会提高代码质量，帮助你避免一些难以发现的错误。人们常常忘记的另一件事是，每当你编写一个相等方法时，你也需要说一些关于哈希的内容。
- en: And so this makes a fairly bold statement。 I'm not hashable at all。 What would
    happen if this were left out？ It would hash but it would compare on identity。
    And for a lot of people that is a surprise and it's rarely what you want。 So once
    again data classes are making a choice for you that is mostly what you want most
    of the time whether you knew it or not。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明了一个相当**大胆**的声明。我根本不可哈希。如果这被省略了，会发生什么？它会被哈希，但会根据身份进行比较。对很多人来说，这是个惊喜，而且这通常不是你想要的。因此，再次强调，数据类为你做出了选择，这通常是你大多数时候想要的，无论你是否意识到。
- en: So I think we can conclude at this point how much work did it save you？
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我们可以在这一点上得出结论，这为你节省了多少工作？
- en: You wrote four lines of code。 What did it write for you？
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你写了四行代码。它为你写了什么？
- en: It wrote about nine lines of code or ten lines of code。 So there's about a six
    line of code savings but along the way it improved quality by doing things that
    other people forget。 By making a tighter checks， making a higher quality repper
    and adding type annotations which are things that will forget。 So I think of the
    win in terms of code saved being very minor here but the win in terms of quality
    by default is a nice win。
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它写了大约九行或十行代码。所以大约节省了六行代码，但在此过程中，它通过做其他人忘记的事情来提高质量。通过进行更严格的检查，制作更高质量的封装并添加类型注解，这些都是人们会忘记的事情。因此，我认为在节省代码方面的胜利非常微小，但在质量方面的默认胜利是一个不错的胜利。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_63.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_63.png)'
- en: There's also all of this other stuff down here and I'm trying to avoid a pejorative
    term junk。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有其他所有东西，我试图避免使用贬义词“垃圾”。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_65.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_65.png)'
- en: It is not junk。 It supports introspection of the class。 But it looks junky in
    the help。 So one of the nice things is it records the parameters for you。 It tells
    you how the data class was built。 This is really nice。 Lots of other code generators
    leave this information out and you have to guess what parameters we used to make
    them。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是垃圾。它支持类的内省。但在帮助中看起来有些杂乱。因此，一个不错的地方是它为你记录参数。它告诉你数据类是如何构建的。这真的很好。很多其他代码生成器都没有提供这些信息，而你必须猜测我们用了什么参数来构建它们。
- en: In addition， it has detailed information about each field and including the
    metadata。 So if you were writing the code by hand， you would probably have written
    only about our seven lines of this。 If you were smart in doing it， you would have
    written all of these lines。 Almost certainly though。 you wouldn't have written
    any of this and this stuff is actually left in your class and when you're handwriting
    code。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还提供每个字段的详细信息，包括元数据。因此，如果你手动编写代码，可能只会写出大约七行。如果你做得聪明，你会写出所有这些行。但几乎可以肯定的是，你不会写出这些内容，这些内容实际上是留在你的类中的，而当你手动编写代码时。
- en: you would probably have never put these attributes in there。 Interestingly。
    this one actually creates a class variable for you。 So you now have a class variable
    and an instance variable that might disagree with each other。 Not really problematic
    but different from what we would write by hand。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能从来没有把这些属性放进去。有趣的是，这个实际上为你创建了一个类变量。所以你现在有一个类变量和一个实例变量，可能彼此不一致。这并不是真正的问题，但与我们手写时不同。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_67.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_67.png)'
- en: So the interesting points are it matches our handwritten code for three of the
    methods。 The doc string matches what you would write by hand。 Equality comparison
    does an exact match。 Head is set to none so you don't get accidental hash ability。
    Generated code includes everything from the original plus the default as a class
    variable。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的地方在于，它与我们手写代码的三个方法相匹配。文档字符串与手动编写的内容相匹配。相等比较是完全匹配的。头部设置为 None，这样你就不会意外地获得哈希能力。生成的代码包括原始代码的所有内容以及作为类变量的默认值。
- en: Probably not what you want and some nice introspection whose only downside is
    it looks a little bit junky in the help。 And that is the common case。 Who wants
    uncommon cases？ That's good。 How many minutes do I have left for uncommon cases？
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是你想要的，还有一些很好的反思，唯一的缺点是它在帮助中看起来有点杂乱。这是常见的情况。谁会想要不常见的情况呢？这很好。我还有多少分钟来处理不常见的情况？
- en: So one of the really nice things about data classes that makes them a little
    bit more complex or more complex than all the other code generators in Python。
    is it allows extensive customization。 So all the things I said it didn't do by
    default。 some of them it does but you have to say what you want。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类的一个真正不错的特点是，它使其比其他所有 Python 代码生成器更加复杂或复杂，它允许广泛的定制。因此，我之前提到的默认情况下不执行的某些操作，有些它确实可以做到，但你必须明确说明你想要什么。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_69.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_69.png)'
- en: So to extend this example we are going to cover freezing and order。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展这个例子，我们将讨论冻结和排序。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_71.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_71.png)'
- en: So data classes are by default mutable。 This is a nice benefit。 On the other
    hand you can't use it as a set element or as a dictionary key which often is what
    we want。 Also they are not orderable which means that you can't sort this in some
    nice consistent print order。 But if you need these all you have to do is say what
    you want。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类默认是可变的。这是一个不错的好处。另一方面，你不能将其用作集合元素或字典键，这通常是我们想要的。此外，它们是不可排序的，这意味着你不能以某种良好的一致性打印顺序进行排序。但如果你需要这些，只需说明你想要什么。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_73.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_73.png)'
- en: So the only change to our previous recipe is saying order equal true and frozen
    equal true。 Who thinks it's kind of nice？ You can just say what you want and get
    it。 And if you don't say what you want you get what you usually need。 This is
    a really nice benefit。 The only problem from this is if you think that the default
    is something that what it actually is。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的示例唯一的变化是将 order 设置为 true 和 frozen 设置为 true。谁觉得这挺好的？你只需说明你想要的就可以得到它。如果你不说明你想要什么，你就会得到你通常需要的。这是一个很好的好处。唯一的问题是，如果你认为默认值与实际情况不同。
- en: if you're testing you'll learn it the hard way。 On the other hand there's some
    really nice tool tips that go along with this。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在测试，你会吃到苦头。另一方面，有一些很不错的工具提示可以与此一起使用。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_75.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_75.png)'
- en: So now let's use that new data class。 It's pretty easy。 This time I make four
    colors and we can now do something new with them。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用那个新的数据类。这很简单。这次我创建了四种颜色，我们现在可以用它们做一些新东西。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_77.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_77.png)'
- en: We can sort them。 Previously that wasn't possible。 Also we can make a set of
    the colors which eliminates the two duplicate colors the one at 66 degrees and
    75% saturation。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对它们进行排序。之前这是不可能的。同时我们可以生成一个颜色集合，从而消除在 66 度和 75% 饱和度下的两个重复颜色。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_79.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_79.png)'
- en: These two capabilities were previously not there。 If you need those capabilities
    are they easy to turn on。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个功能之前是不存在的。如果你需要这些功能，它们是否容易启用。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_81.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_81.png)'
- en: '![](img/f533ae2bed1736499c0d9d25630db316_82.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_82.png)'
- en: Yeah， which is a fairly nice win。 Now back to the question how much work does
    this save you。 In this case a lot more。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这真是一个相当不错的收获。现在回到问题，这节省了你多少工作量。在这种情况下，节省了更多。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_84.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_84.png)'
- en: So there are several comparison methods that get written for you。 These are
    no fun to write by hand。 We already had a solution for that problem in Func Tools
    Total Ordering also implemented as a class decorator。 However it didn't have this
    by default this stronger check to make sure that the classes are the same to prevent
    accidental comparison。 Another interesting thing is when we made it frozen we
    wanted to be immutable so you can't write to it or delete an attribute。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所以有几个比较方法会为你编写。这些手动编写是非常麻烦的。我们在 Func Tools 的全序中已经有了这个问题的解决方案，也是作为类装饰器实现的。然而，它默认没有这个更强的检查，以确保类相同，以防止意外比较。另一个有趣的事情是，当我们使它变为不可变时，我们希望它是不可更改的，因此你不能对其写入或删除属性。
- en: So this is fantastic。 There's a number of ways to achieve that。 One is through
    a meta class。 Another is quite common in the Python world。 If you look at the
    fractions module we make the numerator and denominator un-ritable。 The way we
    do so is by using a read-only property。 In this case though we extend set adder。
    Something fairly interesting when you compare these。 The ones here at the top
    don't call super。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这真是太棒了。有很多方法可以实现这一点。一种是通过元类。另一种在 Python 世界中相当常见。如果你查看分数模块，我们让分子和分母无法写入。我们这样做的方式是使用只读属性。不过在这种情况下，我们扩展了集合加法器。比较这些时，有一点相当有趣。顶部的这些方法不调用
    super。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_86.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_86.png)'
- en: We don't really want them to because a parent class object will return， I forget
    what it returns。 none or not implemented or something like that。 So we really
    don't want to call those there。 But set adder and a day letter we actually really
    do mostly want what the parents have。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们其实不希望它们调用，因为父类对象会返回，我忘了返回什么。可能是 none 或未实现之类的。所以我们真的不想在这里调用它们。但集合加法器和日期字母我们实际上大多希望继承父类的属性。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_88.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_88.png)'
- en: So if you're attempting to modify one of the fields that is blocked it will
    go ahead and raise an exception。 Otherwise it will go ahead and call the parent
    which means that a class can be partially writeable。 So this is really nice。 This
    is beyond the code here is beyond the skill level of most everyday Python programmers
    so they're getting a really nice win for this。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你尝试修改一个被阻止的字段，它会引发异常。否则，它会调用父类，这意味着一个类可以部分可写。这真的很好。这段代码超出了大多数日常 Python 程序员的技能水平，所以他们为此获得了很大的好处。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_90.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_90.png)'
- en: '![](img/f533ae2bed1736499c0d9d25630db316_91.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_91.png)'
- en: Also it's fairly common for people to be challenged in writing and underlying
    hash function and by default it includes all of the fields。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，人们在编写底层哈希函数时常常会遇到挑战，默认情况下它包含所有字段。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_93.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_93.png)'
- en: So what were the interesting points here？ In a way this is better than Funke
    Tools Total Ordering because it's type specific。 We can't call super for the comparison
    methods because object has ones that we don't want。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这里有什么有趣的点呢？从某种程度上说，这比 Funke Tools 的全序更好，因为它是特定类型的。我们不能为比较方法调用 super，因为对象有一些我们不想要的比较方法。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_95.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_95.png)'
- en: The frozen behavior is implemented in an interesting way by extending get adder
    and day letter。 This is different from what most people would write by hand like
    what you see in the fractions module。 So these extended methods do call super
    so that we don't accidentally turn off an important behavior in the parent class。
    And the hatch method does write what you match what you would write by hand。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 冻结行为通过扩展获取添加器和删除器以有趣的方式实现。这与大多数人手动编写的代码不同，比如你在分数模块中看到的。因此，这些扩展方法确实调用超类，以便我们不会意外关闭父类中的重要行为。并且
    hatch 方法确实写下了你手动编写的内容。
- en: As a quick comparison to name tuples all of these behaviors come for free because
    they're inherited for tuple。 And the ones in tuple are written in C so they're
    quite a bit faster so you get all of these behaviors。 Which would make you think
    that for something that's frozen named tuple might be what you wanted to begin
    with。 And I believe that that is mostly true。 However the world's more complex
    than that。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 快速比较一下，所有这些行为都是免费的，因为它们继承自元组。元组中的方法是用C语言编写的，因此它们的速度相当快，因此你可以获得所有这些行为。这会让你认为，对于一个被冻结的命名元组，这可能是你一开始想要的。我认为这在很大程度上是正确的。然而，世界比这更复杂。
- en: Do I want to be mutable or immutable or a mix of both？
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要可变的还是不可变的，或者两者的混合？
- en: I'll have peanut butter and chocolate and half some races。 And sometimes there's
    legitimate use cases for a mix of those。 What about do I want orderable or not？
    Orderable is good if my data is orderable。 orderable is bad if it's not。 What
    if I have a mix？
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我会要花生酱和巧克力，还有一些比赛。有时候，这些的混合是合情合理的使用场景。我想要可排序的还是不可排序的？如果我的数据是可排序的，可排序是好的；如果不是，可排序就是不好的。那么如果我有一个混合呢？
- en: In that more complex world we have something data classes can do for you that
    name tuples can't。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更复杂的世界里，我们有数据类可以为你做的事情，而命名元组却无法做到。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_97.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_97.png)'
- en: Name tuples are somewhat limited in their capability。 Remember their goal is
    to do whatever tuples do。 And not to extend that notion they just take tuples
    add types default values and name via lookups。 You're kidding me where did it
    go？
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 命名元组在功能上有些局限。请记住，它们的目标是做元组能做的任何事情。并且并没有扩展这个概念，它们只是把元组加上类型、默认值和通过查找来命名。你在开玩笑吗，它去哪儿了？
- en: '![](img/f533ae2bed1736499c0d9d25630db316_99.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_99.png)'
- en: Okay we did type make right？
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们确实做对了类型，对吧？
- en: '![](img/f533ae2bed1736499c0d9d25630db316_101.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_101.png)'
- en: Alright so here's things that you might want that are outside the defaults。
    You might want to customize a field specification。 And so in my example we have
    a I'm trying to pick a real world example。 We have a employee class that stores
    an employee ID named gender salary and age。
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这里有一些你可能想要但在默认设置之外的东西。你可能想自定义字段规范。因此在我的例子中，我试图选择一个现实世界的例子。我们有一个员工类，它存储员工ID、性别、薪水和年龄。
- en: We also want to keep a list that grows over time recording everyone who has
    viewed the employee record so we know who's seen it。 So that creates a fairly
    rich problem for us that will exercise all of the powerful capabilities of data
    classes。 One thing we want is a field factory。 Instead of a default value of 。5
    we'd like to make a new empty list every time。 This is very easy to do。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望保持一个随着时间增长的列表，记录所有查看过员工记录的人，以便我们知道谁看过它。这就为我们创造了一个相当复杂的问题，这将发挥数据类的所有强大功能。我们想要的一个东西是字段工厂。我们希望每次都创建一个新的空列表，而不是使用默认值0.5。这是非常容易做到的。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_103.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_103.png)'
- en: We'll just say the default factory is a list。 You use this very much like default
    Dix。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们就说默认工厂是一个列表。你可以像使用默认字典一样使用它。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_105.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_105.png)'
- en: Also what if you want to add custom methods to the class？
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果你想为类添加自定义方法呢？
- en: This is a regular class and so just write your method normally。 In this case
    we'll write an access method to record who viewed the data。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个普通的类，所以只需正常编写你的方法。在这种情况下，我们将编写一个访问方法来记录谁查看了数据。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_107.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_107.png)'
- en: Now we'd like this to be hashable so we could use employees in a dictionary。
    However only three of the fields are immutable。 A person's age will change from
    year to year。 Hopefully their salary will increase as well。 And so we'd like to
    exclude those。 In addition we really don't want the list to be included because
    it is not hashable。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们希望这个字段可以哈希，这样我们就可以在字典中使用员工信息。然而，只有三个字段是不可变的。一个人的年龄会随着年份变化。希望他们的薪水也会增加。因此我们希望排除这些。此外，我们确实不希望列表包含在内，因为它是不可哈希的。
- en: If we specify a default factory it's automatically excluded from the hash function。
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们指定一个默认工厂，它会自动从哈希函数中排除。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_109.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_109.png)'
- en: Also you don't necessarily always want to display all the data in the wrapper。
    In particular the salary information we don't want that to show by default because
    it's sensitive。 Likewise the field information will be for all of the people who
    view the record。 That might be a rather long list and we don't want it to be part
    of the wrapper that will get in the way of debugability。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你并不总是想在包装器中显示所有数据。特别是薪水信息，我们希望默认情况下不显示，因为这是敏感信息。同样，字段信息会显示所有查看记录的人。这可能是一个相当长的列表，我们不希望它成为影响调试性的包装器的一部分。
- en: This is easy to achieve， you just say I want this field to have its wrapper
    turned off。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易实现，你只需说我希望这个字段的包装器关闭。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_111.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_111.png)'
- en: Also we want to limit the fields used in comparisons。 There are some things
    like complex numbers or functions that aren't orderable。 And they would raise
    a type error if we include it so we need to exclude them。
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望限制用于比较的字段。有些东西，比如复数或函数，是不可排序的。如果我们包含这些，将会引发类型错误，因此我们需要将它们排除在外。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_113.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_113.png)'
- en: Also we want to include the metadata like that list of accessors。 That is no
    basis for comparison。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望包含元数据，比如那份访问者列表。这没有比较的基础。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_115.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_115.png)'
- en: This is also easy to do。 If you don't want comparison turn it off。
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这也很容易做到。如果你不想进行比较，可以关闭它。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_117.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_117.png)'
- en: Also from the database world we know that we sometimes want data dictionaries
    to describe our records。 Mechanisms provided called a metadata parameter and there's
    a viewer function called fields。
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 同样在数据库领域，我们知道有时希望数据字典来描述我们的记录。提供的机制称为元数据参数，还有一个查看函数称为字段。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_119.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_119.png)'
- en: So we attach a metadata that lets us specify in this case the spell I pay people
    in bitcoins。 They never know how much they're going to make。 I'll say I'll offer
    you ten bitcoins for years worth of work。 And then like am I rich or I am poor？
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们附加了元数据，让我们在这种情况下指定我用比特币支付给人们。他们永远不知道自己能赚多少钱。我会说我将为你提供十个比特币，以换取一年的工作。那么，我是富有还是贫穷？
- en: '![](img/f533ae2bed1736499c0d9d25630db316_121.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_121.png)'
- en: Well it varies from day to day。 So I've given you a fairly rich set of constraints。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这因日而异。因此我给了你一套相当丰富的约束条件。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_123.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_123.png)'
- en: And if I ask you to write that by hand you might ask for a couple hours of time
    and a couple hours of testing time。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我让你手动编写这个，你可能会要求几个小时的时间和几个小时的测试时间。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_125.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_125.png)'
- en: The question is does data classes make it easier for you？ Yes。 all of those
    specifications are quite readable。
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是数据类是否让你更容易？是的，所有这些规范都是相当易读的。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_127.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_127.png)'
- en: Let's look at how we do it。 I say I want this data class to be ordered。 This
    is an interesting name。 Unsaved Hash。 And I'll let Eric talk to that if you have
    any questions about it。 It is a thorny subject。 Roughly it is named so that people
    realize that they're up to something tricky and don't do anything crazy with it。
    And it says of all of the parameters this is one where you're going to look up
    what it does before you use it。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是怎么做的。我说我希望这个数据类是有序的。这是一个有趣的名称。未保存的哈希。如果你对这个有任何问题，我会让埃里克来解释。这是一个棘手的话题。粗略来说，它的命名是为了让人们意识到他们正在处理一些复杂的东西，避免做出疯狂的事情。它表明，在所有参数中，这是一个你在使用之前需要查阅其功能的参数。
- en: Hence the word unsafe。
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此有了“危险”这个词。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_129.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_129.png)'
- en: It doesn't mean actually unsafe。 It just means more complex than you expected
    for a slug。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着实际上不安全。这只是意味着比你预期的复杂得多。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_131.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_131.png)'
- en: So listing out all of the fields was easy。 Notice how to add a method。 I just
    write it like a normal method。 So we want to add a viewer ID。 Oh。 these three
    field specifications are straightforward。 The salary， I don't want it to display。
    So I turn that off。 I don't want it included as part of the hash。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所以列出所有字段很简单。注意如何添加一个方法。我只是像写正常的方法那样写。所以我们想添加一个查看者ID。哦，这三个字段规范很直接。薪水，我不想显示。因此我把它关掉。我不想将其包含在哈希中。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_133.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_133.png)'
- en: And I would like to record that I'm paying people in Bitcoin。 Also。 age is not
    part of the hash as well， but it is part of the comparison。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我想记录一下我用比特币支付给人们。此外，年龄也不是哈希的一部分，但它是比较的一部分。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_135.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_135.png)'
- en: The viewed by list will be every time we create a new instance， it creates a
    new list for us。 This is the default factory。 We don't want that to be part of
    the comparison or part of the repper。 That is pretty darn easy。 And to me， this
    is the most impressive example of what data classes can do。 How many of you like
    it？
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 被查看者列表每次我们创建一个新实例时，都会为我们创建一个新列表。这是默认工厂。我们不想将其作为比较或部分包装。这非常简单。在我看来，这是数据类所能做的最令人印象深刻的示例。你们中有多少人喜欢它？
- en: '![](img/f533ae2bed1736499c0d9d25630db316_137.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_137.png)'
- en: '[applause]， Very cool。 So let''s just work with that example。'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]，非常酷。所以让我们继续使用这个示例。'
- en: '![](img/f533ae2bed1736499c0d9d25630db316_139.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_139.png)'
- en: I will put my wife in and rather than give away her age in normal units。 I'll
    give it in hexadecimal。 There we go。 I'm already in trouble for missing Mother's
    Day tomorrow。 And our wedding anniversary last week。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把我妻子的年龄用十六进制表示，而不是用常规单位。好了。我因为错过了明天的母亲节而已经惹上麻烦。还有上周我们的结婚纪念日。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_141.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_141.png)'
- en: Not cool。 All right。 Notice that I didn't have to specify the viewers that has
    created a forest by the factory default。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 不太好。好的。注意到我不必指定观看者，这造成了工厂默认的森林。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_143.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_143.png)'
- en: Okay。 So nothing exciting on the instance creation。 I go ahead and call my methods。
    who's accessing this record。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧。所以在实例创建上没有什么令人兴奋的。我继续调用我的方法。谁在访问这条记录。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_145.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_145.png)'
- en: So we record two viewers。 If I pretty print the viewed by。 you can now see the
    two people who accessed the record and when they accessed it。 What did you know
    and when did you know it？ Okay。 And we can now sort it。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们记录了两个查看者。如果我将被查看者打印得漂亮，你现在可以看到访问记录的两个人及其访问时间。你知道了什么，什么时候知道的？好的。我们现在可以对其进行排序。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_147.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_147.png)'
- en: Why？ Because it's orderable。 But when it orders， it's not going to order on
    all the fields。 just the fields that we specified， the ones that make sense。 And
    when we look at the wrappers of these， the data like who it's viewed by is excluded
    from the wrapper。 as is the salary， per our specs。
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？因为它是可排序的。但在排序时，它不会对所有字段进行排序，而只是对我们指定的字段进行排序，只有那些有意义的字段。当我们查看这些数据的包装时，谁查看了这些数据被排除在包装之外。薪水也是如此，按照我们的规范。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_149.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_149.png)'
- en: So in addition， we can use the employees as dictionary keys so I can assign
    Rachel to gather all of the requirements and Martin to write all of the tests。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们可以将员工用作字典键，因此我可以指定瑞秋负责收集所有需求，马丁负责编写所有测试。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_151.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_151.png)'
- en: '![](img/f533ae2bed1736499c0d9d25630db316_152.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_152.png)'
- en: And that's possible because we've marked certain fields as hashable。 Keep in
    mind not all of the fields were hashable。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能的，因为我们将某些字段标记为可哈希的。请记住，并非所有字段都是可哈希的。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_154.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_154.png)'
- en: And so we needed all of this power。 In addition， the fields functions lets us
    introspect the field specifications and we can see that the salary field。 the
    payment is in Bitcoin。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们需要所有这些强大功能。此外，字段函数让我们能够反向检查字段规范，我们可以看到薪水字段的支付是以比特币进行的。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_156.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_156.png)'
- en: The code that's generated here is this is very close to what you would write
    by hand for the init to create a new list。 The wrappers， what you would write
    by hand。 The equalities we discussed before is type specific。 As are the other
    comparison functions。 What's interesting about the comparison functions is not
    how they're written。 It's what they exclude。 They don't include all of the fields。
    And likewise。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里生成的代码与手动为`__init__`编写以创建新列表的代码非常接近。包装器是你手动编写的内容。我们之前讨论的相等性是类型特定的，其他比较函数也是。比较函数有趣之处不在于它们的编写方式，而在于它们排除了什么。它们不包括所有字段，其他也一样。
- en: the hash doesn't include all of the fields。
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希不包括所有字段。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_158.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_158.png)'
- en: So some quick closing thoughts。
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 所以一些快速的结束想法。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_160.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_160.png)'
- en: And then to defend myself during the question and answer period。 I've called
    in for backup and reinforcements。 So if I either tell you any lies or don't know
    the answer。 the person who knows the truth and may be willing to share it with
    you is here。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在问答环节我需要为自己辩护。我已经叫来了增援和后备。所以如果我告诉你任何谎言或不知道答案，知道真相并可能愿意和你分享的人就在这里。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_162.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_162.png)'
- en: So I'll invite Eric to come on up and we'll give him a round of applause when
    he gets here。 So here are the challenges with using it。 One is it's currently
    tricky to add slots to a data class。 And slots is a pretty darn important optimization。
    It'll save you a lot of space and improve the speed of access of the fields。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我会邀请**埃里克**上来，等他到这里时我们给他热烈的掌声。使用它的挑战之一是目前向数据类添加插槽相当棘手。而插槽是一个非常重要的优化，它能节省大量空间并提高字段的访问速度。
- en: So slots works just fine until you have default values。 And for deep reasons，
    they fight each other。 This is hard to fix but probably will be fixed。 If we fix
    it though。 almost certainly we're going to have to have the class decorator not
    modify the class in place but make a brand new class。 This will be irritating
    at so many levels。 The dunder init that's generated doesn't call super because
    most of the time that's not what we want。
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 所以插槽很好用，直到你有默认值。而且出于深层原因，它们互相冲突。这很难修复，但可能会被修复。如果我们修复了它，几乎可以肯定我们必须让类装饰器不直接修改类，而是创建一个全新的类。这在许多方面都会让人恼火。生成的特殊`__init__`方法不调用`super`，因为大多数情况下我们并不想要这样。
- en: But if you incur it from a class who's init does to be to call。 there's an interesting
    dunder method called post init that calls what you need。 There was some debate
    about whether to include a pre init。 but that probably won't happen unless somebody
    asks for it with a compelling idea。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你从一个需要调用的类中引入它，有一个有趣的特殊方法叫做`post init`，它会调用你需要的内容。关于是否包含`pre init`有过一些辩论，但除非有人提出有说服力的想法，否则可能不会发生。
- en: And that's the compelling use case。 Also， data classes were designed to wrap
    around existing classes and it works really well with mutable classes。 But if
    the immutable， there's an immutable parent。 we don't have an easy way to override
    or extend the dunder new method。 It is really all about things that we're putting
    the data in。
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是引人注目的用例。此外，数据类设计用于包裹现有类，特别适合可变类。但是对于不可变类，如果有一个不可变的父类，我们没有简单的方法来重写或扩展特殊的`__new__`方法。这完全是关于我们放入数据的事。
- en: So I tried to reinvent named tuple using data classes and it essentially did
    nothing for me other than create the wrapper and not in the way。 It's clean away
    as the named tuple did。 So there are some things that it's not good at。 Mostly
    it's good for a lot of things。 Future directions。 I expected over time people
    will request things that are in the adders package will come to be present in
    data classes。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我尝试用数据类重新发明命名元组，结果几乎没有给我带来任何好处，只是创建了一个包装器，并且不是以命名元组的方式那样简洁。所以有些事情它做得并不好，但大多数事情它还是很不错的。未来的方向。我预期随着时间的推移，人们会请求添加包中的功能，进而出现在数据类中。
- en: So at some point we'll probably have data valid or daters。 At some point we'll
    probably have better support for slots。 So I hope you enjoyed that tutorial and
    walk through。 I tried to give you simple cases。 slightly improved more common
    cases。 And then the corner case it said we took a challenging problem that had
    many specifications to it and boiled it down to something simple。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在某个时刻，我们可能会有数据有效或数据者。到时候，我们可能会对槽有更好的支持。希望你们喜欢这个教程和演示。我试图给你们提供简单的案例，稍微改进的常见案例，以及我们提到的边缘案例，我们将一个复杂的问题简化为简单的内容。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_164.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_164.png)'
- en: '![](img/f533ae2bed1736499c0d9d25630db316_165.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_165.png)'
- en: And I hope I've presented a compelling set of use cases in our tutorial for
    you。 How did I do？
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望我在教程中为你们提供了一组引人注目的用例。我做得怎么样？
- en: '[Applause]， The challenge for you now is that was a nice round of applause。
    I challenge you to do better。 I''d like you to double that for the person who
    actually did all the work。 Eric， do you want to come up with me？ [Applause]， You''ll
    need a microphone。 [Applause]， Eric Smith。 We have time for about one question。
    So make it a good one。 [Laughter]， Hi， Roman。'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[掌声]，现在的挑战是，那是一阵不错的掌声。我挑战你们做得更好。我希望你们给实际完成所有工作的那个人再加倍掌声。埃里克，你想和我一起上来吗？[掌声]，你需要一个麦克风。[掌声]，埃里克·史密斯。我们有时间回答一个问题。请问一个好问题。[笑声]，嗨，罗曼。'
- en: Thanks for the talk。 There's one thing I can do if I hand write the Dunder in
    it。 I can make arguments keyword only by putting in an asterisk in the function
    signature。 Is there any support for that in declarative data class？ I'll say no。
    and then we'll get the right answer。 There's not。 Part of the reason is because
    it has to be arguments for Dunder in it or the order you do clear it on。
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢你的演讲。如果我手动编写Dunder，我可以通过在函数签名中放置一个星号来使参数仅限关键字。在声明性数据类中是否支持这种做法？我会说不，然后我们会得到正确答案。没有。原因之一是，它必须是Dunder的参数，或者您进行清理的顺序。
- en: It doesn't necessarily make sense that you somewhere in the list of fields you'd
    have to say， "Oh。 and everything after here is keyword only。" And it also doesn't
    work well with inheritance。 where if you inherit from something that had only
    keyword arguments。 then everything you had would suddenly have to become keyword
    argument only。
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在字段列表中，您不一定要说：“哦，从这里开始，后面的都是仅限关键字。”这也不太适合继承。如果您从一个只有关键字参数的类继承，那么您所拥有的所有内容都会突然变成仅限关键字参数。
- en: Because if you have a data class that inherits from another data class。 it adds
    the Dunder in it to the child class。 It just depends all of the fields together
    on the inherited classes。 Dunder in it。 So it has to everything in it because
    it doesn't call it the base and last。 Executive summary， it's harder than it looks。
    It is harder。
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 因为如果您有一个从另一个数据类继承的数据类，它会将Dunder添加到子类。它只会将所有字段组合在一起，依赖于继承类的Dunder。所以它必须在其中的一切，因为它不称其为基类和最后一项。总结一下，这比看上去要难得多。确实更难。
- en: '![](img/f533ae2bed1736499c0d9d25630db316_167.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_167.png)'
- en: All right， let's give them one last round of applause。 [APPLAUSE]。
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们为他们再来一次热烈的掌声。[APPLAUSE]
- en: '![](img/f533ae2bed1736499c0d9d25630db316_169.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f533ae2bed1736499c0d9d25630db316_169.png)'
- en: '[BLANK_AUDIO]。'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[空白音频]。'
