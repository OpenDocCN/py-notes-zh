- en: P1：Kenneth Reitz - Pipenv The Future of Python Dependency Management - PyCon
    2018 - 哒哒哒儿尔 - BV1Ms411H7Hn
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P1：Kenneth Reitz - Pipenv Python 依赖管理的未来 - PyCon 2018 - 哒哒哒儿尔 - BV1Ms411H7Hn
- en: All right。
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_1.png)'
- en: Thank you everybody for coming to the session。 How many of you use requests？
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢大家参加这个会议。你们中有多少人使用 requests？
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_3.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_3.png)'
- en: Yes。 Oh wow。 Kenneth， that must really make you happy。 Thank you very much。
    [APPLAUSE]。 I have to say Kenneth is one of my Python heroes。 And finally。 the
    reason I wanted to chair the session， is because I'll get to meet him in person。
    He's a Python hero for me because he writes APIs， that are designed for humans
    unlike most。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。哇，Kenneth，这一定让你很开心。非常感谢。[掌声]我得说，Kenneth 是我心目中的 Python 英雄。最后，我想主持这个会议的原因是因为我能亲自见到他。他是我心目中的
    Python 英雄，因为他编写的 API 设计是为人类服务的，不像大多数其他 API。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_5.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_5.png)'
- en: of the scientific computing community。 All right？ So and as we all know， and
    I'm part。 of the scientific computing community， so I'm allowed to say that。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 科学计算社区的成员们。好吧？正如我们所知，我也是这个社区的一部分，所以我可以这样说。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_7.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_7.png)'
- en: He's the creative requests。 And as we saw， a lot of people use requests。 It's
    a very popular package。 And he's here to talk about pipen， which is another tool。
    designed for humans。 So with that， Ken， please take it away。 [APPLAUSE]， Hi everybody。
    Welcome to Python Day 2， I think it is。 Is everyone having a good time so far？
    All right。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 他是 requests 的创作者。正如我们所看到的，很多人使用 requests。这是一个非常受欢迎的包。他在这里谈论 pipen，这是另一个为人类设计的工具。好的，Ken，请开始吧。[掌声]大家好。欢迎来到
    Python 第二天，我想是的。大家到目前为止都过得愉快吗？好吧。
- en: I want to say a special thanks to Ernest W。 Durban， for organizing the event。
    I think he's done a great job here in Cleveland。 And I'm looking forward to next
    year as well。 So this is the future of Python dependency management。 So hello。
    My name is Kenneth writes。 If you'd like， you can follow me on Twitter at @KennathRites。
    Every follow is appreciated as always。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我想特别感谢 Ernest W. Durban 组织这个活动。我认为他在克利夫兰做得非常出色。我也期待明年。所以这是 Python 依赖管理的未来。大家好，我是
    Kenneth Reitz。如果你愿意，可以在 Twitter 上关注我 @KennathRites。每一个关注我都非常感激。
- en: I work for DigitalOcean。 This is a new thing for me。 I was working for Heroku，
    but I just。 switched jobs about five days ago。 I wanted to make sure I was representing
    my new company。 at Python。 So I signed the paperwork and went straight here。 So
    I'm still going through onboarding and everything。 So I can't speak officially
    on anything yet。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 DigitalOcean 工作。这对我来说是一个新的开始。我之前在 Heroku 工作，但我大约五天前刚换了工作。我想确保我在 Python 活动中代表我的新公司。因此我签署了文件，直接赶来了这里。我仍在进行入职培训等一切，所以我还不能正式对任何事情发表看法。
- en: but I'm very excited to join the team。 And I think it's the world's most approachable
    infrastructure。 as a service。 So if you have any questions about DigitalOcean。
    or if you think there's any opportunities for us， to collaborate or anything you
    want to know。 you can come ask me about that later。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但我非常兴奋能够加入这个团队。我认为这是世界上最容易接触的基础设施，作为服务提供。如果你对 DigitalOcean 有任何问题，或者觉得我们有任何合作的机会，或者想知道的任何事情，可以稍后来问我。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_9.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_9.png)'
- en: I'm also a board member of the Python Software Foundation。 I'll be giving the
    lightning talk about that later today。 But the Python Software Foundation。 is
    an organization that exists to protect， the intellectual property of Python， as
    well as run。 this event effectively。 That's where most of the revenue for the
    organization。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我也是 Python 软件基金会的董事会成员。我稍后会做关于这个的快速演讲。Python 软件基金会是一个旨在保护 Python 知识产权，并有效地组织这个活动的机构。这就是该组织大部分收入的来源。
- en: comes from is from Python。 And that's one of the reasons Python exists。 And
    it's a wonderful organization。 Anyone here， everyone in the room， I assume。 is
    invested in Python because you're at Python。 So I encourage everyone who isn't
    already a member。 to become a member。 It's free。 It's also always-- donations
    are always welcome。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分收入来自于 Python。这也是 Python 存在的原因之一。这是一个了不起的组织。在场的每个人，我想，都是对 Python 有所投资，因为你们在这里参加
    Python 活动。所以我鼓励还不是会员的每个人，成为会员。这个是免费的。捐款也是一直欢迎的。
- en: But you can sign up and become a member。 And then if you want， you can become
    a voting。 or an active member so you can help the vote and help。 steer the future
    of the language with board decisions， and stuff like that。 So if you know who
    I am。 it's probably， from the Request Library， which is HTTP for humans。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你可以注册并成为会员。如果你愿意，还可以成为投票或活跃会员，这样你就可以参与投票并帮助引导语言未来的决策。所以如果你知道我是谁，可能是因为Request库，它是为人类设计的HTTP。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_11.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_11.png)'
- en: It looks like this。 And it allows you to make HTTP requests very easily。 on
    the internet with Python。 Before this library existed， it was very difficult to
    do this。 because there was your lib2 and other tools that， were not as friendly，
    I'll say。 And this has been very popular。 And I'm very thankful for the community
    for being so。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像这样，允许你在互联网上用Python轻松发出HTTP请求。在这个库出现之前，做到这一点是非常困难的，因为有lib2和其他一些工具，我可以说并不是那么友好。这个库非常受欢迎，我很感谢社区的支持。
- en: abrasive of this project。 It's very humbling。 Some other projects are on GitHub。
    If you maybe recognize me from some of these， OSX GCC installer is responsible
    for the now--。 it's called Xcode install--， Xcode select -install。 It lets you
    install GCC and your Mac without installing， the 5， 6 gigabyte Xcode。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的磨损感让我很谦卑。其他一些项目在GitHub上。如果你可能在这些项目中认出我，OSX GCC安装程序就是现在这个——它被称为Xcode安装——，Xcode选择-install。它让你在不安装5到6GB的Xcode的情况下，在Mac上安装GCC。
- en: That's because of my project OSX GCC installer。 And I have a bunch of other
    stuff， Maya records。 tablet， et cetera。 And the import this podcast。 But anyway，
    that's enough about me。 I'm here to talk about packaging， the Python packaging。
    So who here uses Python packaging？
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这都是因为我的项目OSX GCC安装程序。我还有一堆其他东西，比如Maya记录、平板等等。还有这个播客的导入。不过，关于我就够了。我在这里是为了谈论打包，Python打包。那么这里谁在使用Python打包？
- en: So I said， who here doesn't use Python packaging？ Let's do that instead。 One
    person。 Two people。 So Python packaging affects almost every single person， who
    uses Python。 And it has a bit of an interesting history， because people。 have
    come to Python at different periods of time。 I've been using Python since about
    2007。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我问，谁不使用Python打包？我们反过来问这个吧。一个人。两个人。所以Python打包几乎影响到每一个使用Python的人。它有一个有趣的历史，因为人们在不同的时期接触Python。我从大约2007年开始使用Python。
- en: And so I've got-- which is not--， I know people who have been doing it for much，
    much longer。 So that's not a respectable 10-year of Python。 But compared to some
    people， it is。 So I have some glimpses into the history of packaging。 I like to
    share my perspective on the history。 So there's some things that might be a little
    unclear。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道一些人使用Python的时间要长得多，所以我这十年的Python经历并不算什么。但与某些人相比，还是有些独特的。我对打包历史有一些了解。我喜欢分享我对历史的看法，所以有些事情可能会稍微不清楚。
- en: about the current state of things and why things are the way。 they are and how
    much progress we've actually made。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的状况以及为什么事情会这样发展的进展情况。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_13.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_13.png)'
- en: So in the past， when I started writing Python， if you wanted to install something。
    what you would do is you would download this like tarball， effectively from the
    internet。 And then you would unzip it。 And then you would run setup。py install。
    into your site packages directory。 And it would get installed。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，当我开始写Python时，如果你想安装某个东西，你会从互联网上下载一个tar包，然后解压。接着运行setup.py install，安装到你的site
    packages目录中。然后它就会被安装。
- en: And this is the de facto way to install Python packages。 Some people would actually
    just take。 unzip it， and drag it into their site packages folder。 And that was
    kind of the way that you would manage your Python， dependencies。 And that was
    the way it used to be。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是安装Python包的事实标准方式。有些人实际上会直接解压并拖到他们的site packages文件夹里。这就是管理Python依赖关系的方式，这曾经是常态。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_15.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_15.png)'
- en: There were some problems with this approach， obviously。 The cheese shop I may
    refer to is。 a nickname of the Python package index， which is pipi。org now。 And
    it was merely an index of packages， not a sole package host。 So right now。 if
    you go to register a package on pipi。org， you have to upload files with that。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种方法存在一些问题。我提到的“奶酪商店”是 Python 包索引的一个昵称，现在是 pipi.org。它仅仅是一个包的索引，而不是单一的包托管服务。所以现在，如果你去
    pipi.org 注册一个包，你必须上传文件。
- en: You can't say the files live on this other server， that I'm hosting somewhere
    else。 So before。 you could have registered packages， and say， oh， this website
    and this website， and this website。 it was just an index。 So that was problem
    A。 So the packages were often， hosted elsewhere。 If it was running on the server，
    which served the entire Python， community。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能说文件存在于另一个我在其他地方托管的服务器上。因此，在之前，你可以注册包，并说，哦，这个网站和这个网站，还有这个网站，它只是一个索引。所以那是问题
    A。包通常是在其他地方托管的。如果它运行在为整个 Python 社区提供服务的服务器上。
- en: it was running on a single box in Sweden， which， was very problematic。 It was
    just this one little box running in Sweden。 Its usage was a fraction of what it
    is today。 So that wasn't really that big of a problem。 It worked， and everyone
    was kind of happy。 More obvious problems is that this installation system。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它是在瑞典的一台单一机器上运行，这非常有问题。就只有这一台小机器在瑞典运行。它的使用量仅占现在的一个小部分。所以这并不是一个大问题。它工作得很好，大家都还算满意。更明显的问题是这个安装系统。
- en: was a very manual process and was not good for automation。 You had globally
    installed packages。 which were impossible to have two versions of the same library，
    installed。 which we still have today， obviously。 You can't have-- if you install--。
    I'm not using historically relevant things， but if you were to install Flask10。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常手动的过程，不适合自动化。你有全局安装的包，而同一库的两个版本是无法安装的，这显然至今仍然存在。如果你安装了——。我没有使用历史相关的东西，但如果你要安装
    Flask10。
- en: you can't install Flask09 in the same Python installation， for example。 So if
    you only have a global Python installation， you couldn't work on two projects。
    that have conflicting dependencies。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你不能在同一个 Python 安装中安装 Flask09。因此，如果你只有一个全局的 Python 安装，你就无法在两个有冲突依赖项的项目中工作。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_17.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_17.png)'
- en: So people-- and it's just a poor user experience overall。 So the next iteration
    of this is known as EasyInstall。 That is something that was very popular for a
    long time。 It made things a lot easier。 You would just type EasyInstall， space，
    and then you get a package。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所以人们认为这总体上是一个糟糕的用户体验。因此，这个系统的下一个迭代被称为 EasyInstall。这在很长一段时间内非常受欢迎。它让事情变得简单得多。你只需输入
    EasyInstall，空格，然后你就能得到一个包。
- en: And it would go and grab it from the cheese shop， and install it into your system。
    which is fantastic。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它会从“奶酪商店”抓取并安装到你的系统中，这真是太棒了。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_19.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_19.png)'
- en: It's much better。 This is a much better experience for installation。 but the
    packages were installed from the cheese shop。 And it's much easier to automate。
    There were some downsides to this。 There was no EasyInstall， for example。 So you
    could just install things。 You could uninstall things。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这要好得多。这是一个更好的安装体验，但这些包是从“奶酪商店”安装的。而且自动化要容易得多。这个方法有一些缺点。例如，没有 EasyInstall。因此，你只能安装东西。你可以卸载东西。
- en: So that is kind of a slight step backwards。 And I'll give you a painting of
    today's world looks like。 So from about 2010 onward， this tool came named PIP。
    became the de facto replacement for EasyInstall， for managing packages。 And VirtualLens
    became common practice。 And people started passing around these things。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这有点像是一个小的退步。我将给你描绘一下今天的世界是什么样的。从 2010 年左右开始，这个工具被称为 PIP，成为管理包的事实上的 EasyInstall
    替代品。VirtualLens 也成为了常规做法。人们开始传播这些东西。
- en: called requirements。txt files。 VirtualLens， what it is， is it creates an isolated
    Python。 home for each package to be installed in， one for every project。 You can
    create a virtual and you can install things into it。 And in another project。 you
    create another virtual and then， you can install different versions of dependencies。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 称为 requirements.txt 文件。VirtualLens 的作用是为每个项目创建一个隔离的 Python home，以便在其中安装包。你可以创建一个虚拟环境，并在其中安装东西。在另一个项目中，你可以创建另一个虚拟环境，然后安装不同版本的依赖项。
- en: and they're isolated from each other。 And it's wonderful。 And as time has evolved，
    it doesn't。 include the global packages by default anymore。 So you're very isolated
    Python environments。 You get very reproducible builds。 It's a wonderful tool。
    It's a very powerful concept， which。 allows for extreme flexibility。 And it's
    kind of unique in the Python community。 It's a tool that。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 而且它们彼此隔离。这很美妙。随着时间的发展，它不再默认包含全局包了。因此，你有非常独立的 Python 环境。你可以得到非常可重复的构建。这是一个很棒的工具。它是一个非常强大的概念，允许极大的灵活性。而且在
    Python 社区中，它算是独特的工具。
- en: for example， does not exist in the Ruby， community。 And one of the reasons for
    that is because you can have。 multiple versions of gems in the Ruby community
    installed， at the same time on the same system。 In Ruby， if they had a flask，
    you could install Flask10 and 09。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Ruby 社区中是不存在的。而这其中的一个原因是因为你可以在同一系统上同时安装多个版本的 gem。在 Ruby 中，如果他们有一个 flask，你可以安装
    Flask10 和 09。
- en: into the same global installation at the same time。 So they don't need VirtualLens。
    And then the other tool we have is PIP。 PIP resolves， downloads， installs， and
    uninstalls Python。 packages from the package indexes or arbitrary URLs。 It utilizes
    requirements。txt files。 And it manipulates virtual environments。 I assume everyone
    that raised their hand。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 同时进入相同的全局安装。因此，他们不需要 VirtualLens。然后我们还有另一个工具是 PIP。PIP 解析、下载、安装和卸载 Python 包，来自包索引或任意
    URL。它利用 requirements.txt 文件，并操控虚拟环境。我假设每位举手的人。
- en: said that they use Python packaging uses PIP， and is familiar with it。 So I
    won't go into too deep detail there。 So this practice of using PIP in VirtualLens
    continues today。 This is a practice that began in about 2010。 And it's what we
    use today。 Now。 if you look at other communities， there's some interesting patterns
    that you've seen。
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 说他们使用 Python 包管理，使用 PIP，并对此很熟悉。因此我不会深入讨论这一点。所以在 VirtualLens 中使用 PIP 的做法至今仍在继续。这是大约在
    2010 年左右开始的做法，也是我们今天所使用的。现在，如果你看看其他社区，你会看到一些有趣的模式。
- en: involved over the years。 In Node。js， they have yarn and NPM。 In PHP， they have
    Composer， and Rust。 There's Cargo。 In Ruby， there's Bundler。 All of these things
    show this very similar mechanism known。 as a lock file。 But if you look at Python，
    we use PIP in VirtualLens， which， first off。 is two things， not one thing， like
    all the other languages， other than Node。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来的发展。在 Node.js 中，他们有 yarn 和 NPM。在 PHP 中，他们有 Composer，在 Rust 中则有 Cargo。在 Ruby
    中有 Bundler。所有这些东西展示了一个非常相似的机制，称为锁定文件。但如果你看看 Python，我们使用 PIP 和 VirtualLens，这首先是两件事，而不是像其他语言那样的一件事，除了
    Node。
- en: They have two one things。 [LAUGHTER]， And there's no lock file。 Now。 it could
    be argued that the requirement。txt， is a lock file， but we'll get into that in
    a moment。 But in Python， there's no lock file。 So that's a problem。 There's a
    problem with VirtualLens in the first place。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 他们有两件事。[笑声]，而且没有锁定文件。现在，可以说 requirements.txt 是一个锁定文件，但我们稍后会讨论这个问题。但在 Python
    中，没有锁定文件。所以这是个问题。首先，VirtualLens 就存在这样的问题。
- en: which is that it's difficult to understand abstraction layer。 It's a headache
    for newcomers。 It just increases the barrier to entry to the language。 If you're
    very familiar with Unix concepts。 it makes a lot of sense。 But if you're not familiar
    with Unix concepts， it's a little bit foreign。 and it really， does hamper your
    ability to understand what's going on。 It's a very manual process。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于理解抽象层是困难的。这对新手来说是个头疼的问题。这增加了对语言的入门门槛。如果你非常熟悉 Unix 概念，这一切就很有意义。但如果你不熟悉 Unix
    概念，这就显得有些陌生，而且确实会妨碍你理解正在发生的事情。这是一个非常手动的过程。
- en: easy to automate， but unnatural to use manually。 And there are tools like Virtual
    Envabber， which。 exists that makes this a much easier process to reuse， on a day-to-day
    basis， which is great。 Requirements。txt also has its problems。 The very common
    pattern is you do pip freeze。 and you pipe that into requirements。txt， which，
    gives you a flattened version of all your dependencies。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化很简单，但手动使用不自然。还有像 Virtual Envabber 这样的工具，确实使得这个过程在日常使用中变得更加容易，这很好。requirements.txt
    也有它的问题。一个非常常见的模式是你执行 pip freeze，然后将其输出到 requirements.txt，这会给你所有依赖的扁平版本。
- en: Kind of like， this is a reproducible version list。 of all my dependencies and
    my transient dependencies， into my-- for my project that I'm working on。 But there's
    this impedance mismatch， between what a requirements file is。 because there's
    two different ways to declare， a requirements file。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有点像，这是我所有依赖和我的临时依赖的可重现版本列表，用于我正在工作的项目。但在requirements文件的定义上存在阻抗失配，因为声明requirements文件的方式有两种。
- en: There's what you want installed and what you need installed。 We'll get into
    that in a moment。 There are tools that exist today that make this easier， like
    pip tools。 which I want to give a nice shout out to。 But ideally， a requirements。txt
    file。 is a completely pre-flat and dependency tree， which。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一种是你想安装的，另一种是你需要安装的。我们稍后会详细讨论。今天有一些工具使这更容易，比如pip工具，我想对它表示赞赏。但理想情况下，requirements.txt文件是一个完全预先扁平化和依赖树。
- en: is required in order to establish deterministic builds。 That's what an ideal
    case should be。 So this is one way of doing requirements。txt。 This is the ideal
    case for it。 If you look at it。 there is--， so this is a Flask project。 Flask
    has transient dependencies。 If you require Flask。 it has dependencies itself，
    like Wurxig， it's dangerous， Ginger2， for example。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是建立确定性构建所必需的。这是理想情况下应该如此的。因此，这是一种处理requirements.txt的方法。这是它的理想情况。如果你查看一下，这里有——这是一个Flask项目。Flask有临时依赖。如果你需要Flask，它自身有依赖，比如Wurxig，举个例子，它很危险，Ginger2。
- en: And they all have different versions。 So if you're to pip install Flask and
    then run pip freeze。 to a requirements。txt file， this is what the output looks
    like。 This is great because it's deterministic。 If you were to pip install this
    from a fresh virtual environment。 it's all inclusive of transitive dependencies。
    But it's a little difficult to know what's going on。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都有不同的版本。因此，如果你pip安装Flask，然后运行pip freeze，输出到一个requirements.txt文件，输出看起来就是这样。这很好，因为它是确定性的。如果你从一个新的虚拟环境中pip安装，这是包含所有传递依赖的。但知道发生了什么有点困难。
- en: If you were to look at this in your source code， repository on GitHub or your
    co-worker。 was essential to you， which dependency， is it that you actually want？
    It's unclear。 Do you want-- it's dangerous？ Is that what your team needs or does
    your team need Flask？
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看一下你在GitHub上的源代码库，或者你同事的代码，对你至关重要的是，哪种依赖是你真正想要的？这并不明确。你想要——它很危险？这是你的团队需要的，还是你的团队需要Flask？
- en: Which one are you actually depending on？ That's the problem。 So some teams solve
    this by just doing this， because this works。 You can just do Flask。 And everything
    else will get installed。 But unfortunately。 it'll result in a non-deterministic
    build。 It's much more human readable and understandable。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你到底依赖哪一个？这就是问题所在。有些团队通过这样解决这个问题，因为这样有效。你可以只安装Flask，其他的依赖会自动安装。但是不幸的是，这会导致非确定性构建。它更易读且易于理解。
- en: And it functions properly。 But it's non-deterministic， which can cause build
    failures。 If any of those transitive dependencies update， you'll get a different
    version of those dependencies。 And your application can break。 You could be security
    vulnerabilities。 There's many applications of that。 So this is this impedance
    mismatch between what。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 并且它正常运行。但它是非确定性的，这可能导致构建失败。如果任何一个传递依赖更新，你将获得这些依赖的不同版本。你的应用可能会崩溃，可能存在安全漏洞。这有很多应用场景。因此，这就是你所需要的与所想要之间的阻抗失配。
- en: you want and what you need。 That is problematic with the requirements。txt format。
    So this effectively-- so this requirements format。 that we have is both a lock
    file and not a lock file， depending on how you use it。 So let's just go with the
    assumption that Python has， no lock file right now。
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要的和你需要的。这在要求中是个问题。txt格式。因此，这种要求格式实际上既是锁文件，又不是锁文件，取决于你的使用方式。所以我们假设Python现在没有锁文件。
- en: The solution is to give it a lock file。 So we already went over this。 The two
    types of dependencies-- what you want and what you need。 So one solution of this
    is to have two different requirements， files。 one with what you want and one with
    what you need。 So you have one called requirements to freeze。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是提供一个锁文件。所以我们已经讨论过这一点。两种类型的依赖——你想要的和你需要的。因此，这个问题的一个解决方案是有两个不同的requirements文件，一个是你想要的，一个是你需要的。你有一个叫做requirements以冻结。
- en: and you put in what you need in there like Flask。 And then you have one called
    requirements。txt。 which is， the result of pip freeze。 And this is a good solution
    to this problem that you can use。 standardized tools like pip。 All you need is
    pip to do this。 And this gives you the best of both worlds。 And there's also a
    tool called pip tools。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你会有一个叫做 requirements.txt 的文件，这是 pip freeze 的结果。这是一个很好的解决方案，你可以使用标准化工具，比如 pip。你只需要
    pip 就能做到这一点。这给你提供了最好的两全其美的选择。此外，还有一个叫 pip tools 的工具。
- en: which does a very， similar thing that is built all around this concept， basically。
    which I highly recommend using if you are not， going to use what I recommend later。
    So this is a great pattern。 And I think that this is a good solution for people
    that use。 pip and they're built infrastructure to give you the， best of both worlds。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它做了非常相似的事情，基本上围绕这个概念构建。如果你不打算使用我稍后推荐的内容，我强烈推荐使用这个。因此这是一个很好的模式。我认为这是为使用 pip 的人提供的一个很好的解决方案，给你最好的两全其美的选择。
- en: But it's not a real solution。 The real solution is this new standard that's
    evolving， and。 it's coming out of the PIP file。 A pip file is a new standard，
    replacing requirements。txt in。 the future。 It's written in Toml， so it's easy
    to write and read， manually。 And it features two groups。 So in other tools that
    you use in those other languages， you。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是一个真正的解决方案。真正的解决方案是这个正在演变的新标准，它来自 PIP 文件。PIP 文件是一个新的标准，将在未来取代 requirements.txt。它是用
    Toml 编写的，因此手动编写和阅读都很容易，并且它具有两个组。在你使用的其他语言的其他工具中，你可以把你需要的内容放在里面，比如 Flask。
- en: can often have groups of dependencies。 You'll also see people have requirements
    dash dev。 requirements dash test， requirements dash production， requirements dash
    Heroku。 These are a way of finagling groups into PIP。 So the composer community，
    however。 has gotten away with， having just two groups。 And it's been a very successful
    project in doing so。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项组通常会有多种形式。你还会看到人们有要求的开发环境、测试环境、生产环境和 Heroku 环境。这些是将组纳入 PIP 的一种方式。然而，composer
    社区只使用了两个组，并且这样做取得了非常成功的项目。
- en: So PIP file has room in the spec to support more groups。 But currently。 the
    implementation has two groups， packages and dev packages， which should encapsulate。
    everything that you ever need。 Anything that's not going into production goes
    into dev， packages。 Everything that is going into production goes into， packages。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 PIP 文件的规范中有空间支持更多的组。但目前的实现只有两个组，packages 和 dev packages，这应该涵盖你所需的一切。任何不进入生产的内容都会放入
    dev packages，进入生产的内容则放入 packages。
- en: And that should encapsulate every single use case you could， ever possibly have，
    ideally。 And PIP file is something that is going to go into PIP in， once Donald's
    stuff gets around to it。 basically， which is， wonderful。 It was his idea。 And
    I went through and I made a prototype of the spec。 in Python with some help from
    some contributors。 And there's a project called PIP file you can use to parse。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，这应该涵盖你可能会有的每一个使用案例。而 PIP 文件是将要进入 PIP 的东西，基本上等到唐纳德的内容处理完。这是一个很棒的想法。我在 Python
    中做了一个规范的原型，并得到了几位贡献者的帮助。有一个叫 PIP file 的项目，你可以用来解析。
- en: these files and manipulate them。 And it exists。 And it's going to go into PIP
    one day。 So that's the future of this， is that PIP file will， replace requirements
    that TXT。 So here's what a PIP file looks like。 It's Tamil。 So at the top， you
    see source。 And that specifies which package index you're using。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件并进行操作。它存在，并且总有一天会进入 PIP。所以这就是未来，PIP 文件将取代 requirements.txt。以下是 PIP 文件的样子。它是
    Toml 格式。在顶部，你会看到源，这指定了你正在使用哪个包索引。
- en: It has some parameters like verify as a set equals true， which should always
    be the case。 And you can give the index a name like PIPI。 And there's those two
    groups， like I mentioned。 packages and dev packages。 So in this instance， there's
    Flask。 And I'm assigning it to version star。 which means grab， the latest version。
    And dev packages， really what it means is any version。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一些参数，比如 verify 的集合等于 true，这应该始终成立。你可以给索引一个名字，比如 PIPI。还有前面提到的两个组，packages 和
    dev packages。在这个实例中，有 Flask，我将其分配为版本 star，意味着获取最新版本。而 dev packages 的真正含义是任何版本。
- en: which defaults to the latest version。 And dev packages has PyTest。 So that's
    a good example of what you would put in those， two different groups。 You'd put
    your test runner in dev， and then you put Flask， in the default group。 And then
    this thing can be processed and result in something， called a PIP file。lock。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 默认使用最新版本。开发包包含PyTest。所以这就是你会放入这两个不同组的一个好例子。你会把测试运行器放在开发组中，然后把Flask放在默认组中。然后这个东西可以被处理并生成称为PIP文件.lock的东西。
- en: And this is where the magic of PIP file comes into play。 PIP file。lock is JSON。
    So it's very easily machine-parsable， which is great。 And statically and analyzable。
    It contains all transitive dependencies pin with all， acceptable hashes for each
    release。 And it has， again， two groups default and develop。 So this is probably
    a little hard to see。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是PIP文件的魔力所在。PIP文件.lock是JSON格式。因此，它非常容易被机器解析，这很好，并且是静态可分析的。它包含所有传递依赖项，并为每个发布版本提供所有可接受的哈希。它再次分为两组，默认和开发。因此，这可能有点难以看清。
- en: It's a really big file。 I have it truncated。 But you can see in yellow here，
    there's click。 there's Flask， and there's the version numbers。 And then it includes
    all the hashes， the 256 hashes。 of all， the different wheels and source distributions
    of those， valid dependencies， which is great。 So we have what we need in here
    and what we want over here。 These are two separate things。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常大的文件。我对其进行了截断。但你可以在黄色部分看到，有click，有Flask，还有版本号。然后它包括所有哈希，256哈希。所有不同的wheel和这些有效依赖的源分发，这很好。因此，我们在这里有我们需要的，和我们想要的。这是两个独立的事物。
- en: And this generates this。 So that's the ideal。 The problems with PIP file are
    that it's not yet integrated。 into PIP， which will likely take quite a long time
    due to， resource constraints。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成这个。所以这是理想的。PIP文件的问题在于它尚未集成到PIP中，这可能会因为资源限制而需要相当长的时间。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_21.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_21.png)'
- en: But you can use it today with PIPAM， which is the new project， that I am working
    on。 that I want to encourage everyone。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但你今天可以与我正在进行的新项目PIPAM一起使用，我想鼓励大家。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_23.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_23.png)'
- en: to check out。 And that's what this talk is about。 So the PIPAM sales pitch is
    that it's the officially。 recommended tool from Python。org for managing your Python，
    dependencies。 It lets you use PIP file and PIP file。lock today without， waiting
    for PIP to implement it。 It automates away virtual AMP completely from your workflow。
    It does use virtual AMP。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本次演讲的主题。所以PIPAM的销售宣传是，它是Python.org官方推荐的工具，用于管理你的Python依赖。它让你今天可以使用PIP文件和PIP文件.lock，而无需等待PIP来实现。它完全自动化了虚拟AMP的工作流程。它确实使用虚拟AMP。
- en: but you don't have to interface， with it directly。 It just does it for you。
    It ensures deterministic builds， including hash check， verification upon installation。
    And it gives you other great tools like PIPAM Graph， which， I will demo for you
    shortly。 Some great quotes。 Janis Lydell， who is the former PIP maintainer， said
    that。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但你不必直接与它接口。它会为你处理。它确保确定性的构建，包括哈希检查和安装时的验证。并且它为你提供其他很棒的工具，比如PIPAM Graph，我将很快为你演示。一些很棒的引用。前PIP维护者Janis
    Lydell曾说过。
- en: PIPAM is the porcelain I always wanted to build for PIP。 It fits my brain and
    mostly replaces virtual AMP wrapper， and manual PIP calls for me。 Use it。 And
    Justin Miles Holmes， a good friend of mine， said， PIPAM。 is finally an abstraction
    layer meant to engage the mind， instead of merely the file system。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: PIPAM是我一直想为PIP构建的外表。它适合我的思维，并在很大程度上取代了我手动调用PIP的虚拟AMP包装器。使用它。我的好朋友Justin Miles
    Holmes说，PIPAM终于是一个旨在吸引思维的抽象层，而不仅仅是文件系统。
- en: which I quite enjoy。 All right， so it's time for a demo， as well as Q&A。 So
    if you have any questions while I'm doing the demo， please， line up。 And I will
    do my best to answer them。 I want this to be an interactive demo。 So please come
    and ask any questions that you have as I'm， going through。 And hopefully。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常享受这个。好了，现在是演示和问答时间。如果在演示期间有任何问题，请排队。我会尽力回答你们的问题。我希望这是一个互动的演示。因此，请在我进行演示时随时提问。希望如此。
- en: my SSH connection to my server will go well。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我的SSH连接到我的服务器会顺利。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_25.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_25.png)'
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_26.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_26.png)'
- en: Let's see here。 Is that big enough for everybody to see？ Yes？ Excellent。 OK。
    so I just created a new directory called demo。 And there's no files in this directory
    at all。 So what I'm going to do--， I already installed PIPAM。 I'm going to do
    PIPAM， install requests。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看。这对每个人来说够大吗？是吗？太好了。好的。我刚创建了一个名为demo的新目录。而这个目录里没有任何文件。所以我将要做的事情是，我已经安装了PIPAM。我将使用PIPAM，安装requests。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_28.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_28.png)'
- en: And what it'll do is it will create a virtual environment。 for me automatically
    and create a PIP file for me automatically。 And then it'll install requests。 And
    it'll create the PIP file。lock。 And it'll relock the file。 So now I look-- there's
    two files--。 PIP file and PIP file。lock。 If I look at PIP file， you'll see it，
    requests is in there。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它将自动为我创建一个虚拟环境，并为我自动创建一个PIP文件。然后它将安装requests，并创建PIP file.lock。它会重新锁定文件。所以现在我看到有两个文件--PIP
    file和PIP file.lock。如果我查看PIP file，你会看到其中有requests。
- en: And it automatically specifies--， we support version specifiers。 So you can
    constrain your application to certain Python， version specifiers。 So this one
    requires Python 3。6。 If I want to install a dev package， I could do like PIPAM
    install。 pi test-dev。 And it will install pi test into the dev package directory。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它会自动指定，我们支持版本说明符。所以你可以将你的应用程序限制为某些Python版本说明符。这一个要求Python 3.6。如果我想安装一个开发包，我可以像这样使用PIPAM
    install。pi test-dev。它将把pi test安装到开发包目录。
- en: And it will relock automatically。 And as you note， I don't have to edit this
    PIP file by hand。 It's doing it for me。 That's an idea I got from Composer。 So
    pi test is there， request is there。 And this all works。 So I could run-- so I
    could remove the virtual environment， with PIPAM-RM。 which deletes the virtual
    M completely。 And I just do PIPAM install。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 它会自动重新锁定。正如你所注意到的，我不必手动编辑这个PIP文件。它在为我处理。这是我从Composer那里得到的一个想法。所以pi test在这里，requests也在这里。这一切都能正常工作。所以我可以运行--我可以使用PIPAM-RM移除虚拟环境，完全删除虚拟环境。我只需做PIPAM
    install。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_30.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_30.png)'
- en: And it'll rebuild it from scratch。 And it's using Python 362， unfortunately。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它将从头开始重建。遗憾的是，它使用的是Python 3.6.2。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_32.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_32.png)'
- en: It should be 365。 I can specify the version of Python。
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 应该是3.6.5。我可以指定Python的版本。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_34.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_34.png)'
- en: Let's try that。 There we go， 365。 There we go。 I got that。 So PIPAM install。
    And it'll install the dependencies。 And it actually runs PIP concurrently。 So
    if you have 45 dependencies， it will install them concurrently。 So you don't have
    to wait sequentially for each one， to install one at a time。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试。来吧，3.6.5。好了，我得到了这个。所以PIPAM install。它将安装依赖项。实际上，它是并发运行PIP的。所以如果你有45个依赖项，它将同时安装它们。这样你就不必等待每个依赖项按顺序一个个安装。
- en: So it's much faster than using PIP as well。 Can you work multiple sources concurrently？
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这比使用PIP快得多。你能否同时处理多个源？
- en: So you can have--， Multiple sources。 So you can have an organizational internal
    sort。 of PIPAM running a DevPy。 Yes， it does。 Yeah， you can specify-- if you go
    into the documentation。 there is a way for you to specify multiple sources， and
    then also assign a specific package。 to come from a specific source in the TAML
    file。 Yes。 [INAUDIBLE]， [INAUDIBLE]， [INAUDIBLE]。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以有多个源。你可以有一个组织内部的PIPAM运行在DevPy上。是的，确实可以。是的，如果你查看文档，有一种方法可以让你指定多个源，并且还可以在TAML文件中将特定包分配到特定源。是的。[听不清]，[听不清]，[听不清]。
- en: '[INAUDIBLE]， Sorry， if you have a question， please go to the mic。 Sorry。 You
    mentioned concurrent installation。 What about packages that--， What about what？'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[听不清]，抱歉，如果你有问题，请去麦克风旁。抱歉。你提到并发安装。那关于包的--，那是什么？'
- en: Packages that install differently based， on what's installed before。 Like tornado。
    if you have site on it， it will optimize。 If you don't have site on it， it won't
    optimize。 So--。 If you don't have site on？ Yeah， site on is not really a dependency
    for tornado。 If you don't have it， it's OK。 Yes。 Yeah， so we don't have ordering
    built in。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前安装的内容，安装的包会有所不同。像tornado一样，如果你有site，它会优化。如果你没有site，它就不会优化。所以如果你没有site？是的，site不是tornado的真正依赖。如果你没有它，没关系。是的。所以我们没有内置的顺序。
- en: You can turn off sequential-- you can add sequential flag。 to it and it will
    run them sequentially instead， of doing them at the same time for that use case。
    And so the next thing you do after you've done this。 is you run pipm shell and
    this will give a sub shell， to you with that-- so if I run Python。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以关闭顺序执行——你可以添加顺序标志。这样它将顺序执行，而不是同时进行。在完成这一步后，你可以运行`pipm shell`，这将为你提供一个子shell，这样如果我运行Python。
- en: I got 365， and I can import requests and request works just， like you would
    expect。 And then you do exit。 And it exits out of that shell into my parent shell，
    instead of deactivate。 But if you want， you can do pipm dash dash vm。 And this
    will show you the path to the virtual embedded。 created。 And it's just a normal
    virtual environment。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到了365，并且我可以像预期的那样导入请求和请求工作。然后你退出。它会从那个shell退出到我的父shell，而不是停用。但是如果你想，可以使用`pipm
    dash dash vm`。这将显示你创建的虚拟嵌入路径。这只是一个普通的虚拟环境。
- en: So I could do source this slash bin slash activate。 And it's just like a normal
    virtual amp。 So there's no surprises there。 And I'll get to the next question
    in a moment。 I'll install something that has a bit more dependencies， like Maya。
    Oops， pipm install Maya。 We got some nice features in here like pipm graph。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我可以执行`source this slash bin slash activate`。这就像一个普通的虚拟环境。因此，没有惊喜。我马上就会回答下一个问题。我将安装一些有更多依赖项的东西，比如Maya。哦，`pipm
    install Maya`。这里有一些不错的功能，比如`pipm graph`。
- en: which will give you a graph of your dependency tree。 So here's my top level
    dependencies。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给你一个依赖树的图形。所以这是我的顶级依赖项。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_36.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_36.png)'
- en: Here's requests。 Here's its dependencies。 Here's what's required。 Here's what's
    installed。 It's quite nice。 As well， I could do pipm install Django。 Can someone
    give me the name of an insecure version of Django？ Very insecure。 142。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是requests。这里是它的依赖项。这是所需的。这是已安装的。非常不错。此外，我可以执行`pipm install Django`。有人能告诉我一个不安全版本的Django的名称吗？非常不安全。142。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_38.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_38.png)'
- en: All right， so installing Django equals equals 142。 And the Wi-Fi isn't the fastest，
    I apologize。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，安装Django等于142。Wi-Fi速度不快，我很抱歉。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_40.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_40.png)'
- en: And I have a security vulnerability scanner built in。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个内置的安全漏洞扫描器。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_42.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_42.png)'
- en: It's offered by PyUp。 I have an account with them and it's embedded in the API。
    Keeps embedded inside。 So you can do pipm check。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它由PyUp提供。我在他们那里有一个账户，并且它嵌入在API中。保持嵌入状态。所以你可以执行`pipm check`。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_44.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_44.png)'
- en: And it checked the pipe 508 requirement， switch through those constraints。 It
    said Python 3。6。 So it checked and that was all good。 But here are some known
    vulnerabilities in my dependencies。 So that's a nice feature that we have as well。
    So I installed that invalid version of Django。 And here are the vulnerabilities
    for that version of Django。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它检查了pipe 508要求，切换了那些约束。它说Python 3.6。所以它检查了一切都很好。但这里是我依赖项中的一些已知漏洞。所以这是我们还有的一个不错的功能。所以我安装了那个无效版本的Django。这是该版本Django的漏洞。
- en: So you can get some nice checking of your code， and stuff like that， build that
    into your CI。 Pipm Graph is really useful。 In addition to install， of course，
    you can do uninstall。 You can do pipm uninstall requests。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你可以对你的代码进行很好的检查，等等，将其构建到你的CI中。Pipm Graph非常有用。除了安装，当然，你还可以卸载。你可以执行`pipm uninstall
    requests`。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_46.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_46.png)'
- en: not that you should ever do that。 And it'll remove it from the file， from the
    pip file。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 不是说你应该这样做。它会从文件中删除它，从pip文件中。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_48.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_48.png)'
- en: and relock automatically。 I could also， for example， edit the pip file。 I'm
    just going to change it。 So I just added some new lines。 And then I'm going to
    do pipm install dash-deploy。 So this is what you would use in production。 If you
    were going to go deploy in a Docker image。 or in production， you would never，
    want to ship--， you never want your lock file to be out of sync。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 并且自动重新锁定。例如，我还可以编辑pip文件。我只是要改变它。所以我添加了一些新行。然后我要执行`pipm install dash-deploy`。所以这是你在生产中使用的。如果你要在Docker镜像中部署，或者在生产中，你绝对不希望你的锁文件不同步。
- en: with your pip file。 So this will work fine， apparently。 Hang on。 Maybe we cache
    the--。 I think we do a hash on the values， not on the content。 So I have to add
    a comment or something。 That wasn't a real change。 Yeah， so your pip file was
    out of date。 It expected this hash and this hash is found。 So it'll abort the
    deploy automatically。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的 pip 文件。所以这看起来没问题。等等。也许我们缓存了——我想我们对值进行哈希，而不是内容。所以我得加一个评论或其他东西。那不是一个真正的更改。是的，所以你的
    pip 文件过期了。它期望这个哈希，而这个哈希是找到的。所以它会自动中止部署。
- en: if you pushed a new pip file and didn't lock。 But of course。 you don't need
    to use that in development。 If you do， it knows that it's out of date。 and it'll
    relock automatically for you。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你推送了一个新的 pip 文件但没有锁定。当然，你在开发中不需要使用那个。如果你这样做，它会知道过期，并会自动重新锁定。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_50.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_50.png)'
- en: So next question。 Thank you for your work on the requests。 And my question is，
    at early days。 if pip and the virtual environment， was created in the project，
    then the default。 was changed to home directory。 Do you tell us more about that
    decision？ Yes， so by default。 if you hit pip m dash VM。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所以下一个问题。感谢你对 requests 的工作。我的问题是，在早期，如果 pip 和虚拟环境是在项目中创建的，那么默认值被更改为主目录。你能多告诉我们一些关于那个决定的事情吗？是的，所以默认情况下。如果你输入
    pip m dash VM。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_52.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_52.png)'
- en: you'll notice that the virtual AMP location is， dot local share virtual AMP。
    That's slightly different based on your operating system。 It's in a known good
    location for your operating system。 It mimics the behavior of virtual AMP wrapper
    effectively。 which I determined was the best practice for the community。 If you
    prefer not to do that。 I could make dir dot VM。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到虚拟 AMP 的位置是，dot local share virtual AMP。这根据你的操作系统略有不同。它位于操作系统的已知良好位置。它有效地模拟了虚拟
    AMP 包装器的行为，我认为这是社区的最佳实践。如果你不想这样做，我可以创建 dir dot VM。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_54.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_54.png)'
- en: and then do pip m install。 And it will use the dot VM directory for you automatically。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行 pip m install。它会自动为你使用 dot VM 目录。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_56.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_56.png)'
- en: if there's one there。 Or if you want， there's an environment variable， you can
    set。 which will always use dot VM no matter what。 So it's called pip m VM VIN
    project。 So that's a setting。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果那里有一个。或者如果你想的话，有一个环境变量可以设置。无论如何，它总是会使用 dot VM。它被称为 pip m VM VIN project。这是一个设置。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_58.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_58.png)'
- en: So my question？ Yes。 My question's a follow up to that。 Is it possible to create
    a virtual environment， in a directory that's not in the dot local and not called
    dot。 VENV？ No。 Not currently。 OK， not currently is OK。 Thanks。 Not with this。
    Well， actually， yes。 So--。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我的问题？是的。我的问题是跟进一下。是否可以在一个不在 dot local 并且不叫 dot 的目录中创建虚拟环境？不，目前不可以。好的，目前不可以没关系。谢谢。不是这个。其实，是的。这样——。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_60.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_60.png)'
- en: '[LAUGHTER]， So I can make a virtual environment called test。 What is it？ Virtual
    AMP？'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[笑声]，所以我可以创建一个叫 test 的虚拟环境。那是什么？虚拟 AMP？'
- en: So I've been using pip m for so long。 So I'm making a virtual AMP called test。
    which is using Python 2。7。 I'm going to source test。 VENV-- so I was taking a
    little long--。 activate dot fish。 So I activated my virtual AMP。 Now I run pip
    m install。 And it will-- it knows that it's running， in the virtual environment。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 pip m 已经很久了。所以我正在创建一个叫 test 的虚拟 AMP，它使用 Python 2.7。我将 source test.VENV——所以我花了一些时间——激活
    dot fish。这样我激活了我的虚拟 AMP。现在我运行 pip m install。它会——它知道自己正在虚拟环境中运行。
- en: And it will install things into that virtual environment， for you。 Perfect。
    Thanks。 Yep。 And if you want to switch versions of Python， I just messed everything
    up。 So let me recover from this。 So pip m dash dash 3 will create an environment
    with Python。 3 automatically。 I mean， that had to deactivate。 It gives you a nice
    friendly message。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 它会为你在那个虚拟环境中安装东西。完美。谢谢。是的。如果你想切换 Python 的版本，我刚刚搞砸了一切。所以让我从中恢复过来。pip m dash dash
    3 将自动创建一个 Python 3 的环境。我的意思是，这必须先停用。它给你一个友好的消息。
- en: pip m found itself running within a virtual environment。 So it automatically
    is that environment。 There's a setting to disable that deactivate。 So now that
    I'm out of my virtual environment。 I can do pip m dash dash 3。 And it'll remove
    that environment。 that I had and recreate one with Python 3。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip m`发现自己在虚拟环境中运行。所以它自动进入那个环境。有一个设置可以禁用那个环境的停用。现在我不在我的虚拟环境中。我可以执行`pip m dash
    dash 3`。它会移除我曾经的环境，并使用Python 3重新创建一个。'
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_62.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_62.png)'
- en: And if I want to switch to 2， I just do pip m dash dash 2。 And it destroys it。
    creates it with Python 2。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想切换到2，我只需执行`pip m dash dash 2`。它会销毁当前环境，然后用Python 2创建新的环境。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_64.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_64.png)'
- en: So very simple。 And if you want， you can do dash dash Python， specify the path
    to any interpreter。 And it will use that Python interpreter。 It doesn't work with
    pip m at the moment。 But it works with every other Python interpreter。 And you
    can also specify arbitrary versions of Python。 like 2， 7， 14。 And if you're not
    installed on your system， and you have pip m installed， it。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单。如果你愿意，可以执行`dash dash Python`，指定任何解释器的路径。它将使用那个Python解释器。目前它不支持`pip m`，但可以与其他所有Python解释器一起使用。你也可以指定任意版本的Python，比如2，7，14。如果你的系统上没有安装，而你已安装`pip
    m`，它会执行。
- en: will compile it from source and make it available。 So next question。 Hi。 I had
    a question regarding the speed， of installing new packages and stuff。 It seems
    like it takes a long time， compared to just regular pip， assuming。 because it's
    calculating hash or something。 And I've done some Googling on the issue。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 会从源代码编译并提供使用。那么下一个问题。你好。我有一个关于安装新包速度的问题。与普通的pip相比，似乎需要很长时间，假设是因为在计算哈希或其他原因。我在这个问题上查过一些资料。
- en: It seems like I'm not the only one。 So have you heard of that issue so far？
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎我不是唯一一个有这个问题的人。那么你听说过这个问题吗？
- en: Do you have any inputs on that or maybe ways， that could be sped up？
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对此你有什么看法，或者有没有可能加快的方式？
- en: Because like installing new packages， I think again， I think it's calculating
    hash。 Is it the installation that seems slow or the locking？ I think that-- yeah，
    maybe you're。 at the locking itself。 Yeah， the locking can be slow because it，
    has to resolve a dependency graph。 And if you have a large graph， it can be slow。
    But we've made massive improvements to that。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因为像安装新包，我再次认为，它是在计算哈希。是安装速度慢还是锁定速度慢？我认为，嗯，可能是锁定的过程。是的，锁定可能会慢，因为它需要解析依赖图。如果你有一个很大的图，那确实会很慢。但是我们在这方面做了大量改进。
- en: And it's getting faster every day。 So resolving a dependency graph， it turns
    out。 is quite difficult。 So it involves quite a few requests and stuff like that。
    And it has to download all those packages。 So yeah。 OK， so in the interest of
    time， I'm。 going to have three more minutes of questions。 So three more minutes
    of questions。 Speed round。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 而且它每天都在变得更快。所以解析依赖图，原来是相当困难的。这涉及到很多请求等。而且必须下载所有这些包。所以是的。好的，为了节省时间，我将有三分钟的提问时间。三分钟提问，快速问答。
- en: I'd like to start first with the lady in the back there。 Hi。 So I'm interested
    in using this。 but I'm not necessarily， going to get everyone in my company， to
    start using it right away。 Is there a way that I can convert between this lock
    file， and a requirements。txt so that people are using either。 Yes， we do。 If you
    do pipm。lock-r。
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我想先从后面的女士开始。你好。我对这个很感兴趣，但我不一定会让公司里的每个人立即开始使用。有没有办法可以在这个锁文件和`requirements.txt`之间进行转换，以便人们可以使用任一文件？是的，我们可以。如果你执行`pipm.lock-r`。
- en: it will output a requirements。txt file。 Awesome。 Thank you。 Yep。 Are we on？
    OK。 Should we put the lock file under source control？ Yes。 Thank you。 [LAUGHTER]，
    When you uninstall。 is that recursive？ Does it remove all the dependencies。 that
    were brought in because of that install？ Say it one more time。 When you uninstall。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它会输出一个`requirements.txt`文件。太棒了，谢谢。是的。我们开始了吗？好的。我们应该把锁文件放入源代码控制吗？是的。谢谢。[笑声]，当你卸载时，是否是递归的？它会移除因为那次安装而带来的所有依赖项吗？再说一次。当你卸载时。
- en: is that recursively， uninstalling everything that was brought in for that dependency？
    No。 it'll uninstall only that package。 There's a sync command which will automatically--。
    that's a separate command which will sync your environment， to the lock file。
    OK。 Like a fan。 Up front。 How does pipm。no， which virtual end corresponds， to
    which application directory？
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是递归地卸载为该依赖项引入的所有内容吗？不。它只会卸载那个包。有一个同步命令，它会自动--。这是一个单独的命令，用于将你的环境与锁定文件同步。好的。像风扇一样。前面。pipm怎么做。不是，哪个虚拟环境对应于哪个应用程序目录？
- en: From the path of the directory。 So if you were to move it， it would。 create
    a new virtual environment。 OK。 Gate behind？ Was there kind of a big difference。
    in terms of when you're designing an API that's， for Python versus an API that's
    for consumption through shell。 and is more interactive and not just something，
    that you implement in your code？ Yeah。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从目录的路径来看。所以如果你移动它，它会。创建一个新的虚拟环境。好的。背后？在设计一个面向Python的API与一个通过Shell消费的API时，是否存在较大的差异？而且更具交互性，而不仅仅是你在代码中实现的东西？是的。
- en: I think when you're designing something--， if you look at the code base of pipm。
    the Python side of it is not the most elegant code base， I've ever worked with
    because it's。 trying to present the best user interface possible。 So I think there's
    compromises on both sides。 I think if I try to build it Python first and then
    present， the CLI。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为在设计某个东西时，如果你查看pipm的代码库。它的Python部分并不是我见过的最优雅的代码库，因为它。试图提供最佳的用户界面。因此，我认为两边都有妥协。如果我尝试先用Python构建它，然后再展示CLI。
- en: I think that it would be lesser experience。 So I think that there's always trade-offs。
    Thank you。 OK。 Next question。 Behind？ Hi。 Will this also replace setup pi？ No。
    Setup。py is a completely different tool for different things。 Setup。py is used
    for libraries。 And this is for applications。 OK。 And we'll do one last question。
    I think that gentleman back there。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为那样体验会较差。所以我认为总是存在权衡。谢谢。好的，下一个问题。背后？嗨。这也会替代setup.py吗？不。setup.py是针对不同事情的完全不同工具。setup.py用于库。而这是针对应用程序的。好的。我们来做最后一个问题。我认为那位绅士在后面。
- en: was already there before the mic at the front got filled。 Just to follow up
    on the source control。 checking in your lock files。 This has been a big struggle
    in the node community。 Would you do it for libraries as well as projects？ Would
    you always check in the lock file？
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在麦克风前面填满之前就已经在那里了。只是想跟进一下源代码管理。检查你的锁定文件。这在Node社区一直是一个大问题。你会为库和项目都这样做吗？你会总是检查锁定文件吗？
- en: I would not check in the lock file， if you were targeting multiple versions
    of Python。 where your lock file could be different， under the different versions
    of Python。 Hopefully。 we've done a lot of work， so that it should be a flat lock
    file that。 specifies the versions of Python。 And it really depends on the metadata
    that is provided。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你针对多个Python版本，则我不会检查锁定文件，因为你的锁定文件在不同版本的Python下可能会不同。希望我们已经做了很多工作，因此它应该是一个扁平的锁定文件，指定Python的版本。这实际上取决于提供的元数据。
- en: by those packages。 So if the metadata is good， then you should be able to。 But
    if worst comes the worst， then keep it out。 OK。
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由那些包提供的。所以如果元数据是好的，你应该能够。但如果最坏的情况发生，那就保持不变。好的。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_66.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_66.png)'
- en: With that， let's thank Kenneth。 [APPLAUSE]， And I'm sure he'd be happy to entertain
    questions。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，让我们感谢肯尼斯。[鼓掌]，我相信他会很乐意回答问题。
- en: '![](img/b11954b5468ac09c3c499c218d394ea0_68.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b11954b5468ac09c3c499c218d394ea0_68.png)'
- en: outside of the ballroom。 Yes， absolutely。 Thank you very much。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 舞厅外面。是的，绝对如此。非常感谢。
